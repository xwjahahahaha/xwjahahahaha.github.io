---
title: DGHV:整数上的同态加密(2)-解决噪声与构建全同态蓝图
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2021-08-09 16:46:38
---

上一节我们学习了DGHV somewhat同态（类全同态加密）的基本构建：

> 1. [DGHV:整数上的同态加密(1)-算法构建](https://blog.csdn.net/weixin_43988498/article/details/119459857)

这一节将更进一步的探讨S

# 一、再谈同态加密

通过一些资料的查看，对同态加密的几个要点再做一些补充

## 定义

一个同态加密方案H由一个四元组组成:

$H = \{KeyGen, Enc,Dec,Eval\}$

* $KeyGen$: 密钥生成函数
* $Enc、Dec$ : 加密解密函数
* $Eval$​ : 评估函数，用于验证加密算法的正确性, 如果Eval函数可以运行任意功能的函数，那么就是全同态加密 

<!-- more -->

## 分类

一般分为三类：

* 部分同态加密(Partially Homomorphic Encrypto， PHE)

  ​	- 只实现了部分算法的同态性

  * 加法同态，例如Paillier
  * 乘法同态，例如RSA算法和ElGamal算法

* 些许同态加密（Somewhat Homomorphic Encrypto，SHE）

  ​	- 在密文上执行的操作只能是有限次数的（因为噪声）

  * 例如：**DGHV**、BV、BGN

* 全同态加密（Fully Homomorphic Encrypto，FHE）

  ​	- 允许密文无限次的使用加法和乘法操作

  * 例如：Gentry提出的FHE算法

# 二、解决噪声-Bootstappable 

上一节主要说到噪音的影响以及应对措施：密文刷新

密文刷新需要解密中间过程的密文，解密就需要私钥，**但是直接使用私钥是不安全的，或者说现实的某些情况下这样的做法是不可靠的**, 所以又遇到了麻烦

但是麻烦也可以解决，这里我们就来详细的了解一下这个降低噪声的方法也即bootstappable

首先需要介绍一下Evaluate算法：

## 2.1 Evaluate算法

其组成如下：$Evaluate = (pk, f, c1, c2, c3...)$​ ， $pk、c$都不解释了，分别是公钥和密文

那么$f$是什么呢？

首先需要了解一个概念: Permitted founctions （许可函数集）也称Permitted circuit

组成其集合元素的函数要求是: **同态成立** 也即两个密文经过函数运算后的结果解密后与两个明文直接运算结果相同（也就是基本的同态性）

## 2.2 同态解密

在介绍之前，先看一个小故事

### 小故事一则

![image-20210809222516222](http://xwjpics.gumptlu.work/qinniu_uPic/image-20210809222516222.png)

(也就是[同态加密的原理详解与go实践](https://blog.csdn.net/weixin_43988498/article/details/118802616)中给出的例子)

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20210809222605156.png" alt="image-20210809222605156" style="zoom:30%;" />

​	但是Alice遇到了新的问题：

![N9ygQe](http://xwjpics.gumptlu.work/qinniu_uPic/N9ygQe.png)

---

现在先考虑一个问题**解密算法**本身是不是属于这个集合（许可函数集）？（下面的过程可能有点绕，我会尽量讲清楚）

**我们先假设其属于，后续会讨论**

现在模拟如下的场景：

一个明文$m$，两对公私钥：$pk_1,sk_1,pk_2,sk_2$

现在做如下操作:

1. 将$m$通过公钥$pk_1$加密生成$c_1$，再将$c_1$通过$pk_2$加密得到$c^*$
2. 将$sk_2$通过$pk_2$加密得到$s^*$​  （对没错，将私钥加密）
3. 将$m$通过$pk_2$加密得到$c_2$

上述过程图示就是：

![puVZ48](http://xwjpics.gumptlu.work/qinniu_uPic/puVZ48.png)

现在通过$s^*、c^*$​ 两个密文来评估函数Dec

考虑以下公式是否成立？

$Dec(sk_2, Dec(s^*,c^*)) == Dec(sk_1,c_1)$​​

因为解密算法的同态性，所以等式上述是成立的，解释如下：

首先确定明密文关系：$sk_1、c_1$​​ 如果看作明文，那么根据上述操作可知，其密文分别就是$s^*、c^*$​, 都是通过公钥$pk_2$加密得到的

那么对于密文$s^*、c^*$使用函数Dec的结果解密（也就是再用$sk_2$解密一次即公式最外层的Dec）与明文$sk_1、c_1$的函数直接运算即Dec两者的结果是相同的！

那么在观察等式的右边$Dec(sk_1,c_1)$的结果是什么？没错就是$m$​ (通过$sk_1$解密密文$c_1$的结果为$m$)

则$Dec(sk_2,Dec(s^*,c^*)) = m$​, 那么反推，x通过私钥$sk_2$解密能够得到m，那么x是什么？没错！就是密文$c_2$  !!

那么，可得$Dec(s^*,c^*) = c_2$​, 一个私钥($sk_1$)的加密去解密一个密文($c_1$)的加密得到的结果是一个新的密文就是$c_2$​​

$c_2$是明文$m$在公钥$pk_2$​下加密的密文，这是一个什么密文呢？对了！**新鲜的密文（没有经过密文计算！！！）**

> <font color='#39b54a'>是不是有点像魔术，就像原来一个人穿的是西装，现在你没有看到这个人换衣服的情况下， 魔术师只是施了一下魔法，这个人立刻就换了一身运动服，人还是原来那个人， 只是包装变了。这也是 Gentry 思想中一个最重要的特性:<font color='#e54d42'>**同态解密**</font>。</font>

结合上面的小故事，$sk_2$就是新的钥匙

## 2.3 重加密技术

说了半天，同态解密能做什么？降低噪音

当两个密文运算后得到一个新的密文，这个密文是不是会有很大的噪音？

那么下面我们就将这个运算后的密文做一次同态解密就可以相当于一个新鲜的密文了，并且新鲜的密文的噪音是很小的，所以实现了降噪的目的

> <font color='#39b54a'>事实上，同态解密后的密文比新鲜的密文噪音**稍微大一些**</font>

这一个手法就叫做<font color='#e54d42'>**重加密技术**</font>

![EpiYGH](http://xwjpics.gumptlu.work/qinniu_uPic/EpiYGH.png)

如图，经过重加密技术例如乘法的高噪音问题就可以缓解很多，产生的密文$c^*$可以接着下一步的密文同态计算

解密的过程也是从外到里一层层解密

> <font color='#e54d42'>总结： 因为直接通过私钥解密密文不够安全，所以利用解密算法本身就具有的同态性，借助第二对公私钥分别将密文私钥加密再解密（$Dec(s^*, c^*)$）得到新鲜的密文减少噪音继续运算</font>

## 2.4 增强电路

降低噪声的下一步是为了下一次的运算，所以**增强电路**就是指解密电路 + 一个门电路（可以是加法门电路或者乘法门电路等基本电路）

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/H0Jqxa.png" alt="增强电路" style="zoom:50%;" />

（图中的加法门电路只是一个例子）

因为多次的重加密，所以需要多对公私钥，即产生了以下序列：

* 公钥序列：${pk_1,pk_2,pk_3...}$
* 私钥序列：$sk_1^*,sk_2^*,sk_3^*....$   其中$sk_i^*$是用公钥$pk_{i+1}$​加密得到的密文

**运算电路的每一层都对应一对公钥与私钥**

例如：

---

* 第一层：公私钥$pk_1、sk_2$​

  第一层重加密时使用第二层电路的公钥$pk_2$ 分别加密$sk_1$和密文得到$sk_1^*$ 以及新鲜的密文即明文通过$pk_2$加密的结果，然后将这两者输入解密电路

---

* 第二层：公私钥$pk_2 、sk_2$

  第二层重加密时使用第三层电路的公钥$pk_3$​​​​ 分别加密$sk_2$​​​​和密文得到$sk_2^*$​​​​ 以及新鲜的密文即**第一层电路的输出**通过$pk_3$​​​​​​加密的结果，然后将这两者输入解密电路, 解密电路将输出一个密文，该密文是对明文用$pk_3$加密的结果

----

如此不断的运行….

这样公私钥的数量与电路的深度成**线性**的依赖关系

<font color='#39b54a'>如果被加密的私钥泄露了也不会影响密钥本身的安全的话，那么称之为**circular security**， 如果方案满足这个条件那么就不需要那么多对公私钥了，后续的所有公私钥对都可以公用一对，这样就不用提前预算电路深度从而计算公私钥对的数量</font>

上述的方案证明其circular security还是很困难，但是目前可以认为其不会遭受攻击

<font color='#e54d42'>**结论：如果解密电路是在$Evaluate$所执行的$Permiitted functions$的集合中，那么就可称该方案是$Bootstrappable$​**</font>

# 三、构建全同态电路

一个什么样的方案是全同态的？

如果一个方案能够对密文进行任意功能的计算，而且运算的结果所得的密文是紧凑的，同时Evaluate算法即运算是有效的，那么就可称该方案是全同态的，可用下式子说明：

![全同态公式](http://xwjpics.gumptlu.work/qinniu_uPic/Ypf4rn.png)

* 紧凑性：密文不过于膨胀即生成的密文大小要小（这里可能理解有误）
* 有效的：Evaluate算法能够在有效时间内计算完成
* 任意的：f函数可以表示任意功能的计算
* 正确的：同态性的体现，即加密的密文的结果解密与直接f运算的结果是相同的

## 有效性与任意性

怎样衡量Evaluate算法的有效性呢？有效性就是在有限时间内运算结束，那么关键就是通过算法的**复杂度**来衡量（最直接的方法是通过在图灵机上运算 f 的时间来衡量）

Evaluate的复杂度依赖于其中的函数f, 那么f可能包含各种各样功能的函数，这样难以去计算

所以我们回归最基础的运算，将其拆解为一些简单的布尔电路，例如“与”电路、“或” 电路、“非”电路。而这些电路是可以组合成任意电路的，也就是说**可以表示任意功能的电路**。

这样就可以将任意的函数f拆解为一些简单的布尔电路去衡量了

下面讨论任意性：

我们选择AND电路和XOR电路来考量，因为这两个电路是具有**完备性质的即可以表示出任意的功能的复杂电路**

首先考虑的问题是证明这两个电路属于Evaluate的Permitted functions集合，否则一切都是白谈

AND电路即与门，回忆真值表：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/Ana8DN.png" alt="与门真值表" style="zoom: 67%;" />

显然可以发现AND电路/与门就是二进制的**乘法**

同理XOR电路就是二进制的**加法**（不再解释）

对于我们所述的方案一次二进制加法运算或者一次二进制的乘法运算是能够正确执行的即满足解密正确性的，所以就一定属于$Permitted functions$

证明了其属于Evaluate的Permitted functions集合，又因为其完备性即可表示任意功能计算，那么全同态要求的**f任意性质**就解决了

## 正确性

前面任意性质解决了，但是这两个基础电路构成的任意功能计算就一定是正确的吗？？

前面说过了我们的方案是有噪声的，所以将这两个基础电路多次的组合会导致正确性的失效即解密失败！

那么，有什么办法解决呢？对了！前面一直在说的**重加密技术**！

具体做法：

核心： 在任何密文进入AND电路或XOR电路之前，先让其进入解密电路进行重加密降低噪音，接了解密电路的 AND 电路或 XOR 电路就称为增强电路。

例如：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/WTlYZB.png" alt="示例" style="zoom:45%;" />

那么正确性至此也得以证明！

## 总结

现在，我们通过基础电门AND电路和XOR电路的特性以及重加密技术实现了全同态的所有四个特性要求

是不是足以构建全同态的蓝图了呢？

再等等，还有一个关键点只是假设没有证明：解密电路/解密算法是否属于Permitted functions集合呢？？？

先说结论：不是，但是可以优化让其是！

Ok，剩下的留给下一节再继续学习

> 本文学习自：
>
> http://bbs.sciencenet.cn/home.php?mod=space&uid=411071&do=blog&id=651836
>
> 感谢**陈智罡老师**的博客分析资源！
