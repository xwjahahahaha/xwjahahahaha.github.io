---
title: 北大肖臻-第9讲-比特币脚本
tags:
  - block_chain
categories:
  - knowledge
  - block_chain
  - xiaozhen_public_class
toc: true
date: 2020-06-24 21:41:34
---

# 第九讲 比特币脚本

## The BitCoin Scripting Language

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200624214038.png)

<!-- more -->

### 交易结构

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200624214934.png)

### 交易的输入：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200624220435.png)

### 交易的输出

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200624221055.png)

### 交易验证：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626180440.png)

后面B->C的交易中Vin中的txid和vout**唯一的指向了**前一个交易的一个输出vout

即使两个交易中间隔了许多的区块，图中是两个区块，都是不影响的。

比特币系统的脚本验证过程：

早起版本的比特币系统是将输入脚本与输出脚本放到一起执行，而后来变为先执行输入脚本，无误后再执行输出脚本（分别执行）。如果都能顺利执行，即最后栈顶的值为非0值（true）那么验证通过，这个交易就是合法的，如果执行过程中有任何错误，那么这个交易就是非法的。

前面说过，一个交易可能会有多个输入与多个输出。那么，要将这个交易的所有输入与其对应的其他交易（或自己）的所有输出都验证通过，这个交易才能算作一个合法的交易。

### 输入和输出脚本的几种形式：

#### 最简单的一种形式 P2PK

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626181648.png)

注意：图中的输入与输出脚本不是指在同一个交易中的。而是两个交易中对应的输入与输出的拼接。

这个签名使用私钥对整个交易的签名

脚本执行过程：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626182252.png)

注： 这里为了方便显示，所以看起来是拼接到一起执行的，其实是分别执行的。

  1. 首先前两行分别将签名Sig和公钥PublicKey压入栈
  2. 第三步检查，其实就是分别出栈，**使用公钥去验证签名的正确性**

结果为True，说明验证通过：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626182551.png)

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626182820.png)

#### 第二种形式 P2PKH

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626183156.png)

这一种是较为常见的一种形式，**输出脚本中输出的是公钥的Hash，而输入脚本中要除了签名还要包含公钥**

除了这些，其他的DUP、HASH160都是一些验证操作。

脚本执行过程：

同样的为了方便看，将输入与输出拼接到一起，从上往下执行。

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626183838.png)

前两步操作相同，将输入中的签名和公钥压入栈

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626183932.png)

第三步操作DUP是将栈顶的公钥复制一份

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626184020.png)

第四步操作HASH160是将复制的公钥取HASH值，然后压入栈中。

第五步，将输出脚本里面的公钥Hash压入栈，这时栈里面出现了两个公钥的Hash值

搞清楚这个Hash值的来源：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626184421.png)

第六步，EQUALVERIFY是弹出栈顶的两个Hash值，比较两者是否相等。

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626184641.png)

最后一步，和之前一样，分别弹出，检查公钥与签名是否配对（正确）。

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626184736.png)

整个过程如果两个Hash对不上，或者公钥与私钥签名对不上，那么这个交易就是错误的，非法的

实例：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626184902.png)


#### 第三种形式 P2SH （最复杂的一种）

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626200237.png)

输入脚本中要给出对应赎回脚本的具体内容，同时还要给出让赎回脚本正确运行所需要的签名。

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626200626.png)

用P2SH实现P2PK：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626201207.png)

赎回脚本的内容就是给出公钥然后验证签名是否正确

最下面的输出脚本就是来验证输入脚本给出的赎回脚本是否正确

**第一阶段的验证（脚本文本Hash的验证）**：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626201816.png)

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626202006.png)

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626202144.png)

第一阶段结束

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626202249.png)

**第二阶段验证（脚本内容运行的验证）**：

首先要做的是***将输入脚本中序列化的赎回脚本给反序列化***

然后，***执行赎回脚本***

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626202832.png)

整个过程与第一种方法一致，不再赘述。

最终栈顶为True，那么整个验证过程就算结束，通过。

其实就是将之前的验证过程内容放进了赎回脚本，再将赎回脚本本身作为验证条件。

常见的应用场景： 对多重签名的支持

**多重签名**

优点： 
1. 为私钥的泄露提供了安全性的保障
2. 为私钥的丢失提供了冗余

举例： 一个公司中有五个合伙人，需要从公司的账户上取走钱，最起码需要三个合伙人的签名，那么，当有一个人私钥被泄露了，别人也是无法取走钱的，如果有两个人私钥丢了，那么剩下的三个人还是可以取出来钱的。

这个功能实通过CHECKMUTLTISIG实现的：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626204347.png)

其中指的注意的是：因为是堆栈的存储结构，所以要保证压入栈和出栈的匹配性，所以选择的公私钥***相对顺序***要对应。

对于上例，M = 3， N = 5。

脚本执行：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626204808.png)

可以看到签名与公钥的相对顺序要保持一致

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626204929.png)

最后CHECKMUTLTISIG，查看是否三个签名要求提供了两个，如果是的话，那么就验证通过。

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626205040.png)

注意，这里没有使用第三种方法：P2SH,只是使用了比特币原生的CHECKMUTLTISIG来实现多重签名。

这样有什么问题呢？？

将复杂的工作都交给用户了，比如在网络上购物，网站需要你提供五个公钥以及三个签名，你需要告诉网站M和N分别为几，然后网站在公布出来，你在进行相应的填写，并且每个网站的要求可能还不同，所以，对于用户来说，过于麻烦。

解决办法：P2SH

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626210802.png)

由图中可以明显的看出，其本质在于***将复杂度由输出（用户）转移到了输入（商家）***，输入脚本写好赎回脚本中的内容，包括M，N，然后公布自己的赎回脚本的Hash即可，输出者转账时，只需用他的Hash即可。不必知道商家的支付规则，是五个预选三个，还是三个预选两个，都是商家写好在赎回脚本中，用户不必知道。

要明白的一个问题：

用户转账给商家：A（用户账户）->B（商家账户） （输出脚本-用户填写）

商家使用这笔钱：B（输入-商家填写）->C（其他账户）

用户转钱时，只要填写输出脚本中的商家写好的赎回脚本的Hash值即可，而对于商家的使用这笔钱却比较麻烦了，需要使用多重签名的验证才能使用掉这笔钱。

脚本执行：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626214523.png)

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626214633.png)

取Hash判断是否相等。

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626214709.png)

第一阶段的验证完成。

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626214748.png)

第二阶段，检查赎回脚本的运行：公私钥是否匹配。  

最后成功为True。

实例：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626214937.png)

目前的多重签名基本都是使用P2SH。

#### 特殊的输出脚本 Proof of Burn

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626215243.png)

无法再使用，所以，这个交易是销毁比特币的。

用处何在？？

对于有的小币种AltCoin，其要求销毁一定的比特币能够换取相应的小币种币

其次，比特币所使用的区块链是无法篡改的账本，可以利用其特点digital commitment“密封的信封”

例如，你可以将自己的知识产权内容取Hash写在return后的语句中，这样当以后有知识产权纠纷时，你可以将自己的知识产权内容取Hash与以前写入在链上的内容比对证明。可以证明你在之前就已经有相关产权了。

为什么不用可以达到相同功效的Coinbase域？

因为，Coinbase只能是获得记账权的节点才能使用，并且不一定成功。

而这种方法，任何比特币用户都可以使用。

实例：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626223643.png)

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200626223855.png)

此类交易对全节点（矿工）是友好的，全节点收到这类交易后，明白其永远不会使用了，所以没必要保存到UTXO中。

*注：图片中的很多操作为了简洁起见都没有加上op_前缀，例如op_DUP。*

## 总结

比特币脚本语言是非常简单的脚本语言，以至于连名字都没有，就叫比特币脚本语言。此外其简单还体现在例如不支持循环，所以许多的功能是无法使用的。

但是，这样的设计是有其用意的，不支持循环就不会出现死循环，这样就不会出现停机问题。此外，虽然一些的功能被限制了，但是其也有强大的一面（与密码学相关的功能）例如CHECKMUTLTISIG，一条语句就能完成。

所以，比特币脚本语言看似很简单，但是其对比特币的应用场景作了很好的优化。
