---
title: 闪电网络
tags:
  - block_chain
categories:
  - technical
  - block_chain
toc: true
date: 2020-07-10 14:45:56
---

# RSMC （细节没怎么看懂）

RSMC，全称Revocable Sequence Maturity Contract。 Revocable，就是可撤销的意思； Sequence就是指第12课 nLockTime(CLTV)与Sequence number(CSV) 讲述的Sequence Number。 Sequence Maturity，通俗点讲，就是等到Sequence Number满足条件了，进行履约。

所以翻译成中文就是：可撤销的、基于Sequence成熟度的合约。

<!-- more -->

## RSMC解决的问题
（1）双向支付，而不是单通道

（2）1方中途退出，另外1方要立即拿回钱，而不是等到nLockTime到期才能拿回钱。 同时，应该对主动退出方实行惩罚。

（3）保证交易双方，任何1方都不能抵赖、反悔。


## RSMC交易过程详解
下面就看一下，RSMC如何达成上面的目标。
考虑如下场景，假设Alice与Bob之间经常有资金往来，看他们如何通过RSMC技术实现互相转账：

Step1: 同微支付通道1样，生成1个保证金交易(Funding Transaction）。不过和微支付通道的区别是，这里是双向支付。所以双方，各拿1笔钱出来，打入这个公共账户。


Step2:  同微支付通道类似，为这笔钱生成退款交易（Refund Transaction）。双方可以各自拿回自己的0.5比特币。

备注：和微支付通道一样，实际过程是，双方完成了Step2之后，才会把Step1的交易广播出去。以防钱被死锁在公共账号里面！！！

重点来了：Alice生成的退款交易是C1a + RD1a，Bob生成的退款交易是C1b+RD1b，2者是对称的。 

假入Alice要拿回钱，它就广播C1a + RD1a；

假入Bob要拿回钱，它就广播C1b + RD1b。

 

为什么这么处理呢？

我们看一下：假设Alice想主动中断交易，也就是它把C1a + RD1a 广播到了区块链网络上，那结果是什么呢？？

我们会看到C1a里面，会把Bob的0.5比特币立即返还给Bob，而Alice的0.5比特币被打到了1个新的公共账号： Alice2 & Bob里面！！！

Alice要拿回自己的0.5比特币，要等到RD1a被兑现。而RD1a有个seq = 1000属性，也就是要等到C1a所在的块，后面被追加了1000个块之后，RD1a这个交易才会被进入区块链里面，Alice才能拿到自己的钱！！

一句话：如果Alice主动中断交易（把C1a + RD1a广播到了区块链上），Bob立马拿回自己的钱，Alice则要等到Sequence Maturity之后，才能拿回钱（Alice被轻微惩罚了）。反之亦然！！


Step3: Alice与Bob开始交易
假设Alice要付给Bob 0.1 比特币，那么公共账号里面的资金分配，就从0.5/0.5，变成了0.4/0.6。

过程如下：
Alice生成了C2a与RD2a，C1a与RD1a废除；
同样，Bob生成了C2b与RD2b,  C1b和RD1b废除。


重点：
在双方达成了C2a/RD2a, C2b/RD2b之后，如何让C1a, RD1a, C1b, RD1b 废除呢？ 换句话说，如何保证Alice不反悔（不让Alice把C1a与Rd1a广播到区块链上去？）同样，如何保证Bob不反悔（不让Bob把C1b与Rd1b广播到区块链上去？）

这需要引入惩罚机制！！
在Alice生成C2a/RD2a之前，他要把自己在C1a里面的私钥 Alice2发给Bob；同样，Bob把自己的C1b里面的私钥Bob2发给Alice。

这样，各自会生成一个惩罚交易：

如下图所示：Alice把秘钥Alice2给了Bob，Bob会为C1a生成1个惩罚交易BR1a，攥在自己手里，以防Alice反悔。

假设Alice反悔，也就是把C1a + RD1a广播出去了，Bob就把BR1a广播出去！！ BR1a由于没有Sequence，肯定会先于RD1a执行，所以结果是RD1a不会被执行，BR1a执行了。造成的结果是，Alice拿不回钱，Bob会把Alice的0.5 比特币全转账到自己账户里面，这就是对Alice的惩罚。

反之亦然，会为C1b生成BR1b。

一句话：BR1a是Bob攒在手里的Alice的把柄，BR1b是Alice攥在手里的Bob的把柄，任何1方都不敢把旧的交易广播出去。也就是一旦达成了C2a/RD2a + C2b/RD2b，1就废除了。

Step4: 同微支付通道一样，双方最终完成了交易，把Step3里面，最后1次更新，广播到网络上，各自得到自己的钱。最后1次的，sequence = 0，双方都立即拿到自己的钱。


## 总结

通过上面的过程分析，我们可以看出，RSMC设计的很巧妙：

（1）通过双方各自往同1个公共账号打钱，实现了双向支付。

（2）Alice拿回钱的时候，没有直接打回到她自己的账号里面。而是打到1个新的公共账号 Alice2 & Bob，然后再用一个有sequence number的 RD1a最终拿回钱。通过这点，实现了谁主动中断，谁延迟退钱。这点做的很巧妙！！！

（3）双方协商新1轮的时候，都把自己上1轮的私钥给对方，相当于把自己的把柄给了对方，这样双方都不敢反悔。

这里，又1个很巧的地方：

虽然Alice把私钥给了对方，但Alice不广播C1a，那对方的处罚交易BR1a也不会执行。

Alice广播了C1a，对方就基于广播的交易执行处罚交易BR1a；

Alice不广播C1a，对方也就没机会执行处罚交易BR1a。 

反之亦然！


# HTLC

## 一个例子了解

Alice和Eric之前想进行交易，但没有支付通道。

Alice和Bob之间，Bob和Carol之间、Carol和Diana之间、Diana和Eric之间，已经有了支付通道，那把这些通道串联起来，就相当于建立了Alice和Eric之间的支付通道。

 

 这个过程怎么达成呢？ 

假设Alice需要付给Eric 1个比特币：

首先，由最终的收款方Eric构建了1个秘钥R和对应的Hash值H，然后他把H给了Alice。

Alice呢，就和Bob之间达成了一个合约：Alice对Bob说，如果你在4天内，可以给我H对应的密钥R，我就给你1.003比特币，超过4天，我就拿回这钱；

在这打个比方，Alice就好像搞了个“谜题悬赏”：Alice抛了一个问题，然后悬赏，谁能给出这个问题的答案，就支付给他1.003比特币。这里的问题，就是H；答案，就是密钥R。 

很显然，密钥只有Eric有，Bob没有。那Bob怎么办呢？

Bob和Carol达成1个合约：Bob对Carol说，如果你在3天内，可以给我H对应的密钥R，我就给你1.002比特币，超出3天，我就拿回这钱；

同理，Carol也没公钥，

Carol和Diana达成1个合约：Carol对Diana说，如果你在2天内，可以给我H对应的密钥R，我就给你1.001比特币，超过2天，我就拿回这钱；

同理，Diana也没公钥，

Diana和Eric达成1个合约：Diana对Eric说，如果你在1天内，可以给我H对应密钥R，我就给你1个比特币，超过1天，我就拿回这钱。

所以整个的交易顺序是：Eric把R给了Diana，拿到1.0比特币； Diana把密钥给Carol，拿到1.1比特币；。。。密钥一直传递，最终到Alice那。

最终结果就是：Alice付出了1.3个比特币，Eric收到1.0个比特币，每个中间方，收到0.1个比特币的手续费。

## 脚本实现(后续学习到再来填坑)



> 版权声明：本文为CSDN博主「老王的博客」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
>
>原文链接：https://blog.csdn.net/wzbwzh/article/details/84064620
>
>原文链接：https://blog.csdn.net/wzbwzh/article/details/84328892