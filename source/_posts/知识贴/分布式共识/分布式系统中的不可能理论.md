---
title: 分布式系统中的不可能理论
tags:
categories:
  - knowledge
  - null
toc: true
declare: true
date: 2021-04-07 15:45:15
---

> 内容转载于:https://developer.aliyun.com/article/702243

<!-- more -->

# 不可能三角

这些实践中遇到的问题，也引发了诸多计算科学家进行了非常多的理论研究。这些理论研究对于工程技术人员而言或许过于抽象繁琐，有些甚至是无趣的数学问题，但这些理论对于指导我们解决这些问题意义重大。**这些理论相当于是告诉了我们这类问题解法的理论极限，以及哪些方向可以探索、哪些方向是死路一条。** **站在前人的肩膀上，才不至于花毕生精力去研制“永动机”。**这些理论大家应该都有所了解，这里只简单回顾。

## FLP impossibility

早在1985年，Fisher、Lynch、Paterson三位科学家就发表了关于分布式一致性问题的不可能定理：在完全异步的分布式网络中，故障容错问题无法被解决。（ *We have shown that a natural and important problem of fault-tolerant cooperative computing cannot be solved in a totally asynchronous model of computation.* ）说得更直白点：==在**异步网络**中，不可能存在能够容忍节点故障的一致性算法，哪怕只有一个节点故障。并且这里并没有考虑拜占庭错误，而是假设网络非常稳定、所有的消息都能被正确传递、并且仅被传递一次，即便如此都不可能找到能容忍哪怕只有一个节点失效的一致性协议，可见该结论有多强。==（ *In this paper, we show the surprising result that no completely asynchronous consensus protocol can tolerate even a single unannounced process death. We do not consider Byzantine failures, and we assume that the message system is reliableit delivers all messages correctly and exactly once.* ）

当然了，这只是理论上的。它的意义在于告诉我们此类问题的理论极限，并不意味着此类问题在实践中也不可能被“解决”。如果我们愿意放宽限制、做出牺牲，在工程上是可以找到切实可行的解法的。

FLP不可能定理的最大适用前提是**异步网络模型**。何为同步、异步模型呢？

- 所谓异步模型，是说从一个节点到另一个节点的**消息延迟是有限的，但可能是无界的**（finite but can be unbounded）。这就意味着如果一个节点没有收到消息，它无法判断消息到底是丢失了，还是只是延迟了。也就是说，我们无法通过超时时间来判断某个节点是否故障。
- 所谓同步模型，是说**消息传递的延迟是有限的，且是有界的**。这就意味着我们可以通过经验或采样精确估算消息的最大可能延迟，从而可以通过超时时间来确定消息是否丢失、节点是否故障。

所幸的是，我们所处于的**真实的网络世界更接近同步模型**，在很多场景上，我们都可以通过经验或采样确定最大超时时间。举个通俗点的例子：你给朋友快递了一本书，朋友过了3天还没收到，此时朋友很难判断到底是快递延迟了，还是快递出问题送丢了。但是如果过了一个月，朋友仍没收到书，基本就可以断定快递送丢了。而背后的推论就是基于经验或统计：通常快递都能在1-2周内送达。显然，异步模型其实是反映了节点间通讯的最差情况、极端情况，异步模型包含了同步模型，即能在异步模型上有效的一致性协议，在同步模型上也同样有效。而同步模型是对异步模型做了修正和约束，从而使得更接近真实世界，也使得在实践中一致性问题有可能得到有效解。

另外，即便是在异步网络模型下，FLP也并不意味着一致性永远无法达成，只是说无法保证在有界的时间（in bounded time）内达成。在实践上，如果放宽对bounded time的限制，仍然是有可能找到实践中的解法的。

而根据DLS的研究（http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf ），一致性算法按照网络模型可以分为三大类：

- 部分同步网络模型（partially synchronous model）中的一致性协议可以容忍最多1/3的任意错误。这里的部分同步模型是指**网络延迟是有界的，<u>但是我们无法提前得知</u>。**这里的容错也包含了拜占庭类错误。
- 异步网络模型（asynchronous model）中的确定性协议无法容忍错误。这里的异步模型即是前文所说的网络延迟是无界的。该结论其实就是FLP不可能定理的含义，在完全异步网络中的确定性协议不能容忍哪怕只有一个节点的错误。
- 同步网络模型（synchronous model）可以达到惊人的100%容错，虽然对错误节点超过1/2时的节点行为有限制。这里的同步模型是指**网络延迟一定是有界的**，即**小于某个已知的常数**。

从另一个角度来理解，FLP实际上考虑了分布式系统的3个属性：<font color='#e54d42'>安全(safety)、活性（liveness)、容错：</font>

- 安全是说系统内各个节点达成的值是**一致的、** **==有效的==**。safety其实是保证系统一致性运行的最低要求，其核心是cannot do something bad，即不能干坏事、不能做错事。
- **==活性是说系统内各个节点最终（在有限时间内）必须能够达成一致，即系统必须能够向前推进，不能永远处于达不成一致的状态。==**liveness其实是更高要求，意味着不能只是不干坏事，也不能一直不干事，you must do something good，即必须使得整个系统能良好运转下去。
- 容错是说该协议在**有节点故障**的情况下也必须能有效。

FLP不可能定理其实意味着在异步网络中，不可能存在同时满足这三者的分布式一致性协议。因为分布式环境中，节点故障几乎是必然的，因此容错是必须要考虑的因素，所以**==FLP不可能定理就意味着一致性协议在能做到容错的情况下，没办法同时做到安全性与系统活性。==**通常在实践中，我们可以做出部分牺牲，比如<u>牺牲一部分安全性，意味着系统总能很快达成结论，但结论的可靠性不足；或者牺牲一部分系统活性，意味着系统达成的结论非常可靠，但可能长时间、甚至永远都在争论中，无法达成结论。</u>所幸的是，很多时候现实世界的鲁棒性很强，使一致性协议失效的倒霉事件发生的概率也很可能极低<font color='#39b54a'>(概率上始终没有达成共识,虽然这样在概率上可能性非常低)</font>。



![MfnzwJ](http://xwjpics.gumptlu.work/qinniu_uPic/MfnzwJ.png)

FLP不可能定理示意图（[https://www.slideshare.net/oryband/the-stellar-blockchain-and-the-story-of-the-federated-consensusblockchain-academy](https://www.slideshare.net/oryband/the-stellar-blockchain-and-the-story-of-the-federated-consensusblockchain-academy?spm=a2c6h.12873639.0.0.7e2b7a59vrG4WV)）

另外，FLP并未排除Las Vegas类随机算法，许多一致性算法采用了这种**<u>随机性</u>来规避FLP不可能定理对于确定性异步网络的限制**。此类非确定性一致性算法涉及Las Vegas规则：**==<font color='#e54d42'>网络最终一定能达成一致，但是达成一致所需要的时间可能是无界的。此类算法每轮共识决策都有一定的概率，并且系统在T秒内能够达成一致的概率P随着时间T的增加而指数增长并趋近于1(最终一致性)</font>==**。事实上，该方法被许多成功的一致性算法所采用，是在FLP不可能定理笼罩下的安全地带（escape hatch），比特币的共识机制就是采用了这样的方法。

## CAP theorem

众所周知、大名鼎鼎的CAP原理，从另一个维度，简单明了、直截了当地告诉我们：==**可用性、一致性与网络分区容错性这三者不可能同时实现，而只能实现任意其中的两个**==。( *"Of three properties of shared-data systems (data consistency, system availability and tolerance to network partitions) one can only achieve two at any given time".*) CAP与FLP看起来有相似之处，其实二者并不尽相同，二者是从不同的维度思考问题，另外即使是很相似的概念，内涵也并不完全一样。比如：

- FLP面对的是**分布式一致性问题**，而CAP面对的是**分布式网络中的数据同步与复制**。
- <font color='#e54d42'>**FLP是说在异步网络模型中，三者不可能同时实现；而CAP是说在==所有场景==下，三者都不可能同时实现。**</font>
- FLP中的**liveness强调的是一致性算法的内在属性<font color='#39b54a'>内部节点共识</font>**；而CAP中的**availability强调的是一致性算法对外呈现的外在属性<font color='#39b54a'>外部访问可用</font>**。

理论上，只能从CAP三者中选择两者，然而，这种选择的边界并非是非此即彼的（not binary），很多时候混合考虑不同程度的各个因素，结果可能是更好的。（ *The whole spectrum in between is useful; mixing different levels of Availability and Consistency usually yields a better result.*）

![2eb2x4](http://xwjpics.gumptlu.work/qinniu_uPic/2eb2x4.png)

CAP理论示意图（https://www.researchgate.net/figure/Visualization-of-CAP-theorem_fig2_282679529）

在实践中，我们通常需要根据实际业务场景做折中权衡。比如：

- 传统的关系型数据库如mysql等多采用**ACID**（atomicity, consistency, isolation and durability）理论，通过**同步事务操作保证了强一致性**；因节点较少（一般只有主从），可用性也比较一般；网络拓扑较为简单，而弱化了分区容错性。
- NoSQL存储系统如hbase等多采用**BASE**（Basically Available、Soft state、Eventually consistent）理论，通过**多节点多副本**保证了较高的可用性；另外因节点数增多、网络环境也更复杂，也考虑了网络分区容错性；但一致性较弱，只能保证最终一致性。

![3bbSTW](http://xwjpics.gumptlu.work/qinniu_uPic/3bbSTW.png)

ACID与BASE对比（https://people.eecs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf）

当然，这些并不是定论，各个系统都在各自不断的进化完善中，今天的结论明天可能就会被打破。更好的系统一定是不断探索适合自己的场景，找到更佳的平衡点。

