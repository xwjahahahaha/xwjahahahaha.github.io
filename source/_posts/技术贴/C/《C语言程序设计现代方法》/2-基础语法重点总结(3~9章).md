---
title: 2-基础语法重点总结(3~9章)
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2022-06-10 21:38:17
---

[TOC]


<!-- more -->

> 参考：
>
> * 《C语言程序设计现代方法》

因为前面的章节都算是基础，所以不会记录太多

# 第三章 格式化输入/输出

* 格式化输出`%-m:pX`模式

  * `-`： 表示左对齐
  * `m`: 显示的最小字符数量，如果不够就会补上空格
  * `p`：浮点数是控制小数点数量，整数是位数不足时在前面补0

* 格式化输入：

  * `scanf`中读入的变量[一般]都需要加上`&`，如果不加上可能会产生意想不到的错误, 编译时会报出`format argument is not pointer`的提示

  * `scanf`会读取第一个字符的时候会忽略所有空白字符(包括换行符，换行符等价于空格)，并且会在读下一个输入时跳过中间的空格

  * 多个`scanf`读取字符串要将上一次的`scanf`匹配输入的最后一个回车给读取掉，不然会让下一个`scanf`读取的第一个字符就是上一次输入最后的回车（残留在缓冲区中），造成错误

    * 注意，不要自作聪明的在格式串的最后放一个`\n`,例如`scanf("%d\n", &a)`, 因为`\n`与空白字符无异，当扫描读取掉第一个整数之后，程序会一直等到下一个非空白字符(因为会默认跳过空白字符), 所以你的回车输入会被屏蔽掉，所以程序会一直挂起等到下一个非空白字符才结束

    * 正确的方式可以使用如下方式：

      ```c
      scanf("%c", &ch1);
      ch = getchar();   // 读取掉回车
      scanf("%c", &ch2);
      ```

# 第四章 表达式 ～ 第五章 选择语句

* C语言中(C89标准)一直缺乏合适的布尔类型，所以一般会采用宏的方式去定义:

  ```c
  # define TRUE 1
  # define FALSE 0
  ```

  而在C99标准中，这一问题得到了解决，所以可以在C语言的这一版本中布尔变量可以申明为：

  ```c
  _Bool flag;
  ```

  此类型实际上就是整数类型，但是和一般的整数类型不同的是，只能赋值0或1，如果赋值了一个>1的值，其结果也是1

  > 问：为什么搞了一个这么奇怪的名字`_Bool`？
  >
  > 答：因为C89标准规定`_`和首字母大写的名字是保留名字，程序员不可使用，所以C99这样起名字是为了避免冲突

  更为方便的是C99还提供了`<stdbool.h>`的头文件，这样可以像下面那样更加方便的使用：

  ```c
  # include <stdio.h>
  # include <stdbool.h>
  int main() {
      bool flag;
      flag = true;
      // ...
      flag = false;
      printf("%d\n", flag);
  }
  ```

* `switch`语句的每个分支不能忘记写`break`，否则会继续往下面的`case`或者`default`执行

* i是int型，f是float型，那么`i>0 ? i:f`表达式是什么类型？
  * 是`float`类型，即使表达式为真都会将`i`转换为`float`类型

# 第六章 循环

* C99新语法支持在for循环中直接定义一个循环变量而不需要申明：

  ```c
  for (int i=0; i<n; i++) {
    ....
  }
  ```

* 逗号表达式：[表达式1],[表达式2], …
  * 因为从左往右执行，前一个表达式应该产生副作用/改变变量的值影响后面的表达式，否则前面的表达式写在这里是没有意义的

# 第七章 基本类型

* C语言对于`unsigned long int`和`unsigned short int` 可以省略最后面的`int`

* 字符常量其实是int类型而不是char类型，当计算中出现字符时，C语言只是使用它对应的整数值，具体属于有符号整型还是无符号整型按编译器而定（但一定是只有8位的），所以最好在前面加上`signed char`或是`unsigned char`

* 有符号操作数与无符号操作数组合使用的时候会将有符号数**提升**为无符号数，这样的提升是通过给有符号数加上或者减去n+1的倍数，这样潜在的可能会导致问题，见下面的例子:

  ```c
  # include <stdio.h>
  
  int main() {
      unsigned a = 5;
      signed b = -10;
      printf("期待结果为1，比较的结果：%d\n", a > b);  // 0
      printf("b = %ud\n", b);         // 4294967286d 有符号数转换为无符号数导致了数值的异常增大
  }
  ```

  所以，尽量不要使用无符号数，而使用有符号数

* 在溢出之前强制转换好更大的数据类型，如下的程序看起来没问题但是会导致溢出：

  ```c
  # include <stdio.h>
  int main() {
      long i;
      int j = 100000;
      i = j * j;							// 因为j*j的类型还是int，此时已经无法承受这么大的数了，虽然赋值给i看起来可以接受
      printf("%d * %d = %ld\n", j, j , i);		// 100000 * 100000 = 1410065408
  }
  ```

  正确的写法：

  ```c
  # include <stdio.h>
  int main() {
      long i;
      int j = 100000;
      i = (long)j * j;				// 赋值之前先转换，或者说溢出之前先转换
    	// i = (long)(j*j);				// 这样的写法也还是错的！
      printf("%d * %d = %ld\n", j, j , i);  // 100000 * 100000 = 10000000000
  }
  ```

* `typedef`: 相比于宏，如果要定义新的自定义类型，使用类型定义会更加好`typedef int Bool`, 会把Bool看作是int的同义词；C语言库也广泛使用类型定义创建类型名，一般以`_t`结尾:

  ```c
  typedef unsigned long int size_t;
  typedef int wchar_t;
  ```

* `sizeof`: 获取存储指定类型值所需要的内存空间（字节数=8bit），其返回的值是一个无符号的整型（就是上面的`size_t`），例如`sizeof(int)=4`(32位主机上）

  比较特殊的点在于：此运算符在编译期间就可以确定其结果即编译器本身就可以确定其值（除了C99中的变长数组）

  ```c
  #include <stdio.h>
  
  int main() {
      int i = 10;
      printf("%lu\n", sizeof i);  // 4, sizeof可以省略括号
  }
  ```

  

​	







