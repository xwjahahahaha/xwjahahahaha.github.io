---
title: 运维相关面经
tags:
  - null
categories:
  - null
toc: true
date: 2022-08-13 10:09:05
---

[TOC]

<!-- more -->

# 一、基本命令使用

## 1. 怎样看一个进程cpu、内存占用？

可以通过:

* `ps aux ｜ grep xxx`

  ![image-20220813102235501](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220813102235501.png)

  如果需要知道前n个，可以配合其他命令：

  消耗内存前10排序的进程: `ps aux | sort -k4nr |head -n 10`

* `top`命令

## 2. 进程状态有哪些？

S表示休眠，R表示正在运行，Z表示僵死状态

## 3. VSZ虚拟内存与RSS物理内存的区别?为什么要有两个

> https://blog.csdn.net/q191201771/article/details/103321934

`RSS`是`Resident Set Size`（常驻内存大小）的缩写，用于表示进程使用了多少内存（RAM中的物理内存），**RSS不包含已经被换出的内存**。RSS包含了它所链接的动态库并且被加载到物理内存中的内存。RSS还包含栈内存和堆内存

`VSZ`是`Virtual Memory Size`（虚拟内存大小）的缩写。它包含了进程所能访问的所有内存，**包含了被换出的内存**，**被分配但是还没有被使用的内存**（例如堆栈内存），以及动态库中的内存

## 4. 如何查看主机内存使用情况

> https://www.jianshu.com/p/e9e0ce23a152

### free命令

```shell
free   		# 用KB为单位展示数据
free -m   # 用MB为单位展示数据
free -h   # 用GB为单位展示数据
```

![img](http://xwjpics.gumptlu.work/qinniu_uPic/webp.jpg)

* `total` : 总计物理内存的大小
* `used` : 已使用内存的大小
* `free` : 可用内存的大小
* `shared` : 多个进程共享的内存总额
* `buff/cache` : 磁盘缓存大小
* `available` : 可用内存大小 ， 从应用程序的角度来说：`available = free + buff/cache`

### cat /proc/meminfo

![img](http://xwjpics.gumptlu.work/qinniu_uPic/webp-20220813103752803.jpg)

## 5. 如何查看端口占用情况

### lsof

`lsof -i:端口号`

更多`lsof`命令:

```shell
lsof -i:8080：查看8080端口占用
lsof abc.txt：显示开启文件abc.txt的进程
lsof -c abc：显示abc进程现在打开的文件
lsof -c -p 1234：列出进程号为1234的进程所打开的文件
lsof -g gid：显示归属gid的进程情况
lsof +d /usr/local/：显示目录下被进程开启的文件
lsof +D /usr/local/：同上，但是会搜索目录下的目录，时间较长
lsof -d 4：显示使用fd为4的进程
lsof -i -U：显示所有打开的端口和UNIX domain文件
```

### netstat

**netstat -tunlp** 用于显示 tcp，udp 的端口和进程等相关情况

`netstat -tunlp | grep 端口号`

- -t (tcp) 仅显示tcp相关选项
- -u (udp) 仅显示udp相关选项
- -n 拒绝显示别名，能显示数字的全部转化为数字
- -l 仅列出在Listen(监听)的服务状态
- -p 显示建立相关链接的程序名

例如查看 8000 端口的情况，使用以下命令：

```shell
$ netstat -tunlp | grep 8000
tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      26993/nodejs   
```

更多命令：

```shell
netstat -ntlp   						 //查看当前所有tcp端口
netstat -ntulp | grep 80   	 //查看所有80端口使用情况
netstat -ntulp | grep 3306   //查看所有3306端口使用情况
```

## 6. 如何查看磁盘使用情况

`df -h`

https://blog.51cto.com/u_15127664/3391706

## 7. top中一个进程的cpu使用率是如何计算出来的

> https://www.cnblogs.com/gatsby123/p/11127158.html

某进程cpu使用率 = 该进程cpu时间 / 总cpu时间

`/proc/pid/stat`中可以得出进程自启动以来占用的cpu时间。以bash进程为例:

```basic
79 (bash) S 46 79 79 34816 0 0 0 0 0 0 46 135 387954 4807 20 0 1 0 6114 232049254400 873 18446744073709551615 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

第14项utime和第15项stime分别表示bash自启动起来，执行用户代码态占用的时间和执行内核态代码占用的时间，单位是clock tick，clock tick是时间单位。这两项的详细解释如下（摘自man proc）：

```txt
              (14) utime  %lu
                        Amount  of  time  that  this process has been scheduled in user mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).  This includes
                        guest time, guest_time (time spent running a virtual CPU, see below), so that applications that are not aware of the guest time field  do  not
                        lose that time from their calculations.

              (15) stime  %lu
                        Amount of time that this process has been scheduled in kernel mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).
```

每个clock tick占用多少时间呢？
可以通过`sysconf(_SC_CLK_TCK)`获取1秒内有多少个`clock tick`（通常是100）。也就是说1 `clock tick`为1 / 100秒。

有了上面的基础，
我们可以每隔period秒读取`/proc/pid/stat`，解析其中的`utime`和`stime`，将其和`(utime+stime)`减去上一次采样时这两项的和`(lastutime + laststime)`，这就是`period`秒内该进程占用CPU的时间，单位为clock tick

总的CPU时间为`period * sysconf(_SC_CLK_TCK)`，单位也为clock tick。

所以公式如下：

某进程cpu使用率 = `((utime+stime) - (lastutime+laststime)) / (period * sysconf(_SC_CLK_TCK))`

## 8. 如何实现linux的开机自启动执行

### 方法一：修改/etc/rc.local

修改好脚本，在任意目录启动时正常执行
在`/etc/rc.local`的末尾添加一行以绝对路径启动脚本的行

`vim /etc/rc.local`

```shell
#!/bin/sh
#
#This script will be executed after all the other init scripts.
#You can put your own initialization stuff in here if you don't
#want to do the full Sys V style init stuff.

/bin/bash /server/scripts/test123.sh >/dev/null 2>/dev/null
```

保存并重启

### 方法二：chkconfig管理

init.d目录下都为可执行程序，他们其实是服务脚本，按照一定格式编写，Linux 在启动时会自动执行，类似Windows下的服务 用root帐号登录，`vi /etc/rc.d/init.d/mystart`，追加如下内容：

```shell
#!/bin/bash
#chkconfig:2345 80 05 --指定在哪几个级别执行，0一般指关机，
#6指的是重启，其他为正常启动。80为启动的优先级，05为关闭的优先机
#description:mystart service
#!/bin/bash
#chkconfig: 3 88 88

/bin/bash /server/scripts/test123.sh >/dev/null 2>/dev/null
```

`chmod +x /etc/init.d/mystart`

添加到`chkconfig`，开机自启动

`chkconfig --add mystart`

查看服务进程的状态

`chkconfig --list mystart`

chkconfig管理中删除

`chkconfig --del mystart`

## 9. 软连接硬连接的区别与使用

<img src="https://xzchsia.github.io/img/in-post/linux-hard-soft-link/linux-soft-hard-link-diff.png" alt="Linux硬链接和软连接的区别" style="zoom: 67%;" />

硬连接：

* 具有相同inode节点号的多个文件互为硬链接文件；
* 删除硬链接文件或者删除源文件任意之一，文件实体并未被删除；
* 只有删除了源文件和所有对应的硬链接文件，文件实体才会被删除；
* 硬链接文件是文件的另一个入口；
* 可以通过给文件设置硬链接文件来防止重要文件被误删；
* 创建硬链接命令 `ln 源文件 硬链接文件`；
* 硬链接文件是普通文件，可以用`rm`删除；
* 对于静态文件（没有进程正在调用），当硬链接数为0时文件就被删除。注意：如果有进程正在调用，则无法删除或者即使文件名被删除但空间不会释放
* 硬连接与源文件指向同一个`inode`

软连接：

- 软链接类似windows系统的快捷方式；
- 软链接里面存放的是源文件的路径，指向源文件；
- 删除源文件，软链接依然存在，但无法访问源文件内容；
- 软链接失效时一般是白字红底闪烁；
- 创建软链接命令 `ln -s 源文件 软链接文件`；
- 软链接和源文件是不同的文件，文件类型也不同，inode号也不同；
- 软链接的文件类型是`l`，可以用`rm`删除

# 二、问题排查

## 1. 电脑访问官网访问不通如何排查？网络速度慢如何排查？

> https://www.cnblogs.com/Security-Darren/p/4700387.html

如果是网络不通，要定位具体的问题，一般是不断尝试排除不可能故障的地方，最终定位问题根源。一般需要查看：

* 是否接入到链路/是否插了网线
* 是否启用了相应的网卡
  * 使用`ifconfig`查看网卡状态、配置
* DNS故障检查
  * 使用`nslookup`命令查看DNS解析
* 远程端口是否开放（`telnet [ip] [port]`、`nc -v [host] [port]`）
* 能否路由到目标主机
  * 使用`route -n`命令查看内核路由表，检查网关是否路由连通
  * 使用`traceroute`追踪路由状况

如果是网络速度慢，一般有以下几个方式定位问题源：

* DNS是否是问题的源头
* 查看路由过程中哪些节点是瓶颈
* 查看带宽的使用情况

## 2. rm删除一个大文件(一个log文件)但是磁盘空间没有立即减小的原因

> https://blog.csdn.net/wyzxg/article/details/4971843

未释放磁盘空间原因：

在Linux或者Unix系统中，通过rm或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink).然而如果文件是被
打开的（有一个进程正在使用），那么进程将仍然可以读取该文件，磁盘空间也一直被占用。而我删除的是oracle的告警log文件
删除的时候文件应该正在被使用

首先获得一个已经被删除但是仍然被应用程序占用的文件列表，如下所示：

```shell
[root@ticketb ~]# lsof |grep deleted
oracle    12639  oracle    5w      REG              253,0         648     215907 /home/oracle/admin/dbticb/udump/dbticb_ora_12637.trc (deleted)
oracle    12639  oracle    6w      REG              253,0 16749822091     215748 /home/oracle/admin/dbticb/bdump/alert_dbticb.log (deleted)
oracle    12639  oracle    7u      REG              253,0           0      36282 /home/oracle/oracle/product/10.2.0/db_1/dbs/lkinstdbticb (deleted)
oracle    12639  oracle    8w      REG              253,0 16749822091     215748 /home/oracle/admin/dbticb/bdump/alert_dbticb.log (deleted)
oracle    12641  oracle    5w      REG              253,0         648     215907 /home/oracle/admin/dbticb/udump/dbticb_ora_12637.trc (deleted)
oracle    12641  oracle    6w      REG              253,0 16749822091     215748 /home/oracle/admin/dbticb/bdump/alert_dbticb.log (deleted)
。
。
。
oracle    23492  oracle    6w      REG              253,0 16749822091     215748 /home/oracle/admin/dbticb/bdump/alert_dbticb.log (deleted)
oracle    23492  oracle    7u      REG              253,0           0      36282 /home/oracle/oracle/product/10.2.0/db_1/dbs/lkinstdbticb (deleted)
oracle    23492  oracle    8w      REG              253,0 16749822091     215748 /home/oracle/admin/dbticb/bdump/alert_dbticb.log (deleted)
oracle    23494  oracle   10u      REG              253,0           0      36307 /home/oracle/oracle/product/10.2.0/db_1/dbs/lkinstrmandb (deleted)
```

从输出结果可以看到`/home/oracle/admin/dbticb/bdump/alert_dbticb.log`还被使用，未被释放空间

如何让进程释放呢？

一种方法是kill掉相应的进程，或者停掉使用这个文件的应用，让os自动回收磁盘空间

我这个环境有很多进程在使用的这个文件，停掉进程有点麻烦，再有就是风险很大

当linux打开一个文件的时候,Linux内核会为每一个进程在/proc下的『`/proc/nnnn/fd/目录`（nnnn为pid）』建立一个以其pid
为名的目录用来保存进程的相关信息，而其子目录fd保存的是该进程打开的所有文件的fd（fd：file descriptor）

kill进程是通过截断proc文件系统中的文件可以强制要求系统回收分配给正在使用的的文件。这是一项高级技术，仅到管理员确定不会对运行中的进程造成影响时使用。应用程序对这种方式支持的并不好，当一个正在使用的文件被截断可能会引发不可预知的问题

所以还是最好采用**停应用**来解决

 restart oracle数据库，发现`/home/oracle/admin/dbticb/bdump/alert_dbticb.log`对应的空间被释放

 
