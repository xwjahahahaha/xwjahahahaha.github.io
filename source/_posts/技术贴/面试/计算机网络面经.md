---
title: 计算机网络面经
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2021-11-29 21:40:26
---

[TOC]

<!-- more -->

## 1. GET、POST、PUT、DELETE区别

都属于`Restful`的接口规范 (还有一个种方式就是`rpc`)

* get：获取服务器资源，类似于查询，不会修改数据
* post：向服务端发送数据，类似于插入，会新增服务端的数据状态
* put：向服务端发送数据，类似于更新，会改变服务端的数据状态，但是不会新增
* delete：请求服务端删除一个资源，类似于删除，会减少服务端的数据状态

比较：

* get VS post：get的参数放在请求url上，post的请求数据放在请求体中，get的请求会在浏览器产生缓存而post不会。一个是查询数据的方式，一个是发送数据的方式
* put VS post： 两者都是发送数据，但是post的url一般对应到一个集合资源上新增，而put的url一般对应到一个具体的对象上修改或更新

## 2.`Restful`与`rpc`的区别

`restful`是面向资源的，多用于C/S架构； `rpc`是远程过程调用，多用于微服务

* 从本质上看rpc一般是基于tcp的，而restful是基于Http来实现的
* 从传输的数据量上来看，restful是http封装的所以数据量更大，而rpc更加轻量级也更快
* 因为一般使用restful的服务都是toC的，不明白请求的来源，http协议是各个框架都普遍支持的，所以可以在网关使用restful利用http来接收；而rpc一般用于公司内部自定义的协议，都是商量好的，知道数据模式，所以用tcp传输更加快速

* restful的API是面向资源的，对于一个资源的操作体现在GET、POST、PUT、DELETE上，同一个url可以有不同的操作；而rpc通常直接将操作动作放在请求url上

## 3.RPC框架要做到的最基本的三件事：

1. 服务端如何确定客户端要调用的函数；

   在远程调用中，客户端和服务端分别维护一个【ID->函数】的对应表， ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，附上这个ID，服务端通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。

2. 如何进行序列化和反序列化；

   客户端和服务端交互时将参数或结果转化为字节流在网络中传输，那么数据转化为字节流的或者将字节流转换成能读取的固定格式时就需要进行序列化和反序列化，序列化和反序列化的速度也会影响远程调用的效率。

3. 如何进行网络传输（选择何种网络协议）；

   多数RPC框架选择TCP作为传输协议，也有部分选择HTTP。如gRPC使用HTTP2。不同的协议各有利弊。TCP更加高效，而HTTP在实际应用中更加的灵活。

## 4. session和cookie的介绍与区别

* **存储位置不同：**session存储在服务器上，cookie存储在客户端浏览器上
* **存储量不同：**session的大小没有限制，但是不会存放很多东西并会设置删除机制；cookie保存的数据<=4kb， 一个站点最多保存20个cookie
* **存储方式不同：**session能存储任何数据类型的数据，而cookie只能保管ASCII字符串并编码为unicode字符或二进制数据0
* **安全性不同：**session安全性高对用户透明，cookie对客户端可见安全性低可能会被恶意分析
* **有效期不同：**session依赖于JSESSIONID的cookie，一般关闭窗口该session就会失效。cookie可以设置属性从而达到长期有效的作用
* **跨域不同：**session不支持跨域，而cookie支持

## 5. 基于session的认证与基于token的认证

### 传统的基于session认证

http是一种**无状态的协议**，不可能每次访问服务器资源都需要提供用户名和密码，所以一般就会在服务端保存session然后当服务端返回数据时，会保存为cookie在浏览器中以便下一次使用

缺点：

* session保存在服务端**内存**，如果用户量大的话就会导致服务端压力过大
* 一个session将用户与一个服务端绑定，不利于分布式场景
* cookie保存在浏览器有被攻击的风险

### 基于token的认证

token的认证方式也是无状态的，不将用户与服务端绑定。在每个用户第一次登陆的时候，服务端根据用户信息生成一个时效token，然后返回给用户，下一次再需要请求的时候，用户只需要在请求头中加入这个token就可以访问对应的服务。

## 6. 从输入url链接到网页显示出来的过程/使用到的协议

1. 浏览器查找当前URL是否存在缓存，并比较缓存是否过期。
2. DNS解析URL对应的IP。
3. 根据IP建立TCP连接（三次握手）。
4. HTTP发起请求。
5. 服务器处理请求，浏览器接收HTTP响应。
6. 渲染页面。
7. 关闭TCP连接（四次挥手）。

**DNS协议**解析域名获得IP

依据IP地址浏览器向服务器发送**HTTP**请求，使用**TCP协议**与服务器建立连接

连接建立时要发送数据，发送数据在网络层使用**IP协议**

期间IP数据包在路由器间路由选择使用**OPSF协议**

路由器与服务器通信，需要将IP转换为MAC地址，使用**ARP协议**

随即服务器处理请求，发回一个**HTML**响应，浏览器使用HTTP协议显示HTML页面

## 7. http 7层以及对应的作用/协议

* 物理层：以二进制的形式在物理媒体上进行传输，确定传输标准  集线器、中继器
* 数据链路层： 物理地址寻址、数据成帧、流量控制、数据检错CRC循环冗余检测等   PPP、HDLC 网桥、交换机、

* 网络层：寻找地址和**路由选择**，还实现了**拥塞控制**、网际互联等  IP ARP地址解析协议（IP->Mac） DHCP动态主机分配协议（给主机分配动态IP）。ICMP网际控制报文（站点间传递信息、错误报告等）路由器
* 传输层：端到端的数据传输，流量控制、差错控制。tcp、udp  OSPF开放最短通路优先协议
* 会话层：建立或断开通信连接 
* 表示层：数据格式的转换
* 应用层：为应用程序提供服务 http  RIP路由信息协议 FTP

## 8. Socket

是一个通信模型，简单来说就是接受端绑定IP和端口，对应到IP主机的一个应用程序，不断的监听包，当发送端发送时双方建立tcp连接，然后发送端不断发送，接受端接收。最后断开连接

## 9. tcp三次握手建立连接

第一次握手：客户端发送同步包x到服务器，并进入SYN_SEND状态，等待服务器确认； 

第二次握手：服务器收到同步包，同时自己也发送一个同步包y和一个确认包x+1，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的同步包和确认包，向服务器发送确认包y+1，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

**握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。**

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/cWFX7q.png" alt="cWFX7q" style="zoom: 33%;" />

## 10. tcp四次挥手断开连接 time_wait为什么2MLS？

* 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。
* 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
* 
* 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
* 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

 time wait等待2MLS的原因在于：

只有主动调用closed的一方才会在接收到对端的ACK后进入time_wait状态

2MLS是报文最大生存时间。如果最后一个确认包丢失了，被动关闭方可以再发送一个FIN包，这样主动关闭方可以再返回一个确认包；还有一个原因是让连接中的旧包在网络中时效而不会影响下一次的连接。

## 11. 大量close_wait会出现的问题？怎么解决？

服务端连接没有关闭会造成大量的close_wait

close_wait的危害在于，在一个进程上打开的文件描述符超过一定数量，（在linux上默认是1024，可修改），新来的socket连接就无法建立了，因为每个socket连接也算是一个文件描述符。

对服务端的连接记得释放资源，连接要设置最大超时时间

## 11. DNS域名解析方式

1. 递归查询:
   一般客户机和服务器之间属递归查询，即当客户机向dns服务器发出请求后,若dns服务器本身不能解析,则会向另外的dns服务器发出查询请求，得到结果后转交给客户机；、
2. 迭代查询(反复查询):
   一般dns服务器之间属迭代查询，如：若dns2不能响应dns1的请求，则它会将dns3的ip给dns2，以便其再向dns3发出请求；

## 12. tcp和udp区别

- TCP协议是有连接的，有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的
- TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。
- TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。
- TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率
- TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。
- UDP是面向报文传输的， 应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文 ；TCP是面向字节流传输的， TCP把应用程序发来的数据看成是一连串的字节流 ，等缓冲区缓冲了一定的字节就发送一次

**TCP**： 效率要求低，对准确性要求高的场景 。 eg：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录 

**UDP**： 效率要求高，准确性要求低的场景 。eg: 视频聊天、语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播

## 14. Http状态码

一般情况下有5大类：

* 信息响应(`100`–`199`)
* 成功响应(`200`–`299`)
* 重定向(`300`–`399`)
* 客户端错误(`400`–`499`)
* 服务器错误 (`500`–`599`)。

## 15. JWT的组成部分/Token的一些其他问题

![UY7YbE](http://xwjpics.gumptlu.work/qinniu_uPic/UY7YbE.png)

* Header：同步由以下json结构生成，生成的方式是将整个json字符串经过Base64Url编码

  ```json
  {
    "typ": "JWT",			// 表示是一个JWT字符串
    "alg": "HS256"		// 表示Hash摘要算法
  }
  ```

* Payload: 用来承载需要传递的数据，其一个属性对成为claim标准，这样为claim标准，同样Base64Url编码

  ```json
  {
    "sub": "123456",
    "name": "Jone",
    "admin": true
  }
  ```

* Signature: 将前两个字符串加一个`.`拼接然后通过head头中的hash摘要算法处理

**token被别人获取了是不是就可以访问你的页面了？**

是的，token就像是一个临时密码。解决方法：

* token时间不要设置过长
* 服务端中可以记录token和对应的IP，防止其他IP登陆

* 只读数据可以放宽，但是对于重要的数据操作接口可以加一层密码验证

**token会不会重复？**

如果在claim中加入时间戳的话一般不会

**token的验证？**

将收到的token使用相同的签发人签名对比签名字段是否相同

## 16. 流量控制和可靠传输机制是什么

发送方发送数据，接收方来的急接收

* 停止等待流量控制（一帧）
* 滑动窗口流量控制（多帧）

可靠传输机制就是让发送端发送什么，接收端就接收到什么，避免帧的丢失、重复等

* 停止等待协议，发1接1
* 后退N帧协议，发N接1
* 选择重传协议，发N接N

## 17. 介质访问控制

* 信道划分访问控制： 频分复用、时分复用、波分多路复用、码分多址

* 随机访问控制：CSMA/CD（先听后发，边听边发，冲突停发，随机重发）

* 轮询访问介质访问控制：基于令牌轮询访问

## 18. 路由算法和RIP、OSPF

* 距离向量路由算法RIP：根据跳数判断节点是否可达，每次互相更新全部路由表
* 链路状态路由算法OSPF：使用洪泛法更新路由信息，根据缔结斯特拉算法找出最短路径

IGP内部网关协议：一个自治系统内部所使用的的路由选择协议，例RIP、OSPF

EGP外部网关协议： 不同自治系统的路由器之间交换路由信息， 例BGP

### RIP

​       Routing Information protocol 

​       路由信息协议  报文借助UDP  内部网关协议  应用层协议

​       仅和相邻路由器交换信息，只选择路径上路由器数目最少（最小跳数）的，大于15       跳即认为不可达，适合较小的自治系统

​       距离：跳数

​       距离向量路由算法：

​           ①.收到x的RIP报文，将下一跳字段都修改为X，然后所有距离+1；

​           ②若路由表中的目的网络在本路由表中不存在，那么就添加

​           ③若存在，那么如果下一跳都为x那么就更新，否则比较最短的路径替换

​       优点：

​           实现简单，开销小，收敛较快

​       缺点：

​           限制了网络的规模

​           交换的是整个路由表，开销较大

​           坏消息传的慢，更新过程的收敛时间较长

### OSPF

​    Open shortest path first 开放最短通路优先  借助IP传送 内部网关协议 传输层协议

​    路由算法是链路状态路由算法，仅当网络网络拓扑发生变化，采用洪泛法向本自治系统发送信息，发送的链路状态的信息是指链路的代价可能包括链路的时延、费用、长度等等。整个自治系统内部的所有路由器都会维护一个链路状态数据库。当代价为无穷时，即表示两个路由器没有相连即不可达。路径的选择使用Dijkstra最短路径算法求得。

​    OSPF适合大型的自治系统，它会将自治系统划分为更小的区域，且坏消息传的快

### BGP

​    Border Gateway protocol 边界网关协议 借助TCP传送 外部网关协议 应用层协议·

​    在不同自治系统间交换路由信息的协议，采用路径-向量路由选择协议，是找到一条能够到达目的网络较好的路由

​    特点

​    1.交换信息的节点数量级是自治系统数量级的

​    2.每个自治系统的BGP发言人（边界路由器）数量很少，使得系统之间的路由选择不过于复杂

​    3.支持CIDR

## 19. 拥塞控制

### 1.慢开始算法

​    拥塞窗口从1开始，没经过一个轮次，拥塞窗口就加一倍，开始较缓慢整体以指数型增长，增长到规定的阈值就开始拥塞避免算法

### 2.拥塞避免算法

​    拥塞避免“加法增大”，每经过一个往返时延就增加一个MSS大小，呈线性增长。出现了拥塞，就将阈值设置为拥塞窗口的一半（“乘法减小”），然后将拥塞窗口置1

### 3.快重传算法

​    要求每收到一个失序的报文段就立即发出重复确认，连续收到三个重复确认就立即重传

### 4.快恢复算法

​    发送端收到连续3个重复的确认，就执行“乘法减小”，阈值设置为拥塞窗口的一半，但接下来不执行慢开始方法，而是以当前拥塞窗口的一半继续执行拥塞避免加法增大

**拥塞控制怎样知道网络出现阻塞？**

发送端连续收到多/三个接收端重复确认包

## 20. RTT问题

RTT指从一个短分组从客户到服务器然后再返回客户所花费的时间。

TCP超时重传的时间的估算：>RTT的时间

通过样本RTT的时间计算估计的时间（在某一个时刻）

使用以下公式更新评估RTT的时间：

```go
EstimatedRTT = (1-α)*EstimatedRTT + α*SampleRTT
```

## 21.TCP如何保证可靠传输

TCP协议保证数据传输可靠性的方式主要有：

数据链路层：

- 校验和 ： tcp首部有一个校验和字段，如果不一致则说明出现了错误 （校验数据段，16位加起来取反）
- 序列号：tcp首部对于每一个tcp包都有编号，确定包的顺序
- 确认应答：tcp首部的确认号，实现发送ACK报文
- 超时重传：如果迟迟没有收到确认就会重新发送
- 连接管理：三次握手、四次挥手
- 流量控制：控制发送端发送饿接收端来的急接收
- 拥塞控制：保证网络不阻塞

