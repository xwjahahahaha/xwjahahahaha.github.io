---
title: 状态中心模块优化
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2022-01-11 16:20:221
---

# 一、目的/原因

目前状态中心的问题如下：

* 虚拟机的状态文件存储在CFS目录下，当前版本会将CFS的存储介质由单机版的SQLite替换为MySQL，从而引入新问题，MySQL会出现不可写的场景（即当控制节点掉线个数达到半数时，MySQL不可写），而此种场景下需要支持虚拟机状态数据的修改（如虚拟机进程挂掉）

  > CFS：HCI使用的分布式服务，利用fuse文件系统挂载在/cfs和/cfs_ro目录下，提供集群配置文件的读写，此版本之前，虚拟机状态文件存储在这里。

* 虚拟机状态文件会随虚拟机的规模正比例递增，读写虚拟机状态时，全量读写整个文件会存在性能问题，而且，配置集中化存储后，每次读取都会造成较大的网络带宽的浪费

* HCI当前版本，集群规模需要支持256节点51200虚拟机，状态操作和维护存在性能瓶颈。

<!-- more -->

修改的目的：

1. 支持大集群规模下HCI各种资源的状态维护。
2. 统一维护资源状态数据，减少数据重复采集和存储冗余，降低性能消耗。
3. 提供状态数据监听触发能力，减少轮询带来的消耗。
4. 简化业务使用状态数据的方式，提高开发效率。

效果：

* 本模块提供状态更新接口，**支持手动操作资源后立即主动更新资源状态，以保证状态数据的实时性**。如，虚拟机开机后，主动更新虚拟机状态为“运行中”，其他服务和用户页面能立即感知虚拟机状态为“运行中”。
* 本模块提供状态定时更新校正机制，支持非正常操作导致资源状态变化后，能在敏感时间内更新资源状态。
* 本模块提供状态变化通知机制，依赖于状态变化触发操作的模块（如：HA、告警等）可直接注册触发条件到本模块，待状态变化满足触发条件时，主动通知目标服务，目标服务根据状态数据执行相应动作。避免定时获取状态数据增加系统性能压力，也避免增大响应时延。

# 二、应用场景

* 资源管理场景：用户在HCI管理页面，手动操作HCI上的各种资源，如：开关虚拟机、启禁用节点网口。

* 硬件维护场景：用户手动操作HCI相关物理硬件，如拔插USB、拔插磁盘。

* 硬件故障场景：HCI相关物理硬件异常故障，如：主机掉电、网口断线、磁盘故障。

* 软件故障场景：HCI系统相关进程异常故障，如：进程core掉，进程OOM被杀。

* 用户业务场景：用户的业务虚拟机繁忙，虚拟机资源和HCI系统资源消耗过高。

# 三、方案设计

## 1、状态数据采集方式

**方案1：报表模块统一采集（采纳）**
改造`Prometheus`，当采集的数据为状态数据时，转发给状态服务，`Prometheus`自己不存储。

<img src="http://xwjpics.gumptlu.work/image-20220307155151555.png" alt="image-20220307155151555" style="zoom: 67%;" />

优点：

* 状态服务不用感知节点规模和节点变化情况
* 后续由其他信息需要采集各节点数据的需求可复用此机制

缺点：

* 报表服务和状态服务之间存在耦合，报表服务不正常时，状态服务也会不可用

**方案2：状态服务自行采集**
参考或直接借用Prometheus的定时采集机制，由状态服务自行采集各节点的状态数据。

优点：

* 状态服务和报表服务完全独立，互不影响

缺点：

* 状态服务需要感知节点规模和节点变化情况，需要处理拉取失败等异常

**最终选择方案一，原因在于：拉取相关的共性问题可统一解决，耦合度不高，可接受**

方案一的缺陷处理：

将`Retrieval`模块拆成较独立的模块，模块实现支持扩展性，根据配置的数据类型和目标服务进行转发，不感知目标服务是谁，可支持根据采集的数据类型往多个服务转发数据。

> 需要一种新的采集服务就创建对应新的模块，然后相应的进行目标服务的转发，不感知目标服务是谁，增强拓展性

## 2、存储组件选型

状态中心选用存储组件需要满足以下需求：

数据库特性需求：

1. 多副本：推荐主备或较强一致性，可选单节点。单节点需考虑节点宕机情况。
2. 持久化：推荐内存，可选持久化。内存需要考虑数据丢失情况。
3. 关系型：推荐关系型，可选非关系型。非关系型需要合理设计数据存储结构。
4. 变化通知机制：推荐带此功能的组件。否则需要自己实现变化触发机制。

其他需求：控制节点少数组/在线数量较少时，数据库需要可写。

由于系统需求需要在控制节点多数离线时，仍要保证状态数据正常更新，故不可以选择一致性协议的方案，只能选择单机或主备方案：

方案：Redis单机、Redis哨兵模式、MongoDB单机版、Etcd单机版、服务内存（选择）

选择理由：

* 前三种虽然HCI项目中已经有使用，但是都不支持变化通知机制
* ETCD单机版支持变化通知机制但是不是关系型数据，且不能提供高可用
* 服务内存不需要引入任何新组件需要自行实现（包括状态变化通知机制）
* **状态数据不需要持久化，状态服务目前分析无多进程或多节点的扩展需求。**

缺陷解决：

1. 维护状态服务进程的可靠性，减少内存数据丢失的概率。
2. 进程异常挂掉重启时，触发一次拉取状态数据
3. 根据各业务诉求，合理设计数据存储结构

## 3、高可用方案选型

相关需求：

* 主控挂掉后，需要在短时间内由另一控制节点提供状态服务
* 控制节点全部挂掉后，允许不提供状态服务

方案：

* 使用带高可用能力的存储组件

  状态服务往存储组件更新数据后，组件自动同步数据到其他控制节点。主控挂掉后，另一控制节点可无缝衔接，对外提供状态服务

* 使用单机版存储组件，由状态服务同步数据到其他节点

  主控的状态服务更新数据后，主动写到其他控制节点的存储组件或转发到其他节点的状态服务来更新。主控挂掉后，另一控制节点可无缝衔接，对外提供状态服务

* 不做高可用（选择的方案）

* 复用报表高可用方案

  每个控制节点的报表服务都是独立的服务，三个节点职责一致。

决策依据：

1. 方案1，维护组件之间的主备关系较复杂，关联场景处理较麻烦。
2. 数据可靠性要求不高，仅在主控节点宕机或切换时，才需要高可用能力。
3. 资源开销较低

所选方案缺陷的处理措施：状态服务所在节点切换时，**触发一次拉取全量数据**

## 4、通知方案选型

状态数据变化后，会根据指定条件选择性的触发一些动作，比如HA、告警等。

之前实现是：各模块自己定时轮询关心的状态数据，检查是否满足触发条件，满足则执行相应动作。此方案实现较简单，但存在一些问题，如：定时轮询会存在时延性、定时轮询会消耗较多的系统资源。

目前打算实现一种**状态变化后主动通知的机制**。

方案：

* `k8s apiserver`机制**（选用）**

  简述：服务端与客户端之间维护长连接，第一次发送全量数据，后续变化时，发送变化数据

* `Etcd watch`机制

  简述：客户端watch指定的key或key前缀，数据变化时，服务端推送数据。

  说明：更新时触发 + `gRPC`通知（HTTP/2）

* `zk watch`机制

  简述：客户端get时候设置watch的回调，服务端数据变化时触发回调（触发数据只有事件，没有实际数据），客户端重新get并再次设置watch。（watch只会触发一次：没有重新watch的话，后续变化不会通知）

  说明：更新时触发 + zk自有协议通知

* `Prometheus alert`机制

  简述：维护告警触发条件（可热更新），定时检测数据，满足触发条件时，发给` AlertManager` 

  说明：定时检测触发 + `RestAPI`通知

决策依据：

1. 大多数场景仅需要边缘触发。

   > 边缘触发：状态数据更新时，达到触发条件时触发通知
   >
   > 水平触发：
   >
   > * 数据上报时：每次数据上报时，如果数据上报时此次更新的数据触发条件时触发通知
   > * 定时检测：另起协程定时获取所有数据，一旦满足触发条件触发通知

2. 水平触发需要频繁检测数据，资源消耗较高。

所选方案缺陷的处理措施：**需要水平触发能力的服务，可保存状态，自行定时触发。**

## 5、通知策略维护策略

通知策略的维护方案可以通过持久化存储为配置文件维护或者直接维护在内存，或者两者相结合

最终选择了维护在内存中：

需要状态数据变化通知的服务，向状态服务注册触发条件，状态服务在内存中维护。状态服务挂掉时，配置会丢失，其他服务需要感知后重新注册。

决策依据：

1. 需要通知能力的服务，都为同一节点上的服务，进程可靠性和通知可靠性都较高，策略丢失概率较低，且有补救措施。
2. 策略处理较灵活，依赖通知能力的服务可以自行注册和回收。

## 6、通知方式选型

方案有：RestAPI、消息队列、长链接（选择）

最终选择长链接：

关心状态数据变化的服务，带上触发条件主动请求状态服务，并维持此连接，当状态数据变化满足触发条件时，状态服务通过此连接通知。

决策依据：

1. 单节点通信，通知可靠性可满足需求。
2. 长连接消耗影响可接受（预计<40个，可接受）。
3. 可适配后续k8s相关服务。
4. 易于维护通知策略的生命周期，链接断开即认为策略结束。

# 四、状态中心总体框架

## 总体结构

![image-20220307164942138](http://xwjpics.gumptlu.work/image-20220307164942138.png)

`api-sdk`：封装资源各种信息的操作接口

**定时更新状态-关键流程：**

1. `Prometheus`组件，定时拉取各节点的状态信息
2. 拉取到状态信息后，主动推送给状态服务
3. 状态服务处理上报的数据并保存

## 状态中心内部结构

![image-20220307165305097](http://xwjpics.gumptlu.work/image-20220307165305097.png)

`StatusNotifier`: 更新时触发此模块，通知外部监听的模块

**关键流程（更新状态）**

1. `APIHandler`接收外部更新请求
2. `APIHandler`将更新请求转发给`StatusProcesser`模块处理
3. 处理后更新到`StatusStore`
4. 更新时触发`StatusNotifier`处理，然后将变化通知到外部监听的模块





