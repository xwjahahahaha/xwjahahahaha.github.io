---
title: 走向虚拟化-1-虚拟化基础概念浅理解
tags:
categories:
  - technical
toc: true
declare: true
date: 2022-01-07 16:25:05
---

[TOC]

# 虚拟化基础概念浅理解

> 参考：
> https://blog.csdn.net/aiyun1242/article/details/101811473
> VMX(2) -- VMCS理解： https://blog.csdn.net/lindahui2008/article/details/81834941
> https://www.cnblogs.com/sammyliu/p/4543110.html
>
> https://www.cnblogs.com/liuxgcn/p/11139027.html

## 1.CPU的Ring权级

Ring是指CPU的运行级别：

* Ring0：系统内核运行的最高级别
* Ring1~Ring2：硬件驱动程序
* Ring3：用户应用程序

每一层只能访问本层或权限更低层的数据

![image-20220107152340940](http://xwjpics.gumptlu.work/image-20220107152340940.png)

## 2. 全虚拟化、类虚拟化

虚拟化的难题：虚拟机运行在非Ring0级别，那么虚拟机系统如何实现真实物理机Ring0级别的指令呢？
解决方案：

* 类虚拟化（修改操作系统软件支持）

  * 客户端知道自己处于虚拟操作系统环境中，原本需要执行Ring0级别的特权指令就被修改为一些和VMM商量好的方式

  * 也就是将原本操作系统代码中需要Ring0级别访问的特权操作进行修改为非特权并模拟，特制成类似于x86、arm等内核版本，这样就解决了这个问题
  * 典型的实现：Xen类虚拟化

* 硬件辅助的全虚拟化（更新硬件支持） 

  * cpu厂商开始支持虚拟化，例如x86 CPU引入Interl-VT技术，支持VMX root operation （根模式）和 VMX non-root operation （非根模式）两种模式，两种模式都支持Ring0~3四个级别
  * VMM可以运行在根模式，而虚拟机OS运行在非根模式，这样实现了只是在硬件上实现区分而不是原本的软件级别

## 3. 根模式/非根模式、VMS、VMCS

在x86处理器的VMS(Virtual Machine Extension)功能中实现了VMX root operation （根模式）和 VMX non-root operation （非根模式）两种模式，两种模式都支持高特权级别
主要是当前CPU厂商对虚拟化的硬件支持，主要为两个方面：

* 通过在硬件上实现区分指令特权级别避免了【VMM截获虚拟机指令->解析→模拟】的过程，虚拟机OS指令权级可以直接在逻辑CPU硬件上实现
* 通过在硬件上实现VMCS(Virtual Machine Control Structure)虚拟机控制结构记录vCPU和物理主机CPU状态

VMCS虚拟机控制结构:

* 可以类比理解于进程PCB, 保存vCPU的控制和状态信息, 主要包含以下6类： 
  * Guest-state area： CPU状态信息，包括基本的运行环境（通用寄存器）等
  * Host-state area：主机物理CPU状态信息，因为物理CPU是在CPU与vCPU之间来回切换执行的，所以两边都要记录才可以保证切换的时候CPU上下文的重放。其包含的信息大致与Guest-state area相同
  * VM-execution control fields：对vCPU的运行行为进行控制，包括中断事件在vCPU中处理还是退出给VMM处理、是否使用EPT（Extended Page Table）、某些指令是否发出VMM Exit等
  * VM-exit control fields：对VM Exit的行为进行控制，即退出应该保存vCPU的哪些上下文状态（例如MSR寄存器等）以及切换到主机物理CPU需要恢复哪些状态
  * VM-entry control fields：即对VM Entry的行为进行控制，如需要保存和恢复哪些MSR寄存器，是否需要向vCPU注入中断和异常等事件
  * VM-exit information fields：记录下发生VM Exit发生的原因及一些必要的信息，方便于VMM对VM Exit事件进行处理

* 每个vCPU都有自己的一份VMCS数据结构，并且在同一个VM中的vCPU可能会通过VMCS中的指针共享一些数据，如I/O bitmap，MSR bitmap和EPT表等。

## 4.Hypervisor/VMM

虚拟机监视器（英语：virtual machine monitor，缩写为 VMM）
主要作用：

* 是虚拟化的核心，为各个虚拟机提供虚拟化支持
* VMM层在内核kernel中实现，虚拟机中的硬件资源访问由VMM进行驱动/管理，VMM是在虚拟环境中的一种“元”操作系统
* VMM在不同的虚拟机之间协调硬件资源的分配，同时在各个虚拟机之间施加防护

主要工作：

* 虚拟CPU：截获解析虚拟机CPU指令，在内核模拟指令并维护一个vCPU状态

## 5.KVM、Qemu、Guest

Kernel-Based Virtual Machine基于内核的虚拟机，运行在内核中的VMM，是Linux内核的一个模块，将Linux变成了一个Hypervisor/VMM

* 它由 Quramnet 开发，该公司于 2008年被 Red Hat 收购。
* 它支持 x86 (32 and 64 位), s390, Powerpc 等 CPU。
* 它从 Linux 2.6.20 起就作为一模块被包含在 Linux 内核中。
* 它需要支持虚拟化扩展(Intel VT 或者 AMD-V)的 CPU。

在KVM中：

* 虚拟机被实现为（或者说模拟为）常规的Linux进程，由标准的linux调度程序调度
* 虚拟机的每个虚拟CPU/vCPU实现为（或者说模拟为）常规的Linux线程
* 这些让KVM能够有使用linux内核的已有功能，但是KVM本身不进行任何硬件的模拟，所以需要 QEMU 通过 /dev/kvm 接口设置一个 GUEST OS 的地址空间，然后向其提供模拟I/O，并将视频显示映射回宿主机的显示屏

KVM架构：

![image-20220107152257951](http://xwjpics.gumptlu.work/image-20220107152257951.png)

* Guest：客户机系统即虚拟机系统，包括CPU（vCPU）、内存、驱动（Console、网卡、I/O 设备驱动等），被KVM设置为一种受限制的CPU模式下使用
* KVM：运行在内核空间，提供CPU的虚拟化以及客户机的I/O拦截，客户机的I/O被拦截后交给Qemu处理
* Qemu：运行在宿主机的用户空间，为KVM提供服务，提供用户I/O的虚拟化，通过 IOCTL /dev/kvm 设备和 KVM 交互。

## 6. Qemu-KVM

其实 QEMU 原本不是 KVM 的一部分，它自己就是一个纯软件实现的虚拟化系统，所以其性能低下。但是，QEMU 代码中包含整套的虚拟机实现，包括处理器虚拟化，内存虚拟化，以及 KVM需要使用到的虚拟设备模拟（网卡、显卡、存储控制器和硬盘等）。

为了简化代码，KVM 在 QEMU 的基础上做了修改。VM 运行期间，QEMU 会通过 KVM 模块提供的系统调用进入内核，由 KVM 负责将虚拟机置于处理的特殊模式运行。当虚机进行 I/O 操作时，KVM 会从上次系统调用出口处返回 QEMU，由 QEMU 来负责解析和模拟这些设备。
从 QEMU 角度看，也可以说是：

**QEMU 使用了 KVM 模块的虚拟化功能，为自己的虚机提供了硬件虚拟化加速。除此以外，虚机的配置和创建、虚机运行所依赖的虚拟设备、虚机运行时的用户环境和交互，以及一些虚机的特定技术比如动态迁移，都是 QEMU 自己实现的。** 

## 7. Inter VT

现代 CPU 本身实现了对特殊指令的截获和重定向的硬件支持，甚至新硬件会提供额外的资源来帮助软件实现对关键硬件资源的虚拟化从而提高性能。
以 X86 平台为例，支持虚拟化技术的 CPU  带有特别优化过的指令集来控制虚拟化过程。通过这些指令集，VMM 很容易将客户机置于一种受限制的模式下运行，
一旦客户机试图访问物理资源，硬件会暂停客户机运行，将控制权交回给 VMM 处理。VMM 还可以利用硬件的虚级化增强机制，将客户机在受限模式下对一些特定资源的访问，完全由硬件重定向到 VMM 指定的虚拟资源，整个过程不需要暂停客户机的运行和 VMM 的参与（根模式和非根模式？）
由于虚拟化硬件提供全新的架构，支持操作系统直接在上面运行，无需进行二进制转换，减少了相关的性能开销，极大简化了VMM的设计，使得VMM性能更加强大。从 2005 年开始，Intel 在其处理器产品线中推广 Intel Virtualization Technology 即 IntelVT 技术。



