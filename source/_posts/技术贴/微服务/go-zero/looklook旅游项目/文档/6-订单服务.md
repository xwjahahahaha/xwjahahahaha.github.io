---
title: 6.订单服务
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2022-04-30 20:45:30
---


# 六、订单服务

本项目地址 :  https://github.com/Mikaelemmmm/go-zero-looklook

<!-- more -->

## 1、订单服务业务架构图

<img src="https://github.com/Mikaelemmmm/go-zero-looklook/raw/main/doc/chinese/images/6/image-20220428110910672.png" alt="image-20220428110910672" style="zoom:50%;" />

## 2、依赖关系

`order-api`（订单api） 依赖 `order-rpc`（订单rpc）、`payment-rpc`（支付rpc）、`travel-rpc`（民宿rpc）

`order-rpc`（订单rpc） 依赖` travel-rpc`（民宿rpc）

## 3、订单举例

### 3.1 下订单

1、用户在去浏览`travel`服务中的民宿`homestay`看中选择日期之后要下单，调用下单api接口

`app/order/cmd/api/desc/order.api`

```protobuf
//订单模块v1版本的接口
@server(
   prefix: order/v1
   group: homestayOrder
)
service order {
   
   @doc "创建民宿订单"
   @handler createHomestayOrder
   post /homestayOrder/createHomestayOrder (CreateHomestayOrderReq) returns (CreateHomestayOrderResp)
   
   .....
}
```

2、order-api中调用order-rpc

```go
// CreateHomestayOrder create order
func (l *CreateHomestayOrderLogic) CreateHomestayOrder(req types.CreateHomestayOrderReq) (*types.CreateHomestayOrderResp, error) {

	homestayResp , err:=l.svcCtx.TravelRpc.HomestayDetail(l.ctx,&pb.HomestayDetailReq{
		Id: req.HomestayId,
	})
	if err != nil{
		return nil, err
	}
	if homestayResp.Homestay == nil || homestayResp.Homestay .Id == 0{
		return nil,errors.Wrapf(xerr.NewErrMsg("homestay no exists"),"CreateHomestayOrder homestay no exists id : %d",req.HomestayId)
	}

	userId := ctxdata.GetUidFromCtx(l.ctx)
	// 调用orderRpc
	resp, err := l.svcCtx.OrderRpc.CreateHomestayOrder(l.ctx, &order.CreateHomestayOrderReq{
		HomestayId:    req.HomestayId,
		IsFood:        req.IsFood,
		LiveStartTime: req.LiveStartTime,
		LiveEndTime:   req.LiveEndTime,
		UserId:        userId,
		LivePeopleNum: req.LivePeopleNum,
		Remark:        req.Remark,
	})
	if err != nil {
		return nil, errors.Wrapf(xerr.NewErrMsg("create homestay order fail"), "create homestay order rpc CreateHomestayOrder fail req: %+v , err : %v ", req, err)
	}

	return &types.CreateHomestayOrderResp{
		OrderSn: resp.Sn,
	}, nil
}
```

3、rpc中校验条件创建订单之后 ，**会调用Asynq创建一个延迟关闭订单的消息队列**

`go-zero-looklook/app/order/cmd/rpc/internal/logic/createHomestayOrderLogic.go`

```go
// CreateHomestayOrder.
func (l *CreateHomestayOrderLogic) CreateHomestayOrder(in *pb.CreateHomestayOrderReq) (*pb.CreateHomestayOrderResp, error) {

	//1、Create Order
	if in.LiveEndTime <= in.LiveStartTime {
		return nil, errors.Wrapf(xerr.NewErrMsg("Stay at least one night"), "Place an order at a B&B. The end time of your stay must be greater than the start time. in : %+v", in)
	}
	// 调用TravelRpc获取民宿详情
	resp, err := l.svcCtx.TravelRpc.HomestayDetail(l.ctx, &travel.HomestayDetailReq{
		Id: in.HomestayId,
	})
	if err != nil {
		return nil, errors.Wrapf(xerr.NewErrMsg("Failed to query the record"), "Failed to query the record  rpc HomestayDetail fail , homestayId : %d , err : %v", in.HomestayId, err)
	}
	if resp.Homestay == nil {
		return nil, errors.Wrapf(xerr.NewErrMsg("This record does not exist"), "This record does not exist , homestayId : %d ", in.HomestayId)
	}

	var cover string //Get the cover...
	if len(resp.Homestay.Banner) > 0 {
		cover = strings.Split(resp.Homestay.Banner, ",")[0]
	}
	// 创建一个新的订单
	order := new(model.HomestayOrder)
	order.Sn = uniqueid.GenSn(uniqueid.SN_PREFIX_HOMESTAY_ORDER)		// 订单号
	...
	order.LiveEndDate = time.Unix(in.LiveEndTime, 0)
	// 计算住宿时间
	liveDays := int64(order.LiveEndDate.Sub(order.LiveStartDate).Seconds() / 86400) //Stayed a few days in total
	// 计算价格
	order.HomestayTotalPrice = int64(resp.Homestay.HomestayPrice * liveDays) //Calculate the total price of the B&B
	if in.IsFood {
		order.NeedFood = model.HomestayOrderNeedFoodYes
		//Calculate the total price of the meal.
		order.FoodTotalPrice = int64(resp.Homestay.FoodPrice * in.LivePeopleNum * liveDays)
	}

	order.OrderTotalPrice = order.HomestayTotalPrice + order.FoodTotalPrice //Calculate total order price.
	// 存储到数据库
	_, err = l.svcCtx.HomestayOrderModel.Insert(l.ctx,nil, order)
	if err != nil {
		return nil, errors.Wrapf(xerr.NewErrCode(xerr.DB_ERROR), "Order Database Exception order : %+v , err: %v", order, err)
	}

	//2、Delayed closing of order tasks.
	// 调用Asynq创建一个延迟关闭订单的消息队列
	payload, err := json.Marshal(jobtype.DeferCloseHomestayOrderPayload{Sn: order.Sn})
	if err != nil {
		logx.WithContext(l.ctx).Errorf("create defer close order task json Marshal fail err :%+v , sn : %s",err,order.Sn)
	}else{
		// 30分钟后关闭
		_, err = l.svcCtx.AsynqClient.Enqueue(asynq.NewTask(jobtype.DeferCloseHomestayOrder, payload), asynq.ProcessIn(CloseOrderTimeMinutes * time.Minute))
		if err != nil {
			logx.WithContext(l.ctx).Errorf("create defer close order task insert queue fail err :%+v , sn : %s",err,order.Sn)
		}
	}

	return &pb.CreateHomestayOrderResp{
		Sn: order.Sn,
	}, nil
}
```

4、`go-zero-looklook/app/mqueue/cmd/job/internal/logic/closeOrder.go`有定义asynq的延迟关闭订单任务

```go
// ProcessTask defer close no pay homestayOrder  : if return err != nil , asynq will retry
func (l *CloseHomestayOrderHandler) ProcessTask(ctx context.Context, t *asynq.Task) error {
	// 延迟关闭订单逻辑
	var p jobtype.DeferCloseHomestayOrderPayload
	if err := json.Unmarshal(t.Payload(), &p); err != nil {
		return errors.Wrapf(ErrCloseOrderFal, "closeHomestayOrderStateMqHandler payload err:%v, payLoad:%+v", err, t.Payload())
	}

	resp, err := l.svcCtx.OrderRpc.HomestayOrderDetail(ctx, &order.HomestayOrderDetailReq{
		Sn: p.Sn,
	})
	if err != nil || resp.HomestayOrder == nil {
		return errors.Wrapf(ErrCloseOrderFal, "closeHomestayOrderStateMqHandler  get order fail or order no exists err:%v, sn:%s ,HomestayOrder : %+v", err, p.Sn, resp.HomestayOrder)
	}

	if resp.HomestayOrder.TradeState == model.HomestayOrderTradeStateWaitPay {	// 如果不是等待支付状态就直接忽略
		_, err := l.svcCtx.OrderRpc.UpdateHomestayOrderTradeState(ctx, &order.UpdateHomestayOrderTradeStateReq{
			Sn:         p.Sn,
			TradeState: model.HomestayOrderTradeStateCancel,		// 改变交易状态
		})
		if err != nil {
			return errors.Wrapf(ErrCloseOrderFal, "CloseHomestayOrderHandler close order fail  err:%v, sn:%s ", err, p.Sn)
		}
	}

	return nil
}
```

所以我们启动这个`mqueue-job`的时候，`asynq`就会被加载、定义路由，当我们之前添加的延迟队列到了20分钟，就会自动执行关闭订单逻辑，如果订单没有被支付，这里就会关闭掉订单，支付了就忽略掉了，这样就可以不用使用定时任务轮询关闭订单了

### 3.2 订单列表

没啥逻辑，就是查出来显示罢了，自己看一下就好了

```protobuf
//订单模块v1版本的接口
@server(
   prefix: order/v1
   group: homestayOrder
)
service order {

   @doc "用户订单列表"
   @handler userHomestayOrderList
   post /homestayOrder/userHomestayOrderList (UserHomestayOrderListReq) returns (UserHomestayOrderListResp)
   
}
```

### 3.3 订单明细

没啥逻辑，就是查出来显示罢了，自己看一下就好了

```protobuf
//订单模块v1版本的接口
@server(
	prefix: order/v1
	group: homestayOrder
)
service order {

	@doc "用户订单明细"
	@handler userHomestayOrderDetail
	post /homestayOrder/userHomestayOrderDetail (UserHomestayOrderDetailReq) returns (UserHomestayOrderDetailResp)
}
```

## 4、结尾

下了订单，当然我们要支付了，那就看下一篇支付服务吧













