---
title: 容器安全相关调研
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2022-06-20 21:42:29
---

[TOC]

<!-- more -->

> 参考：
>
> * 《security_observability_with_ebpf》
> * [SDN x Cloud Native Meetup #46 WebinarFirecracker 與 gVisor 的三兩事](https://www.youtube.com/watch?v=c31fg5gQwHI)
> * https://xz.aliyun.com/t/11480
> * https://docs.docker.com/engine/security/apparmor/
> * https://zhuanlan.zhihu.com/p/337289840
> * https://docs.kernel.org/bpf/prog_lsm.html
> * https://cloud.tencent.com/developer/article/1817124

# 一、基本概念

## 1. Linux capabilities

在过去，进程要么作为根用户(UID 0)运行，要么作为标准用户(!=UID 0)，该系统是二进制的

一个进程要么是根进程，可以(几乎)做任何事情，要么是一个普通用户，只能使用自己的资源。

有时<font color='#e54d42'>**非特权进程需要特权能力**</font>，例如*ping*发送原始数据包而不授予它根权限。为了解决这个问题，内核引入了*capabilities*，这为非特权进程提供了更细粒度的安全能力，例如`CAP_NET_RAW`能力，以启用*ping*发送原始数据包

*capability*可以在文件或process上实现。为了观察一个正在运行的进程的*capability*，我们可以检查内核的虚拟文件系统，*/proc*:

![image-20220621142526077](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220621142526077.png)

通过`capsh`可以转换为人类可读字符串

能力集*capability set*：

一个进程或文件可以被授予几种能力集(有效的、允许的、可继承的、环境的)，但是我们只讨论有效的。

“有效”能力集指出进程中哪些能力是有效的，对于容器进程，一般只讨论有效能力集s*effective capability set*, 因为这些*capability*是被激活的，当一个进程试图执行一个特权操作时，内核将检查该进程的有效能力集的二进制位的某一位是否为1(上面的例子是16进制表示的)

> <font color='#39b54a'>总结：linux提供的，可以为非特权进程设置某项特权操作</font>

## 2. seccomp、 seccomp-bpf

`seccomp`（全称`securecomputing mode`）是linux内核提供的一种安全机制，在Linux系统里，大量的系统调用（systemcall）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。通过seccomp，我们限制程序使用某些系统调用，这样可以减少系统的暴露面，同时是程序进入一种“安全”的状态。

详细可见：[Seccomp、BPF与容器安全](/Users/xwj/blog/source/_posts/技术贴/eBPF/容器安全/Seccomp、BPF与容器安全.md)

> <font color='#39b54a'>总结：seccomp是linux提供的，依赖于classical BPF的用于限制某个进程对于一系列**系统调用**的使用权限，并设置对应的反应操作</font>

## 3. seccomp与linux capabilities的区别在哪？

都是对进程的限制，那么这两种linux提供的功能具体上有何区别？

以下来自于对此回答[Difference between linux capabities and seccomp](https://security.stackexchange.com/questions/210400/difference-between-linux-capabities-and-seccomp)的我的理解的几个点：

* <font color='#e54d42'>**Capabilities involve various checks in kernel functions reachable by syscalls. 能力涉及对系统调用可访问的内核函数的各种检查**</font>，一旦检查失败，一般来说相关的系统调用也会是失败的，能力的检查可能会在特定的系统调用函数开始，也可以在内核更深层次的领域，多种不同的系统调用最终都会到达该领域

* seccomp限制的是进程能不能调用某个系统调用，而<font color='#e54d42'>**capabilities只与你的权利是否满足目标的要求**</font>有关，满足就代表有这个能力可以达到这个目的，否则无论如何都不允许实现，其<font color='#e54d42'>**并不关心中途你使用了怎样的系统调用/方法**</font>

  举例来说：例如，即使字符设备的权限允许写入访问, 尝试打开` /dev/cpu/*/msr` 进行写入也会失败，除非调用 `open() `系统调用的进程具有 `CAP_SYS_RAWIO `能力，linux对于此项的检查与进程使用哪种系统调用无关(例如你还可以使用`openat`，但是如果不附加能力还是无法写入)

## 4. 强制访问控制MAC(Mandatory Access Control)：AppArmor与SELinux

强制访问控制的实现是为了解决linux安全性问题，其具体的实现技术可以有：`AppArmor`和`SELinux`

`AppArmor` (`Application Armor`) 是一个 **Linux 安全模块**，可保护操作系统及其应用程序免受安全威胁，其是`SELinux`的代替方案，属于Linux安全防护领域，本身与docker并没有强绑定的关系。 为了使用它，系统管理员将 AppArmor 安全配置文件与每个程序相关联。 简单的来说通过其可以**指定程序可以读、写或运行哪些文件，是否可以打开网络端口等**

更多细节见：[AppArmor和SELinu、MAC强制访问控制系统](/Users/xwj/blog/source/_posts/技术贴/eBPF/容器安全/AppArmor和SELinux、MAC强制访问控制系统.md)

## 5. Audit

`linux audit`子系统是一个用于收集记录系统、内核、用户进程发生的行为事件的一种安全审计系统。该系统可以可靠地收集有关上任何与安全相关（或与安全无关）事件的信息，它可以帮助跟踪在系统上执行过的一些操作。

linux审计系统可以通过提供系统上事件详细信息，来提高系统的安全性。但是它并不能像selinux那样为系统提供额外的安全性保护措施。审核仅需要为user提供系统上发生的event细节，user根据这些信息追踪event并采取相应的其他安全措施。

audit和syslog有本质区别。syslog记录的信息有限，主要目的是软件调试，对于用户的操作行为（如某用户修改删除了某文件）却无法通过这些日志文件来查看。而audit的目的则不同，它是linux**安全体系**的重要组成部分，**是一种“被动”的防御体系**。

在内核里有**内核审计模块**，记录系统中的各种动作和事件，比如系统调用，文件修改，执行的程序，系统登入登出和记录所有系统中所有的事件，它的**主要目的是方便管理员根据日记审计系统是否允许有异常**，是否有入侵等等，说穿了就是把和系统安全有关的事件记录下来。

更多细节见：https://zhuanlan.zhihu.com/p/337289840

## 6. KRSI

KRSI作为Linux security module来实现的，可以进行access-control决策，不过access control其实并不是KRSI的核心目标。KRSI其实是用来对系统整体的行为进行监测来检测是否有攻击在进行。所以某种意义上来说，KRSI可以看做是kernel里的audit机制的一个扩展，利用BPF来扩大audio子系统的可配置性。

KRSI逻辑本身非常好理解：它会允许拥有合适权限的用户来在Linux security module子系统里面的几百处hook位置加载BPF program。为了让这个操作更加便捷，KRSI在`/sys/kernel/security/bpf`下面提供了一系列文件系统接口，针对每个hook都有一个文件节点。可以使用bpf()系统调用来把BPF program（属于新增的`BPF_PROG_TYPE_LSM`类型）挂载到上述hook的位置。对任何一个hook，都可以挂载多个BPF program。每当某个security hook被触发的时候，所有挂载在这里的BPF program都会被依次调用。只要任意一个BPF program返回了error status，都会拒绝这次请求。

详细细节可见：https://docs.kernel.org/bpf/prog_lsm.html

# 二、容器平面/运行时角度：容器安全技术汇总概述与概述

所有容器安全技术/项目的核心目标其实就是：

<font color='#e54d42'>**既有像虚拟机一样的隔离性，又有像容器一样的轻量快速**</font>

其总结如下：

| 技术分类                      | 标志项目                                 | 优点                     | 缺点                                                         |
| ----------------------------- | ---------------------------------------- | ------------------------ | ------------------------------------------------------------ |
| LXC：capabilies、seccomp、MAC | docker                                   | 轻量                     | 适配性较差，通过固定设置的规则难以适配新的场景               |
| 独立内核/微内核               | Firecracker、Kata、runV、Nable container | 可以实现完全隔离         | 笨重，虚拟内核过于庞大，unikernels方案对于当前容器生态不友好还需要适配 |
| 内核代理模式                  | gVisor                                   | 启动快，有一定的安全隔离 | 还是与宿主机内核强相关，无法像虚拟机的方式提供给容器一个想要的独立的内核版本，对所有系统调用的封装会影响容器中应用的系统调用的性能，**性能相比微内核的方式差很多** |

## 1. 容器内规则过滤执行

这些可能都是一些单纯的技术，可以解决容器安全的问题，但是还未成为一个完整的项目/系统

### seccomp技术

Seccomp 代表安全计算（Secure Computing Mode）模式，自 2.6.12 版本以来，一直是 Linux 内核的一个特性。 它可以用来沙箱化进程的权限，限制进程从用户态到内核态的调用

[libseccomp-golang](https://github.com/seccomp/libseccomp-golang)

### MAC

使用强制访问策略MAC(Mandatory Access Control)， 对于容器的访问和调用进行筛选和控制

- 启动AppArmor

  - Docker 期望找到加载和执行的 AppArmor 策略，docker会给容器自动生成和加载默认的profile配置文件(`docker-default`)来描述其安全策略，Docker 二进制文件在 tmpfs 中生成此配置文件，然后将其加载到内核中

    > **Note**: This profile is used on containers, *not* on the Docker Daemon.

    `docker-default` 配置文件是运行容器的默认配置。它**具有适度的保护性，同时提供广泛的应用兼容性**。该配置文件是从[模板](https://github.com/moby/moby/blob/master/profiles/apparmor/template.go)生成的

    如果不想用默认那么可以用如下的方式重新配置:

    ```shell
    $ docker run --rm -it --security-opt apparmor=<your-profile> hello-world
    ```

    **加载和卸载一个新的profile：**

    To load a new profile into AppArmor for use with containers:

    ```shell
    $ apparmor_parser -r -W /path/to/your_profile
    ```

    Then, run the custom profile with `--security-opt` like so:

    ```shell
    $ docker run --rm -it --security-opt apparmor=your_profile hello-world
    ```

    To unload a profile from AppArmor:

    ```shell
    # unload the profile
    $ apparmor_parser -R /path/to/profile
    ```

- 启用SElinux（针对docker daemon）

  - `docker daemon --selinux-enabled`

### 优缺点

优点：轻量

缺点：适配性较差：通过固定设置的规则难以适配新的场景

## 2. 独立内核/微内核

通过对原本VM的内容缩减和简化，实现轻量化VM，例如删除不使用的资源，例如keyboards、video displays等

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220626201120226.png" alt="image-20220626201120226" style="zoom:50%;" />

### Firecracker

https://github.com/firecracker-microvm/firecracker

可以直接将容器运行在Firecracker的轻量虚拟机环境中

`Fircracker-containerd`

![Firecracker Host Integration](http://xwjpics.gumptlu.work/qinniu_uPic/firecracker_host_integration.png)

### Kata Containers

### RunV 容器运行沙盒

https://help.aliyun.com/document_detail/160309.html

### Unikernels 

`immutable os`， 类似于MicroVMs,但是也有不同

特点：

* 类似镜像的打包**将依赖的kernel也打包进去**，并且kernel不可修改

* 只能运行一个应用程序/process，也正因为如此可以针对此进程特定的轻量化

将单独的应用程序特定打包到kernel，整体在特定的环境中运行（底层还是VM引擎，不过上层是这些特定的kernel）

具体的项目包括：

![image-20220626201251774](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220626201251774.png)

* [Nable container](https://nabla-containers.github.io/)

当下的挑战：与容器生态的衔接（都还没有做到很好的衔接），需要花费额外的时间去学习Unikernel

### 优缺点

优点：可以实现完全隔离

缺点：笨重，虚拟内核过于庞大

### 架构对比

![image-20220626201933579](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220626201933579.png)

## 3. 内核代理kernel proxy

`container Sandboxes`

核心思路：模拟一层`kernel`代理，对上层容器的系统调用进行筛选和模拟让上层无法感知（适配容器生态）, 容器运行在`sandbox`中

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220626201957729.png" alt="image-20220626201957729" style="zoom:50%;" />

### gVisor

https://gvisor.dev/

gVisor 是一个用 Go 编写的应用程序内核，它实现了大部分 Linux 系统调用接口。它在正在运行的应用程序和主机操作系统之间提供了额外的隔离层/代理层

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220626202106303.png" alt="image-20220626202106303" style="zoom:50%;" />

缺点：

* 还是与宿主机内核强相关，无法像虚拟机的方式提供给容器一个想要的独立的内核版本
* 对所有系统调用的封装会影响容器中应用的系统调用的性能，**性能相比微内核的方式差很多**，详细可见[gVisor、Firecracker、LXC性能对比.md](/Users/xwj/blog/source/_posts/技术贴/eBPF/容器安全/gVisor/gVisor、Firecracker、LXC性能对比.md)

# 三、k8s平面：BPF与云原生容器安全

| 项目名   | 优点                                                         | 要求                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Falco    | 灵活的规则(针对CVE漏洞有专门的优化)、拓展型强：可以拓展事件源插件；提供了客户端开发sdk | /                                                            |
| Tatragon | Kubernetes-aware、检测全面                                   | 内核应该支持[BTF](https://github.com/cilium/tetragon#btf-requirement)，或者 BTF 文件应该放在 Tetragon 可以读取的地方 |
|          |                                                              |                                                              |

## 1. Falco

Falco 就是为云原生容器安全而生，原生支持了 k8s 环境，基于系统调用和用户空间的事件（实现中ing）采集，同时也支持 k8s audit 审计日志的接入，可以**通过灵活的规则引擎来描述任何类型的主机或者容器的行为和活动**，**在触发策略规则后可以实时发出警报告警，同时支持将告警集成到各种工作流或者告警通道**；**同时 Falco 可利用最新的检测规则针对恶意活动和 CVE 漏洞发出警报，而且规则可以实现动态更新和开箱即用。**

![k8s_audit_falco](http://xwjpics.gumptlu.work/qinniu_uPic/k8s_audit_falco-20220712152547797.png)

- Falco Drivers： Falco 的内置驱动主要有 Kernel Module、eBPF Probe和用户空间（还在实现中）检测 3 种。当前用户空间检测已经具备了整体框架，但是目前还没有官方的支持 Driver（v0.24.0 版本开始支持）。<font color='#39b54a'>其中 Kernel Module 和 eBPF Probe 主要是采集系统的系统调用（syscall）</font>，eBPF Probe 是作为 Kernel Module 替代方案存在的，性能高效且能够提供更好的安全性（避免内核Bug），但是对于内核版本有一定的要求（一般建议 4.10 以后 ）。
- Kubernetes 审计事件：对接 k8s 系统中 kube-apiserver 产生的审计事件，规则在 falco [k8s_audit_rules.yaml](https://github.com/falcosecurity/falco/blob/master/rules/k8s_audit_rules.yaml) 中定义，**该事件源需要修改 kube-apiserver 中对于 audit 日志的保存方式，需要调整成基于 webhook 的方式，将审计日志发送到 Falco 内置的服务端口上**。
- 丢弃系统调用事件：Falco 可以智能检测系统调用丢弃的事件（ v0.15.0以后的版本），可以基于规则进行告警。

更多细节见：[初始Falco](/Users/xwj/blog/source/_posts/技术贴/eBPF/容器安全/[转载]初识Falco.md)

## 2. Tatragon

Tetragon detects and is able to react to security-significant events, such as

- Process execution events
- System call activity
- I/O activity including network & file access

![Tetragon Overview Diagram](http://xwjpics.gumptlu.work/qinniu_uPic/smart_observability.png)

### 观察的事件

* 进程执行生命周期：

  可以通过 Tetragon`process_exec`和`process_exit`JSON 事件来观察。这些事件包含进程的完整生命周期，从 fork/exec 到 exit，具体观测数据包括：

  - 二进制名称：定义可执行文件的名称
  - 父进程：帮助识别进程执行异常（例如，如果一个 nodejs 应用程序分叉一个 shell，这是可疑的）
  - 命令行参数：定义程序运行时行为
  - 当前工作目录：帮助从临时文件夹中识别隐藏的恶意软件执行，这是恶意软件中使用的常见模式
  - Kubernetes 元数据：包含 pod、标签和 Kubernetes 命名空间，这对于识别服务所有者至关重要，尤其是在多租户环境中
  - exec_id：一个唯一的进程标识符，与一个进程的所有记录的活动相关联

  ```shell
  🚀 process default/xwing /bin/bash
  🚀 process default/xwing /usr/bin/whoami
  💥 exit    default/xwing /usr/bin/whoami 0
  ```

* 文件访问：

  可以通过 Tetragon `process_kprobe`JSON 事件观察到。通过使用 kprobe 挂钩点，这些事件能够观察 Linux 内核中的任意内核调用和文件描述符，使您能够监控进程在其整个生命周期中打开、读取、写入和关闭的每个文件

  ```shell
  🚀 process default/xwing /usr/bin/vi /etc/passwd
  📬 open    default/xwing /usr/bin/vi /etc/passwd
  📚 read    default/xwing /usr/bin/vi /etc/passwd 1269 bytes
  📪 close   default/xwing /usr/bin/vi /etc/passwd
  📬 open    default/xwing /usr/bin/vi /etc/passwd
  📝 write   default/xwing /usr/bin/vi /etc/passwd 1277 bytes
  💥 exit    default/xwing /usr/bin/vi /etc/passwd 0
  ```

* 网络可观测性

  ```shell
  🚀 process default/xwing /usr/bin/curl http://cilium.io
  🔌 connect default/xwing /usr/bin/curl tcp 10.244.0.6:34965 -> 104.198.14.52:80
  📤 sendmsg default/xwing /usr/bin/curl tcp 10.244.0.6:34965 -> 104.198.14.52:80 bytes 73
  🧹 close   default/xwing /usr/bin/curl tcp 10.244.0.6:34965 -> 104.198.14.52:80
  💥 exit    default/xwing /usr/bin/curl http://cilium.io 0
  ```

* 特权执行

  Tetragon 还提供了检查进程能力capabilities和内核命名空间的能力。

  ```shell
  🚀 process default/test-pod /bin/sleep 365d                🛑 CAP_SYS_ADMIN
  🚀 process default/test-pod /usr/bin/jq -r .bundle         🛑 CAP_SYS_ADMIN
  🚀 process default/test-pod /usr/bin/cp /kind/product_name /kind/product_uuid /run/containerd/io.containerd.runtime.v2.task/k8s.io/7c7e513cd4d506417bc9d97dd9af670d94d9e84161c8c8 fdc9fa3a678289a59/rootfs/ 🛑 CAP_SYS_ADMIN
  ```

### 特点

* `eBPF Real-Time`：它直接在内核中执行过滤、阻止和对事件做出反应，避免上下文切换
* `eBPF Flexibility`: Tetragon 可以连接到 Linux 内核中的任何函数并过滤其参数、返回值、Tetragon 收集的有关进程的相关元数据（例如，可执行文件名称）、文件和其他属性
* `eBPF Kernel Aware`：Tetragon 通过 eBPF 可以访问 Linux 内核状态。然后，Tetragon 可以将这个内核状态与 Kubernetes 感知或用户策略相结合，以创建由内核实时执行的规则

## 3. 天翼云容器运行时安全主控引擎

下面是天翼云云容器引擎产品为了保证容器运行时安全实现的安全主控引擎：

* Pod 通过 sidecar 注入 WAF 组件对容器进行深度攻击防御
* 容器安全代理 Sage 组件以 Daemonset 形式部署在各个节点上，用来收集容器和主机异常行为，并通过自己的 sidecar 推送到消息队列中
* 安全主控引擎组件 jasmine 从消息队列中拉取事件，对数据进行分析，对有故障的容器和主机进行隔离。并将事件推送给 SIEM 安全信息事件管理平台进行管理

![img](http://xwjpics.gumptlu.work/qinniu_uPic/1620.png)

# 四、分析与总结

## 1. 容器安全分层抽象

* 构建时安全(build)
* 部署时安全(deployment)
* 运行时安全(runtime)

## 2. 想法

目标：

* 适配原docker容器生态，原容器无需任何改动与感知
* 因为时后台持久运行的守护进程，需要很小的性能消耗

想法：

* 目前貌似都缺少预扫描机制，先对当前容器所需要的最小权限提供给用户，确定最小权限的事直接交给用户是不友好的
* 针对特定漏洞CVE专门实现检测工具
  * 可能要求对漏洞攻击本身熟悉



