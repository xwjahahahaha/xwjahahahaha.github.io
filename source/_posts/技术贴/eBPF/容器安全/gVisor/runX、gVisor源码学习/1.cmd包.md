---
title: 1.cmd包
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2022-03-16 08:31:14
---

[TOC]

> * https://github.com/google/gvisor

# 一、`subcommand`包

`gVisor`的`runsc`中所有的命令都是通过`"github.com/google/subcommands"`包实现的

<!-- more -->

其基本实现格式如下：

```go
import (
  "context"
  "flag"
  "fmt"
  "os"
  "strings"

  "github.com/google/subcommands"
)

type printCmd struct {
  capitalize bool
}

func (*printCmd) Name() string     { return "print" }
func (*printCmd) Synopsis() string { return "Print args to stdout." }
func (*printCmd) Usage() string {
  return `print [-capitalize] <some text>:
  Print args to stdout.
`
}

func (p *printCmd) SetFlags(f *flag.FlagSet) {
  f.BoolVar(&p.capitalize, "capitalize", false, "capitalize output")
}

func (p *printCmd) Execute(_ context.Context, f *flag.FlagSet, _ ...interface{}) subcommands.ExitStatus {
  for _, arg := range f.Args() {
    if p.capitalize {
      arg = strings.ToUpper(arg)
    }
    fmt.Printf("%s ", arg)
  }
  fmt.Println()
  return subcommands.ExitSuccess
}
```

核心就是实现此接口：

```go
// A Command represents a single command.
type Command interface {
	// Name returns the name of the command.
	Name() string

	// Synopsis returns a short string (less than one line) describing the command.
	Synopsis() string

	// Usage returns a long string explaining the command and giving usage
	// information.
	Usage() string

	// SetFlags adds the flags for this command to the specified set.
	SetFlags(*flag.FlagSet)

	// Execute executes the command and returns an ExitStatus.
	Execute(ctx context.Context, f *flag.FlagSet, args ...interface{}) ExitStatus
}
```

然后注册：

```go
func main() {
  subcommands.Register(subcommands.HelpCommand(), "")
  subcommands.Register(subcommands.FlagsCommand(), "")
  subcommands.Register(subcommands.CommandsCommand(), "")
  subcommands.Register(&printCmd{}, "")

  flag.Parse()
  ctx := context.Background()
  os.Exit(int(subcommands.Execute(ctx)))
}
```

# 二、项目中实现

## 1. `runsc`实现各个`cmd`的大致架构是什么？

通过在`runsc/cmd`包下实现每个`cmd`接口，然后在`runsc/cli/main.go`中注册所有`cmd`

## 2. `help`的实现

`help`作为根命令，结构体中包含了`subcommand.commander`, `commander`是一系列`cmd`的集合,是`topCMD`或者理解为`root command`

```go
type Help struct {
	cdr *subcommands.Commander			// commander是一系列cmd的集合,是topCMD或者理解为root command
	commands []subcommands.Command
	help bool
}
```

```go
// A Commander represents a set of commands.
type Commander struct {
	commands  []*CommandGroup
	topFlags  *flag.FlagSet // top-level flags
	important []string      // important top-level flags
	name      string        // normally path.Base(os.Args[0])

	Explain        func(io.Writer)                // A function to print a top level usage explanation. Can be overridden.
	ExplainGroup   func(io.Writer, *CommandGroup) // A function to print a command group's usage explanation. Can be overridden.
	ExplainCommand func(io.Writer, Command)       // A function to print a command usage explanation. Can be overridden.

	Output io.Writer // Output specifies where the commander should write its output (default: os.Stdout).
	Error  io.Writer // Error specifies where the commander should write its error (default: os.Stderr).
}
```

`help`命令使用了默认的`Commander`即：

```go
help := cmd.NewHelp(subcommands.DefaultCommander)
```

```go
// DefaultCommander is the default commander using flag.CommandLine for flags
// and os.Args[0] for the command name.
var DefaultCommander *Commander
```

在其`commands`字段中则是注册了两个`topic`:

```go
help.Register(new(cmd.Platforms))
help.Register(new(cmd.Syscalls))
```

`help`命令的`Execute`命令执行逻辑在于，根据参数数量判断对应的输出：

* 如果为0即仅有`help`, 则输出所有提示介绍
* 其他即>0（`help <command>`），则输出对应`command`的详细帮助介绍

## 3. `paltforms`命令的实现

* 命令功能：输出当前`gVisor`支持的平台

* 核心功能实现：依靠从`pkg/sentry/platform`获取支持的`List`

  ```go
  func (p Platforms) Execute(ctx context.Context, f *flag.FlagSet, args ...interface{}) subcommands.ExitStatus {
  	for _, p := range platforms.List() {
  		fmt.Fprintf(os.Stdout, "%s\n", p)
  	}
  	return subcommands.ExitSuccess
  }
  ```

## 4. `syscalls`命令

* 命令功能：输出系统调用支持清单(支持的os、arch等信息)，可以用多种格式输出(table、json、csv)

* 核心实现：通过从系统(`sentry/kernel`包)获取到`syscallTableMap`，然后用此结构取对应需要的字段封装给`SyscallDoc`显示

  ```go
  // CompatibilityInfo 系统&架构 => 兼容性描述文档
  type CompatibilityInfo map[string]map[string]ArchInfo
  
  // ArchInfo 架构arch => 兼容性描述文档 (ArchInfo是给用户返回看的)
  type ArchInfo struct {
  	// Syscalls 架构的系统调用号 => 文档
  	Syscalls map[uintptr]SyscallDoc `json:"syscalls"`
  }
  
  // SyscallDoc 系统调用文档
  type SyscallDoc struct {
  	Name string `json:"name"`
  	num  uintptr
  
  	Support string   `json:"support"`
  	Note    string   `json:"note,omitempty"`
  	URLs    []string `json:"urls,omitempty"`
  }
  
  var (
    ...
    // syscallTableMap os => arch => syscall table (syscallTableMap是从系统获取的)
  	syscallTableMap = make(map[string]map[string]*kernel.SyscallTable)
  )
  ```

## 5. `Create`命令













# 三、代码重点细节

## 1. 怎样设计多格式输出并保证拓展性？

从`cmd/syscalls.go`中可以借鉴一种实现思路：

```go
// CompatibilityInfo 系统&架构 => 兼容性描述文档
type CompatibilityInfo map[string]map[string]ArchInfo

// ArchInfo 架构arch => 兼容性描述文档 (ArchInfo是给用户返回看的)
type ArchInfo struct {
	// Syscalls 架构的系统调用号 => 文档
	Syscalls map[uintptr]SyscallDoc `json:"syscalls"`
}

// SyscallDoc 系统调用文档
type SyscallDoc struct {
	Name string `json:"name"`
	num  uintptr

	Support string   `json:"support"`
	Note    string   `json:"note,omitempty"`
	URLs    []string `json:"urls,omitempty"`
}

type outputFunc func(io.Writer, CompatibilityInfo) error

var (
	// 用于表示适用于所有的os和arch
	osAll = "all"
	archAll = "all"

	...

	outputMap = map[string]outputFunc{
		"table": outputTable,
		"json": outputJSON,
		"csv": outputCSV,
	}
)

// outputTable 以表格形式输出兼容性信息
func outputTable(w io.Writer, info CompatibilityInfo) error {
	tw := tabwriter.NewWriter(w, 0, 0, 2, ' ', 0)
	...
	return nil
}

// outputJSON 输出为json格式
func outputJSON(w io.Writer, info CompatibilityInfo) error {
	e := json.NewEncoder(w)
	// 设置缩进
	e.SetIndent("", "  ")
	return e.Encode(info)
}


func outputCSV(w io.Writer, info CompatibilityInfo) error {
	csvWriter := csv.NewWriter(w)
			...
	return nil
}

```

* 定义方法变量`outputFunc`并对不同格式做映射，映射到不同的方法变量实现上即不同的输出方法
* 遍历例如`CompatibilityInfo`这样的映射关系封装`SyscallDoc`这样的显示结构体并排序
* 添加例如`osAll`、`archAll`这样的代表全部的特例变量来实现获取全部功能

```go
// Execute executes the command and returns an ExitStatus.
func (s Syscalls) Execute(ctx context.Context, f *flag.FlagSet, args ...interface{}) subcommands.ExitStatus {
	// 检查输入格式是否正确
	out, has := outputMap[s.format]
	if !has {
		util.Fatalf("Unsupprted output format %q", s.format)
	}

	// 填充数据
	...

	w := os.Stdout		// 默认输出到标准输出
	if s.filename != "" {
		w, err = os.OpenFile(s.filename, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
		if err != nil {
			util.Fatalf("Error opening %q: %v", s.filename, err)
		}
	}
  // out 可以代表任何输出格式的输出函数
	if err := out(w, info); err != nil {
		util.Fatalf("Error writing output: %v", err)
	}

	return subcommands.ExitSuccess
}
```

* 而在具体上层调用的时候，不同输出格式的函数直接用`outputMap`获取到并抽象执行
* **拓展性：如果需要新的输出格式，只需要拓展`outputMap`和实现对应的`outputFunc`即可，核心逻辑`Execute`无需任何变动**

## 2. `create`命令中的`AF_UNIX`是什么？作用是什么？

> 参考文档：
>
> * https://www.cnblogs.com/shangerzhong/p/9153737.html

```go
type Create struct {
	// bundlerDir bundlerDir路径，默认是当前的工作路径
	bundlerDir string
	// pidFile 写入sandbox pid的文件名。仅当沙箱中的容器进程准备好使用的时候才会被创建
	pidFile string
	// consoleSocket 是一个AF_UNIX socket/套接字的路径，它将接收引用控制台伪终端主端(master end)的文件描述符。
	// 除非 spec.Process.Terminal 为真，否则这将被忽略。
	consoleSocket string
	// userLog userLog 是将用户可见日志发送到的路径。
	// 此日志不同于调试日志。
	// 前者旨在供用户使用，并且应仅包含与运行容器的人相关的信息
	// 例如。不受支持的系统调用，而后者更冗长且被开发人员使用。
	userLog string
}
```

作用：

* `AF_UNIX`用于同一台机器上的进程之间通信，类似于网络socket的端口唯一标识，其通过文件路径唯一标识发送方和接收方

* 网络数据包流转流与`AF_UNIX`数据包流程对比

  * 网络数据包流转流程:（典型的`TCP/IP`四层通信模型）

    <img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220516205557000.png" alt="image-20220516205557000" style="zoom:87%;" />

    发送、接收双方都通过`socket`绑定对应的IP:端口，发送时指定对方IP以及端口，经过`Internet`最终到达接收方；接收方也可以从接收到的数据包中获取到发送方的IP端口

    发送方调用`send()`系统调用将原始数据发送到系统内核缓冲区，缓冲区依次经过TCP层、IP层、链路层的封装，最终将数据包通过网卡发送到网络中，经过路由选择最终到达接收方的网卡，**接收方的网卡通过系统中断通知os**，再进行反操作的解码解封装，最终将原始数据上报到接收方进程

  * `AF_UNIX`包的流转过程：

    ![image-20220516210452821](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220516210452821.png)

    典型的本地`IPC`，类似于管道，依赖路径名标识发送方和接收方。即发送数据时，**指定接收方绑定的路径名，操作系统根据该路径名可以直接找到对应的接收方，并将原始数据直接拷贝到接收方的内核缓冲区中**，并上报给接收方进程进行处理。同样的接收方可以从收到的数据包中获取到发送方的路径名，并通过此路径名向其发送数据。

    > 不需要经过网络栈协议的层层封装和解封

  * 相同点

    上层的调用`socket()`、`bind()`、`connect()`、`accept()`、`send()`、`recv()`以及用来对其进行多路复用事件检测的`select()`、`poll()`、`epoll()`都是完全相同的。上层感受不到底层的差别

  * 不同点

    <img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220517093737285.png" alt="image-20220517093737285" style="zoom:57%;" />

    1. 建立socket传递的地址域，及`bind()`的地址结构稍有区别：

       * `socket()` 分别传递不同的域`AF_INET`和`AF_UNIX`
       * `bind()`的地址结构分别为`sockaddr_in`（制定IP端口）和`sockaddr_un`（指定路径名）

    2. 流程不同

       `AF_INET`需经过多个协议层的编解码，消耗系统cpu，并且数据传输需要经过网卡，受到网卡带宽的限制。

       `AF_UNIX`数据到达内核缓冲区后，由内核根据指定路径名找到接收方`socket`对应的内核缓冲区，直接将数据拷贝过去，不经过协议层编解码，节省系统cpu，并且不经过网卡，因此不受网卡带宽的限制。

    3. `AF_UNIX`的传输速率远远大于`AF_INET`
    4. ` AF_INET`不仅可以用作本机的跨进程通信，同样的可以用于不同机器之间的通信，其就是为了在不同机器之间进行网络互联传递数据而生。而`AF_UNIX`则只能用于本机内进程之间的通信。 
