---
title: 268.缺失数字
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2020-07-29 17:04:16
---

## 题目描述
Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.

<!-- more -->

Example 1:

Input: [3,0,1]

Output: 2

Example 2:

Input: [9,6,4,2,3,5,7,0,1]

Output: 8

Note:

Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?

>来源：力扣（LeetCode）
>
>链接：https://leetcode-cn.com/problems/missing-number
>
>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 解题思路及代码
```java
class Solution {
    //自己的思路：映射到大小为n的数组空间，标记然后一次遍历
    public int missingNumber(int[] nums) {
        //映射函数
        int[] flagArray = new int[nums.length + 1];
        //标记
        for (int i : nums) {
            flagArray[i] = 1;
        }
        //查找
        for (int i = 0; i < flagArray.length; i++) {
            if(flagArray[i] != 1)
                return i;
        }
        return 0;
    }

    //方法二：hash表
    //时间复杂度/空间复杂度O(N)
    public int missingNumber(int[] nums) {
        Set<Integer> set = new HashSet<>();
        //加元素
        for (int num : nums) {
            set.add(num);
        }
        //查元素
        for (int i = 0; i < nums.length+1; i++) {
            if(!set.contains(i))
                return i;
        }
        return -1;
    }


    //方法三：异或运算
    //时间复杂度O(N) 空间复杂度O(1)  最快
    public int missingNumber(int[] nums) {
        int ret = nums.length;
        for (int i = 0; i < nums.length; i++) {
            ret ^= i ^ nums[i];
        }
        return ret;
    }

    //方法四：数学方法前n和
    //时间复杂度O(N) 空间复杂度O(1)  也很快，但是要考虑溢出问题
    public int missingNumber(int[] nums) {
        int n = nums.length;
        int sum = (n * (n+1))/2;
        for (int i = 0; i < n; i++) {
            sum -= nums[i];
        }
        return sum;
    }
}
```

