---
title: 3.无重复字符的最长子串
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-02-18 23:44:39
---

## 题目描述

[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

难度中等

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

<!-- more -->

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

通过次数1,488,709

提交次数3,868,75

## 解题思路及代码

```go
// 滑动窗口
func lengthOfLongestSubstring(s string) int {
    n := len(s)
    if n == 0 {
        return 0
    }
    // 已访问标记map
    marked := make(map[byte]bool)
    left, right, maxLen := 0, 0, 0
    for right < n {
        // 不断移动右边界
        for right < n && !marked[s[right]] {
            marked[s[right]] = true
            right ++
        }
        // 如果遇到重复停止，此时right再重复的字符上
        // 比较最大值
        if size := right-left; size > maxLen {
            maxLen = size
        }
        // 移动左边界
        marked[s[left]] = false
        left++
    }
    
    return maxLen
}
```

二刷

```go
// 滑动窗口，窗口内始终保持无重复字符   
func lengthOfLongestSubstring(s string) int {
    n := len(s)
    l, r := 0, 0
    countMap := make(map[byte]bool) // 统计当前窗口内出现的字符
    max := 0
    for r < n {
        // 判断是否需要缩小窗口
        for countMap[s[r]] && l < r {
            delete(countMap, s[l])
            l++
        }
        // 加入r位置字符 
        countMap[s[r]] = true
        // 比较当前窗口的最大值
        if r-l+1 > max {
            max = r-l+1
        }
        // 移动右边
        r++
    }
    return max
}
```

三刷：

```go
func lengthOfLongestSubstring(s string) int {
    n := len(s)
    maxLen := 0
    l, r := 0, 0
    count := make(map[string]int)
    for r < n {
        // 记录右边界的字符
        count[string(s[r])]++
        
        // 判断右边界的字符是否超过一次
        for l < r && count[string(s[r])] > 1 {
            // 移动左边界直到满足不重复
            count[string(s[l])]--
            l++
        }

        // 比较最大长度
        if r-l+1 > maxLen {
            maxLen = r-l+1
        }

        r++
    }

    return maxLen
}
```

