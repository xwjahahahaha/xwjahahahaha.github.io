---
title: 438.找到字符串中所有字母异位词
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-19 14:14:36
---

## 题目描述

[438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

难度中等758

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

**提示:**

- `1 <= s.length, p.length <= 3 * 104`
- `s` 和 `p` 仅包含小写字母

通过次数138,422

提交次数257,249


<!-- more -->

## 解题思路及代码

```go
// 滑动窗口
// 异位词特点：长度一样并且每个字符出现次数相同 => 固定滑动窗口的大小
func findAnagrams(s string, p string) []int {
    ans, pCount, sCount := make([]int, 0), [26]int{}, [26]int{}
    // 特殊情况，如果len(s) < len(p), 那么不用构建窗口了，一定不存在
    if len(s) < len(p) {
        return []int{}
    }
    // 初始化窗口
    for i, c := range p {
        sCount[s[i]-'a']++
        pCount[c-'a']++
    }
    // 第一次建立完窗口先判断一下
    if sCount == pCount {       // go中数组可以直接比较
        ans = append(ans, 0)
    }
    // 滑动窗口
    l, r := 0, len(p)-1
    for r<len(s)-1 {
        // 调整统计
        sCount[s[l]-'a']--      // 前端少1
        sCount[s[r+1]-'a']++    // 后端多1
        // 移动
        l++; r++
        // 判断是否满足
        if sCount == pCount {
            ans = append(ans, l)
        }
    } 
    return ans
}
```

二刷：

```go
func findAnagrams(s string, p string) []int {
    res := make([]int, 0)
    countP, countS := make(map[string]int), make(map[string]int)
    for _, c := range p {
        countP[string(c)]++
    }

    l, r := 0, 0
    for r < len(s) {
        countS[string(s[r])]++

        if r-l+1 == len(p) && same(countS, countP) {
            res = append(res, l)
        }

        if r-l+1 == len(p) {
            // 当满足长度时，l++
            countS[string(s[l])]--
            l++
        }

        r++
    }

    return res
}

func same(countS, countP map[string]int) bool {
    for k, v := range countP {
        if countS[k] != v {
            return false
        }
    }
    return true
}
```

