---
title: 131-分割回文串
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-02-05 13:34:11
---

## 题目描述

#### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

难度中等

给定一个字符串 *s*，将 *s* 分割成一些子串，使每个子串都是回文串。

返回 *s* 所有可能的分割方案。

**示例:**

```
输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]
```


<!-- more -->

## 解题思路及代码

搜索问题主要使用回溯法。

回溯法思考的步骤：

1、画递归树；

2、根据自己画的递归树编码。

![](http://xwjpics.gumptlu.work/qiniu_picGo/20210205133808.png)

思考如何根据这棵递归树编码：

1、每一个结点表示剩余没有扫描到的字符串，产生分支是截取了剩余字符串的前缀；

2、产生前缀字符串的时候，判断前缀字符串是否是回文。

如果前缀字符串是回文，则可以产生分支和结点；
如果前缀字符串不是回文，则不产生分支和结点，这一步是剪枝操作。
3、在叶子结点是空字符串的时候结算，此时**从根结点到叶子结点的路径，就是结果集里的一个结果，使用深度优先遍历，记录下所有可能的结果。**

采用一个路径变量 path 搜索，path 全局使用一个（注意结算的时候，需要生成一个拷贝），因此在递归执行方法结束以后需要回溯，即将递归之前添加进来的元素拿出去；
path 的操作只在列表的末端，因此合适的数据结构是栈。

```txt
作者：liweiwei1419
链接：https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```go
//方法: 构建递归树，然后回溯找路径

func partition(s string) [][]string {
    res := [][]string{}     //创建结果数组(切片)
    path := []string{}      //创建路径数组(切片)
    backtracking(s, 0, len(s), path, &res)   //调用递归回溯函数
    return res
}

//回溯方法
//参数: s:原始字符串  start:截断开始下标 len:s的长度 path:路径保存 res:结果集合
func backtracking(s string, start int, length int, path []string, res *[][]string){
    //判断是否到达叶子节点(空字符串)
    if start == length{
        //将当前path装填到res中
        //拷贝一份path
        tmp := make([]string, len(path))
        copy(tmp, path)
        *res = append(*res, tmp)
        return  //结束递归
    }

    //未到达叶子节点则开始递归
    //[start, i]表示字符串截取的前缀
    for i:=start; i<length; i++{
        //判断当前前缀是否为回文
        if !isPalindrome(s, start, i){
            continue;   //剪枝操作
        }
        //是回文则开始向下递归(再截取前缀)
        //首先记录当前截取前缀路径,即[start, i]
        path = append(path, s[start:i+1])
        //递归剩下的部分[i+1, len(s)]
        backtracking(s, i+1, length, path, res)
        //关键的一步,当此次i递归结束后，若有叶子结点那么path也生成完毕
        //回溯需要让path重置（各个结果/路径不干扰），需要从叶子节点向树根一步一步返回
        //也就是将“栈”path元素一个个弹出，go没有栈所以采用切片
        path = path[0:len(path)-1]
    }
}


//判断回文的方法
func isPalindrome(s string, start int, end int) bool{
    l, r := start, end
    for l < r {
        if s[l] != s[r]{
            return false
        }
        l++
        r--
    }
    return true
}
```

