---
title: 460.LFU缓存
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-03-18 00:35:45
---

## 题目描述

[460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/)

难度困难

请你为 [最不经常使用（LFU）](https://baike.baidu.com/item/缓存算法)缓存算法设计并实现数据结构。

实现 `LFUCache` 类：

- `LFUCache(int capacity)` - 用数据结构的容量 `capacity` 初始化对象
- `int get(int key)` - 如果键 `key` 存在于缓存中，则获取键的值，否则返回 `-1` 。
- `void put(int key, int value)` - 如果键 `key` 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 `capacity` 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 **最近最久未使用** 的键。

为了确定最不常使用的键，可以为缓存中的每个键维护一个 **使用计数器** 。使用计数最小的键是最久未使用的键。

当一个键首次插入到缓存中时，它的使用计数器被设置为 `1` (由于 put 操作)。对缓存中的键执行 `get` 或 `put` 操作，使用计数器的值将会递增。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

 <!-- more -->

**示例：**

```go
输入：
["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
输出：
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

解释：
// cnt(x) = 键 x 的使用计数
// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // 返回 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小
                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // 返回 -1（未找到）
lfu.get(3);      // 返回 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // 返回 -1（未找到）
lfu.get(3);      // 返回 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // 返回 4
                 // cache=[3,4], cnt(4)=2, cnt(3)=3
```

**提示：**

- `0 <= capacity <= 104`
- `0 <= key <= 105`
- `0 <= value <= 109`
- 最多调用 `2 * 105` 次 `get` 和 `put` 方法

## 解题思路及代码

题解可参考：https://leetcode-cn.com/problems/lfu-cache/solution/chao-xiang-xi-tu-jie-dong-tu-yan-shi-460-lfuhuan-c/

```go
type Node struct {
    Val int
    Pre *Node
    Next *Node
}

type List struct {
    Len int
    PreHead *Node
    Tail *Node
}

type HashList struct {
    list *List
    nodeMap map[int]*Node
}

type LFUCache struct {
    c int
    dataMap map[int]int
    freqMap map[int]int             // 记录每个键的使用频率
    listMap map[int]*HashList       // 每个频率都是一个单独的Hash链表
    miniFreq int                    // 维护频率中的最小值
}

func NewHashList() *HashList {
    return &HashList {
        NewList(),
        make(map[int]*Node),
    }
}

func NewList() *List {
    return &List{
        0,
        &Node{-1, nil, nil},
        nil,
    }
}

func (l *List) addNodeInTail(val int) {
    newNode := &Node{val, nil, nil}
    if l.Len == 0 {
        l.PreHead.Next = newNode
        newNode.Pre = l.PreHead
    }else {
        l.Tail.Next = newNode
        newNode.Pre = l.Tail
    }
    l.Tail = newNode
    l.Len ++
}

func (l *List) adjustNode(node *Node) {
    if node == l.Tail {
        return 
    }
    // 删除该节点位置
    node.Pre.Next = node.Next
    node.Next.Pre = node.Pre
    // 加到最后
    l.Tail.Next = node
    node.Pre = l.Tail
    l.Tail = node
}

func (l *List) delHeadNode() *Node {
    if l.Len == 0 {
        return nil
    }
    res := l.PreHead.Next
    if l.Len == 1 {
        l.PreHead.Next = nil
        l.Tail = nil
        l.Len --
        return res
    }
    l.PreHead.Next.Next.Pre = l.PreHead     // 这里注意顺序
    l.PreHead.Next = l.PreHead.Next.Next
    l.Len --
    return res
}

func (l *List) delNode(node *Node) {
    if l.Len == 0 || node == nil {
        return
    }
    if l.Len == 1 {
        l.PreHead.Next = nil
        l.Tail = nil
        l.Len --
        return 
    }
    if node == l.Tail {
        // 如果是尾节点
        l.Tail = node.Pre
        l.Tail.Next = nil
        l.Len --
        return
    }
    node.Pre.Next = node.Next
    node.Next.Pre = node.Pre
    l.Len --
}

func Constructor(capacity int) LFUCache {
    return LFUCache{
        capacity,
        make(map[int]int),
        make(map[int]int),
        make(map[int]*HashList),
        0,
    }
}

// 让一个key的频率+1
func (this *LFUCache) addFrequency(key int) {
    // 更新频率
    freq := this.freqMap[key]
    node := this.listMap[freq].nodeMap[key]
    // 删除原频率链表节点
    this.listMap[freq].list.delNode(node)
    if this.listMap[freq].list.Len == 0 {
        // 如果此频率链表没有节点，则删除此链表
        delete(this.listMap, freq)
        // 更新最小频率值
        if freq == this.miniFreq {  // 如果当前是最小频率对应的链表的最后一个元素，那么最小值才+1
            this.miniFreq = freq+1
        }
    }
    freq ++ 
    this.freqMap[key] = freq
    // 在新频率链表添加此节点
    // 判断是否有该链表, 没有就创建
    if _, has := this.listMap[freq]; !has {
        this.listMap[freq] = NewHashList()
    }
    this.listMap[freq].list.addNodeInTail(node.Val)
    this.listMap[freq].nodeMap[key] = this.listMap[freq].list.Tail  
}

func (this *LFUCache) Get(key int) int {
    if ans, has := this.dataMap[key]; !has {
        return -1
    }else {
        // 更新频率
        this.addFrequency(key)
        // 返回值
        return ans
    }
}


func (this *LFUCache) Put(key int, value int)  {
    if this.c == 0 {
        return
    }
    // 判断是更新还是新增
    if _, has := this.dataMap[key]; has {
        // 更新
        this.addFrequency(key)
        // 更新值
        this.dataMap[key] = value
    }else {
        // 新增
        // 判断是否需要删除
        if len(this.dataMap) == this.c {
            // 删除最低频率中最近最久未使用
            delNode := this.listMap[this.miniFreq].list.delHeadNode()
            // 更新最小频率值
            if this.listMap[this.miniFreq].list.Len == 0 {
                delete(this.listMap, this.miniFreq)
                if len(this.listMap) > 0 {
                    this.miniFreq ++                // 如果一个链表都没有了就不更新
                }
            }
            delete(this.dataMap, delNode.Val)
            delete(this.freqMap, delNode.Val)       // 删除该键的频率
        }
        // 加入节点
        this.dataMap[key] = value
        this.freqMap[key] = 0
        this.miniFreq = 0
        // 没有则创建
        if _, has := this.listMap[0]; !has {
            this.listMap[0] = NewHashList()
        } 
        this.listMap[0].list.addNodeInTail(key)
        this.listMap[0].nodeMap[key] = this.listMap[0].list.Tail
    }
}


/**
 * Your LFUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
```

二刷：

```go
type Node struct {
    Val int
    Prio int
    Pre *Node
    Next *Node
}

type List struct {
    head *Node
    tail *Node
}

func NewList() *List {
    initNode := &Node{-1, -1, nil, nil}
    return &List{initNode, initNode}
}

func (l *List) addTail(node *Node) {
    if l.tail == nil {
        return
    }

    l.tail.Next = node
    node.Pre = l.tail
    node.Next = nil
    l.tail = node
}

func (l *List) deleteHead() *Node {
    if l.head.Next == nil {
        return nil
    }

    delNode := l.head.Next
    if l.head.Next == l.tail {
        l.head.Next = nil
        l.tail = l.head
        return delNode
    }

    l.head.Next = l.head.Next.Next
    if l.head.Next != nil {
        l.head.Next.Pre = l.head
    }
    return delNode
}

func (l *List) isNull() bool {
    return l.head.Next == nil
}

func (l *List) deleteNode(node *Node) {
    if node == l.tail {
        l.tail.Pre.Next = nil
        l.tail = l.tail.Pre
        return
    }

    node.Pre.Next = node.Next
    node.Next.Pre = node.Pre
}

func (l *List) String() string {
    s := ""
    s += "{"
    for p:=l.head.Next; p!=nil; p=p.Next {
        s += fmt.Sprintf("%d ", p.Val)
    }
    s += "}"
    return s
}

type LFUCache struct {
    c int
    nowMinPrio int          // 当前最小的频率
    prios map[int]*List     // 频率 => List
    dataMap map[int]int
    nodeMap map[int]*Node
}


func Constructor(capacity int) LFUCache {
    return LFUCache{capacity, 1, make(map[int]*List), make(map[int]int), make(map[int]*Node)}
}


func (this *LFUCache) Get(key int) int {
    if _, has := this.dataMap[key]; !has {
        return -1
    }

    // 增加优先级
    this.addPrio(this.nodeMap[key])
    return this.dataMap[key]
}


func (this *LFUCache) Put(key int, value int)  {
    if this.c == 0 {
        // 处理容量为0的特殊情况
        return 
    }
    if _, has := this.dataMap[key]; !has {
        // 判断是否满了
        if len(this.dataMap) == this.c {
            // 删除最小优先级的头节点
            list := this.prios[this.nowMinPrio]
            delNode := list.deleteHead()
            // 判断此链表是否为空
            if list.isNull() {
                delete(this.prios, delNode.Prio)
                // 最小频率+1，如果还有链表的话
                if len(this.prios) > 0 {
                    this.nowMinPrio++
                }
            }
            delete(this.dataMap, delNode.Val)
            delete(this.nodeMap, delNode.Val)
        }

        // 加入
        newNode := &Node{key, 1, nil, nil}
        this.dataMap[key] = value
        this.nodeMap[key] = newNode
        if this.prios[1] == nil {
            this.prios[1] = NewList()
        }
        this.prios[1].addTail(newNode)
        // 注意新加入节点需要将最小频率重新设置为1
        this.nowMinPrio = 1
    }else {
        // 更新操作
        this.dataMap[key] = value
        this.addPrio(this.nodeMap[key])
    }
}


func (this *LFUCache) addPrio(node *Node) {
    if node == nil {
        return 
    }

    newPrio := node.Prio+1
    if this.prios[newPrio] == nil {
        this.prios[newPrio] = NewList()
    }
    // 删除原来的优先级链表的节点
    this.prios[node.Prio].deleteNode(node)
    if this.prios[node.Prio].isNull() {
        delete(this.prios, node.Prio)
        // 注意，仅当当前节点的频率是最小频率时才将当前最小频率+1
        if node.Prio == this.nowMinPrio {
            this.nowMinPrio++
        }
    }
    // 节点的优先级++
    node.Prio++
    // 加入到新优先级链表的尾部
    this.prios[newPrio].addTail(node)
}

/**
 * Your LFUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
```

