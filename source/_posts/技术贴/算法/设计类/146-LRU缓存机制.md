---
title: 146.LRU缓存机制
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2021-10-28 16:37:37
---

## 题目描述

[146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

难度中等1692

运用你所掌握的数据结构，设计和实现一个 [LRU (最近最少使用) 缓存机制](https://baike.baidu.com/item/LRU) 。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

 <!-- more -->

**进阶**：你是否可以在 `O(1)` 时间复杂度内完成这两种操作？

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

 

**提示：**

- `1 <= capacity <= 3000`
- `0 <= key <= 10000`
- `0 <= value <= 105`
- 最多调用 `2 * 105` 次 `get` 和 `put`



## 解题思路及代码

```go
// Hash表 + 双向链表
// Hash表实现链表节点的O(1)访问
// 双向链表实现访问时间顺序以及交换
type LRUCache struct {
    // map + 双向链表
    linkMap map[int]*node
    list *ToWayLinkedList

    dataMap map[int]int
    len int 
}

// 初始化
func Constructor(capacity int) LRUCache {
   return LRUCache{make(map[int]*node), NewToWayLinkedList(), make(map[int]int), capacity}
}

// 读取数据
func (this *LRUCache) Get(key int) int {
    if _, has := this.dataMap[key]; !has {
        return -1
    }
    // 更新访问时间
    this.list.Update(this.linkMap[key])
    return this.dataMap[key]
}

// 写数据
func (this *LRUCache) Put(key int, value int)  {
    _, hasKey := this.dataMap[key]      //注意： 如果当前达到容量上限但是原本的键存在则依然更新
    if len(this.dataMap) < this.len || hasKey {
        // 未满，直接存储
        if _, has := this.dataMap[key]; has {
            // 更新操作
            this.dataMap[key] = value
            // 更新时间
            this.list.Update(this.linkMap[key])
        } else {
            // 创建操作
            this.dataMap[key] = value
            this.linkMap[key] = this.list.Insert(key)   // 创建链表节点
        }
    }else {
        // 满了，替换存储
        // 删除当前时间最久的
        delNode := this.list.DeleteFirst()
        delete(this.linkMap, delNode.data)      // 注意：这里删除的是最久未使用节点的key
        delete(this.dataMap, delNode.data)
        // 加入新的节点
        this.dataMap[key] = value
        this.linkMap[key] = this.list.Insert(key)
    }
}


type ToWayLinkedList struct {
    head *node      // 头节点
    tail *node      // 尾节点
    len int         // 节点数
}

type node struct {
    data int        
    pre *node       // 前指针
    next *node      // 后指针
}

// 新建一个双向链表
func NewToWayLinkedList() *ToWayLinkedList {
    head, tail := &node{-1, nil, nil}, &node{-1, nil, nil}
    head.next = tail
    tail.pre = head
    return &ToWayLinkedList{head, tail, 0}
}

// 尾部插入一个节点
func (l *ToWayLinkedList) Insert(data int) *node {
    newNode := &node{data, nil, nil}
    l.tail.pre.next = newNode
    newNode.next = l.tail
    newNode.pre = l.tail.pre
    l.tail.pre = newNode
    l.len ++
    return newNode
}

// 删除首节点
func (l *ToWayLinkedList) DeleteFirst() *node {
    if l.len == 0 {
        fmt.Println("not have node")
        return nil
    }
    delNode := l.head.next
    l.head.next = l.head.next.next
    delNode.pre = nil
    delNode.next = nil
    l.head.next.pre = l.head
    l.len --
    return delNode
}

// 将特定节点移动到尾部
func (l *ToWayLinkedList) Update(kNode *node) {
    if kNode.next == l.tail {
        return
    }
    // 删除原本位置
    preNode := kNode.pre
    preNode.next = preNode.next.next
    kNode.pre = nil
    kNode.next = nil
    preNode.next.pre = preNode
    // 插入末尾
    l.tail.pre.next = kNode
    kNode.next = l.tail
    kNode.pre = l.tail.pre
    l.tail.pre = kNode
} 

/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
```

n刷(2022/3/17)

```go
type Node struct {
    Val int
    Pre *Node
    Next *Node
}

type List struct {
    Len int
    PreHead *Node
    Tail *Node
}

func NewList() *List {
    return &List{
        0, 
        &Node{-1, nil, nil},
        nil,
    }
}

func (l *List) addNodeInTail(val int) {
    newNode := &Node{val, nil, nil}
    if l.Len == 0 {
        l.PreHead.Next = newNode
        newNode.Pre = l.PreHead
    }else {
        l.Tail.Next = newNode
        newNode.Pre = l.Tail
    }
    l.Tail = newNode
    l.Len ++
}

func (l *List) adjustNode(node *Node) {
    if node == l.Tail {
        return
    }
    // 删除原节点位置
    node.Pre.Next = node.Next
    node.Next.Pre = node.Pre
    // 插入末尾
    l.Tail.Next = node
    node.Pre = l.Tail
    l.Tail = node
}

func (l *List) delHeadNode() *Node {
    if l.Len == 0 {
        return nil
    }
    res := l.PreHead.Next
    if l.Len == 1 {
        l.PreHead.Next = nil
        l.Tail = nil
        l.Len --
        return res
    }
    l.PreHead.Next.Next.Pre = l.PreHead             // 注意这里顺序
    l.PreHead.Next = l.PreHead.Next.Next
    l.Len --
    return res
}

type LRUCache struct {
    c int
    dataMap map[int]int
    nodeMap map[int]*Node
    list *List
}


func Constructor(capacity int) LRUCache {
    return LRUCache{
        capacity, 
        make(map[int]int), 
        make(map[int]*Node),
        NewList(),
    }
}


func (this *LRUCache) Get(key int) int {
    // 判断是否存在
    if ans, has := this.dataMap[key]; !has {
        return -1
    }else {
        // 更新频率
        this.list.adjustNode(this.nodeMap[key])
        return ans
    }
}


func (this *LRUCache) Put(key int, value int)  {
    // 判断更新还是新建
    if _, has := this.dataMap[key]; has {
        // 更新
        this.dataMap[key] = value
        this.list.adjustNode(this.nodeMap[key])
    }else {
        // 新增
        // 判断是否需要替换
        if len(this.dataMap) == this.c {
            // 需要删除掉最近最久未使用
            delNode := this.list.delHeadNode()
            delete(this.dataMap, delNode.Val)
            delete(this.nodeMap, delNode.Val)
        }
        this.dataMap[key] = value
        this.list.addNodeInTail(key)        // 注意是key
        this.nodeMap[key] = this.list.Tail
    }
}


/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
```



