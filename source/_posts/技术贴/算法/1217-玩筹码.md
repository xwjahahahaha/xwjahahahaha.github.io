---
title: 1217-玩筹码
tags:
  - java
categories:
  - technical
  - leetcode
toc: true
date: 2020-12-13 14:46:21
---

## 题目描述

#### [1217. 玩筹码](https://leetcode-cn.com/problems/minimum-cost-to-move-chips-to-the-same-position/)

数轴上放置了一些筹码，每个筹码的位置存在数组 `chips` 当中。

<!-- more -->

你可以对 **任何筹码** 执行下面两种操作之一（**不限操作次数**，0 次也可以）：

- 将第 `i` 个筹码向左或者右移动 2 个单位，代价为 **0**。
- 将第 `i` 个筹码向左或者右移动 1 个单位，代价为 **1**。

最开始的时候，同一位置上也可能放着两个或者更多的筹码。

返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。

**示例 1：**

```
输入：chips = [1,2,3]
输出：1
解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。
```

**示例 2：**

```
输入：chips = [2,2,2,3,3]
输出：2
解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。
```

**提示：**

- `1 <= chips.length <= 100`
- `1 <= chips[i] <= 10^9`


## 解题思路及代码

贪心算法思路:

1. 能使用第一种操作移动到一起，绝对不用第二种操作（因为第二种操作的代价为1）

2. 当有两堆相邻的筹码要合并成一堆筹码时，将小堆的筹码全部移向大堆，这样代价才是最小

题目规律:

  使用代价为0的操作中：

  所有在奇数位置上的筹码都可以移动到某一个奇数位置，设都移动到第一个位置

  同理，所有偶数位置上的筹码都可以移动到某一个偶数位置，设都移动到第二个位置

代码思路：

1. 通过代价为0的方法，现将所有的筹码移动到相邻的两个位置 => 统计位置矩阵中奇数位置个数和偶数位置个数

2. 将小筹码堆合并到大筹码堆，小堆筹码个数*1 => 比较较小的就是最小代价

```java
class Solution {
    public int minCostToMoveChips(int[] position) {
        int minProperty = 0;        //代价
        int odd = 0, even = 0;      //奇偶个数
        for(int i=0; i<position.length; i++){
            if (position[i] % 2 == 1){
                odd++;
            }else{
                even++;
            }  
        }
        minProperty = odd > even ? even : odd;
        return minProperty;
    }
}
```

