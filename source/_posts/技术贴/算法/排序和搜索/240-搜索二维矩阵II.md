---
title: 240-搜索二维矩阵II
tags:
  - java
categories:
  - technical
  - leetcode
toc: true
date: 2020-09-02 14:55:01
---

## 题目描述

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

每行的元素从左到右升序排列。

每列的元素从上到下升序排列。

示例:

现有矩阵 matrix 如下：
```C
  [
    [1,   4,  7, 11, 15],
    [2,   5,  8, 12, 19],
    [3,   6,  9, 16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
  ]
```

给定 target = 5，返回 true。

给定 target = 20，返回 false。
<!-- more -->

## 解题思路及代码

```java
class Solution {
    //笨办法：遍历
    //时间复杂度O(M*N) 空间复杂度O(1)
    public boolean searchMatrix(int[][] matrix, int target) {
        //java遍历二维数组的两种方式
        //第一种：
        // for(int i=0; i<matrix.length; i++)
        //     for(int j=0; j<matrix[i].length; j++)
        //         if (matrix[i][j] == target)
        //             return true;
        //第二种：
        for(int[] rows: matrix)
            for(int num: rows)
                if (num == target)
                    return true;
        return false;
    }

    //方法二：根据矩阵规律，遍历的改进版  并没有啥用
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix==null||matrix.length==0||(matrix.length==1&&matrix[0].length==0)) return false;
        for(int i=0; i<matrix.length; i++){
            //判断：若当前行第一个数已经比target大了，那么后续行就不用找了
            if(matrix[i][0] > target) break;
            for(int j=0; j<matrix[i].length; j++){
                //判断:当前数已经大于target，那么其后数一定大于,换下一行
                if(matrix[i][j] > target) break;
                if(matrix[i][j] == target) return true;    
            }
        }
        return false;
    }


    //第三种方法：遍历对角线，基于对角线元素行列都是升序，使用二分查找
    //start 对角线元素  vertical 代表是否垂直，也就是两种方向
    //时间复杂度O(lg(n!))。空间复杂度O(1)
    public boolean binarySearch(int[][] matrix, int target, int start, boolean vertical){
        int l = start;
        //垂直为行高，不垂直为列高
        int r = vertical ? matrix.length-1 : matrix[0].length-1;
        while(l <= r){
            int mid = (l + r) >> 1;
            if(vertical){ //在列上二分查找
                if(matrix[mid][start] > target)
                    r = mid - 1;
                else if(matrix[mid][start] < target)
                    l = mid + 1;
                else
                    return true;
            }else{ //在行上二分查找
                if(matrix[start][mid] > target)
                    r = mid - 1;
                else if(matrix[start][mid] < target)
                    l = mid + 1;
                else
                    return true; 
            }
        }
        return false;
    }

    public boolean searchMatrix(int[][] matrix, int target) {
        //排除空数组情况
        if(matrix==null||matrix.length==0||(matrix.length==1&&matrix[0].length==0)) return false;
        //找出数组的最小行/列
        int len = Math.min(matrix.length, matrix[0].length);
        for(int i=0; i<len; i++){
            boolean col = binarySearch(matrix, target, i, true);
            boolean row = binarySearch(matrix, target, i, false);
            if(col || row)
                return true;    //列和行其中有一个返回true，则说明找到了
        }
        return false;
    }


     //方法四：左下寻找法  非常巧妙
    //从左下角开始寻找，如果指针指向值大于目标值则向上走一行（因为右边的都比目标值大了）
    //如果指针指向值小于目标值则向右走一行（因为其同列上面的都比当前行的值小）
    //时间复杂度O(M+N) 空间复杂度O(1)
    public boolean searchMatrix(int[][] matrix, int target) {
        //排除空矩阵
        if(matrix==null || matrix.length==0 || (matrix.length==1&&matrix[0].length==0)) return false;

        //指向左下角
        int row = matrix.length-1;
        int col = 0;

        while(col < matrix[0].length && row >= 0){
            if(matrix[row][col] > target)
                //大于目标值，则向上走
                row--;
            else if(matrix[row][col] < target)
                //小于目标值,则向右走
                col++;
            else 
                return true;
        }
        return false;
    }
}
```
