---
title: 排序算法总结
tags:
  - golang
categories:
  - technical
  - null
toc: true
declare: true
date: 2021-10-31 15:15:55
---

> 学习自：
>
> * https://blog.csdn.net/zxzxzx0119/article/details/79826380
>
> * https://zhuanlan.zhihu.com/p/42586566

> leetcode练习：https://leetcode.cn/problems/sort-an-array/

对常见的排序算法进行三方面总结：

1. 基本思路与实现
2. 稳定性
3. 复杂度分析

<!-- more --> 

[TOC]

# 一、总览

（注意：表中快排的空间复杂度`O(logN)`~`O(N)`）

![](http://xwjpics.gumptlu.work/qinniu_uPic/20200525161742.png)

什么是排序算法的**稳定性**？

简单来说如果原本数组中的两个相等的数的次序为相对一前一后，排序结束后仍然为相对一前一后，那么就可以说这个排序算法是稳定的。即保证排序前后两个相等的数的相对顺序不会改变

所以在具体的排序算法中可以进行特定的处理改变稳定性

举例：对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成`arr[i] >= arr[i + 1]`，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。

# 二、冒泡排序

## 1. 基本思路

每次沉底一个最大的数，将大的数一直向后交换，大的沉底，小的自动上浮

```go
func bubbleSort(nums []int)  {
	// i：当前需要冒泡的数组长度
	for i:=len(nums)-1; i>0; i-- {
		// j：冒泡的位置
		for j:=0; j<i; j++ {
			// 如果前一个数大就和后一个交换，不断沉底
			if nums[j] > nums[j+1] {
				nums[j], nums[j+1] = nums[j+1], nums[j]
			}
		}
	}
}
```

二刷：

```go
// 冒泡排序
// 时间复杂度 最好O(n)(标记优化) 平均O(N^2) 最坏O(N^2)
// 空间复杂度 O(1)
func sortArray(nums []int) []int {
    n := len(nums)
    for i:=0; i<n-1; i++ {
        flag := false                       // 标记是否被优化过
        for j:=0; j+1<n-i; j++ {
            if nums[j] > nums[j+1] {
                nums[j], nums[j+1] = nums[j+1], nums[j]
                flag = true
            }
        } 
        // 如果未交换过则说明已经有序，退出
        if !flag {
            break
        }
    }

    return nums
}
```

时间复杂度：

* 最好$O(N)$: 唯一的情况是数组已经有序(并且是下面的优化版本)
* 平均$O(N^2)$
* 最差$O(N^2)$

**优化思路一**: 设立flag，如果当前长度没有发生任何交换，则说明已经有序，直接结束

```go
func bubbleSort(nums []int)  {
   // i：当前需要冒泡的数组长度
   for i:=len(nums)-1; i>0; i-- {
     	flag := true
      // j：冒泡的位置
      for j:=0; j<i; j++ {
         // 如果前一个数大就和后一个交换，不断沉底
         if nums[j] > nums[j+1] {
            nums[j], nums[j+1] = nums[j+1], nums[j]
            // 一旦发生了交换，就改变标记
            flag = false
         }
      }
      // 一旦发现没有交换就直接结束
      if flag {
         break
      }
   }
}
```

时间复杂度：平均优化到$O(N)$

**优化思路二**：记录上次最后一次交换的位置，最后一次交换位置后面的位置都是有序的，所以只需要到达这个位置即可

```go
func bubbleSort(nums []int)  {
	// i：当前需要冒泡的数组长度
	for i:=len(nums)-1; i>0; i-- {
    flag := true
		// 记录上一次结束位置，初始化时为i
		end := i
		// j：冒泡的位置
		for j:=0; j<i; j++ {		//  注意：这里不能写<end，虽然end与i一样但是循环体end一直在改变
			// 如果前一个数大就和后一个交换，不断沉底
			if nums[j] > nums[j+1] {
				nums[j], nums[j+1] = nums[j+1], nums[j]
				// 一旦发生了交换，就改变标记
				flag = false
				// 记录最后一次交换位置
				end = j+1
			}
		}
		// 替换i
		i = end
		// 一旦发现没有交换就直接结束
		if flag {
			break
		}
	}
}
```

## 2. 稳定性

因为当两个数相等时不交换，所以稳定

## 3. 复杂度分析

时间复杂度:

* 最好$O(N)$: 唯一的情况是数组已经有序
* 平均$O(N^2)$，优化后可到达$O(N)$
* 最差$O(N^2)$

空间复杂度$O(1)$

# 三、选择排序

## 1. 基本思路

每次找到最大的，然后与最后一个数交换

```go
func selectSort(nums []int) {
	// 一共需要n-1次
	for i:=0; i<len(nums)-1; i++ {
		maxIndex := 0
		for j:=0; j<len(nums)-i; j++ {
			if nums[j] > nums[maxIndex] {
				maxIndex = j
			}
		}
		// 和最后一个交换
		nums[maxIndex], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[maxIndex]
	}
}
```

二刷：

```go
// 选择排序
// 时间复杂度 最好O(N^2) 平均O(N^2) 最坏O(N^2)
// 空间复杂度 O(1)
// 不稳定
func sortArray(nums []int) []int {
    n := len(nums)
    for i:=0; i<n-1; i++ {
        min := i
        for j:=i+1; j<n; j++ {
            if nums[j] < nums[min] {
                min = j
            }
        }
        // 交换
        nums[min], nums[i] = nums[i], nums[min]
    }

    return nums
}
```

## 2. 稳定性

用数组实现的选择排序是不稳定的，**用链表实现的选择排序是稳定的**

一般排序算法描述的都是数组，所以可以说是**不稳定的**

## 3. 复杂度分析

时间复杂度:

* 最好$O(N^2)$
* 平均$O(N^2)$，优化后可到达$O(N)$
* 最差$O(N^2)$

空间复杂度$O(1)$

# 四、插入排序

## 1. 基本思路

从前往后维护一个有序窗口，每次考察窗口的下一个元素，如果比窗口的最右侧/最大元素小，则从右往左遍历窗口直到合适顺序的地方插入。初始化认为数组的第一个位置有序。 （像是一种向前的冒泡排序）

```go
func insertSort(nums []int) {
	// i: 这个有序窗口的最右边位置的下一个考察的位置, 起始位置0默认有序
	for i:=1; i<len(nums); i++ {
		// 从窗口的下一个判定位置，一直向左遍历
		for j:=i; j>0; j-- {
			// 如果当前位置j比窗口位置j-1小，则一直向右侧交换
			if nums[j] < nums[j-1] {
				nums[j], nums[j-1] = nums[j-1], nums[j]
			}else {
				// 如果已经大于，那么就已将该元素加入到了有序窗口
				break
			}
		}
	}
}
```

优化思路：二分法查找插入排序的位置

```go
func insertSort(nums []int) {
	// i: 有序窗口的下一个考察的位置(target), 起始位置0默认有序
	for i:=1; i<len(nums); i++ {
		// 二分法找出当前窗口中合适顺序的位置，插入
		l, r, target := 0, i-1, nums[i]
		for l <= r {
			mid := (l+r) >> 1
			if nums[mid] < target {
				l = mid+1
			}else {
        // 即使找到了相同的值，也舍去，目的是找到合适插入的位置(刚好大于target的位置)
				r = mid-1
			}
		}
		// l就是刚好大于target的位置
		// 从i开始移位，赋值
		for j:=i; j>=l+1; j-- {
			nums[j] = nums[j-1]
		}
		//插入
		nums[l]= target
	}
}
```

## 2. 稳定性

如果遇到相同的值比较，不会进行交换，所以是稳定的

## 3. 复杂度分析

**在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择**，一般做为快速排序的扩充。

时间复杂度:

* 最好$O(N)$
* 平均$O(N^2)$
* 最差$O(N^2)$

空间复杂度$O(1)$

# 五、希尔排序

## 1. 基本思路

希尔排序使更高效的插入排序，它的思想在于：

* 把数组分成几块，每一块进行一个插入排序；
* 而分块的依据在于增量的选择分好块之后，从gap开始到n，每一组和它前面的元素（自己组内的）进行插入排序；

每次和组内的元素比较完之后，最后的元素基本就是有序的了，希尔排序相对于插入排序的优势在于插入排序每次只能将数据移动一位，**在数组较大且基本无序的情况下性能会迅速恶化。**

![希尔排序](http://xwjpics.gumptlu.work/qinniu_uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=,size_16,color_FFFFFF,t_70-20211101141829191.png)

```go
func shellSort(nums []int) {
	// gap每次减小为原来的一半
	for gap:=len(nums)/2; gap>0; gap/=2 {
		// i为每个分组的起始位置
		for i:=0; i<gap; i++ {
			// 下面对每个分组进行插入排序
			for j:=i+gap; j<len(nums); j+=gap {
				for k:=j; k>i; k-=gap {
					if nums[k-gap] > nums[k] {
						nums[k-gap], nums[k] = nums[k], nums[k-gap]
					}else {
						break
					}
				}
			}
		}
	}
}
```

二刷：

```go
// 希尔排序
// 时间复杂度 最好O(N^1.3) 最坏O(N^2) 平均O(NlogN~N^2)
// 空间复杂度O(1)
// 不稳定
func sortArray(nums []int) []int {
    n := len(nums)
    for gap:=n/2; gap>0; gap/=2 {       // 分组
        // 希尔排序
        for r:=gap; r<n; r+=gap {
            for t:=r; t-gap>=0; t-=gap {
                if nums[t] < nums[t-gap] {
                    nums[t], nums[t-gap] = nums[t-gap], nums[t]
                }
            }
        }
    }

    return nums
}
```

## 2. 稳定性

**不稳定**。插入排序是一种稳定的排序算法，但是希尔排序不是，因为在多次插入的过程中，相同元素完全有可能在不同的插入轮次中移动破坏稳定性

## 3. 复杂度分析

时间复杂度:

* 最好$O(N^{1.3})$
* 平均$O(NlogN)$~$ O(N^2)$
* 最差$O(N^2)$

空间复杂度$O(1)$

**希尔排序时间复杂度的大小还是要取决于步长的合适度**

在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。

# 六、快速排序

## 1. 基本思路

1. 从数列中挑出一个元素，称为"基准/轴值"（pivot），
2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为**分区（partition）操作**。
3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。

![快速排序](http://xwjpics.gumptlu.work/qinniu_uPic/nNT0Di.jpg)

```go
func quickSort(nums []int)  {
	var quickProcess func(int, int)
	gitMid := func(l, r int) int {
		pivot := nums[l]
		for l < r {
			for l < r && nums[r] >= pivot { r-- }
			nums[l] = nums[r]
			for l < r && nums[l] <= pivot { l++ }
			nums[r] = nums[l]
		}
		nums[l] = pivot
		return l
	}
	quickProcess = func(l, r int) {
		if l < r {
			mid := gitMid(l, r)
			// 左半部
			quickProcess(l, mid-1)
			// 右半部
			quickProcess(mid+1, r)
		}
	}
	quickProcess(0, len(nums)-1)
}
```

二刷：

```go
// 快速排序
// 时间复杂度 最好O(NLogN) 平均O(NlogN) 最坏O(N^2)
// 空间复杂度 最好O(logN) 最差O(N)
// 不稳定
func sortArray(nums []int) []int {
    quickSort(nums, 0, len(nums)-1)
    return nums
}

func quickSort(nums []int, l, r int) {
    if l < r {
        mid := getMid(nums, l, r)
        quickSort(nums, l, mid)
        quickSort(nums, mid+1, r)
    }
}

func getMid(nums []int, l, r int) int {
    pivot := nums[l]
    for l < r {
        for l < r && nums[r] >= pivot { r-- }
        nums[l] = nums[r]
        for l < r && nums[l] <= pivot { l++ }
        nums[r] = nums[l]
    }

    nums[l] = pivot
    return l
}
```

缺点： 如果每次选择的pivot都是极端数值（最大或者最小），导致后面划分的数组极度不平衡，复杂度灰降低到$O(N^2)$

![快速排序弊端](http://xwjpics.gumptlu.work/qinniu_uPic/mB1jD1.jpg)

改进策略： 随机快排/快速选择（就是选择pivot时不选择最左边的而是随机选择）

```go
func quickSort(nums []int)  {
	rand.Seed(time.Now().UnixNano())        // 随机种子
	var quickProcess func(int, int)
	gitMid := func(l, r int) int {
		// 选取最左边为pivot
		pivot := nums[l]
		for l < r {
			for l < r && nums[r] >= pivot { r-- }
			nums[l] = nums[r]
			for l < r && nums[l] <= pivot { l++ }
			nums[r] = nums[l]
		}
		nums[l] = pivot
		return l
	}
	quickProcess = func(l, r int) {
		if l < r {
			// 改为随机选择
			randIdx := rand.Int() % (r-l+1) + l
			// 与最左边的数交换
			nums[randIdx], nums[l] = nums[l], nums[randIdx]
			mid := gitMid(l, r)
			// 左半部
			quickProcess(l, mid-1)
			// 右半部
			quickProcess(mid+1, r)
		}
	}
	quickProcess(0, len(nums)-1)
}
```

非递归（迭代）实现快排

```go
func sortArray(nums []int) []int {
    quickSort(nums, 0, len(nums)-1)
    return nums    
}

func quickSort(nums []int, l, r int) {
    stack := []int{}
    // 先存右指针再存左指针
    stack = append(stack, r)
    stack = append(stack, l)

    for len(stack)>0 {
        // 弹出左右指针
        l := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        r := stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        if l < r {
            mid := getMid(nums, l, r)
            
            // 压入栈: 先右再左
            stack = append(stack, mid-1)
            stack = append(stack, l)
            
            stack = append(stack, r)
            stack = append(stack, mid+1) 
        }
    }
}

func getMid(nums []int, l, r int) int {
    pivot := nums[l]
    for l < r {
        for l < r && nums[r] >= pivot { r-- }
        nums[l] = nums[r]
        for l < r && nums[l] <= pivot { l++ }
        nums[r] = nums[l]
    }
    nums[l] = pivot
    return l
}
```

## 2. 稳定性

不稳定，因为我们无法保证相等的数据按顺序被扫描到和按顺序存放。

## 3. 复杂度分析

时间复杂度:

* 最好$O(NlogN)$
* 平均$O(NlogN)$
* 最差$O(N^2)$

空间复杂度$O(logN)$~$O(N)$, $O(N)$是最坏情况，每次都选取到了最大/最小值，每次只能划分出一个数，调用栈的大小就是$O(N)$;如果每次运气都很好，选择的pivot都刚刚好平分数组，那么调用栈的时间复杂度就是$O(logN)$

时间复杂度$O(NlogN)$: 最优情况下， 对于每个pivot都需要折半的递归调用，折半递归到最底层一个数的时间复杂度就是$O(logN)$（共有$O(logN)$层，有这么多次操作）。在每一层中，需要遍历$N$个元素调换顺序，所以总的时间复杂度最优为$O(NlogN)$

# 七、归并排序

## 1. 基本思路

归并排序也是分治法一个很好的应用，先递归到最底层，然后从下往上每次两个序列进行归并合起来，是一个由上往下分开，再由下往上合并的过程，而对于每一次合并操作，对于每一次`merge`的操作过程如下：

![归并排序](http://xwjpics.gumptlu.work/qinniu_uPic/70.png)

![归并排序](http://xwjpics.gumptlu.work/qinniu_uPic/3BCnUD.png)

```go
func mergeSort(nums []int) {
	mergeProcess(nums, 0, len(nums)-1)
}

func mergeProcess(nums []int, l, r int)  {
	if l < r {
		// 分为两部分
		mid := l + (r-l) >> 1
		// 左右分离
		mergeProcess(nums, l, mid)
		mergeProcess(nums, mid+1, r)
		// 此时已经分割开，有序, 进行合并
		if nums[mid] > nums[mid+1] {		// 优化：如果两个部分前后已经有序就不需要合并了即只有大于才合并
			merge(nums, l, mid, r)
		}
	}
}

func merge(nums []int, l, mid, r int)  {
	// 两个部分的起始位置
	p1, p2 := l, mid+1
	// 创建中间辅助数组
	help := make([]int, 0)
	for p1<=mid && p2<=r {
		if nums[p1] <= nums[p2] {
			help = append(help, nums[p1])
			p1 ++
		}else {
			help = append(help, nums[p2])
			p2 ++
		}
	}
	// 处理两边剩余部分
	for p1 <= mid {
		help = append(help, nums[p1])
		p1++
	}
	for p2 <= r {
		help = append(help, nums[p2])
		p2++
	}
	// 赋值到原数组
	for i, v := range help {
		nums[l+i] = v
	}
}
```

二刷：

```go
// 归并排序
// 时间复杂度 最好O(NlogN) 平均O(NlogN) 最坏O(NlogN)
// 空间复杂度O(N)
// 稳定
func sortArray(nums []int) []int {
    mergeSort(nums, 0, len(nums)-1)
    return nums
}

func mergeSort(nums []int, l, r int) {
    if l < r {
        mid := (r-l)/2+l
        mergeSort(nums, l, mid)
        mergeSort(nums, mid+1, r)
        
        // 合并
        if nums[mid] > nums[mid+1] {
            merge(nums, l, mid, r)
        }

        
    }
}

func merge(nums []int, l, mid, r int) {
    p, p1, p2 := 0, l, mid+1
    tmp := make([]int, r-l+1)
    
    for p1 <= mid && p2 <= r {
        if nums[p1] < nums[p2] {
            tmp[p] = nums[p1]
            p1++
        }else {
            tmp[p] = nums[p2]
            p2++
        }
        p++
    }
    for p1 <= mid {
        tmp[p] = nums[p1]
        p1++
        p++
    }
    for p2 <= r {
        tmp[p] = nums[p2]
        p2++
        p++
    }

    for i:=0; i<len(tmp); i++ {
        nums[l+i] = tmp[i]
    }
}
```

注意几点:

- **注意上面的代码中`if(arr[mid] > arr[mid+1])`防止一开始数组很有序的情况；**
- **注意在外排比较的时候，为了保证稳定性，左右相等的时候，先拷贝左边的；**

## 2. 稳定性

归并排序是稳定的

## 3. 复杂度分析

时间复杂度:

* 最好$O(NlogN)$
* 平均$O(NlogN)$
* 最差$O(NlogN)$

因为不断的二分区域，所以分到长度为1即只有一个数时的时间复杂度为$O(logN)$(因为共有$O(logN)$层，分了这么多次)，再看每一层中都需要进行merge操作，看上面的过程图就可以发现每层不管分成几组几个，总的都是$N$个，所以每一层merge操作的时间复杂度就是$O(N)$, 总体就是$O(NlogN)$

空间复杂度$O(N)$, 来源于其中的辅助数组

归并排序在**数据量比较大的时候也有较为出色的表现**（效率上），但是，**其空间复杂度$O(n)$使得在数据量特别大的时候（例如，1千万数据）几乎不可接受**。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。

# 八、堆排序

## 1. 基本思路

可用数组表示的完全二叉树。

1. 已知父节点数组索引i

   父节点是i, 则左子节点为2i，右子节点为2i+1

   > 通常数据的0索引位置创建但不使用，根节点从index1开始，否则上述规律无意义

2. 已知子节点数组索引为i

   则其父节点索引为i/2，其当前层为i/2 (除2也可以用效率更高的位运算)

* 大顶堆：父节点的值比其**所有**子节点都大

* 小顶堆：父节点的值比其**所有**子节点都小

> <font color='#e54d42'>这里的“值”可以代表为任意属性优先值，进而得到**优先队列（也就是堆）：特殊的队列，取出元素的顺序按照元素的优先权而不是先后顺序**</font>

堆的根节点一定是最大/小值，但是节点的顺序未知

堆的原始操作，时间复杂度都为`nlogk`，`k`为按优先级分类的规模（例如按数组中元素出现次数划分，共有k个规模）

* **上浮** shift up: 向堆尾新加入一个元素，堆规模 +1，依次向上与父节点比较，如小于父节点就交换。
* **下沉** shift down: 从堆顶取出一个元素（堆规模 -1，用于堆排序）或者更新堆中一个元素（本题），依次向下与子节点比较，如大于子节点就交换。

堆排序的过程是一个反复调整堆的过程：

- 利用数组建立一个小顶堆；
- 调用`siftDown`，把堆（无序区）的尺寸缩小`1`，取出栈顶元素，并从新的堆顶元素开始进行堆调整；
- 重复步骤，直到堆的大小为`1`；

```go
// 堆排序

type myMinHeap []int		// 小顶堆

func (h *myMinHeap) shiftUp(v int) {
	*h = append(*h, v)
	// 调换位置
	i := len(*h)-1
	for i > 1 && (*h)[i] < (*h)[i/2] {
		// 小于父节点，调换位置
		(*h)[i], (*h)[i/2] = (*h)[i/2], (*h)[i]
		i /= 2
	}
}

func (h *myMinHeap) shiftDown() int {
	n := len(*h)
	v := (*h)[1]
	(*h)[1] = (*h)[n-1]
	*h = (*h)[:n-1]
	// 调整
	minPoint, i := 1, 1
	for {
		// 找出父、左右孩子中最小的节点
		if 2*i < n-1 && (*h)[i] > (*h)[2*i] {
			minPoint = 2*i
		}
		if 2*i+1 < n-1 && (*h)[minPoint] > (*h)[2*i+1] {
			minPoint = 2*i+1
		}
		if minPoint == i {
			// 如果已经满足，则不需要调整了，因为底下本来就是有序的
			break
		}
		// 将父节点与最小的交换
		(*h)[i], (*h)[minPoint] = (*h)[minPoint], (*h)[i]
		i = minPoint
	}
	return v
}

func heapSort(nums []int) {
	// 创建小顶堆
	minHeap := myMinHeap([]int{0})
	for _, v := range nums {
		minHeap.shiftUp(v)
	}
	// 每次删除掉一个
	for i:=0; i<len(nums); i++ {
		nums[i] = minHeap.shiftDown()
	}
}
```

二刷：

```go
// 堆排序
// 时间复杂度 最好O(NlogN) 最差O(NlogN) 平均O(NlogN)
// 空间复杂度 O(N)
// 不稳定
type minHeap []int

func (m *minHeap) shiftUp(v int) {
    *m = append(*m, v)
    i := len(*m)-1
    for i>1 && (*m)[i/2] > (*m)[i] {
        (*m)[i/2], (*m)[i] = (*m)[i], (*m)[i/2]
        i /= 2
    }
}

func (m *minHeap) shiftDown() int {
    res := (*m)[1]
    (*m)[1] = (*m)[len(*m)-1]
    *m = (*m)[:len(*m)-1]

    i := 1
    for {
        minIdx := i
        if i*2 < len(*m) && (*m)[i*2] < (*m)[minIdx] {
            minIdx = i*2
        }
        if i*2+1 < len(*m) && (*m)[i*2+1] < (*m)[minIdx] {
            minIdx = i*2+1
        }
        if i == minIdx {
            break
        }

        (*m)[minIdx], (*m)[i] = (*m)[i], (*m)[minIdx]
        i = minIdx
    }
    
    return res
}

func sortArray(nums []int) []int {
    newMinHeap := minHeap([]int{-1})
    for _, v := range nums {
        newMinHeap.shiftUp(v)
    } 

    i := 0
    for len(newMinHeap) > 1 {
        nums[i] = newMinHeap.shiftDown()
        i++
    }

    return nums
}
```

## 2. 稳定性

不稳定

## 3. 复杂度分析

时间复杂度:

* 最好$O(NlogN)$
* 平均$O(NlogN)$
* 最差$O(NlogN)$

完美二叉树时间复杂度$O(logN)$, 每次删除一个共$N$个最坏情况下操作$O(NlogN)$次

空间复杂度$O(1)$

堆排序在建立堆和调整堆的过程中会产生比较大的开销，**在元素少的时候并不适用**。但是，**在元素比较多的情况下，还是不错的一个选择**。尤其是在解决诸如**“前n大的数”**一类问题时，几乎是首选算法。

# 九、桶排序

> 参考：https://blog.csdn.net/guoweimelon/article/details/50904245

[桶排序](https://so.csdn.net/so/search?q=桶排序&spm=1001.2101.3001.7020)（Bucket sort）或所谓的箱排序，**并不是比较排序**，它不受到 `O(nlogn)` 下限的影响

## 1. 基本思路

桶排序工作的原理是**将数组分到<font color='#e54d42'>有限数量</font>的桶子里，每个桶子再个别排序**，有可能再使用别的[排序算法](https://so.csdn.net/so/search?q=排序算法&spm=1001.2101.3001.7020)或是以递归方式继续使用桶排序进行排序。桶排序是**鸽巢排序**的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间`O(n)`

桶排序算法的运行过程如下：

1. 将待排序元素划分到不同的桶
2. 先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间` [minV, maxV] `均匀划分成 k 个区间，每个区间就是一个桶
3. 将序列中的元素分配到各自的桶
4. 对每个桶内的元素进行排序，可以选择任意一种排序算法
5. 将各个桶中的元素合并成一个大的有序序列
   * 这里就可以用一个为k大小的小顶堆，然后从k个有序数组中找出最小，然后不断合并（类似于合并k个有序链表）

## 2. 稳定性

稳定（其实要看每个桶中使用的）

## 3. 复杂度分析

假设数据是均匀分布的，则每个桶的元素平均个数为 `n/k `。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 `O(n/klog(n/k)) `。总的时间复杂度为 `O(n)+O(k)O(n/klog(n/k)) = O(n+nlog(n/k)) = O(n+nlogn-nlogk)`

当 k 接近于 n 时，桶排序的时间复杂度就可以近似认为是` O(n)` 的。即<font color='#e54d42'>桶越多，时间效率就越高，而桶越多，空间就越大</font>

# 十、计数排序

## 1. 基本思路

> * https://blog.csdn.net/thinkwon/article/details/101544159
> * https://blog.csdn.net/qq_19446965/article/details/81517552

是一种O(n)的[排序算法](https://so.csdn.net/so/search?q=排序算法&spm=1001.2101.3001.7020)，其思路是开一个长度为 `maxValue-minValue+1 `的数组，然后

1. 分配。扫描一遍原始数组，以`当前值- minValue `或者作为下标，将该下标的计数器增1
2. 收集。扫描一遍计数器数组，按顺序把值收集起来

> * 所以对应于数组来说，需要提前知晓（扫描一遍）数组的最大值和最小值
>
> * **其实计数排序就是一种特殊的桶排序，所以也不是一种比较排序算法，当桶的数量最大时就是计数排序**
> * 由于用来计数的[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），**这使得计数排序对于数据范围很大的数组，需要大量时间和内存（不适合数据值差异很大的原始数据）**

例如数组为：`8，5，4，7，2，1，5，10`

使用一个大小为11的桶即可(0号桶空置, 10-1+1=10)，那么映射下来就是如下：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220805155935499.png" alt="image-20220805155935499" style="zoom:67%;" />

那么扫描一遍数组取不是空的位置的下标就是排序的结果，如果如图中a[5]=2则需要记录两个5

那么代码可以是：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220805160217887.png" alt="image-20220805160217887" style="zoom:67%;" />

```go
// 计数排序
// 时间复杂度O(n+k)
// 空间复杂度O(n+k)
func sortArray(nums []int) []int {
    // 找到最小值和最大值
    min, max := 0, 0
    for i:=0; i<len(nums); i++ {
        if nums[i] < min {
            min = nums[i]
        }
        if nums[i] > max {
            max = nums[i]
        }
    }

    // 创建桶
    negativeBuckets := make([]int, -min+1)
    postiveBuckets := make([]int, max+1)

    // 写入桶
    for _, v := range nums {
        if v <= 0 {
            negativeBuckets[-v]++
        }else {
            postiveBuckets[v]++
        }
    }

    // 遍历桶
    p := 0
    // 先遍历负数桶
    for i:=-min; i>=0; i-- {
        for j:=0; j<negativeBuckets[i]; j++ {
            nums[p] = -i
            p++
        }
    }
    // 在遍历正数桶
    for i:=0; i<len(postiveBuckets); i++ {
        for j:=0; j<postiveBuckets[i]; j++ {
            nums[p] = i
            p++
        }
    }
    
    return nums
}
```

## 2. 稳定性

稳定

## 3. 复杂度分析

假设共有n个数，数的范围是0~k（为了方便，所以假设范围都在正数区间，如果有负数其实也是一样的，可以映射过来）

那么对于计数排序，如下面的例子：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220806151728902.png" alt="image-20220806151728902" style="zoom:50%;" />

主要的复杂度看红框的部分，第一层i是遍历的位图/数组的大小，所以时间复杂度为k

第二层遍历的是某一个位置（这个位置就是那个数的值）出现的次数，虽然这两层是嵌套的关系，但是可以知道的是所有的数出现的次数之和一定是n次（也就是即使外圈循环完了总和也就是n次），所以总的时间复杂度应该是`O(n+k)`而不是`O(n*k)`

时间复杂度：

* 最好：`O(n+k)`
* 平均：`O(n+k)`
* 最差：`O(n+k)`

空间复杂度：

* `O(n+k)`

# 十一、基数排序

> https://www.cnblogs.com/sun/archive/2008/06/26/1230095.html

## 1. 基本思路

基数排序是**非比较排序算法**,算法的时间复杂度是O(n). 相比于快速排序的O(nlgn),从表面上看具有不小的优势.但事实上可能有些出入,**因为基数排序的n可能具有比较大的系数K**.因此在具体的应用中,应首先对这个排序函数的效率进行评估.

基数排序的主要思路是,<font color='#e54d42'>将所有待比较数值(**注意,必须是正整数**)统一为**同样的数位长度**,数位较短的数前面补零</font>. 然后, 从最低位开始, 依次进行一次**稳定排序**(我们常用上一篇blog介绍的计数排序算法, 因为**每个位可能的取值范围是固定的从0到9**).这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列

比如这样一个数列排序:` 342 58 576 356`, 以下描述演示了具体的排序过程(红色字体表示正在排序的数位)

第一次排序(个位)：

```shell
3 4 2
5 7 6
3 5 6
0 5 8
```

第二次排序(十位)：

```shell
3 4 2
3 5 6
0 5 8
5 7 6
```

第三次排序(百位)：

```shell
0 5 8
3 4 2
3 5 6
5 7 6
```

结果: `58 342 356 576`

两个问题:

- 为什么要从低位开始向高位排序?

> ​    **如果要从高位排序, 那么次高位的排序会影响高位已经排好的大小关系. 在数学中, 数位越高,数位值对数的大小的影响就越大.从低位开始排序,就是对这种影响的排序. 数位按照影响力从低到高的顺序排序, 数位影响力相同则比较数位值.**  简单的例子：52和61

- 为什么同一数位的排序子程序要使用稳定排序?

> ​    **稳定排序的意思是指, 待排序相同元素之间的相对前后关系,在各次排序中不会改变.比如实例中具有十位数字5的两个数字58和356, 在十位排序之前356在58之前,在十位排序之后, 356依然在58之前.**
>
> ​    **<font color='#e54d42'>稳定排序能保证,上一次的排序成果被保留,十位数的排序过程能保留个位数的排序成果</font>,百位数的排序过程能保留十位数的排序成果.**

## 2. 稳定性

稳定

## 3. 复杂度分析

n个数，共有k个位

时间复杂度：

*  最好、最坏、平均：`O(n*k)`

空间复杂度：`O(n+k)`
