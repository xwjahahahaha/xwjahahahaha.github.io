---
title: 二分法边界问题
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2021-10-31 22:07:28
---

> 学习自：https://blog.csdn.net/Lin_RD/article/details/105186081
>

# 一、二分法流程

二分法的一般流程如下：

1. 确定左右边界：[left, right)
2. 确定终止条件
3. 获得中点
4. 比较，缩减一半区间

<!-- more -->

# 二、确定左右边界

对于一个有序序列最小索引是0，最大索引是$n-1$

可以使用两种方法表示其区间：

* 左闭右开： $[0, n)$
* 左闭右闭：$[0, n-1]$

一般情况符合使用习惯的话都会使用左闭右开的方式

# 三、确定终止条件

需要明确的是，我们需要遍历整个数组，因此终止条件必须要确保数组的所有元素被包含

如果使用$[0, n)$此时右值不可取，因此终止条件是: `while left < right`

如果使用$[0, n-1]$此时右值可取，因此终止条件是:`while left <= right`

例子：假设数组只有一个元素，n=1，左闭右开$[0, 1)$则当设置$left<right$则$0<1$满足可以进入考察全部元素

如果是左闭右闭$[0,0]$那么只有设置$left<=right$即有等号才能进入循环，判断所有元素

**<font color='#e54d42'>取右值用<=    不取右值用<  </font>**

# 四、获取中点

最主要的是防止溢出：

```go
mid := left + (right-left)/2
mid := (left+right)>>1
```

# 五、收缩区间

避免死循环，所以需要保证每次进入while可行区间必须缩小即要么left变大或者right变小

升序序列下，当`nums[mid]<target`时，应该将`left`右移，省略左半部分

此时有两种情况：

1. `left=mid`
2. `left=mid+1`

选择哪一种考察的原则是：**对于位置`mid`的值是否是可能的`target`**

这里很明显不是，所以我们采用第二种（因为两种情况都是左闭，所以`left`都可以取到）

当`nums[mid]>target`时，`right`左移，省略右半部分

此时也有两种情况：

1. `right=mid`
2. `right=mid-1`

相同的对应上面的原则，`mid`的值也一定不是可能的`target`，要舍去

* 左闭右开[0, n)： 因为`right`取不到，所以对应第一种可以直接舍去`mid`位置，满足；第二种则会多舍去一个`mid-1`位置，让`mid-1`位置无法考察到，所以应该选择`right=mid` （隐式收缩）

* 左闭右闭[0, n]：`right`可以取到，所以要舍去的话只能选择第二种方式即`right=mid-1` （显式收缩）

> <font color='#39b54a'>right是否能取到，是对应while条件，如是是left < right，那么当left==right时是无法进入while循环中的，所以无法取到；对于left<=right条件，当left等于right时可以取到right </font>

总结如下(都假设mid值不是要找的值)：

|   while条件   | 收缩左半部 | 收缩右半部  |
| :-----------: | :--------: | :---------: |
| Left < Right  | Left=mid+1 |  Right=mid  |
| Left <= Right | Left=mid+1 | Right=mid-1 |

# 六、退出循环的位置

while退出后，left和right分别指向哪？

## 1. while left < right

首先明确的是，这个条件下退出时`left == right`

因为此条件下每次`right=mid`而判断收缩右半部的条件是:`nums[mid]>target`所以可以明确的是`nums[right]>target`，即退出循环后`right`指针指向的值一定是大于`target`的

再者，推出循环时`left==right`，所以退出循环后`left`、`right`指向的值都是大于目标值的

实际上，**`left`、`right`都指向第一个大于`target`的值**

> * 假设left-1存在：
>   * 如果执行过赋值left = mid + 1， 那么nums[mid] < target。所以nums[left-1] < target。nums[left-1] < target < nums[left]，显然nums[left]是nums中大于target的最小值。
>   * 如果left = mid + 1没有执行过， 那么说明left == 0，没有移动过，这就相当于left-1不存在。
>
> * 如果left-1不存在， left-1不存在说明left == 0， 因为0是第一个索引，所以nums[left]还是第一个大于target的数(target小于nums[0])

## 2. while left <= right

退出时，`left==right+1`

如果执行过赋值` right = mid - 1`，` nums[mid] > target`， 换句话说`nums[right+1] == nums[mid] > target`。`left = right + 1`所以`nums[left] > target`。

如果没执行过`right = mid-1`， 那么`right == n-1`, `left == right+1 == n`。也就是说不存在大于`target`的数字(`nums[n-1]<target`)。

如果执行过赋值`left = mid + 1`，` nums[mid] < target`所以`nums[mid+1]=nums[left]>target`

如果没执行过`left = mid + 1`， 那么`left == 0`，是第一个索引，所以`left`仍然是第一个大于`target`的数字。

**<font color='#e54d42'>综上所述：不论哪种情况，结束二分时left都是指向第一个大于target的数，或者不存在大于target的数，那么left指向序列的末尾n， 需要注意的是，nums[left-1]并不一定就是目标值，因为目标值不一定存在于序列中</font>**

# 七、训练

[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

两种情况如下：

```go
// 左闭右开
func search(nums []int, target int) int {
    l, r := 0, len(nums)
    for l < r {
        mid := l + (r-l)/2
        if nums[mid] < target {
            l = mid+1
        }else if nums[mid] > target {
            r = mid 
        }else {
            return mid
        }
    }
    return -1
}
```

```go
// 左闭右闭
func search(nums []int, target int) int {
    l, r := 0, len(nums)-1
    for l <= r {
        mid := l + (r-l)/2
        if nums[mid] < target {
            l = mid+1
        }else if nums[mid] > target {
            r = mid-1
        }else {
            return mid
        }
    }
    return -1
}
```

[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

```go
func searchInsert(nums []int, target int) int {
    l, r := 0, len(nums)
    for l < r {
        mid := (l+r) >> 1
        if nums[mid] < target {
            l = mid+1
        }else if nums[mid] > target {
            r = mid
        }else {
            return mid
        }
    }
    // 不存在于数组的三种情况
    // if l == 0 { return 0 }   目标值比数组最小的数都小
    // if l == n { return n }   目标值比数组最大的数都大
    // if nums[l-1] != target { return l }  // 目标值在数组中相邻的两个数中间
    return l
}
```

