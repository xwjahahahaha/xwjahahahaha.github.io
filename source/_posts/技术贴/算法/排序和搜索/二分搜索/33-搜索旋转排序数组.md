---
title: 33-搜索旋转排序数组
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-05-07 15:35:58
---

## 题目描述

[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

难度中等

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

<!-- more --> 

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

 

**提示：**

- `1 <= nums.length <= 5000`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-10^4 <= target <= 10^4`

 

**进阶：**你可以设计一个时间复杂度为 `O(log n)` 的解决方案吗？



## 解题思路及代码

```go
// 二分搜索
// 虽然旋转了,但是部分有序
// 二分查找到中点时,左右两侧一定有一部分是完全有序(升序)的,所以可以判断舍弃那一部分
// 时间复杂度O(logN)
func search(nums []int, target int) int {
    n := len(nums)
    l, r := 0, n-1 
    for l <= r {
        mid := (l+r) >> 1
        if nums[mid] == target {
            return mid
        }else {
            if nums[l] <= nums[mid] {
                if target >= nums[l] && target < nums[mid] {
                    // 舍弃右边
                    r = mid - 1
                }else {
                    // 舍弃左边
                    l = mid + 1
                }
            }else {
                if target > nums[mid] && target <= nums[r]{
                    // 舍弃左边
                    l = mid + 1   
                }else {
                    // 舍弃右边
                    r = mid - 1
                }
            }
        }
    }
    return -1
}
```



// 二刷的烂思路：

```go
func search(nums []int, target int) int {
    // 找出旋转点
    l, r := 0, len(nums)-1
    for l < r {
        mid := l + (r-l) >> 1
        if nums[l] < nums [mid] {
            l = mid
        }else {
            r = mid
        }
    }
    // 如果数组本身就是有序，那么找到的旋转点就是真正旋转点的前一个，所以要+1
    if l+1 <len(nums) && nums[l] < nums[l+1] {
        l++
    }
    // 找出target
    left, right := 0, len(nums)     // 注意：使用左闭右开
    if target > nums[0] {
        // 左半部
        right = l+1                 // 左闭右开所以l+1
    }else if target < nums[0] {
        // 右半部
        left = l+1
    }else {
        return 0
    }
    for left < right {
        mid := left + (right-left) >> 1
        if nums[mid] < target {
            left = mid + 1
        }else if nums[mid] > target {
            right = mid
        }else {
            return mid
        }
    }
    if left > 0 && l < len(nums) && nums[left-1] == target {
        return left-1
    }
    return -1
}
```

