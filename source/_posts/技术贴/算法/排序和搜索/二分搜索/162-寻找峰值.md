---
title: 162-寻找峰值
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-05-01 15:13:12
---

## 题目描述

[162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

难度中等

峰值元素是指其值大于左右相邻值的元素。

给你一个输入数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

 <!-- more -->

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

**示例 2：**

```
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

 

**提示：**

- `1 <= nums.length <= 1000`
- `-231 <= nums[i] <= 231 - 1`
- 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

 

**进阶：**你可以实现时间复杂度为 `O(logN)` 的解决方案吗？




## 解题思路及代码

```go
// 直接的思路: 线性扫描 寻找比两边都大的值就是峰值
// 时间复杂度O(N) 空间复杂度O(1)
func findPeakElement(nums []int) int {
    n := len(nums)
    if n == 1 {
        return 0
    }
    for idx, val := range nums {
        if (idx == 0 && val > nums[idx+1]) || (idx == n-1 && val > nums[idx-1]) || (idx > 0 && idx < n-1 && val > nums[idx-1] && val > nums[idx+1]) {
            return idx
        }
    }
    return -1
}

// 线性扫描的简单做法
// 时间复杂度O(N) 空间复杂度O(1)
func findPeakElement(nums []int) int {
    // 一直往上跑.如果峰值为1立即结束,如果峰值为n-1那么遍历结束,如果峰值在中间,那么判断结束
    n := len(nums)
    for i:=0; i<n-1; i++ {
        if nums[i] > nums[i+1] {
            return i
        }
    }
    return n-1
}


// 二分查找
// 只需要返回任何一个峰值即可, 则对于二分法的中点有:
// 如果中点mid处于下坡(其值大于后一个值),那么一定存在一个峰值在[left, mid]即左侧, 而右侧是否存在不需考虑
// 同理,处于上坡位置则一定存在一个峰值在右侧
func findPeakElement(nums []int) int {
    n := len(nums)
    l, r := 0, n-1     
    for l < r {                 // 不能等于,因为确定了有峰值, 等于进入循环体会造成死循环   
        mid := (l+r) >> 1
        // 下坡, 缩放到左边
        if nums[mid] > nums[mid+1] {        
            r = mid         // 无法确定此时的mid是否为峰值,所以不加
        } else {
        // 上坡, 缩放到右边
            l = mid + 1     // mid一定不是峰值了,所以+1
        }
    }
    return l
}
```

二刷：

```go
// 二分法不一定要有序，只要有条件能判断舍弃掉一半的值就ok
// 注意前提条件是只要找到一个峰值即可
func findPeakElement(nums []int) int {
    l, r := 0, len(nums)-1
    for l < r {             // 不能等于
        mid := (r-l)/2 + l
        // 处于上坡
        if nums[mid] < nums[mid+1] {
            // 舍弃左边, 此时mid位置一定不是峰值，所以+1
            l = mid+1
        }else {
            // 下坡，舍弃右边，此时mid位置可能是峰值，所以不-1
            r = mid
        }
    }

    return l
}
```

