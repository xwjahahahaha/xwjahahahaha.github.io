---
title: 34-在排序数组中查找元素的第一个和最后一个位置
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-05-02 11:38:47
---

## 题目描述

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

难度中等981

给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

**进阶：**

- 你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？

<!-- more --> 

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

 

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- `nums` 是一个非递减数组
- `-109 <= target <= 109`




## 解题思路及代码

按视频思路:

```go
// 闭区间二分查找
// 找到目标元素后还是线性查找,时间复杂度O(N), 不满足题意
func searchRange(nums []int, target int) []int {
    n := len(nums)
    l, r := 0, n-1
    ans := []int{}
    for l <= r {
        mid := (l + r) >> 1
        if nums[mid] == target {
            // 左右扩充一下区间
            i := 0
            for i=mid; i>=0 && nums[i] == target ; i-- {}
            ans = append(ans, i+1)
            for i=mid; i<n && nums[i] == target ; i++ {}
            ans = append(ans, i-1)
            return ans
        }else if nums[mid] > target {
            r = mid - 1
        }else {
            l = mid + 1
        }
    }
    return []int{-1, -1}
}

// 二分查找
// 找到后继续二分查找
// 1. 先查找第一个满足题意的left边界, 如果找不到则直接返回-1,-1
// 2. 再查找满足提议的right边界
func searchRange(nums []int, target int) []int {
    n := len(nums)
    leftIdx, rightIdx := -1, -1
    if n == 0 {
        return []int{leftIdx, rightIdx}
    }

    // 查找left边界leftIdx
    l, r := 0, n-1
    for l < r {         
        mid := (l + r) >> 1
        if nums[mid] < target {
            // 搜索空间: [mid+1, r]
            l = mid + 1
        }else if nums[mid] == target {
            // 此时左边界一定在mid左侧,但是其本身也可能就是左边界,所以不-1,继续二分查找
            // 搜索空间: [l, mid]
            r = mid 
        }else {
            // 搜索空间: [l, mid-1]
            r = mid - 1
        }
    }
    // 结束 l == r, 对当前位置再次检查
    if nums[l] == target {
        leftIdx = l
    } else {
        // 否则没有目标值, 直接返回
        return []int{leftIdx, rightIdx}
    }

    // 查找right边界rightIdx
    l, r = leftIdx, n-1
    for l < r {   
        fmt.Println(l ,r)      
        mid := (l + r + 1) >> 1         // !!! 注意, 因为有l = mid, 而默认去中间mid是下取整,所以会导致死循环, 故这里要改成上取整
        // 此时不存在比target小的情况
        if nums[mid] == target {
            // 此时右边界可能在mid右侧, 但是其本身也可能就是右边界,所以不+1,继续查找
            // 搜索空间: [mid, r]
            l = mid
        }else {
            // nums[mid] > target
            // 搜索空间: [l, mid-1]
            r = mid - 1
        }
    }
    // 不需要检查, 因为一定存在target
    rightIdx = l
    return []int{leftIdx, rightIdx}
}
```

