---
title: 75-颜色分类
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-23 19:45:58
---

## 题目描述

[75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

难度中等 

给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

 <!-- more -->

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**示例 3：**

```
输入：nums = [0]
输出：[0]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

 

**进阶：**

- 你可以不使用代码库中的排序函数来解决这道题吗？
- 你能想出一个仅使用常数空间的一趟扫描算法吗？


## 解题思路及代码

```go
// 快速排序
// 时间复杂度、空间复杂度O(nlogn)
func sortColors(nums []int)  {
    var quickSort func(int, int) 
    var getMid func(int, int) int 
    getMid = func(l, r int) int {
        // 1. 暂存中间点
        pivot := nums[l]
        // 2. 左右移动
        for l < r {
            // 右大
            for nums[r] >= pivot && l < r {
                r --
            }
            nums[l] = nums[r]
            // 左小
            for nums[l] <= pivot && l < r {
                l ++
            }
            nums[r] = nums[l] 
        }
        // 3. 恢复中间点值
        nums[l] = pivot
        return l
    } 
    quickSort = func(l, r int) {
        if l < r {
            // 获取中间位置
            mid := getMid(l, r)
            // 左边快排
            quickSort(l, mid-1)
            // 右边快排
            quickSort(mid+1, r)
        }
    }
    quickSort(0, len(nums)-1)
}


// 单指针两次遍历 时间复杂度O(N), 空间复杂度O(1)
// 第一次遍历将0放到前面
// 第二次遍历将1放到前面(0后面)
func sortColors(nums []int)  {
    head := 0
    // 第一次遍历
    for i, v := range nums {
        if v == 0 {
            nums[head], nums[i] = 0, nums[head]
            head ++ 
        }
    }
    // 第二次遍历
    for i:=head; i<len(nums); i++ {
        if nums[i] == 1 {
            nums[head], nums[i] = 1, nums[head]
            head ++
        }
    }
}

// 双指针一次遍历
// 两个头指针分别代表0和1
func sortColors(nums []int)  {
    p0, p1 := 0, 0
    for i, v := range nums {
        if v == 0 {
           // 交换
           nums[p0], nums[i] = 0, nums[p0]
           if p0 < p1 {
               // 小于则一定再交换,因为此时p0指向的值一定为1(被1换过来了)
               // 所以再把当前i的值指向的1换回到p1指向的位置(p1的位置一定是++过的,不是1), 即换到末尾
               nums[p1], nums[i] = nums[i], nums[p1]
           }
           // 两个指针都满足了,同时++
           p0 ++
           p1 ++
        }else if v == 1 {
            // 对于1就是简单的交换, ++
            nums[p1], nums[i] = 1, nums[p1]
            p1 ++
        }
    }
}

// 双指针一次遍历
// 两个指针分别代表0和1
func sortColors(nums []int)  {
    if len(nums) <= 1 {
        return
    }
    p0, p2 := 0, len(nums)-1
    // 当i>p2时就结束了
    for i:=0; i<=p2; i++ {
        if nums[i] == 0 {
            // 交换,++
            nums[i], nums[p0] = nums[p0], 0
            p0 ++
        }
        // 可以不写else,因为在i之前不会有2了(前面有的话一定被交换到后面去了), 
        // 所以不会出现经过上面的if交换导致2被交换到前面去,从而没被下面的if判断(if之间没影响)
        if nums[i] == 2 {
            // 交换, --
            nums[i], nums[p2] = nums[p2], 2
            p2 --
            // 如果换过来的数为1,那么无影响,但是如果为0或者2,
            // 那么当i++时,这个被换过来的数就略过了,导致错误,所以要回退一下i重新判断
            if nums[i] != 1 {
                i --
            }
        }
    }
}
```

二刷：

```go
// 计数排序 时间复杂度O(n+k) 空间复杂度O(1)
func sortColors(nums []int)  {
    count := make([]int, 3)
    for _, v := range nums {
        count[v]++
    }

    p := 0
    for i, v := range count {
        for j:=0; j<v; j++{
            nums[p] = i
            p++
        }
    }
}

// 双指针只遍历一次
func sortColors(nums []int)  {
    p0, p1 := 0, 0              // 分别指向下一个要交换的0，1的位置
    for i, v := range nums {
        if v == 0 {
            // 先交换0
            nums[p0], nums[i] = nums[i], nums[p0]
            // 如果p0<p1，那么一定p0指向的一定是1，因为如果p0指向的是0，那么其一定会++前进一步
            // 只有可能p0++到达了p1前面已经交换过的1
            if p0 < p1 {
                // 再交换1
                nums[p1], nums[i] = nums[i], nums[p1]
            }
            // 两个指针都要++，对于p1来说前面多换进来一个0，所以也要++
            p0 ++
            p1 ++
        }else if v == 1 {
            nums[p1], nums[i] = nums[i], nums[p1]
            p1++
        }
    }
}
```

