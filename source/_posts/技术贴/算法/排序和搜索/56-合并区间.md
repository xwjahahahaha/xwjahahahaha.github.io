---
title: 56-合并区间
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
declare: true
date: 2021-05-03 11:22:39
---

# 题目描述

[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

难度中等

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

 <!-- more -->

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**提示：**

- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 104`

# 解题思路和代码

时间复杂度O(nlongn)

```go
// 直接的思路: 快速排序 + 合并
func merge(intervals [][]int) [][]int {
    n := len(intervals)
    // 先排序
    quickSort(0, n-1, intervals)
    // 合并
    ans := mergeOnce(intervals)
    m := len(ans)
    // 循环合并
    for n > m {
        n = m
        ans = mergeOnce(ans)
        m = len(ans)
    }   
    return ans
}

func partition(l, r int, intervals [][]int) int {
    pivot := intervals[l]
    for l < r {
        for intervals[r][0] >= pivot[0] && l < r { r -- }
        intervals[l] = intervals[r]
        for intervals[l][0] <= pivot[0] && l < r { l ++ }
        intervals[r] = intervals[l]
    }
    intervals[l] = pivot
    return l
}

// 快速排序
func quickSort(l, r int, intervals [][]int) {
    if l < r {
        mid := partition(l, r, intervals)
        quickSort(l, mid-1, intervals)
        quickSort(mid+1, r, intervals)
    }
}

func mergeOnce(intervals [][]int) [][]int {
    ans := [][]int{}
    n := len(intervals)
    for i:=0; i<n; i++ {
        // 合并
        // 1. 前后相同, 直接去重
        // 2. 中间交集: 前者[1] > 后者[0] && 前者[1] < 后者[1]
        // 3. 全包子集: 前者[1] >= 后者[1]
        if i == n-1 {
            ans = append(ans, intervals[n-1])
            continue
        }
        if intervals[i][0] == intervals[i+1][0] && intervals[i][1] == intervals[i+1][1] || intervals[i][1] > intervals[i+1][1] {
            ans = append(ans, []int{intervals[i][0], intervals[i][1]})
            i ++
        }else if intervals[i][1] >= intervals[i+1][0]{
            ans = append(ans, []int{intervals[i][0], intervals[i+1][1]})
            i ++
        }else {
            ans = append(ans, intervals[i])
        }
    }
    return ans
}


// 方法二: 简洁的方法, 排序+归并
// 维护一个ans结果切片, 依次考察原切片中的每个区间, 现将第一个区间直接放入ans
// 依次遍历后面的区间, 如果当前考察区间的前一位 > ans数组最后一个区间的后一位, 那么直接插入到ans中
// 如果 < 那么判断ans最后一区间的最后一位与考察区间的最后一位谁大, 然后[替换]ans最后区间的最后一位
func merge(intervals [][]int) [][]int {
    n := len(intervals)
    // 排序
    quickSort(0, n-1, intervals)
    ans := [][]int{intervals[0]}
    // 考察
    for _, interval := range intervals {
        last := ans[len(ans)-1][1]
        if interval[0] > last {
            ans = append(ans, interval)
        }else if last < interval[1]{
            ans[len(ans)-1][1] = interval[1]
        }
    } 
    return ans
}
```

三刷：

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return intervals
    }

    // 先排序再合并
    sort.SliceStable(intervals, func(i, j int) bool {
        if intervals[i][0] == intervals[j][0] {
            return intervals[i][1] < intervals[j][1]
        }
        return intervals[i][0] < intervals[j][0]
    })

    // 维护一个结果数组，表示当前合并结果的区间，然后不断从已排序的区间中拿出第一个区间进行合并
    res := [][]int{intervals[0]}
    for _, n := range intervals {
        nowLaster := res[len(res)-1]
        if n[0] == nowLaster[0] || n[0] <= nowLaster[1] {
            // 第一位相同或者<=当前第二位，第二位>当前第二位
            if n[1] > nowLaster[1] {
                nowLaster[1] = n[1]
            }
        }else if n[0] > nowLaster[1] {
            // 第一位>当前的第二位 直接放入
            res = append(res, n)
        }
    }

    return res
}
```



