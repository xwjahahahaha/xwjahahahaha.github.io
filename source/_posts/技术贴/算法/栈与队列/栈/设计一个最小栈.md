---
title: 设计一个最小栈
tags:
  - java
categories:
  - technical
  - leetcode
toc: true
date: 2020-06-09 17:11:00
---

## 问题描述

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

* push(x) —— 将元素 x 推入栈中。

* pop() —— 删除栈顶的元素。

* top() —— 获取栈顶元素。

* getMin() —— 检索栈中的最小元素。
<!-- more -->
示例:

输入：

`["MinStack","push","push","push","getMin","pop","top","getMin"]`

`[[],[-2],[0],[-3],[],[],[],[]]`


输出：

`[null,null,null,null,-3,null,0,-2]`

解释：

MinStack minStack = new MinStack();

minStack.push(-2);

minStack.push(0);

minStack.push(-3);

minStack.getMin();   --> 返回 -3.

minStack.pop();

minStack.top();      --> 返回 0.

minStack.getMin();   --> 返回 -2.

提示：

pop、top 和 getMin 操作总是在 非空栈 上调用。

>来源：力扣（LeetCode）

>链接：https://leetcode-cn.com/problems/min-stack

>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 解题思路

本题可用数组、链表实现栈结构（直接使用写好的API，本题的意义也没了）

本题的关键在于解决getMin查找最小元素的方法上。可使用**辅助栈**方法，栈中每加入一个元素，将其与辅助存储中的栈顶元素（当前最小值）比较,只有小于才插入当前值，否则还是插入最小值。弹出元素时，辅助栈也一起弹。

## 代码

使用写好的API，很简单，无意义
```java
class MinStack {
    //用LinkedList结构实现栈
    private LinkedList<Integer> stackList;
    
    /** initialize your data structure here. */
    public MinStack() {
        stackList = new LinkedList<>();
    }
    
    public void push(int x) {
        stackList.push(x);
    }
    
    public void pop() {
        stackList.pop();
    }
    
    public int top() {
        return stackList.getFirst();
    }
    
    public int getMin() {
        return Collections.min(stackList);
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

1.效率低下，打败17%，原因：使用链表找最小元素值，使用普通遍历会很慢

```java
class MinStack {
    /**链表节点类**/
    private class Node {
        private int value;
        private Node next;
    }

    /**链表类**/
    private class MyList{
        private Node headNode;
    }
    //用链表结构实现栈
    private MyList stackList;
    
    /** initialize your data structure here. */
    public MinStack() {
        stackList = new MyList();
        Node firstNode = new Node();
        //头结点的next作为栈的出入口
        stackList.headNode = firstNode;
    }
    
    public void push(int x) {
        Node newNode = new Node();
        newNode.value = x;
        newNode.next = null;
        //连接到下一个节点
        //先让新的节点连接上后面的链表,是null也无妨，刚刚好
        newNode.next = this.stackList.headNode.next;
        //头结点连上新节点
        this.stackList.headNode.next = newNode;       
    }
    
    public void pop() {
        //弹出头结点的第一个元素
        this.stackList.headNode.next = this.stackList.headNode.next.next;
    }
    
    public int top() {
        return this.stackList.headNode.next.value;
    }
    
    //1. 顺序遍历，打擂台  时间复杂度O(N) (N很大时，重复调用查找时间复杂度会很大)
    public int getMin() {
       
        Node node = this.stackList.headNode.next;
        int min = Integer.MAX_VALUE;
        while(node != null){
            if(node.value < min)
                min = node.value;
            node = node.next;
        }
        return min;
    }
}
```

2.使用辅助存储,将时间复杂度降到O(1) 打败80%

```java
class MinStack {
    /**链表节点类**/
    private class Node {
        private int value;
        private Node next;
    }

    /**链表类**/
    private class MyList{
        private Node headNode;
    }
    //用链表结构实现栈
    private MyList stackList;
    //辅助链表，存储最小值
    private MyList helpList; 
    
    /** initialize your data structure here. */
    public MinStack() {
        //数据链表
        stackList = new MyList();
        Node firstNode = new Node();
        //头结点的next作为栈的出入口
        stackList.headNode = firstNode;

        //辅助链表
        helpList = new MyList();
        Node firstHelpNode = new Node();
        helpList.headNode = firstHelpNode;
    }
    
    public void push(int x) {
        //数据链表：
        Node newNode = new Node();
        newNode.value = x;
        //连接到下一个节点
        //先让新的节点连接上后面的链表,是null也无妨，刚刚好
        newNode.next = this.stackList.headNode.next;
        //头结点连上新节点
        this.stackList.headNode.next = newNode;     

        //辅助链表:
        //如果新插入的节点值，比当前辅助链表最上面的值（最小值）还小就插入
        Node copyNode = new Node();
        copyNode.value = x;
        if(this.helpList.headNode.next != null && x >= this.helpList.headNode.next.value)
            //栈不为空,但插入的数不是最小值，重复插入最小值
            copyNode.value = this.helpList.headNode.next.value;
        //栈为空或当前值小于最小值，那么插入当前值
        copyNode.next = this.helpList.headNode.next;
        this.helpList.headNode.next = copyNode;      
    }
    
    public void pop() {
        //弹出数据链表元素
        this.stackList.headNode.next = this.stackList.headNode.next.next;
        //弹出辅助链表元素
        this.helpList.headNode.next = this.helpList.headNode.next.next;
    }
    
    public int top() {
        return this.stackList.headNode.next.value;
    }
    
    public int getMin() {
        return this.helpList.headNode.next.value;
    }
}
```

二刷：

```go
type MinStack struct {
    dataStack []int
    minStack []int          // 每次保存当前数据栈的最小值
}


func Constructor() MinStack {
    return MinStack{[]int{}, []int{}}
}


func (this *MinStack) Push(val int)  {
    // 更新数据栈
    this.dataStack = append(this.dataStack, val)
    // 更新辅助栈
    if len(this.minStack) == 0 {
        this.minStack = append(this.minStack, val)
    }else {
        // 取栈顶数字，其表示当前最小值
        top := this.minStack[len(this.minStack)-1]
        // 比较
        if val < top {
            this.minStack = append(this.minStack, val)
        }else {
            this.minStack = append(this.minStack, top)
        }
    }
}


func (this *MinStack) Pop()  {
    // 弹出数据栈
    this.dataStack = this.dataStack[:len(this.dataStack)-1]
    // 弹出最小栈
    this.minStack = this.minStack[:len(this.minStack)-1]
}


func (this *MinStack) Top() int {
    return this.dataStack[len(this.dataStack)-1]
}


func (this *MinStack) GetMin() int {
    return this.minStack[len(this.minStack)-1]
}


/**
 * Your MinStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(val);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.GetMin();
 */
```

