---
title: NC137.表达式求值
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2021-12-16 22:36:37
---

## 题目描述

https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4


<!-- more -->

## 解题思路及代码

经典的计算过程模拟题，注意提前计算的思路

```go
package main

import "strings"
// import "fmt"

/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 返回表达式的值
 * @param s string字符串 待计算的表达式
 * @return int整型
*/

// 用两个栈保存，一个栈保存数字，一个栈保存所有运算符
// 边放边先执行操作符，需要取栈运算符计算的情况：
// 1.新加入运算符时，判断栈顶运算符优先级是否大于等于此运算符，满足的话就先执行掉，将结果放到数字栈；直到遇到左括号或者栈空
// 2.此运算符为右括号，则取运算符计算直到遇到左括号
func solve( s string ) int {
    // 预处理: 去除掉所有空格
    s = strings.Replace(s, " ", "", -1)
    // 用两个栈保存，一个栈保存数字，一个栈保存所有运算符
    numStack, optStack := make([]int, 0), make([]byte, 0)
    // 防止一开始出现负数，在数字栈中先加入一个0名，这样一开始的负数就不用处理了
    numStack = append(numStack, 0)
    // 优先级表
    priority := make(map[byte]int)
    priority['*'] = 2
    priority['+'] = 1
    priority['-'] = 1
    // 扫描加入
    for i:=0; i<len(s); i++ {
        if isNumsOrOpts(s[i]) {
            // 数字
            // 加入数字栈
            j, num := toNumber(s, i)
            numStack = append(numStack, num)
            i = j-1
        }else {
            // 运算符
            // 判断是否需要计算
            if s[i] == ')' {
                // 右括号情况: 计算直到左括号(注意：这里在内部不会出现高优先级opt以及左右括号了，因为我们能先算的都先算掉了)
                for n:=len(optStack); n > 0 && optStack[n-1] != '('; {
                    numStack = Calculate(numStack, optStack[n-1])
                    optStack = optStack[:n-1]
                    n = len(optStack)
                }
                // 去掉左括号
                optStack = optStack[:len(optStack)-1]
            }else if s[i] == '('{
                // 左括号,直接加入
                optStack = append(optStack, s[i])
            }else {
                // 普通运算符情况: 满足条件就先执行
                for n:=len(optStack); n > 0 && optStack[n-1] != '(' && priority[s[i]] <= priority[optStack[n-1]]; {
                    numStack = Calculate(numStack, optStack[n-1])
                    optStack = optStack[:n-1]
                    n = len(optStack)
                }
                // 加入本次操作符
                optStack = append(optStack, s[i])
            }
        }
    }
    // 处理剩下的运算符
    for n:=len(optStack); n > 0; {
        numStack = Calculate(numStack, optStack[n-1])
        optStack = optStack[:n-1]
        n = len(optStack)
    }
    // 返回栈顶元素
    return numStack[len(numStack)-1]
}

// 判断是否是数字还是运算符
func isNumsOrOpts(c byte) bool {
    if c >= '0' && c <= '9' {
        return true
    }
    return false
}

// 读取一串字符变为一个数字
// 返回（指针结束位置, 数字）
func toNumber(s string, start int) (int, int) {
    sum, i := 0, start
    for i < len(s) && isNumsOrOpts(s[i]) {
        num := s[i] - '0'
        if i > start {
            sum *= 10
        }
        sum += int(num)
        i++
    }
    return i, sum
}

// 取两个值计算一次，并把结果放到数字栈上
func Calculate(numStack []int, opt byte) []int {
    n := len(numStack)
    if n < 2 {
        return numStack
    }
    // 出栈
    n1, n2 := numStack[n-1], numStack[n-2]
    numStack = numStack[:n-2]
    // 计算
    res := 0
    switch opt {
    case '+' : res = n1 + n2
    case '-' : res = n2 - n1
    case '*' : res = n1 * n2
    }
    numStack = append(numStack, res)
    return numStack
}
```

