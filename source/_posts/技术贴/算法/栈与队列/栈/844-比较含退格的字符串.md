---
title: 844.比较含退格的字符串
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-03-18 14:12:06
---

## 题目描述

[844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)

难度简单

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

 <!-- more -->

**示例 1：**

```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

**示例 2：**

```
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

**示例 3：**

```
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```

 

**提示：**

- `1 <= s.length, t.length <= 200`
- `s` 和 `t` 只含有小写字母以及字符 `'#'`

 

**进阶：**

- 你可以用 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？

## 解题思路及代码

思路一：栈

```go
// 栈
func backspaceCompare(s string, t string) bool {
    stack1 := readToStack([]byte{}, s)
    stack2 := readToStack([]byte{}, t)
    if len(stack1) != len(stack2) {
        return false
    }
    for i:=0; i<len(stack1); i++ {
        if stack1[i] != stack2[i] {
            return false
        }
    }
    return true
}

func readToStack(stack []byte, s string) []byte {
    for i:=0; i<len(s); i++ {
        if s[i] == '#' {
            if len(stack) > 0 {
                // 出栈
                stack = stack[:len(stack)-1]
            }
        }else {
            stack = append(stack, s[i])
        }
    }
    return stack
}
```

思路二：双指针， 时间/空间复杂度都为$O(1)$

```go
// 从后往前双指针
func backspaceCompare(s string, t string) bool {
    n, m := len(s), len(t)
    p1, p2 := n-1, m-1
    count1, count2 := 0, 0   // 统计需要跳过字符的个数
    for p1 >= 0 || p2 >= 0 {
        // 处理s
        for p1 >= 0 {
            // 判断字符类型
            if s[p1] == '#' {
                count1 ++
                p1 --
            }else {
                // 判断此字母是否需要跳过
                if count1 > 0 {
                    p1 --
                    count1 --
                }else {
                    break
                }
            }
        }
        // 处理t
        for p2 >= 0 {
            if t[p2] == '#' {
                count2 ++
                p2 --
            }else {
                if count2 > 0 {
                    p2 --
                    count2 --
                }else {
                    break
                }
            }
        }
        // 比较字符
        if p1 >= 0 && p2 >= 0 {
            if s[p1] != t[p2] {
                return false
            }
        }else {
            // 已经有一个为-1，但另一个还不是则一定为false
            if p1 >= 0 || p2 >= 0 {
                return false
            }
        }
        p1--; p2--
    }
    return true
}
```

