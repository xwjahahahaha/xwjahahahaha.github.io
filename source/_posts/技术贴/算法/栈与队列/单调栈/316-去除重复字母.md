---
title: 316.去除重复字母
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-04-11 23:44:42
---

## 题目描述

[316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

难度中等

给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

 <!-- more -->

**示例 1：**

```
输入：s = "bcabc"
输出："abc"
```

**示例 2：**

```
输入：s = "cbacdcbc"
输出："acdb"
```

**提示：**

- `1 <= s.length <= 104`
- `s` 由小写英文字母组成

**注意：**该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同

## 解题思路及代码

```go
// 单调栈
// 如果一个字符在整个字符串只出现一次则直接入栈，因为此时必须存在无需考虑字典序
// 如果一个字符在当前栈中已经出现，那么不入栈：因为“已出现”则说明其一定满足了单调栈的字典序的单调递增,如果将之前出现的删除再在最后加入新的对于整体的字典序不会提升
// 对于每一个入栈的字符，考虑与当前栈顶元素是否满足字典顺序：
// 1. 如果不满足且当前栈顶元素后面还会出现，则出栈栈顶元素，保证字典序最小
// 2. 如果满足则直接入栈
func removeDuplicateLetters(s string) string { 
    n := len(s)
    stack, countMap, hasMap := []byte{}, [26]int{}, [26]bool{}
    // 记录每个字符出现的次数，用于判断后续是否还有该字符
    for i:=0; i<n; i++ {
        countMap[int(s[i]-'a')]++
    }
    // 遍历字符串
    for i:=0; i<n; i++ {
        // 栈为空或当前栈无此字符
        if !hasMap[int(s[i]-'a')] {
            // 判断当前栈状态是否可以出栈
            for len(stack) > 0 {
                top := stack[len(stack)-1]
                topIdx := int(top-'a')
                if s[i] < top && countMap[topIdx] > 0 {
                    stack = stack[:len(stack)-1]
                    hasMap[topIdx] = false
                }else {
                    break
                }
            }
            // 入栈
            stack = append(stack, s[i])
            // 记录已存在
            hasMap[int(s[i]-'a')] = true
        } 
        // 减少该字符次数，不管是否入栈
        countMap[int(s[i]-'a')]--
    }
    return string(stack)
}
```

