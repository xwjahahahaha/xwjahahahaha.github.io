---
title: 84.柱状图中最大的矩形
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-20 23:34:48
---

## 题目描述

[84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

难度困难1705

<!-- more -->

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 

**示例 1:**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/histogram.jpg)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

**示例 2：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/histogram-1.jpg)

```
输入： heights = [2,4]
输出： 4
```

 

**提示：**

- `1 <= heights.length <=105`
- `0 <= heights[i] <= 104`

通过次数205,712

提交次数472,448

## 解题思路及代码

```go
// 暴力（会超时）
// 面积 = 底*高, 枚举每个柱子的高度向两边扩散，找最大
// func largestRectangleArea(heights []int) int {
//     maxArea := 0
//     for i, h := range heights {
//         l, r := i, i
//         // 扩散左边
//         for l>=1 && heights[l-1] >= h { l-- }       // 注意这里用l-1判断
//         // 扩散右边
//         for r<len(heights)-1 && heights[r+1] >= h { r++ }
//         thisArea := (r-l+1) * h
//         if thisArea > maxArea {
//             maxArea = thisArea
//         }
//     }
//     return maxArea
// }

// 单调递增栈
// 一个柱子可以计算其面积的情况：左右两侧找到比自己高度小的
// 维护一个单调递增栈，两头卡，遇到比自己小的出栈时就可以确定这个位置的面积
func largestRectangleArea(heights []int) int {
    if len(heights) == 0 {
        return 0
    }
    stack, maxArea := make([]int, 0), 0      // 单调栈存下标
    stack = append(stack, 0)                // 加入第一个柱子下标
    for i:=0; i<len(heights); i++ {
        // 不断出栈判断，直到不满足
        for len(stack) > 0 && heights[i] < heights[stack[len(stack)-1]] {
            stackTop := stack[len(stack)-1]
            // 如果小于栈顶，那么栈顶元素最大高度就可以确定了
            stack = stack[:len(stack)-1]    // 出栈
            // 计算最大面积，高度就是栈顶高度，宽度是: 右边届-左边届-1
            left, right := 0, i
            if len(stack) == 0 {
                left = -1                       // 如果栈空就是-1
            }else {
                left = stack[len(stack)-1]      // 左边届就是当前栈顶
            }
            nowMaxArea := heights[stackTop] * (right-left-1)
            if nowMaxArea > maxArea {
                maxArea = nowMaxArea
            }
        }
        // 如果当前位置i的高度不小于栈顶，加入位置i的数，保持递增
        stack = append(stack, i)
    }
    // 处理最后栈的剩余
    for len(stack) > 0 {
        stackTop := stack[len(stack)-1]
        stack = stack[:len(stack)-1]    
        left, right := 0, len(heights)
        if len(stack) == 0 {
            left = -1
        }else {
            left = stack[len(stack)-1]
        }
        nowMaxArea := heights[stackTop] * (right-left-1)
        if nowMaxArea > maxArea {
            maxArea = nowMaxArea
        }
    }
    return maxArea
}
```

