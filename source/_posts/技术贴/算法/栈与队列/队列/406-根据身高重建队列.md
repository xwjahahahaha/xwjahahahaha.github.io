---
title: 406-根据身高重建队列
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2020-11-17 18:35:46
---

## 题目描述

#### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

难度中等

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对 `(h, k)` 表示，其中 `h` 是这个人的身高，`k` 是应该排在这个人前面且身高大于或等于 `h` 的人数。 例如：[5,2] 表示前面应该有 2 个身高大于等于 5 的人，而 [5,0] 表示前面不应该存在身高大于等于 5 的人。

编写一个算法，根据每个人的身高 `h` 重建这个队列，使之满足每个整数对 `(h, k)` 中对人数 `k` 的要求。

**示例：**

```
输入：[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
输出：[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

<!-- more -->

## 解题思路及代码

```go
//第一种方法：低到高排序
//对于每个人的数据[hi, ki], hi代表身高,ki代表前面比当前人身高高或等于的人的数量
//1. 先排序按由低到高插入
//2. 如果我们按照排完序后的顺序，依次将每个人放入队列中，那么当我们放入第 i 个人时：每个插入的人前面必须要有k个位置，所以该人就应该插在第k+1的位置处
//3. 如果两个人的身高相同，那么就看其k值，k值大的肯定就相对于k值小的排在后面
//排序规则：第一要素：身高升序 第二要素：同身高下的k升序
//时间复杂度O(N*N)  空间复杂度O(N)
func reconstructQueue(people [][]int) [][]int {
    //按两个要素排序
    sort.Slice(people, func (i, j int) bool {
        a, b := people[i], people[j]
        return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1])
    })
    //分别插入
    ans := make([][]int, len(people))
    for i:=0; i<len(people); i++ {      //循环按排序顺序插入
        k := people[i][1] + 1  //需要在k个空位出插入
        //找空位插入
        for j, v := range ans{
            if v == nil{
                k--
                if k==0 {
                    ans[j] = people[i]
                    break
                }
            }
        }                                                                                                                                           
    }
    return ans
}
```

```go
////第二种方法:从高到低的方法
//先排序从高到低排序，规则和前面类似：按第一h降序，第二h相同时k升序
//插入第i个时，前i-1个都是比自己高的，后面的n-i个都是对i的k无影响的，所以要根据k插入在从0数第k+1个位置.
func reconstructQueue(people [][]int) (ans [][]int) {
    //排序
    sort.Slice(people, func (i, j int) bool {
        a, b:= people[i], people[j]
        return a[0] > b[0] || (a[0] == b[0] && a[1] < b[1])
    })

    //插入
    for _, v := range people{
        idx := v[1]
        ans = append(ans[:idx], append([][]int{v}, ans[idx:]...)...)
    }
    return ans
}
```

