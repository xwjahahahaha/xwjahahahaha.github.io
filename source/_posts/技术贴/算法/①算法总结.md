---
title: 算法总结
tags:
  - python
  - java
  - golang
categories:
  - technical
toc: true
date: 2020-07-03 16:16:25
---

这里将记录个人刷题时的总结与注意事项

<!-- more -->

# 零、预处理

在使用具体的算法之前，使用预处理可以解决一些问题，从而带来给问题化简

## 1. 数组排序

数组排序可以实现结果的去重复

## 2. 输入特殊值直接消除

通常在函数的最开始将绝对会产生固定结果的特殊输入返回结果值或直接终止。

# 一、位运算

## 1.1 技巧记录

1. x & (x-1) 可以去除掉x二进制下的的最后一位1  => [布赖恩·克尼根算法](https://myblog.gumptlu.work/2020/07/03/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/)
2. x & 1 然后再 x >>= 1 可以每次取到x的最后一位，然后右移。

## 1.2 翻转一个数x的二进制位
1. 取最后一位（x & 1），然后移位，最后添加到前面。

# 二、数组

## 2.1 概念简介

**数组是存放在连续内存空间的相同数据类型的集合**，所以**易查询不易增删**（空间连续需要移动元素）

二维数组在空间中**不是连续的**，它是由多条连续的一维数组空间以及一个一维数组存放各个首地址。

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/3c7dkX.jpg" alt="3c7dkX" style="zoom: 33%;" />

## 2.2 数组使用技巧

1. **实现简单的hash表:** 利用数组连续内存空间的特点即查询快时间复杂度O(1)
2. **覆盖考虑尾部开始:** 对于需要移动数据覆盖数组内容的操作,例如:合并数组. 从前往后移动不是好的选择, 因为要这样的移动次数较大. 从后往前覆盖移动能够减少移动的次数
   *  [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)
3. **双指针法：**数组的合并也可考虑类似链表双指针的方法，一一比较，如果数组够长那么可以从尾部开始合并
   * [27.移除元素](/Users/xwj/blog/source/_posts/技术贴/算法/数组/27-移除元素.md)

# 三、链表

## 1. 基本概念

链表: 内存非连续, **易增删易改变顺序但是难遍历/查询**

## 2. 技巧总结

1. 链表按顺序插入是有序的，可以作为时间顺序记录

2. 链表主要考察**指针的处理**！改变Next指针要注意不能导致链表断开（先用另一个指针指向后面的节点）

3. 预防空指针Next

   链表题目中注意判断时要防止出现空指针: `nil.Next`, 所以可以添加`tail.Next != nil`预防

4. 链表原地分离: [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

5. **快慢双指针法**：链表中常用快慢指针做题，==快慢指针之间的**固定间距**往往可以解决问题==

   * [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)
   * [剑指 Offer II 022. 链表中环的入口节点](https://leetcode-cn.com/problems/c32eOV/)

6. **哑节点：**链表的合并不要考虑像数组那样需要创建多余的空间，通过改变指针即可。一般的做法就是创建一个**哑节点**，使用俩个指针分别指向两个链表，然后选择一个优先级高的节点连接在哑节点之后，再移动指针串联。

   * [合并两个排序的链表](/Users/xwj/blog/source/_posts/技术贴/算法/链表/剑指Offer25-合并两个排序的链表.md)

7. **创建虚拟头节点：**方便对链表头节点等相关的操作！

   * [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)
   * [707.设计链表](/Users/xwj/blog/source/_posts/技术贴/算法/链表/707-设计链表.md)

8. 防断裂先保存指针：当需要改变Next指针的时候，防止下一个节点丢失通常会采用临时变量去保存其指针

   * [反转链表](/Users/xwj/blog/source/_posts/技术贴/算法/链表/剑指Offer24-反转链表.md)

## 3. 链表设计

链表数据结构设计难度符合面试的时间, 并且结构灵活,很有可能成为面试题

## 4. Hash表+双向链表（优化查询）

链表的遍历是非常慢的，但是其插入、改变顺序、删除非常快速。可以使用Hash表+双向链表的方式实现链表的O(1)快速查询

思路：

* 使用Hash表存储值与链表节点地址，实现随机查询
* 使用双向链表快速插入、删除，链表节点保存

![iy3a7q](http://xwjpics.gumptlu.work/qinniu_uPic/iy3a7q.png)

例题：[LRU缓存机制](/Users/xwj/blog/source/_posts/技术贴/算法/设计类/146-LRU缓存机制.md)

# 四、字符串

## 1 翻转字符串中的字符

手写实现的两种思路：

1. **较短或确定长度的字符串**：循环字符串的0 ~ len/2个字符,交换字符str[i]与str[len-1-i]
2. **较长的字符串**: 分段，每个小段翻转，整体交换实现翻转。(分治)

## 2 子串与滑动窗口

**涉及==子串并且滑动时状态/特性能够保留、或者数组子序列（连续性）问题==  => 考虑滑动窗口**

**滑动窗口:左少右多,中间满足,不断移动**

设计考量：

* 窗口内要维持什么？
* 左指针何时移动？ **当窗口内维持的条件已经要不满足的时候，舍弃掉之前的**
* 右指针何时移动？ **当窗口内维持的条件仍然还满足的时候，继续右移，扩大窗口**

[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

[904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)

## 3 重复/次数/统计

**题目看到重复/统计/次数 => 散列表 key为字母,value为次数** 

# 五、栈、队列

## 1. 基本特点

* 栈：先进后出
* 队列：先进先出

## 2. 技巧总结

1. 辅助记录栈

   希望快速得到当前的数据栈数据的某个特点（例如最大、最小等），但是因为栈本身的结构限制无法实现。这时就使用与当前数据栈同步的辅助记录栈记录，可以实现状态的回滚。

   [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

2. **逆序**一定先想到栈

   [剑指 Offer II 025. 链表中的两数相加](https://leetcode-cn.com/problems/lMSNwu/)

# 六、树

## 1 遍历

二叉树的遍历:

递归简单,但是迭代较困难

* 递归	<font color='green'> **(隐形的制造一个栈)**   </font>
* 迭代	<font color='green'> **(人为的制造栈)**   </font>

### 中序

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

记忆点:

* 搜索二叉树的中序遍历是升序序列

### 前序

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

### 后序

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

### 层序

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

层序遍历递归模版:

```go
func solution(root *Node) {
		if root == nil {
        return nil
    }
    queue := []*Node{}
    divisionNode := &Node{}											//创建分隔符节点
    queue = append(queue, root, divisionNode)		//root和分隔符先进队
    for len(queue) > 0 {
      	// 节点出队
        node := queue[0]
        queue = queue[1:len(queue)]
        if node == divisionNode {
            // 层结束
          	// 对于每层最后的操作:
          	
          	// do soemthing ......
          
          	// 每层结束插入结束符
            if len(queue) > 0 {
                queue = append(queue, divisionNode)
            }
        } else {
            // 层未结束
          	// 对于该层的每一个节点: 
          
            // do someting ...... 
          
            // 左右孩子入队
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
  	// 返回题目具体需求 
    return 
}
```

### 基于遍历的题

遍历不仅仅简单的遍历,而是**==可以作为其他题要求的基础或者拓展应用==**:

* 升序/降序序列: 得到二叉树元素的遍历序列,搜索二叉树的中序遍历=>升序

例:

[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

[230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

## 2 细节/注意点

1. 一般情况下处理左右孩子节点时,要先判断孩子节点是否不会空,否则会空指针异常,但是也有**特殊情况**,<font color='#e54d42'>例如二叉树遍历的迭代实现中需要让root为空</font>

   ```go
   if node.Left != nil {
     queue = append(queue, node.Left)
   }
   if node.Right != nil {
     queue = append(queue, node.Right)
   }  
   ```

2. 可以构建指向父节点的关系映射以此来使用在一些需要从叶子向根节点的遍历

   [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

# 七、堆、优先队列

## 1. 堆

### 概念

可用数组表示的完全二叉树。

1. 已知父节点数组索引i

   父节点是i, 则左子节点为2i，右子节点为2i+1

   > 通常数据的0索引位置创建但不使用，根节点从index1开始，否则上述规律无意义

2. 已知子节点数组索引为i

   则其父节点索引为i/2，其当前层为i/2 (除2也可以用效率更高的位运算)

* 大顶堆：父节点的值比其**所有**子节点都大

* 小顶堆：父节点的值比其**所有**子节点都小

> <font color='#e54d42'>这里的“值”可以代表为任意属性优先值，进而得到**优先队列（也就是堆）：特殊的队列，取出元素的顺序按照元素的优先权而不是先后顺序**</font>

堆的根节点一定是最大/小值，但是节点的顺序未知

堆的原始操作，时间复杂度都为`nlogk`，`k`为按优先级分类的规模（例如按数组中元素出现次数划分，共有k个规模）

* **上浮** shift up: 向堆尾新加入一个元素，堆规模 +1，依次向上与父节点比较，如小于父节点就交换。
* **下沉** shift down: 从堆顶取出一个元素（堆规模 -1，用于堆排序）或者更新堆中一个元素（本题），依次向下与子节点比较，如大于子节点就交换。

堆的具体实现可见[堆的实现](/Users/xwj/blog/source/_posts/技术贴/算法/堆优先队列/堆的实现.md)

### 技巧

模式识别:  <font color='#e54d42'>维护**动态数据(可能有持续新输入)**的最大、小值  => 堆</font>

堆的作用:

- 构建优先队列

- 支持堆排序

- 快速找出一个集合中的最小值（或者最大值）=> topK问题

  最大堆求topk小，最小堆求 topk 大。

  - topk小：构建一个 k 个数的最大堆，当读取的数小于根节点时，替换根节点，重新塑造最大堆
  
  - topk大：构建一个 k 个数的最小堆，当读取的数大于根节点时，替换根节点，重新塑造最小堆
  
    > <font color='#39b54a'>替换的原因：例如在topk小问题中，如果新输入小于根节点，因为要找出topk小的k个元素，那么最大堆的根节点是最大的元素就被剔除出去了，剩下的重新塑造。不断这样剔除最后剩下topk小的元素</font>

* 堆的最大优势：**求TopK问题的优化**，将一个问题由可能的最优复杂度$nlogn$降低到$nlogk$, 其中$k$是按优先级分类的规模。

  例如题目347前k个频率最高的元素问题，原本计数->排序，排序的最好算法复杂度`nlogn`，但是对于计数数组使用堆可以做到复杂度$nlogk$

* 堆的使用（大小控制）：当大于k的时候先添加到k+1个再删除一个（注意顺序很重要）

  ```go
  maxHeap := MaxHeap([]int{-1})    // 创建一个大顶堆
  for i:=0; i<len(input); i++ {
    maxHeap.shiftUp(input[i])
    if i >= k{
      // 超过k个先删除再添加
      maxHeap.shiftDown()
    }
  }
  ...
  ```


Topk大问题:[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)、[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

## 2. 优先队列

**使用场景：复杂数据结构的排序**

[973. 最接近原点的 K 个点](https://leetcode-cn.com/problems/k-closest-points-to-origin/)

在优先队列中，**元素被赋予优先级**。当访问元素时，**具有最高优先级的元素最先删除。**优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用**堆**数据结构来实现。

# 八、方法

## 1 递归与迭代

### 优劣

|        | 递归         | 迭代             |
| ------ | ------------ | ---------------- |
| 优势   | 代码编写简洁,好写 | 一般相比递归效率 |
| 劣势   | 1.注意防止栈溢出, 栈调用效率损失  2.子问题避免重复计算 | 编写较困难,可能需要手动建数据结构(栈、队列) |

相同点 : 分解大问题,处理子问题

### 递归

1. **分治法递归提前分析好参数变量(画图)** （递归函数的参数一般为数组的下标）

   例:

   [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

   ![zkfP9T](http://xwjpics.gumptlu.work/qinniu_uPic/zkfP9T.png)

2. 注意递归退出情况/临界情况

3. 逻辑产生分支即多种情况可以使用多个递归并用逻辑表达式连接的结构编写代码

   例子：[剑指 Offer 19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

### 迭代

1. 分析要使用的数据结构实现迭代

## 2 DFS与BFS

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

### 2.1 DFS

DFS深度优先用<font color='orange'>栈</font>，注意栈溢出

* 递归,隐性的维护该栈
* 迭代,显性的维护该栈

### 2.2 BFS

BFS广度优先用<font color='orange'>队列</font>。

## 3 快速选择

### 特点

模式识别: <font color='#e54d42'>**确定数据量**的情况下寻找第K大的数 => 快速选择算法</font>

**动态数据流(持续有新输入)** => 选择堆排序算法

快速排序中轴值(pivot)计算的方法

### 原理:

1.  <font color='#e54d42'>**快速排序划分Partition过程中, 能够确定的轴值其位置就一定在最终排序位置中确定了**</font>(因为不管划分左边部分还是右边部分是否有顺序,其数量已定则轴值位置就确定了)

2. **如果某次划分的轴值为目标第k个时**,那么此轴值就是题要求的第k大/小元素(大小看排序顺序),其他部分的顺序就不用管

### 优化:

快速排序的性能和「划分」出的子数组的长度密切相关,如果每次轴值的选择造成的划分都是1和n-1,那么这种情况最坏为O($N^2$), 通过**随机化**可以加速整个过程.

随机化简单来说就是在partition之前(其默认选择最左或者最右), 将数列中随机一个元素与最左/右调换

### 例题

[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

## 4 回溯

> 一种通过探索所有可能的候选解来找出所有的解的算法。如果**候选解被确认不是一个解（或者至少不是最后一个解）**，回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。

回溯法一般是多个步骤组成, 每个步骤有多种选择

**回溯借助于栈进行递归, 是树型DFS的典型使用方法**

每一个步骤的多个选项就对应每一层树的多个分支

回溯法的思想也是要找子问题, 结合子问题解决原问题:

* 字符串, 找子字符串
* 树, 子树

<font color='#39b54a'>**搜索问题**主要使用回溯法。</font>例如:

* 求组合:

  * 全部组合

    [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

  * 部分组合 : 在全部组合的基础上按要求剪枝

    [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

经典问题的思考：

![wKBIiJ](http://xwjpics.gumptlu.work/qinniu_uPic/wKBIiJ.png)

回溯法思考的步骤：

1. 画递归树；
2. 根据自己画的递归树编码。
3. **注意剪枝**
   * 子问题一致性: 子问题为false则其所有父问题一定为false
4. **递归树从底向上的路径就是答案**

---

一般模版:

```go
// 子集一般对应递归树path
回溯(子集, 全集):
    if 满足条件/结束条件:  	// 下一步做什么,所以会当成结束条件
        加入答案
    for 元素 in 全集:			 // 这一步要做什么, 再过度到下一步
        元素加入子集
        回溯(子集, 全集)		// 回溯到上一步需要改回什么
        回退操作/元素退出子集
```

---

注意事项:

* 回退操作一定要深度遍历到最后再进行,即一般放在代码最后,最直接的方法使用defer:

  ​			`defer func() { 回退的步骤 }() // 回溯操作`

* 递归函数的参数要选择好,<font color='#e54d42'>**使用回溯处理子问题时,递归函数的参数要做到对子问题的缩减**</font>

## 5 动态规划

### 1. 特点/判断使用

动态规划的特点：

1. 求问题的最优解

2. **最优解依赖子问题的最优解**

3. 子问题之间可能会有相互重复的部分

   > 从下往上求解，先计算小问题存储下来，可以避免重复的部分

4. <font color='#e54d42'>从上往下分析问题，从下往上求解问题</font>

### 2. 设计思路

1. 明确`dp[i]/dp[i][j]`动态规划方程表示什么含义（不一定就是题目要求的含义，可以是通过此含义再通过简单的计算可得到题目需要的含义）（dp[i]的考虑要考虑状态的转移规律）
2. 明确状态转移方程是什么
3. 明确边界位置的dp值是什么？或者说初始化哪些dp数据
4. 明确填表的顺序是什么？（从下往上填表？从左到右？从小到大？）(确定依据：状态转移的方向)
5. 明确最后的结果怎么计算？(例如$max(dp[i]), i\in[0, n)$还是$dp[n-1]$)

### 3. 重要总结

- 动态规划的核心思想是:**每次都尽可能的利用上次的结果为本次计算提供服务**

  *==借助上一步(或者是对上所有步进行筛选最优的一步)的成果完成下一步==*,很重要的思想!<font color='#e54d42'>(不仅仅在动态规划中)</font>

- 所以对应的就需要构造状态转移方程,来将本次的结果进行拆分**[已知答案的子问题] && [其他易求解的问题]**

- 本质上也是**使用空间来换取时间**的典型案例(使用空间记录子问题答案,然后不断推向父问题以至于最后得出答案) **==由下往上==**

- 动态规划要注意**边界条件的设定初始值**,这样才能保证推导的正确性

- 如果递推式从小到大的过程中**可能性是唯**一的,那么就可以从小情况开始遍历,出现反例则开始剪枝

- **做动态规划看不出递推式可以先写两个解找规律(例如斐波那契数列)**

示例: [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

根据子问题最优结果最为此问题的求解基础: [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)、[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

[剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/) [NC19 连续子数组的最大和](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=188&&tqId=38594&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

## 6 贪婪算法

每次都选择当前最好/优的选项

## 7 二分法

### 1. 区间缩放前提

前提：有序数组(或**部分有序**)，且数组中无重复元素（如果有的话结果可能不唯一）

题目中数组是有序的 => 二分法

二分法的边界处理问题要抓住**循环不变量** => 区间的定义（前闭后闭还是前闭后开）

[35-搜索插入位置](https://myblog.gumptlu.work/2021/02/16/技术贴/算法/数组/35-搜索插入位置/)

<font color='#e54d42'>**核心: 每次都能够依据条件(有序)删除掉一半的区间**</font>

一般前提: **有序**, 但是也有虽然无序但可按特殊性质进行区间缩放,例如峰值问题:

[162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

例如部分有序问题: [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

### 2. 边界问题：开/闭区间

[二分法边界问题](/Users/xwj/blog/source/_posts/技术贴/算法/排序和搜索/二分搜索/二分法边界问题.md)

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

### 3. mid上下取整

mid = (l + r) >> 1 **默认一般是下取整**,但是当条件函数中有left = mid时, 可能上取整会造成死循环(因为nums[left] = target), 如果是right = mid 则不会影响

所以此时解决方法就是将取中值改为: mid = (l+r+1) >> 1<font color='#e54d42'>**多添加一个1,使其成为上取整**</font>

上下取整对于mid来说都是一样的

例: [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

### 4. 取中值溢出

解决: 

1. mid = left + (right - left)/2  (但是当right很大而left很小甚至为负时仍然可能会溢出)
2. 位运算 : mid = (left + right) >> 2   
3. 转换为long型

### 5. 结束时left在哪

前提：在for循环中判断了是否为target，如果是那么就直接返回，如果前提满足则在数组中第一个**大于**target的数

* 如果在循环中考虑等于目标值就直接结束（不退出循环了）返回结果，那么**退出循环发生时一定是在数组中找不到这个数**，此时left指向的是刚好大于target的位置

  ```go
  func search(nums []int, target int) int {
      l, r := 0, len(nums)
      for l < r {
          mid := l + (r-l)/2
          if nums[mid] < target {
              l = mid+1
          }else if nums[mid] > target {
              r = mid 
          }else {
              return mid				// 找到直接返回，不退出循环
          }
      }
      return -1
  }
  ```

* 如果在循环中等于目标值也不退出，那么最终退出循环时**left的位置一定是刚好不大于(<=)target的数**

### 6. 二分法有重复数字处理（结果不唯一）

就是通过即使找到了目标值也直接返回，而是等到循环结束后left指向第一个不大于目标值的位置来实现找到第一个重复的目标值位置

```go
package main

/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 如果目标值存在返回下标，否则返回 -1
 * @param nums int整型一维数组 
 * @param target int整型 
 * @return int整型
*/
// 改变一般二分法的思路，结束时找出的是刚好小于等于目标值的数
func search( nums []int ,  target int ) int {
    l, r := 0, len(nums)-1
    for l <= r {
        mid := l + (r-l)>>1
        if nums[mid] < target {
            l = mid+1
        }else {
            r = mid-1
        }
    }
    // 结束时l在刚好不大于target的位置
    if l < len(nums) {        // 判断保证target存在，如果不满足则说明target一定不存在
        if nums[l] == target {    // 可能就是target
            return l
        }
        // 或者刚好比target小的数, 那么其下一个数一定就是target第一个位置的数
        if l < len(nums)-1 && nums[l+1] == target {
            return l+1
        }
    }
    return -1
}
```







## 8 排序算法

见： [排序算法总结](/Users/xwj/blog/source/_posts/技术贴/算法/排序和搜索/排序算法总结.md)

快排的**拓展变体：**

* 快速选择（见上方）

* 双指针结构拓展

  借助快速排序中获取中点函数中的双指针思路，设计题目变体，例如：

  #### [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

  通用解法：

  ```go
  func resolution(nums []int) []int {
      if len(nums) == 0 {
          return nums
      }
      l, r := 0, len(nums)-1
      for l < r {
        	for l < r && Func(nums[r])) {
              r--
          }
           nums[l] = nums[r]
        	for l < r && !Func(nums[l])) {
              l++
          } 
          nums[r] = nums[l]
      }
      nums[l], nums[r] = nums[r], nums[l]
      return nums
  }
  
  func Func(){
    // TODO 判断算法
  }
  ```

# 九、复杂度优化策略

## 1 基本策略

1. 遍历时前后处理结果相同，只需要遍历一半, [0, n] 变为 [0, n/2]

2. 空间换时间： 记录重复计算的值

## 2 数值整数次方优化

=> *指数二分，复杂$log^n$*
$$
a^n = \begin{cases}a^{n/2} * a^{n/2} & n为偶数 \\ a^{(n-1)/2} * a^{(n-1)/2} * a & n为奇数 \end{cases}
$$


例题：[剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)



# 十、计算防溢出处理 

## 1 循环求余法

指数函数、幂函数计算时，防止计算溢出的方法：循环求余法

```go
// 求 (x^a) % p —— 循环求余法。固定搭配建议背诵
public long  remainder(int x,int a,int p){  //x为底数，a为幂，p为要取的模
  long rem = 1 ;
  for (int i = 0; i < a; i++) {
    rem = (rem * x) % p ;   
  }
  return rem;
}
```

例题：[剑指 Offer 14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

## 2 字符数组表示大数

字符数组大数的+1怎样实现：[剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

# 十一、处理一些极端样例技巧

* **for循环顺序：** 要按照(特别是不用三段式的for循环的时候)： 初始化 -> 判断条件 -> 操作（注意不要改变判断条件的值） -> ++或– -> 判断。 这样写才不会出现++或者–随后就操作导致数组溢出等问题。



# java/Go数据结构重要api

## java

### 1. 复制数组

System包下:

```java
public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)
```

从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的源数组到 dest 引用的目标数组，数组组件的一个子序列被复制下来。被复制的组件的编号等于 length 参数。源数组中位置在 srcPos 到 srcPos+length-1 之间的组件被分别复制到目标数组中的 destPos 到 destPos+length-1 位置。 

![](http://xwjpics.gumptlu.work/qiniu_picGo/20210202124259.png)

<font color='green'>**使用：**</font>

`System.arraycopy(原数组, 原数组复制开始下标, 目的数组, 目的数组开始下表, 复制总长度);`

### 2. 字符串处理 

StringBuffer实例：

```java
public StringBuffer reverse()
//将此字符序列用其反转形式取代。返回其翻转后的结果
```

频繁的动态添加字符应当考虑StringBuffer

SringBuffer类和String一样，也用来代表字符串，相比String, StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。当遇到插入、删除等字符串操作时，可以考虑用StringBuffer

----

单字符处理：

* 判断是否为数字与字母

  ```java
  public static boolean isDigit(char ch)
  ```

  ```java
  public static boolean isLetter(char ch)
  ```

  ```java
  public static boolean isLetterOrDigit(char ch)
  ```

* 大小写转换

  ```java
  public static char toLowerCase(char ch)		//转换为小写
  ```

  ```java
  public static char toUpperCase(char ch)		//转换为大写
  ```

## Go

### 1.栈、队列

Go中可以采用**切片**来处理需要类似栈\队列的数据结构：

栈：

* 入栈slice =  append（slice, item）
* 出栈v := slice[len(slice)-1] , slice = slice[ : len(slice)-1]

队列：

* 入队slice = append(slice, item)
* 出队 item = slice[0]; slice = slice[1:]

### 2.go数组排序api

```go
// Slice sorts the provided slice given the provided less function.
//
// The sort is not guaranteed to be stable. For a stable sort, use
// SliceStable.
//
// The function panics if the provided interface is not a slice.
func Slice(slice interface{}, less func(i, j int) bool) 
```

字符串排序示例:

```go
// v是字符串,需要先转换为字节数组
s := []byte(v)
sort.Slice(s, func(i, j int) bool { return s[i] < s[j] })
v = string(s)
```

数组切片排序:

```go
nums := int{}
sort.Slice(nums, func(i, j int) bool {return nums[i]<nums[j]})
```

### 3.最大最小值

#### 无符号整型uint

其最小值是0，其二进制表示的所有位都为0，`const UINT_MIN uint = 0`

其最大值的二进制表示的所有位都为1，那么，

`const UINT_MAX = ^uint(0)`

#### 有符号整型int

根据补码，其最大值二进制表示，首位0，其余1，那么，

`const INT_MAX = int(^uint(0) >> 1)`

根据补码，其最小值二进制表示，首位1，其余0，那么，

`const INT_MIN = ^INT_MAX`

### 4.浮点数比较相等

不可以直接使用等号比较两个浮点数的大小，而是只能在一定的范围内比较

```go
const MIN = 0.000001
// MIN 为用户自定义的比较精度
func IsEqual(f1, f2 float64) bool {
    if f1>f2{
        return math.Dim(f1, f2) < MIN
    }else{
        return math.Dim(f2, f1) < MIN
    }
}
```

### 5.复制一个slice(新的空间)

`append([]int(nil), *path...)`



