---
title: 逆序数
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-03-01 23:26:49
---

## 题目描述

### 逆序数
https://www.nowcoder.com/questionTerminal/8fe007e54fc04b5e82089aaa71ba3553

作为程序员的小Q，他的数列和其他人的不太一样，他有2n2^n2n个数。老板问了小Q一共 m次，每次给出一个整数$qi(1<=i<=m)$ ,要求小Q把这些数每$2^{q_i}$分为一组，然后把每组进行翻转，小Q想知道每次操作后整个序列中的逆序对个数是多少呢？ 

例如: 

对于序列1 3 4 2，逆序对有(4, 2),(3, 2),总数量为2。 

翻转之后为2 4 3 1，逆序对有(2, 1),(4, 3), (4, 1), (3, 1),总数量为4。 

<!-- more -->

### 输入描述:

第一行一个数$n(0≤n≤20)$
第二行$2^n$个数，表示初始的序列($1≤初始序列≤10^9$)
第三行一个数$m(1 \leq m \leq 10^6)$
第四行m个数表示$q_i(0 \leq q_i \leq n)$

### 输出描述:

m行每行一个数表示答案。

### 示例1

输入

```
2
2 1 4 3
4
1 2 0 2
```

输出

```
0
6
6
0
```

说明

初始序列2 1 4 3
$2^{q_1} = 2$->
第一次：1 2 3 4 -> 逆序对数为0
$2^{q_2} = 4$ ->
第二次：4 3 2 1 -> 逆序对数为6
$2^{q_3} = 1$ ->
第三次：4 3 2 1 -> 逆序对数为6
$2^{q_4} = 4$ ->
第四次：1 2 3 4 -> 逆序对数为0

## 解题思路及代码

### 思路一：暴力

先翻转再用归并排序找出所有逆序对个数

时间复杂度$O(M*NlogN)$， 只能通过60%，因为每次翻转过后都需要重新计算一次逆序对

```go
package main

import (
	"fmt"
	"math"
)

func main() {
	// 读取输入
	var n, m int
	fmt.Scan(&n)
	nums := make([]int, int64(math.Pow(2.0, float64(n))))
	var num int
	for i := 0; i < len(nums); i++ {
		fmt.Scan(&num)
		nums[i] = num
	}
	fmt.Scan(&m)
	M := make([]int, m)
	for i := 0; i < m; i++ {
		fmt.Scan(&num)
		M[i] = num
	}

	for i := 0; i < len(M); i++ {
		// 先翻转对应组数字
		flip(nums, int(math.Pow(2.0, float64(M[i]))))
		// 求逆序对个数
		tmpNums := make([]int, len(nums))
		copy(tmpNums, nums)
		fmt.Println(countPair(tmpNums))
	}
}

// flip 翻转数组对应组
func flip(nums []int, m int) {
	if m == 1 {
		return
	}
	if m > len(nums) {
		m = len(nums)
	}
	for i := 0; i < len(nums); i += m { // i 开始位置
		// 翻转数组
		tmpNum := nums[i : i+m]
		for j := 0; j < m/2; j++ {
			tmpNum[j], tmpNum[m-1-j] = tmpNum[m-1-j], tmpNum[j]
		}
	}
}

func countPair(nums []int) int {
	// 归并排序
	var sortNum func(l, r int) int
	sortNum = func(l, r int) int {
		if l >= r {
			return 0
		}
		mid := (r-l)/2 + l
		count := sortNum(l, mid) + sortNum(mid+1, r)
		count += merge(nums, l, mid, r)
		return count
	}

	return sortNum(0, len(nums)-1)
}

func merge(nums []int, l, mid, r int) int {
	help, count, t := make([]int, r-l+1), 0, 0
	p1, p2 := l, mid+1
	for p1 <= mid && p2 <= r {
		// 统计逆序对个数
		if nums[p1] <= nums[p2] {
			count += p2 - mid - 1
			help[t] = nums[p1]
			p1++
			t++
		} else {
			help[t] = nums[p2]
			p2++
			t++
		}
	}
	// 剩余
	for p1 <= mid {
		help[t] = nums[p1]
		count += r - (mid + 1) + 1 // 这里也要加
		p1++
		t++
	}
	for p2 <= r {
		help[t] = nums[p2]
		p2++
		t++
	}
	// 拷贝
	for i := 0; i < len(help); i++ {
		nums[l+i] = help[i]
	}

	return count
}
```

### 思路二：状态记录

https://blog.csdn.net/qq_43517189/article/details/105313349

只通过了80%

* 分别记录当前数组不同分组下不同长度逆序对、顺序对的个数
* 求顺序对的个数的思路就是将整个数组翻转求逆序对，其结果就是顺序对个数
* 如果翻转的区间长度<=某个逆序对长度，则交换顺序对、逆序对个数（翻转导致的）
* 这样再累加不同长度的逆序对个数就是结果，不必每次都求一次逆序对个数

例如：

* 输入nums为`2 1 4 3`，其长度为$2^1$分组下的逆序对个数为2(`(2,1)和(4,3)`)，长度为$2^2$分组下逆序对个数为0，前面两个逆序对不能再重复计算了，所以总个数就是2+0=2个
* 其对应的顺序对数组、逆序对数组如下：(第一位$2^0$占空间无意义)
  * 顺序对A: `[0, 0, 4]  `
  * 逆序对B: `[0, 2, 0]`
* 当翻转q的个数序列依次为`1 2 0 2`时，就将对应的顺序对`A[q]`与`B[q]`交换，再累计B的和就是每一个翻转的答案

关键点/注意点/编码的坑：

* 归并排序求逆序对会对原数组排序，应该使用临时数组

* 归并排序内部不需要再累计子层（折半递归的左右两部分）的逆序对数量，只统计本层的个数，注意这里与暴力做法的区别
* merge合并数组函数比较注意排除等号，即两个数相同时不贡献逆序对

```go
package main

import (
	"fmt"
	"math"
)

func main() {
	// 读取输入
	var n, m int
	fmt.Scan(&n)
	nums := make([]int, int64(math.Pow(2.0, float64(n))))
	var num int
	for i := 0; i < len(nums); i++ {
		fmt.Scan(&num)
		nums[i] = num
	}

	// 顺序对个数
	orderRecord := make([]int64, n+1) // 0位无意义
	// 逆序对个数
	reOrderRecord := make([]int64, n+1)
	// 1. 求解两个数组
	var mergeSort func(l, r int, cnt []int64, nums []int, index int) // index就是顺序对/逆序对的下标，从n到1
	mergeSort = func(l, r int, cnt []int64, nums []int, index int) {
		if l < r {
			mid := l + (r-l)/2
			mergeSort(l, mid, cnt, nums, index-1) // 这里注意：不需要将子层的逆序对个数累计到此层，只需要此层的结果
			mergeSort(mid+1, r, cnt, nums, index-1)
			if nums[mid] > nums[mid+1] {
				// 合并
				merge(nums, l, mid, r, index, cnt)
			}
		}
	}

	// 注意点：归并会被排序，应该用临时数组
	tmp := make([]int, int64(math.Pow(2.0, float64(n))))
	copy(tmp, nums)
	mergeSort(0, len(nums)-1, reOrderRecord, tmp, n)
	flipNums(nums) // 翻转数组，再求顺序对数组
	copy(tmp, nums)
	mergeSort(0, len(nums)-1, orderRecord, tmp, n)

	// 2. 翻转统计
	fmt.Scan(&m)
	var q int
	for i := 0; i < m; i++ {
		fmt.Scan(&q)
		// 交换范围内顺序与逆序的数量
		for j := 1; j <= q; j++ {
			orderRecord[j], reOrderRecord[j] = reOrderRecord[j], orderRecord[j]
		}
		// 统计逆序对数量
		count := int64(0)
		for j := 1; j <= n; j++ {
			count += reOrderRecord[j]
		}
		fmt.Println(count)
	}
}

func merge(nums []int, l, mid, r int, index int, cnt []int64) {
	help := make([]int, r-l+1)
	p1, p2, t, count := l, mid+1, 0, int64(0)
	for p1 <= mid && p2 <= r {
		if nums[p1] <= nums[p2] { // 注意等号
			help[t] = nums[p1]
			p1++
			t++
		} else {
			count += int64(mid - p1 + 1) // 统计逆序对个数
			help[t] = nums[p2]
			p2++
			t++
		}
	}
	// 处理剩余
	for p1 <= mid {
		help[t] = nums[p1]
		p1++
		t++
	}
	for p2 <= r {
		help[t] = nums[p2]
		p2++
		t++
	}
	// 赋值
	for i := 0; i < len(help); i++ {
		nums[l+i] = help[i]
	}

	// 记录在数组
	cnt[index] += count
}

func flipNums(nums []int) {
	n := len(nums)
	for i := 0; i < n/2; i++ {
		nums[i], nums[n-1-i] = nums[n-1-i], nums[i]
	}
}
```

