---
title: 阿里笔试-子集
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2022-02-27 10:36:56
---

# 【2021】阿里巴巴编程题（4星）

## 1、子集

### 问题![image-20220227103847759](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220227103847759.png)

<!-- more -->

**输入描述:**

```
第一行输入一个正整数.表示有组数据.
对于每组数据,第一行输入一个正整数.表示物品个数.
接下来两行,每行有个整数.
第一行表示个节点的属性.
第二行表示个节点的属性.
```

**输出描述:**

```
输出行,每一行对应每组数据的输出.
```

**输入例子1:**

```
2
3
1 3 2
0 2 3
4
1 5 4 2 
10 32 19 21
```

**输出例子1:**

```
2
3
```

### 解答

这题的核心思路有两个：

* 对x排序，让此题变成求y序列的最长自序列问题
* 注意点：当x相同时应该将y大的排序在前面，因为这样对y求最长序列使用【贪心+二分】算法的时候相同x较小的y能够替换较大的y

【动态规划】时间复杂度过高$O(N^2)$，过不了

```go
package main

import "fmt"

type pair struct {
	x int
	y int
}

// N^2牛客无法通过
func main() {
	// 读取T组数据
	var T int
	if num, _ := fmt.Scan(&T); num == 0 {
		return
	}
	for i := 0; i < T; i++ {
		// 读取数组个数
		var n int
		if num, _ := fmt.Scan(&n); num == 0 {
			break
		}
		// 读取x, y
		pairs := make([]pair, n)
		var xNum int
		for j := 0; j < n; j++ {
			fmt.Scan(&xNum)
			pairs[j].x = xNum
		}
		// 读取y
		var yNum int
		for j := 0; j < n; j++ {
			fmt.Scan(&yNum)
			pairs[j].y = yNum
		}

		// 逻辑处理
		// 对x排序
		quickSort(pairs, 0, n-1)
		// 对y求最长递增子序列就是答案，dp 时间复杂度O(N^2)
		dp := make([]int, n)
		dp[0] = 1
		for i := 1; i < n; i++ {
			// i 表示dp[0:i]的最大递增子序列长度
			max := 1
			for j := 0; j < i; j++ {
				dp[i] = 1
				if pairs[j].x < pairs[i].x && pairs[j].y < pairs[i].y {
					if dp[j]+1 > max {
						max = dp[j] + 1
					}
				}
				dp[i] = max
			}
		}
		// 找出dp数组中最大的值
		max := dp[0]
		for i := 1; i < n; i++ {
			if dp[i] > max {
				max = dp[i]
			}
		}
		fmt.Println(max)
	}
}

func quickSort(pairs []pair, l, r int) {
	if l < r {
		mid := getMid(pairs, l, r)
		quickSort(pairs, l, mid-1)
		quickSort(pairs, mid+1, r)
	}
}

func getMid(pairs []pair, l, r int) int {
	pivot := pairs[l]
	for l < r {
		for l < r && pivot.x <= pairs[r].x {
			r--
		}
		pairs[l] = pairs[r]
		for l < r && pivot.x >= pairs[l].x {
			l++
		}
		pairs[r] = pairs[l]
	}
	pairs[l] = pivot
	return l
}
```

【贪心+二分】$O(NlogN)$不知道为什么最多就过4个，剩下的超时

```go
package main

import (
	"fmt"
	"sort"
)

type pair struct {
	x int
	y int
}

func main() {
	// 读取T组数据
	var T int
	fmt.Scan(&T)
	for i := 0; i < T; i++ {
		// 读取数组个数
		var n int
		fmt.Scan(&n)
		// 读取x, y
		pairs := make([]pair, n)
		var xNum int
		for j := 0; j < n; j++ {
			fmt.Scan(&xNum)
			pairs[j].x = xNum
		}
		// 读取y
		var yNum int
		for j := 0; j < n; j++ {
			fmt.Scan(&yNum)
			pairs[j].y = yNum
		}

		// 逻辑处理
		// 对x排序
		sort.SliceStable(pairs, func(i, j int) bool {
			if pairs[i].x == pairs[j].x {
				return pairs[i].y > pairs[j].y // 注意：相同x，y大的放在前面，这样y的更新才正确
			}
			return pairs[i].x < pairs[j].x
		})
		// 对y求最长递增子序列就是答案，贪心+二分 时间复杂度O(NlogN)
		// dp[i] 表示长度为len(dp)的所有子序列的y最小值
		dp := make([]int, 1)
		// 初始化
		dp = append(dp, pairs[0].y)
		for i := 1; i < n; i++ {
			if pairs[i].y > dp[len(dp)-1] {
				dp = append(dp, pairs[i].y)
			} else {
				// 二分找出更新位置
				binarySearch := func(t int) int {
					l, r := 1, len(dp)
					for l < r {
						mid := l + (r-l)/2
						if dp[mid] < t {
							l = mid + 1
						} else {
							r = mid
						}
					}
					return l
				}
				// 更新最小值
				dp[binarySearch(pairs[i].y)] = pairs[i].y
			}
		}
		// 输出结果
		fmt.Println(len(dp) - 1)
	}
}
```

## 2、小强爱数学

### 问题

![image-20220227104541289](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220227104541289.png)

**输入描述:**

```
第一行输入一个正整数.表示有组数据
接下来行,每行输入三个整数,和.
```

**输出描述:**

```
输出行,每一行表示每组数据的结果.
```

**输入例子1:**

```
3
4 4 3
2 3 4
5 2 6
```

**输出例子1:**

```
16
999999993
9009
```

### 解答

找到规律

```go
// https://www.nowcoder.com/question/next?pid=30440638&qid=1664953&tid=52504730
package main

import "fmt"

var MOD = 1000000007

// A = x+y, B = x*y
// f(0) = 2
// f(1) = x+y
// f(2) = x^2+y^2 = f(1)A-B*f(0)
// f(3) = x^3+y^3 = f(2)A-B*f(1)
func main() {
	var T int
	fmt.Scan(&T)
	for i := 0; i < T; i++ {
		var A, B, n int
		fmt.Scan(&A)
		fmt.Scan(&B)
		fmt.Scan(&n)
		// 斐波那契数列
		dp := make([]int, n+1)
		dp[0], dp[1] = 2, A
		for i := 2; i <= n; i++ {
			// 这里+mod的原因是前面减法可能产生负数，所以+一个MOD
			dp[i] = ((dp[i-1]*A)%MOD - (dp[i-2]*B)%MOD + MOD) % MOD
		}
		fmt.Println(dp[n])
	}
}
```

