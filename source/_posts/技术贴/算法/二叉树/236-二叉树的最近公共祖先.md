---
title: 236.二叉树的最近公共祖先
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-11-08 22:55:13
---

## 题目描述

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

难度中等

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 <!-- more -->

**示例 1：**

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-109 <= Node.val <= 109`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

## 解题思路及代码

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
// 方法一
// 依靠递归遍历，构建子节点与父节点的关系映射
// 然后分别从p, q出发寻找是否有重复的父节点
// 时间、空间复杂度O(N)
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    fatherMap := make(map[*TreeNode]*TreeNode)
    fatherMap[root] = nil       // 初始化根节点的父节点为空
    // 构建父节点映射
    var dfs func(*TreeNode, *TreeNode)
    dfs = func(node, fatherNode *TreeNode) {
        // 递归结束条件
        if node == nil {
            return 
        }
        // 处理当前节点
        if fatherNode != nil {
            fatherMap[node] = fatherNode
        }
        // 递归左右节点
        dfs(node.Left, node)
        dfs(node.Right, node)
    }
    dfs(root, nil)
    // 遍历q寻找其父节点，构建路径访问记录
    qVisited := make(map[int]bool, 0)
    for node:=q; node!=nil; node=fatherMap[node] {
        qVisited[node.Val] = true
    }
    // 遍历p查找共同访问的节点
    for node:=p; node!=nil; node=fatherMap[node] {
        if qVisited[node.Val] {     // 找到共同访问过的节点
            return node
        }
    }
    return nil
}

// 方法二
// 分析出规律：最近公共祖先一定是下面的两种情况之一:
// 1. p和q分别在自己的左右子树中出现
// 2. 自己是p或是q，并且子树有p或q，那么自己就是最近公共祖先
// 为什么一定是最近？毫无疑问第二种自己是公共祖先一定是最近的；对于第一种，最近的公共祖先一定是第一次相交的节点，那么p、q一定分别在左右两侧，再往上的祖先就不是最近也不会分别在两边了。
// 将递归函数返回值设置为：是否有p或者q
// 时间、空间复杂度O(N)
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    // 递归结束条件
    if root == nil {
        return nil
    }
    // 如果当前节点是p或q，则一定自己是最近公共祖先(因为树从上往下遍历）
    if root == p || root == q {
        return root
    }
    // 对于当前节点，得到其左右子树的最近公共祖先
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    // 判断:
    // 如果都不为nil，则说明是第一种情况
    if left != nil && right != nil {
        return root
    }
    // 有一个子树有结果
    if left == nil {
        return right
    }
    // 不可能出现两个都是nil, 因为一定有公共祖先
    return left
}

```

