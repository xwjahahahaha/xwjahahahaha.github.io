---
title: 129-求根到叶子节点数字之和
tags:
  - java
categories:
  - technical
  - leetcode
toc: true
date: 2020-10-29 09:32:48
---

## 题目描述

#### [129. 求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

难度中等215

给定一个二叉树，它的每个结点都存放一个 `0-9` 的数字，每条从根到叶子节点的路径都代表一个数字。

例如，从根到叶子节点路径 `1->2->3` 代表数字 `123`。

计算从根到叶子节点生成的所有数字之和。

**说明:** 叶子节点是指没有子节点的节点。

<!-- more -->

**示例 1:**

```
输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.
```

**示例 2:**

```
输入: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
输出: 1026
解释:
从根到叶子节点路径 4->9->5 代表数字 495.
从根到叶子节点路径 4->9->1 代表数字 491.
从根到叶子节点路径 4->0 代表数字 40.
因此，数字总和 = 495 + 491 + 40 = 1026.
```

## 解题思路及代码

## 方法一：深度优先DFS  

**时间复杂度O(N) 空间复杂度O(N)(取决于栈的深度，最坏情况下直线为N)**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
//方法一：深度优先DFS  时间复杂度O(N) 空间复杂度O(N)(取决于栈的深度，最坏情况下直线为N)
class Solution {
    public int sumNumbers(TreeNode root) {
       //默认当前根节点的父节点值为0
       return dfs(root, 0);
    }

    public int dfs(TreeNode root, int preSum){
        //递归返回条件
        if(root == null){
            return 0;
        }
        //计算当前节点
        preSum = preSum*10 + root.val;
        //递归
        if(root.left == null && root.right == null){   //叶子节点
            return preSum;
        }else{                                         //一般节点 
            return dfs(root.left, preSum) + dfs(root.right, preSum);
        }
    } 
}
```

## 方法二：广度优先搜索  

**时间复杂度O(N) 空间复杂度O(N)**

使用广度优先搜索，需要维护两个队列，分别存储节点和节点对应的数字。
初始时，将根节点和根节点的值分别加入两个队列。每次从两个队列分别取出一个节点和一个数字，进行如下操作：
如果当前节点是叶子节点，则将该节点对应的数字加到数字之和；<font color='orange'>只有到了叶子节点才累计和</font>
如果当前节点不是叶子节点，则获得当前节点的非空子节点，并根据当前节点对应的数字和子节点的值计算子节点对应的数字，然后将子节点和子节点对应的数字分别加入两个队列。

```java
class Solution {
    public int sumNumbers(TreeNode root) {
        if(root == null) return 0;
        //创建两个队列
       Queue<TreeNode> nodeQueue = new LinkedList<>();    //节点队列
       Queue<Integer> valQueue = new LinkedList<>();    //数值队列
       int sum = 0;
       //初始化加入
       nodeQueue.offer(root);
       valQueue.offer(root.val);
       //循环加入队列，直到节点队列为空，所有节点统计完
       while(!nodeQueue.isEmpty()){
            //弹出一个节点
            TreeNode node = nodeQueue.poll();
            //弹出其值
            int num = valQueue.poll();
            //取其左右子节点
            TreeNode left = node.left;
            TreeNode right = node.right;
            //判断是否为叶子结点
            if(left == null && right == null){
                sum += num; //是叶子节点就加入到累计和
            }else{
                if(left != null){
                    //加入左节点
                    nodeQueue.offer(left);
                    valQueue.offer(num * 10 + left.val);
                }
                if(right != null){
                    //加入右节点
                    nodeQueue.offer(right);
                    valQueue.offer(num * 10 + right.val);
                }
            }
        }
        return sum;
    }
}
```

