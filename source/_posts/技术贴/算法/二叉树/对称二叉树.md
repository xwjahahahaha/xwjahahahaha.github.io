---
title: 对称二叉树
date: 2020-05-25 15:38:59
tags: java
categories: 
    - technical
    - leetcode 
toc: true
---
### 题目描述
给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```
<!-- more -->
但是下面这个 `[1,2,2,null,3,null,3] `则不是镜像对称的:
```
    1
   / \
  2   2
   \   \
   3    3
```

### 解题思路
迭代与递归两种方法

### 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

//方法一：递归：  时间复杂度/空间复杂度：O(n) 
// “对称”类似于镜面，两个树对称则需要满足一下两个条件：
// 1. 两个树的当前节点的值是相同的
// 2. 每个树的左子树必须与另一个树的右子树相同
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return isMirror(root, root);
    }
    
    public boolean isMirror(TreeNode t1, TreeNode t2){
        if(t1 == null && t2 == null) return true;
        //有一个为null则不对称
        if(t1 == null || t2 == null) return false;
        return (t1.val == t2.val) && (isMirror(t1.left, t2.right)) && (isMirror(t1.right, t2.left));
    }
    
}

```

```java
//方法二： 迭代：  复杂度同递归
//使用队列
 class Solution {
    public boolean isSymmetric(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode t1, t2;
        //一开始只把两个根节点放入
        queue.add(root);
        queue.add(root);
        //开始判断
        while(!queue.isEmpty()){
            t1 = queue.poll();
            t2 = queue.poll();
            if(t1 == null && t2 == null) continue;
            if(t1 == null || t2 == null) return false;
            //必须从队列出来的两个节点的值相等，这样才认为是对称的
            if(t1.val != t2.val) return false;
            //重点：把当前节点的左右节点放到队列中，注意两个树存放顺序要相反（因为镜像对称保证出来连续的两个是相同的）
            queue.add(t1.left);
            queue.add(t2.right);
            queue.add(t1.right);
            queue.add(t2.left);
        }
        return true;
    }   
 }

```