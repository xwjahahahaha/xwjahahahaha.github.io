---
title: 有序序列转换二叉平衡搜索树
tags:
  - java
categories:
  - technical
  - leetcode
toc: true
date: 2020-05-28 11:24:00
---

## 题目描述
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定有序数组: `[-10,-3,0,5,9]`,

一个可能的答案是：`[0,-3,9,-10,null,5]`，它可以表示下面这个高度平衡二叉搜索树：
```
      0
     / \
   -3   9
   /   /
 -10  5
```
<!-- more -->
## 解题思路

平衡二叉搜索树： 平衡：平衡因子绝对值不大于1， 搜索树：左小右大

我的思路：递归的每次找中值作为根节点->解决平衡的问题

**众所周知（就我不知系列）：二叉搜索树的中序遍历的结果是一个升序序列**

已知中序遍历的结构是不唯一的，题目中添加了平衡的条件，但还是不唯一的

只有知道了一个二叉树的中序+ 前序/后序 才能唯一的确定一个二叉树结构

本题最终可看为这样的问题： 给定一个升序序列，构建出一个平衡（找中点）的二叉搜索树

## 代码
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

//方法一： 递归构建树  时间复杂度O(n),空间复杂度: 节点：O(n) 栈深度O(logn) (一次递归处理两个孩子节点)
class Solution {
    //设置成成员变量，不用传参了
    int nums[];
    
    public TreeNode helper(int left, int right){
        //递归出口：left<right 表示子树不存在元素，返回空
        if(left > right) return null;
        //不管奇偶，取中点,注意防止溢出,个数为偶数的话就是始终选择中点左边的作为根节点
        int mid = (left + right) >> 1;
        //构建根节点
        TreeNode root = new TreeNode(nums[mid]);
        //递归左右孩子
        root.left = helper(left, mid-1);
        root.right = helper(mid+1, right);
        return root;
    }
    
    public TreeNode sortedArrayToBST(int[] nums) {
        this.nums = nums;
        return helper(0, nums.length-1);
    }
}
```

>作者：gumptlu

>链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jin-liang-zi-ji-si-kao-by-gumptlu/

>来源：力扣（LeetCode）

>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

