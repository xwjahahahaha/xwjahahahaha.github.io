---
title: 116-填充每个节点的下一个右侧节点指针
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-05 11:07:06
---

## 题目描述

#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

难度中等

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

 <!-- more -->

**进阶：**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

 

**示例：**

![img](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

 

**提示：**

- 树中节点的数量少于 `4096`
- `-1000 <= node.val <= 1000`




## 解题思路及代码

**==借助上一步的成果完成下一步==**,很重要的思想!

```go
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Left *Node
 *     Right *Node
 *     Next *Node
 * }
 */

// 层次遍历改进
// 时间复杂度O(N) 空间复杂度O(N) 不满足常量级
func connect(root *Node) (head *Node) {
	if root == nil {
        return nil
    }
    queue := []*Node{}
    divisionNode := &Node{}
    queue = append(queue, root, divisionNode)
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:len(queue)]
        if node == divisionNode {
            // 层结束
            node.Next = nil
            if len(queue) > 0 {
                queue = append(queue, divisionNode)
            }
        } else {
            // 层未结束
            // 队列下一个就是右侧节点
            // 队列下一个节点不能是分隔符节点
            if len(queue) > 0 && queue[0] != divisionNode {
                node.Next = queue[0]
            }
            // 左右孩子入队
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
    return root
}

// 借助上层已建立的next指针
func connect(root *Node) (head *Node) {
    if root == nil {
        return nil
    }
    // 创建最左指针
    utmostLeft := root
    // 因为是完美二叉树,所以最左节点一定在最左边
    // 当最左指针的下一层为空时,代表层级遍历结束(不用再为下一层建立next指针)
    for utmostLeft.Left != nil {
        // 使用next指针遍历当前层
        // 注意,根节点的next本来就是为nil
        for node:=utmostLeft; node!=nil; node = node.Next {
            // 为下层建立next有两种情况
            // 1. 同一个父节点: 直接相连
            node.Left.Next = node.Right
            // 2. 不同父节点: 使用上层建立的next指针快速相连
            if node.Next != nil {
                node.Right.Next = node.Next.Left    
            }else {
                // 当前节点没有next,则其右孩子也不需要next
                // 因为本身就是nil,所以这一步可以省略
                node.Right.Next = nil
            }         
        }     
        utmostLeft = utmostLeft.Left
    }
    return root
}
```

