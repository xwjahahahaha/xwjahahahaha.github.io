---
title: NC45-实现二叉树先序,中序和后序遍历
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2021-12-10 21:38:13
---

## 题目描述

分别用递归和迭代两种方式实现二叉树的前序、中序、后序遍历


<!-- more -->

## 解题思路及代码

```go
package main
import . "nc_tools"
/*
 * type TreeNode struct {
 *   Val int
 *   Left *TreeNode
 *   Right *TreeNode
 * }
 */

/**
 * 
 * @param root TreeNode类 the root of binary tree
 * @return int整型二维数组
*/
func threeOrders( root *TreeNode ) [][]int {
    ret := make([][]int, 3)
    for i:=0; i<len(ret); i++ {
        ret[i] = make([]int, 0)
    }
    // 递归
//     firstOrder(root, &ret[0])
//     midOrder(root, &ret[1])
//     backOrder(root, &ret[2])
    // 迭代
    firstOrderByIteration(root, &ret[0])
    midOrderByIteration(root, &ret[1])
    backOrderByIteration(root, &ret[2])
    return ret
}

// 先序, 递归实现
func firstOrder(root *TreeNode, path *[]int) {
    if root == nil {
        return 
    }
    *path = append(*path, root.Val)
    firstOrder(root.Left, path)
    firstOrder(root.Right, path)
}

// 先序，迭代实现
func firstOrderByIteration(root *TreeNode, path *[]int) {
    // 手动创建栈
    stack := make([]*TreeNode, 0)
    for root != nil || len(stack) > 0 {
        // 不断将左孩子加入
        for root != nil {
            // 先记录到结果集
            *path = append(*path, root.Val)
            // 入栈
            stack = append(stack, root)
            root = root.Left
        }
        // 出栈
        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        // 处理右节点
        root = root.Right
    }
}

// 中序, 递归
func midOrder(root *TreeNode, path *[]int) {
    if root == nil {
        return 
    }
    midOrder(root.Left, path)
    *path = append(*path, root.Val)
    midOrder(root.Right, path)
}

// 中序，迭代
func midOrderByIteration(root *TreeNode, path *[]int) {
     // 手动创建栈
    stack := make([]*TreeNode, 0)
    for root != nil || len(stack) > 0 {
        // 不断将左孩子加入
        for root != nil {
            // 入栈
            stack = append(stack, root)
            root = root.Left
        }
        // 出栈
        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        // 记录到结果集
        *path = append(*path, root.Val)
        // 处理右节点
        root = root.Right
    }
}

// 后序，递归
func backOrder(root *TreeNode, path *[]int) {
    if root == nil {
        return 
    }
    backOrder(root.Left, path)
    backOrder(root.Right, path)
    *path = append(*path, root.Val)
}

// 后序，迭代
func backOrderByIteration(root *TreeNode, path *[]int) {
    // 手动创建栈
    stack, visited := make([]*TreeNode, 0), &TreeNode{}        // visited用于标记上次已访问的节点
    for root != nil || len(stack) > 0 {
        // 左孩子入栈
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }
        // 出栈
        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        // 判断该节点的右孩子是否被访问或者为空，如果是则说明可记录
        if visited == root.Right || root.Right == nil {
            // 标记被访问
            visited = root
            *path = append(*path, root.Val)
            root = nil        // 设置为空，在从栈中往上取
        }else {
            // 右孩子还未被访问
            // 将当前节点入栈，重新再次入栈，因为还没访问完毕
            stack = append(stack, root)
            // 迭代右孩子
            root = root.Right
        }
        
    }
}
```

