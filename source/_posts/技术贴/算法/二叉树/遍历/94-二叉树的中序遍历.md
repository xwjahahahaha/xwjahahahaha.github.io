---
title: 94-二叉树的中序遍历
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-03-31 10:31:39
---

## 题目描述

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

难度中等

<!-- more -->

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

```
输入：root = [1,2]
输出：[2,1]
```

**示例 5：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

```
输入：root = [1,null,2]
输出：[1,2]
```

 

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

## 解题思路及代码

递归与迭代

时间复杂度O(N)

空间复杂度O(N) (最坏当链表为一条直线时,栈的深度就是N)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
 
 // 递归
func inorderTraversal(root *TreeNode) []int {
    path := make([]int, 0)
    GetPath(&path, root)
    return path
}

func GetPath(path *[]int, root *TreeNode){
    if root == nil {
        return 
    }
    GetPath(path, root.Left)
    *path = append(*path, root.Val)
    GetPath(path, root.Right)
}



// 迭代
// 维护一个栈
func inorderTraversal(root *TreeNode) (res []int){
   stack := []*TreeNode{}
   for root != nil || len(stack) > 0 {
       // 一直遍历左边
       for root != nil {
           // 入栈
           stack = append(stack, root)
           root = root.Left
       }
       // 处理中间
       root = stack[len(stack)-1]
       stack = stack[:len(stack)-1]
       res = append(res, root.Val)
       // 右边
       root = root.Right
   }
   return res
}
```

