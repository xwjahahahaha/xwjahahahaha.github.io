---
title: 103-二叉树的锯齿形层次遍历
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-03 13:06:42
---

## 题目描述

[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

难度中等

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

<!-- more -->

例如：
给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回锯齿形层序遍历如下：

```
[
  [3],
  [20,9],
  [15,7]
]
```




## 解题思路及代码

两种方法: 递归(深度优先)、迭代(广度优先) 不翻转奇数层数组,而是在插入时判断层数奇数层倒叙插入

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

// 递归
func zigzagLevelOrder(root *TreeNode) (res [][]int) {
    if root == nil {
        return nil
    }
    // 创建递归函数
    var recursive func(*TreeNode, int)
    recursive = func(node *TreeNode, level int){
        // 如果当前层次与结果集大小相等,那么就为新的层创建空间
        if len(res) == level {
            res = append(res, []int{})
        }
        // 判断层数奇偶,决定插入结果集顺序,奇数反序,偶数正序
        if level == 0 || level % 2 == 0 {
            res[level] = append(res[level], node.Val)
        }else {
            // 反序添加
            res[level] = append(res[level], 0)
            for i:=len(res[level])-1; i>0; i-- {
                res[level][i] = res[level][i-1]
            }
            res[level][0] = node.Val
        }
        // 递归子节点
        if node.Left != nil {
            recursive(node.Left, level+1)
        }
        if node.Right != nil {
            recursive(node.Right, level+1)
        }
    }
    recursive(root, 0)
    return
}

// 迭代
func zigzagLevelOrder(root *TreeNode) (resList [][]int) {
    if root == nil {
        return nil
    }
    queue := []*TreeNode{}
    res := []int{}
    division := &TreeNode{}
    // 加入根节点与分隔符节点
    queue = append(queue, root, division)
    for len(queue) > 0 {
        // 弹出节点
        node := queue[0]
        queue = queue[1:]
        // 判断是否为分隔符节点
        if node == division {
            resList = append(resList, res)
            res = []int{}
            if len(queue) > 0 {
                queue = append(queue, division)
            }
        }else {
            // 层还未结束,继续添加
            // 根据当前层数奇偶,判断添加到结果集的顺序.奇数为逆序,偶数为顺序
            level := len(resList)
            if level == 0 || level % 2 == 0 {
                res = append(res, node.Val)
            }else {
                // 反序添加
                res = append(res, 0)
                for i:=len(res)-1; i>0; i-- {
                    res[i] = res[i-1]
                }
                res[0] = node.Val
            }
            // 添加子节点到队列
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
    return
}
```

二刷：

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func zigzagLevelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }

    res := [][]int{[]int{}}
    division := &TreeNode{}
    queue := []*TreeNode{root, division}

    for len(queue) > 0 {
        // 出队
        node := queue[0]
        queue = queue[1:]

        if node == division {
            // 此时上一层的所有孩子也已经入队，所以在此加入
            if len(queue) > 0 {     // 确保不是最后一个division
                // 上一层结束，开始本层
                res = append(res, []int{})
                queue = append(queue, division)
            }
        }else {
            // 加入当前层, 分为不同的顺序
            nowAry := &res[len(res)-1]                  // 注意取地址
            if len(res) % 2 == 0 {
                // 右->左
                // 头插
                *nowAry = append(*nowAry, 0)
                for i:=len(*nowAry)-1; i>=1; i-- {
                    (*nowAry)[i] = (*nowAry)[i-1]
                }
                (*nowAry)[0] = node.Val
            }else {
                // 左->右
                *nowAry = append(*nowAry, node.Val)
            }
            // 左右孩子入队
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
    return res
}
```

