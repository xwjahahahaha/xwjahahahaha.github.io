---
title: 145-二叉树的后序遍历
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-01 10:10:31
---

## 题目描述

#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

难度中等555

给定一个二叉树，返回它的 *后序* 遍历。

<!-- more -->

**示例:**

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

## 解题思路及代码

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

 // 递归
func postorderTraversal(root *TreeNode) (res []int) {
    var recursive func(node *TreeNode)
    recursive = func(node *TreeNode) {
        // 边界情况
        if node == nil {
            return 
        }
        // 左
        recursive(node.Left)
        // 右
        recursive(node.Right)
        // 中
        res = append(res, node.Val)
    }
    recursive(root)
    return
}


// 迭代
func postorderTraversal(root *TreeNode) (res []int) {
    stack := []*TreeNode{}
    // 已访问的右子节点需要标记,防止死循环
    var visited *TreeNode       // 表示已访问
    for root != nil || len(stack) > 0 {
        // 左走,入栈
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }
        // 走完,出栈,到达中间根节点
        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        // 判断此根节点右子节点
        // 1. 为空或已访问则结束此根节点
        if root.Right == nil || root.Right == visited {
            // 加入结果集
            res = append(res, root.Val)
            visited = root
            root = nil
        }else{
            // 2. 不为空或者未访问则重新入栈访问右节点
            stack = append(stack, root)     // root重新入栈
            root = root.Right
        }
    }
    return
}
```

