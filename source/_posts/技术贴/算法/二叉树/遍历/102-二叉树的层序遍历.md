---
title: 102-二叉树的层序遍历
tags:
  - java
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2020-05-27 12:08:23
---

## 题目描述
[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

难度中等

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 <!-- more -->

**示例：**
二叉树：`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层序遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

## 解题思路
递归与迭代

## 代码 

### Java

```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
//第一种方法： 迭代  时间复杂度/空间复杂度 O(N)
//每层结束插入一个分层符节点
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        //创建两个结果链表
        List<List<Integer>> resList = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        //创建分层符节点
        TreeNode divisionNode = new TreeNode(Integer.MIN_VALUE);
        //空树则直接返回
        if(root == null) return resList;
        //根节点入队
        queue.offer(root);
        //第一层就一个根节点，所以直接插入分层节点
        queue.offer(divisionNode);
        while(!queue.isEmpty()){
            root = queue.poll();
            if(root == null) continue;
            //判断该节点是否为分层节点
            if(root.val == Integer.MIN_VALUE){
                //是分层符则处理结果列表
                resList.add(list);
                //新建列表，储存下一层
                list = new ArrayList<>();
                //最厉害的地方！！！！
                //这一层结束，那么其下一层所有子节点现在也全部入队了，所以在此插入分层节点
                if(!queue.isEmpty()){
                    queue.offer(divisionNode);   
                }
            }else{
                //不是分层符节点，则不断加入到列表中
                //访问该根节点
                list.add(root.val);
                //将左右儿子入队
                if(root.left != null) queue.offer(root.left);
                if(root.right != null) queue.offer(root.right); 
            }
        }
        return resList;
    }
}
```
```java
//第二种方法： 递归   时间复杂度/空间复杂度 O(N)
//用辅助函数参数level来协助统计层数
class Solution {
    //创建结果数组
    List<List<Integer>> levels = new ArrayList<>();
    public void helper(TreeNode node, int level){
        //重点： 当结果列表的大小=层数，那么新建一个list存储当前层
        if(levels.size() == level)  levels.add(new ArrayList<Integer>());
        //根据参数level，把当前的节点插入对应的层次列表中
        levels.get(level).add(node.val);
        //递归处理其子节点，注意层次要+1
        if(node.left != null) helper(node.left, level+1);
        if(node.right != null) helper(node.right, level+1); 
    }
    
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) return levels;
        //设置根节点在第0层
        helper(root, 0);
        return levels;
    }
}
```

### Go

```go
// 递归
// 时间复杂度O(N)
// 空间复杂度O(N) (最坏为单链情况)
func levelOrder(root *TreeNode)  [][]int {
    if root == nil {
        return nil
    }
    res := make([][]int, 0)
    var recursive func(node *TreeNode, level int)
    recursive = func(node *TreeNode, level int){
        // 如果当前层是新层次,那么就新创建一层空间
        if len(res) == level {
            res = append(res, []int{})
        }
        // 添加当前节点到对应层
        res[level] = append(res[level], node.Val)
        // 递归左右子节点
        if node.Left != nil {
            recursive(node.Left, level+1)
        }
        if node.Right != nil {
            recursive(node.Right, level+1)
        }   
    }
    recursive(root, 0)
    return res
}
```

```go
// 迭代
func levelOrder(root *TreeNode)  (resList [][]int) {
    if root == nil {
        return nil
    }
    // 创建队列
    queue := make([]*TreeNode, 0)
    // 每一层创建一个存储空间
    res := make([]int, 0)
    // 设置分隔符节点
    divisionNode := &TreeNode{}
    // 加入根节点
    queue = append(queue, root)
    // 二叉树首层一定是只有一个元素,所以直接插入分隔符
    queue = append(queue, divisionNode)
    // 迭代
    for len(queue) > 0 {
        // 弹出队列首节点
        node := queue[0]
        queue = queue[1:]
        // fmt.Println(node.Val)
        // 判断是不是分隔符
        if node == divisionNode {
            // 是,则说明此层已经遍历完毕
            // 将此层的结果集加入到总集合中
            resList = append(resList, res)
            // 为下一层创建新的结果集合
            res = []int{}
            // 重点: 本层结束, 一定代表着本层所有节点的孩子节点都已经入队
            // 所以在此处在队列中插入分隔符节点符号
            // 注意,当到叶子节点层后就不需要加入分隔符了,所以添加一个判断
            if len(queue) > 0 {
                queue = append(queue, divisionNode)
            }
        }else {
            // 不是,就将其左右孩子入队
            // 先将本节点值写入到结果集中
            res = append(res, node.Val)
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }         
        }
    }
    return 
}
```

二刷

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }

    res := [][]int{[]int{}}
    division := &TreeNode{}
    queue := []*TreeNode{root, division}

    for len(queue) > 0 {
        // 出队
        node := queue[0]
        queue = queue[1:]

        if node == division {
            // 此时上一层的所有孩子也已经入队，所以在此加入
            if len(queue) > 0 {     // 确保不是最后一个division
                // 上一层结束，开始本层
                res = append(res, []int{})
                queue = append(queue, division)
            }
        }else {
            // 加入当前层
            res[len(res)-1] = append(res[len(res)-1], node.Val)
            // 左右孩子入队
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
    return res
}
```

