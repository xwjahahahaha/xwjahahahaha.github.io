---
title: 105-从前序与中序遍历序列构造二叉树
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-04 10:54:16
---

## 题目描述

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

难度中等

根据一棵树的前序遍历与中序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

<!-- more -->

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

## 解题思路及代码

总体是递归的过程

1. 根据前序遍历的preLeft找到根节点
2. 在中序遍历中找到根节点pIndex
3. 计算左子树的长度, len = pIndex-1-inLeft+1 = pIndex-inLeft
4. 推算前序遍历左子树范围(长度与中序相等) x - (preLeft+1) + 1 = len   => x = pIndex-inLeft+preLeft
5. 这样右子树也可得出
6. 递归左右子树
7. 本次根节点链接左右子树的根节点

![zkfP9T](http://xwjpics.gumptlu.work/qinniu_uPic/zkfP9T.png)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
 // 递归
func buildTree(preorder []int, inorder []int) (head *TreeNode) {
    // 遍历中序一次创建映射
    where := make(map[int]int, 0)
    for i, v := range inorder {
        where[v] = i
    }
    // 递归
    var helper func(int, int, int, int) *TreeNode
    helper = func (preLeft, preRight, inLeft, inRight int) (childNode *TreeNode){
        if preLeft > preRight || inLeft > inRight {
            return nil
        }
        // 确定根节点位置
        pIndex := where[preorder[preLeft]]
        // 创建节点
        node := &TreeNode{ Val : inorder[pIndex] }
        // 递归左右子树
        leftNode := helper(preLeft+1, pIndex-inLeft+preLeft, inLeft, pIndex-1)
        rightNode := helper(pIndex-inLeft+preLeft+1, preRight, pIndex+1, inRight)
        // 链接
        node.Left = leftNode
        node.Right = rightNode 
        return node
    }
    return helper(0, len(preorder)-1, 0, len(inorder)-1)   
}
```

二刷：

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
// 分治递归减小问题范围
func buildTree(preorder []int, inorder []int) *TreeNode {
    return buildTreeProcess(preorder, inorder, 0, len(preorder)-1, 0, len(inorder)-1)
}

// pl, pr : preorder的范围[pl, pr]
// il, ir : inorder的范围[il, ir]
func buildTreeProcess(preorder, inorder []int, pl, pr, il, ir int) *TreeNode {
    // 边界情况/递归结束情况
    if il > ir {
        return nil
    }
    if il == ir  {
        return &TreeNode{preorder[pl], nil, nil}
    }
    // 生成当前根节点
    rootNode := &TreeNode{preorder[pl], nil, nil}
    // 在inorder中找到根节点位置
    mid := il
    for i:=il; i<=ir; i++ {
        if inorder[i] == preorder[pl] {
            mid = i
            break
        }
    }
    // 递归其左右子树
    // pl+mid-il: mid-il根据inorder中的mid位置确定左边一共有mid-il个数，然后偏移得到preorder的右边界
    leftSonNode := buildTreeProcess(preorder, inorder, pl+1, pl+mid-il, il, mid-1)  
    rightSonNode := buildTreeProcess(preorder, inorder, pl+mid-il+1, pr, mid+1, ir)
    if leftSonNode != nil {
        rootNode.Left = leftSonNode 
    }
    if rightSonNode != nil {
        rootNode.Right = rightSonNode
    }
    return rootNode
}
```

三刷，更简洁递归

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
// 递归
func buildTree(preorder []int, inorder []int) *TreeNode {
    // 递归结束条件
    if len(preorder) == 0 || len(inorder) == 0 {
        return nil
    }
    // 根结点
    root := &TreeNode{preorder[0], nil, nil}
    
    // 递归划分左右子树
    rootIndex := getNodeIndex(root.Val, inorder)    // 获取根节点位置
    root.Left = buildTree(preorder[1:1+rootIndex], inorder[:rootIndex])
    root.Right = buildTree(preorder[1+rootIndex:], inorder[rootIndex+1:])

    return root
} 

func getNodeIndex(val int, nums []int) int {
    for i, num := range nums {
        if num == val {
            return i
        }
    }
    return -1
}
```

三刷：

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func buildTree(preorder []int, inorder []int) *TreeNode {
    m, n := len(preorder), len(inorder)
    if m == 0 || n == 0 {
        return nil
    }

    val := preorder[0]

    // find index 
    idx := 0             
    for i, v := range inorder {
        if v == val {
            idx = i
            break
        }
    }

    left := buildTree(preorder[1:1+idx], inorder[:idx])
    right := buildTree(preorder[1+idx:], inorder[idx+1:])
    
    return &TreeNode{val, left, right}
}   
```

