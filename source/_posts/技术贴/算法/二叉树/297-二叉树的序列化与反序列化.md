---
title: 297.二叉树的序列化与反序列化
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-05-01 10:43:09
---

## 题目描述

[297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

难度困难

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

<!-- more -->

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode-cn.com/faq/#binary-tree)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

 

**示例 1：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/serdeser.jpg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

**提示：**

- 树中结点数在范围 `[0, 104]` 内
- `-1000 <= Node.val <= 1000`

## 解题思路及代码

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
// 方法一：通过前序遍历保存
type Codec struct {
    
}

func Constructor() Codec {
    return Codec{}
}

// Serializes a tree to a single string.
func (this *Codec) serialize(root *TreeNode) string {
    // 前序遍历
    ans := ""
    var dfs func(node *TreeNode) 
    dfs = func(node *TreeNode) {
        if node == nil {
            ans += "nil,"
            return 
        }
        ans += strconv.Itoa(node.Val)+","
        dfs(node.Left)
        dfs(node.Right)
    }
    dfs(root)
    return ans[:len(ans)-1]         // 去掉最后一个逗号
}

// Deserializes your encoded data to tree.
func (this *Codec) deserialize(data string) *TreeNode {    
    sp := strings.Split(data, ",")
    var build func() *TreeNode
    build = func() *TreeNode {
        // 取第一个字符串
        c := sp[0]
        sp = sp[1:]
        if c == "nil" {
            return nil
        }
        val, _ := strconv.Atoi(c)
        // 递归取下一个
        return &TreeNode{val, build(), build()}
    }
    return build()
}



/**
 * Your Codec object will be instantiated and called as such:
 * ser := Constructor();
 * deser := Constructor();
 * data := ser.serialize(root);
 * ans := deser.deserialize(data);
 */
```

