---
title: 199.二叉树的右视图
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-09 15:30:07
---

## 题目描述

[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

难度中等

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 <!-- more -->

**示例 1:**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/tree.jpg)

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

**示例 2:**

```
输入: [1,null,3]
输出: [1,3]
```

**示例 3:**

```
输入: []
输出: []
```

**提示:**

- 二叉树的节点个数的范围是 `[0,100]`
- `-100 <= Node.val <= 100` 

## 解题思路及代码

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
// 思路一：bfs层序遍历记录每层最后一个
func rightSideView(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }
    queue, divsion := make([]*TreeNode, 0), &TreeNode{}
    queue = append(queue, root, divsion)
    ans := make([]int, 0)
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        if node == divsion {
            if len(queue) > 0 {
                queue = append(queue, divsion)
            }
        }else {
            if queue[0] == divsion {
                // 说明此节点是本层最后一个节点
                ans = append(ans, node.Val)
            }
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
    return ans
}

// dfs：中->右->左的顺序访问，这样每一层第一个访问到的一定是最右边的节点
func rightSideView(root *TreeNode) []int {
    ans := make([]int, 0)
    var dfs func(*TreeNode, int)
    dfs = func(root *TreeNode, depth int) {
        if root == nil {
            return
        }
        // 判断当前深度是否有结果, 没结果代表是第一个,加入结果集
        if len(ans) == depth {
            ans = append(ans, root.Val)
        }
        depth++
        dfs(root.Right, depth)
        dfs(root.Left, depth)
    }
    dfs(root, 0)
    return ans
}
```

二刷：

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func rightSideView(root *TreeNode) []int {
    ans := []int{}
    var dfs func(root *TreeNode, level int)
    dfs = func(root *TreeNode, level int) {
        if root == nil {
            return
        }
        // 判断此节点是否是当前层的第一个
        if len(ans) <= level {
            ans = append(ans, root.Val)
        }
        dfs(root.Right, level+1)
        dfs(root.Left, level+1)
    }
    dfs(root, 0)
    return ans
}
```

三刷：

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
// 右->中->左，那么每一层的第一个节点就是该层最右边的节点
func rightSideView(root *TreeNode) []int {
    res := make([]int, 0)
    var dfs func(root *TreeNode, level int)
    dfs = func(root *TreeNode, level int) {
        if root == nil {
            return
        }

        if level == len(res) {
            // 此时是该层的第一个节点。加入到结果集
            res = append(res, root.Val)
        }

        dfs(root.Right, level+1)
        dfs(root.Left, level+1)
    } 
    dfs(root, 0)
    return res
}
```

