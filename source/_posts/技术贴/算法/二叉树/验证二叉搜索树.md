---
title: 验证二叉搜索树
date: 2020-05-24 15:16:32
tags: java
categories: 
    - technical
    - leetcode 
toc: true
---

## 题目描述：

[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

>给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：
* 节点的左子树只包含小于当前节点的数。
* 节点的右子树只包含大于当前节点的数。
* 所有左子树和右子树自身必须也是二叉搜索树。

<!-- more -->
示例 1:

![](http://qapzfpul3.bkt.clouddn.com/qiniu_picGo/20200524152005.png)

示例 2：

![](http://qapzfpul3.bkt.clouddn.com/qiniu_picGo/20200524152051.png)

***
## 解决方法：
三种方法：**递归、迭代、中序遍历**

```
/**
 * 已给的树的定义：
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
```

```java
//第一种方法： 递归
//注意： 不能简单的判断左孩子和右孩子与根节点的关系，而是要判断整个左子树以及整个右子树与根节点的关系！
//所以要使用整个区间（low, high）来比较
class Solution {
    public boolean helper(TreeNode node, Integer low, Integer high){
        if(node==null) return true;  //为空数认为是二叉搜索树
        //判断当前节点
        int val = node.val;
        //当前节点的值不在区间内
        if(low != null && val <= low) return false;
        if(high != null && val >= high) return false;
        
        //判断左右节点
        //根据二叉搜索树特性修改区间，每次只修改一个
        if(!helper(node.left, low, val)) return false;   
        if(!helper(node.right, val, high)) return false;
        
        return true;
    }
    
    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }
}
```

```java
//第二种方法： 将递归转换成为迭代   时间复杂度/空间复杂度 与递归相同
class Solution {
    //创建三个栈 java就用LinkedList
    LinkedList<TreeNode> nodeStack = new LinkedList();
    LinkedList<Integer> lowStack = new LinkedList();
    LinkedList<Integer> highStack = new LinkedList();
    
    //更新栈的方法
    public void updateStacks(TreeNode node, Integer low, Integer high){
        nodeStack.push(node);
        lowStack.push(low);
        highStack.push(high);
    }
    
    public boolean isValidBST(TreeNode root) {
        Integer low = null, high = null, val;
        //初始化进栈
        updateStacks(root, low, high);
        
        while(!nodeStack.isEmpty()){
            //出栈
            root = nodeStack.pop();
            low = lowStack.pop();
            high = highStack.pop();
            //判断本节点
            //因为有的节点只有一个孩子或者是叶子节点，所以会把null节点入栈，如果弹出时读到了就continue不然会空指针异常
            if(root == null) continue;   
            val = root.val;
            if(low != null && val <= low) return false;
            if(high != null && val >= high) return false;
            //把左右节点压入栈
            updateStacks(root.left, low, val);
            updateStacks(root.right, val, high);
        }
        
        return true;
    }
}
```

```java
//第三种方法： 二叉树中序遍历  时间复杂度/空间复杂度都为N
//为什么用中序？因为二叉搜索树用中序遍历得到的遍历结果序列是一定升序的
class Solution {
    public boolean isValidBST(TreeNode root) {
        //用一个栈存放节点
        LinkedList<TreeNode> stack = new LinkedList();
        //存放遍历结果的上一个数，用于比较
        Integer inorder = null;
        
        while(!stack.isEmpty() || root != null){  //条件：栈空了，右端也遍历完了才结束（因为可能栈空了但是右边还没遍历完）
            //先到达最左端
            while(root != null){
                stack.push(root);
                root = root.left;
            }
            //开始出栈，检查是否升序
            root = stack.pop();
            //这次的值比上一次的小，那么就返回false不是升序不是二叉搜索树
            if(inorder != null && root.val <= inorder) return false;
            //符合升序，先把当前值记录下来，再按照中序遍历，到右子树
            inorder = root.val;
            root = root.right; 
        }
        return true;
    } 
}
```

二刷:

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */  
// 递归判断，但是要注意不能简单的判断大小关系，因为上层往下层一直都有一个上届或者下届约束
func isValidBST(root *TreeNode) bool {
    var help func(root *TreeNode, lower int, hight int) bool
    help = func(root *TreeNode, lower int, hight int) bool {
        if root == nil {
            return true
        }

        // 判断当前节点值是否在区间内
        if root.Val >= hight {
            return false
        }

        if root.Val <= lower {
            return false
        }

        // 递归判断左右子树
        return help(root.Left, lower, root.Val) && help(root.Right, root.Val, hight) 
    }
    
    return help(root, math.MinInt, math.MaxInt)
}

// 方法二：中序遍历检测
func isValidBST(root *TreeNode) bool {
    stack := make([]*TreeNode, 0)
    beforNum := math.MinInt                 // 记录前一个值，初始化取最小值
    for len(stack) > 0 || root != nil {
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }

        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        // 应该是严格递增
        if root.Val <= beforNum {
            return false
        }
        beforNum = root.Val

        root = root.Right
    }

    return true
}
```

