---
title: 106.从中序与后序遍历序列构造二叉树
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-02-23 21:34:06
---

## 题目描述

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

难度中等

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

 <!-- more -->

**示例 1:**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/tree.jpg)

```
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

**示例 2:**

```
输入：inorder = [-1], postorder = [-1]
输出：[-1]
```

 

**提示:**

- `1 <= inorder.length <= 3000`
- `postorder.length == inorder.length`
- `-3000 <= inorder[i], postorder[i] <= 3000`
- `inorder` 和 `postorder` 都由 **不同** 的值组成
- `postorder` 中每一个值都在 `inorder` 中
- `inorder` **保证**是树的中序遍历
- `postorder` **保证**是树的后序遍历

通过次数163,168

提交次数225,604

## 解题思路及代码

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

// 重要性质：后序遍历数组从后往前看都是根节点
// 递归
func buildTree(inorder []int, postorder []int) *TreeNode {
    // 递归结束条件
    if len(inorder) == 0 || len(postorder) == 0 {
        return nil
    }

    // 当前中间节点
    root := &TreeNode{postorder[len(postorder)-1], nil, nil}

    // 在中序遍历中找到其位置
    Index := findIndex(root.Val, inorder)

    // 递归
    root.Left = buildTree(inorder[:Index], postorder[:Index])
    root.Right = buildTree(inorder[Index+1:], postorder[Index:len(postorder)-1])

    return root
}

func findIndex(target int, nums []int) int {
    for i, v := range nums {
        if v == target {
            return i
        }
    }
    
    return -1
}
```

二刷：

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func buildTree(inorder []int, postorder []int) *TreeNode {
    m, n := len(inorder), len(postorder)
    if m == 0 || n == 0 {
        return nil
    }

    val := postorder[n-1]

    // find index
    idx := 0
    for i, v := range inorder {
        if v == val {
            idx = i
            break
        }
    }

    return &TreeNode{
        val, 
        buildTree(inorder[:idx], postorder[:idx]), 
        buildTree(inorder[idx+1:], postorder[idx:n-1]),
    }
}
```

