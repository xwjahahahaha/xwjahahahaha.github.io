---
title: 230-二叉搜索树中第K小的元素
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-07 10:38:26
---

## 题目描述

#### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

难度中等374

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```

 

 

**提示：**

- 树中的节点数为 `n` 。
- `1 <= k <= n <= 104`
- `0 <= Node.val <= 104`

 

**进阶：**如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 `k` 小的值，你将如何优化算法？


<!-- more -->

## 解题思路及代码

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

 // 对于搜索树,中序遍历的结果就是有序的
func kthSmallest(root *TreeNode, k int) (res int) {
    // order := []int{}
    count := 0
    var helper func(*TreeNode)
    helper = func(node *TreeNode){
        if node == nil {
            return
        }
        // 左
        if node.Left != nil {
            helper(node.Left)
        }
        // 中
        // order = append(order, node.Val)
        count ++
        // 判断是否到达第k个
        if count == k {
            res = node.Val
        }
        // 右
        if node.Right != nil {
            helper(node.Right)
        }
    }
    helper(root)
    return 
}

// 迭代实现中序遍历, 迭代找到后能够提前结束,提高效率
func kthSmallest(root *TreeNode, k int) (res int) {
    stack := []*TreeNode{}
    count := 0
    for root != nil || len(stack) > 0 {
        // 左
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }
        // 中
        // 出栈
        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        count ++ 
        if count == k {
            return root.Val
        }
        // 右
        root = root.Right 
    }
    return -1
}
```

