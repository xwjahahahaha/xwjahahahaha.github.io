---
title: 打家劫舍
tags:
  - java
categories:
  - technical
  - leetcode
  - 动态规划
toc: true
date: 2020-06-05 15:56:44
---

## 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。**
<!-- more -->
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：

输入：`[1,2,3,1]`

输出：4

解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 2：

输入：`[2,7,9,3,1]`

输出：12

解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。


提示：

0 <= nums.length <= 100

0 <= nums[i] <= 400

>来源：力扣（LeetCode）

>链接：https://leetcode-cn.com/problems/house-robber

>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 思路
S(i)表示到当前房屋的最大偷窃金额,H(i)表示当前房屋的金额

对于当前的第i间房屋，偷还是不偷，这是一个问题 --> 看对整体偷窃总额的影响

1. 偷： 那么其前一间房屋不能偷，则最大偷窃总额为: 前i-2个房间的最大偷窃金额S(i-2) + 这个房间的金额H(i)

2. 不偷： 那么到当前第i个房间的最大偷窃总额就是S(i-1)
3. 判断谁大，决定是否偷窃当前房屋

**递推公式为：Sn = max(Sn-1, Sn-2 + Hn)**

## 代码

```java
//第一种方法： 动态规划 + 滚动数组（迭代） 时间复杂度O(N) 空间复杂度O(1)
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if(len == 0) return 0;
        if(len == 1) return nums[0];
        //初始化s0和s1
        int s0 = nums[0], s1 = s0 > nums[1] ? s0 : nums[1];
        if(len == 2) return s1;
        int s2 = 0;
        for(int i=3; i<=nums.length; i++){
            s2 = s1 > s0 + nums[i-1] ? s1 : s0 + nums[i-1];
            //迭代
            s0 = s1;
            s1 = s2;
        }
        return s2;        
    }
}
```

二刷思路：

一个简单的二维思路：

```go
func rob(nums []int) int {
    n := len(nums)
    dp := make([][2]int, n)     // 0: 不偷  1: 偷
    dp[0][0] = 0
    dp[0][1] = nums[0]
    for i:=1; i<n; i++ {
        dp[i][0] = max(dp[i-1][0], dp[i-1][1])  
        dp[i][1] = dp[i-1][0] + nums[i]
    }
    return max(dp[n-1][0], dp[n-1][1])
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

一维的思路:

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 1 {
        return nums[0]
    }
    dp := make([]int, n)
    dp[0] = nums[0]
    dp[1] = max(dp[0], nums[1])
    for i:=2; i<n; i++ {
        // 今天偷或者不偷的最大值
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }
    return dp[n-1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

