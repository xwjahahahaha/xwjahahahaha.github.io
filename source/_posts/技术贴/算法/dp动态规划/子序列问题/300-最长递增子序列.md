---
title: 300.最长递增子序列
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-09 10:15:32
---

## 题目描述

[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

难度中等

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

 <!-- more -->

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

 

**进阶：**

- 你可以设计时间复杂度为 `O(n2)` 的解决方案吗？
- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

## 解题思路及代码

方法一：dp

从后往前填表

```go
// 动态规划, dp[i]表示从第i个位置到数组末尾的最大子序列个数
// 从末尾开始填表或者从开头填表均可
func lengthOfLIS(nums []int) int {
    n := len(nums)
    dp := make([]int, n)
    dp[n-1] = 1     // 初始化临界值
    // 从后往前填表
    for i:=n-2; i>=0; i-- {
        // 确定此位置的最大子序列
        // 遍历从此位置到最后，找最大的
        max := 0
        for j:=i+1; j<n; j++ {
            if nums[j] > nums[i] && dp[j] > max {
                max = dp[j]
            }
        }
        dp[i] = max+1
    } 
    // 遍历dp数组找出最大的
    ans := 0
    for i:=0; i<n; i++ {
        if dp[i] > ans {
            ans = dp[i]
        }
    }  
    return ans
}
```

从前往后填表

```go
package main

/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 给定数组的最长严格上升子序列的长度。
 * @param arr int整型一维数组 给定的数组
 * @return int整型
*/
func LIS( arr []int ) int {
    n := len(arr)
    if n == 0 {
        return 0
    }
    dp := make([]int, n)
    // 初始化
    dp[0] = 1
    // 填表
    for i:=1; i<n; i++ {
        // 遍历从此位置到开头，比自己小的dp值，并找到最大值
        max := 0
        for j:=i-1; j>=0; j-- {
            if arr[i] > arr[j] && dp[j] > max {
                max = dp[j]
            }
        }
        // 设置此位置的dp值
        dp[i] = max+1
    }
    // 遍历dp数组，找出最大值
    max := 0
    for i:=0; i<n; i++ {
        if dp[i] > max {
            max = dp[i]
        }
    }
    return max
}
```

方法二：

```go
// 贪心+二分
// 时间复杂度O(NlogN),空间复杂度O(N)
// 贪心：想要最长每次递增一定要最小，这样才可能最长
// d[i]:表示所有长度为i的最长子序列的最大值的最小值
// 如果nums[i] > d[len] 则直接加入d[i]数组，因为是新的len+1长度的最长子序列
// 否则在d[i]数组中遍历找到d[i-1]<nums[i]<d[i]的位置然后更新d[i]的值，目的是保持长度为i的最长子序列的最大值最小，所以需要更新
func lengthOfLIS(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    d := make([]int, 1)             // 贪心数组, 0下标位置留空
    d = append(d, nums[0])          // 初始化
    for i:=1; i<len(nums); i++ {
        n := len(d)
        if nums[i] > d[n-1] {
            d = append(d, nums[i])
        }else {
            // 更新最小值
            // 二分找到位置
            binarySearch := func(t int) int {
                l, r := 1, n            // 注意这里是1
                for l < r {
                    mid := l + (r-l) >> 1
                    if d[mid] == t {
                        return mid
                    }else if d[mid] > t {
                        r = mid
                    }else {
                        l = mid+1
                    }
                }
                return l
            }
            // 更新
            d[binarySearch(nums[i])] = nums[i]
        }
    }
    return len(d)-1
}
```

二刷：

```go
func lengthOfLIS(nums []int) int {
    // dp[i]表示子数组[:i]（取i位置）最长递增子序列长度
    n := len(nums)
    dp := make([]int, n)
    // 初始化
    dp[0] = 1
    // 按顺序填表
    for i:=1; i<n; i++ {
        max := 0
        // 遍历之前的所有最长子序列
        for j:=0; j<i; j++ {
            // 如果当前的nums[i]<nums[j]则会递增, ++
            if nums[i] > nums[j] && dp[j] > max {
                max = dp[j]
            }
        }
        dp[i] = max+1
    }

    // 找到所有dp中最大的
    max := 0
    for i:=0; i<n; i++ {
        if dp[i] > max {
            max = dp[i]
        }
    }

    return max
}
```

