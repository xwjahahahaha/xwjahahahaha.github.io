---
title: BM65.最长公共子序列二
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-03-01 22:44:00
---

## 题目描述

### 描述

给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回"-1"。目前给出的数据，仅仅会存在一个最长的公共子序列

数据范围：$0 \le |str1|,|str2| \le 2000$

要求：空间复杂度$O(n^2)$ ，时间复杂度 $O(n^2)$

<!-- more -->

### 示例1

输入：

```
"1A2C3D4B56","B1D23A456A"
```

返回值：

```
"123456"
```

### 示例2

输入：

```
"abc","def"
```

返回值：

```
"-1"
```

### 示例3

输入：

```
"abc","abc"
```

返回值：

```
"abc"
```

### 示例4

输入：

```
"ab",""
```

返回值：

```
"-1"
```

## 解题思路及代码

https://blog.csdn.net/hrn1216/article/details/51534607 优秀的题解

```go
package main

// import "fmt"

/**
 * longest common subsequence
 * @param s1 string字符串 the string
 * @param s2 string字符串 the string
 * @return string字符串
*/
func LCS( s1 string ,  s2 string ) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i:=0; i<=m; i++ {
        dp[i] = make([]int, n+1)
    }
    
    // 确定最长公共子序列长度
    for i:=0; i<m; i++ {
        for j:=0; j<n; j++ {
            if s1[i] == s2[j] {
                dp[i+1][j+1] = dp[i][j]+1
            }else {
                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])
            }
        }
    }
    
    // 获取最长公共子序列(不唯一，也是最难的地方), 整体思路就是根据dp表倒推
    // 从后往前比较，如果两个字符相同则代表来自于表斜上方数据即dp[i-1][j-1]
    // 如果两个字符不同，则判断左方和上方哪个数较大（如果相同则两个方向都行，这也是结果不唯一的原因）移动哪个
    i, j, ans := m, n, ""            // i,j 是dp表格的索引
    for i > 0 && j > 0 {
        if s1[i-1] == s2[j-1] {
            // 相同同时--，并将结果保存到结果集
            ans = string(s1[i-1]) + ans
            i--
            j--
        }else {
            if s1[i-1] != s2[j-1] {
                // 如果不相等就选择少一个字符序列和较大的一方--
                if dp[i-1][j] > dp[i][j-1] {
                    i--
                }else {
                    j--
                }
            }
        }
    }
    if dp[m][n] == 0 {
        return "-1"
    }else {
        return ans
    }
}

func max(a, b int) int {
    if a > b {
        return a
    }
    
    return b
}
```

