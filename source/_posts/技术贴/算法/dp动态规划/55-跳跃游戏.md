---
title: 55-跳跃游戏
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-05-07 16:31:58
---

## 题目描述

[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

难度中等1176

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

<!-- more --> 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

 

**提示：**

- `1 <= nums.length <= 3 * 104`
- `0 <= nums[i] <= 105`

通过次数231,638

提交次数550,464

## 解题思路及代码

贪心算法

```go
// 从后往前,动态规划
// 1. 前面有一步可达, 此步可达前一步 2. 此步直接可达末尾
// dp[i] = dp[i+j] || nums[i] >= n-i-1
// 耗时较高564ms, 时间复杂度很高
func canJump(nums []int) bool {
    n := len(nums)
    dp := make([]bool, n)
    dp[n-1] = true
    for i:=n-2; i>=0; i-- {
        for j:=0; j<=nums[i]; j++ {
            dp[i] = dp[i+j] || nums[i] >= n-i-1
            if dp[i] {
                break;
            }
        }        
    }
    return dp[0]
}

// 标记最远位置、贪心算法
// 时间复杂度O(n)
func canJump(nums []int) bool {
    n := len(nums)
    if n==1 {
        return true
    }
    end := 0
    for i:=0; i<n; i++ {
        if i > end {                // 当i大于最远位置时,当前位置已经不可达所以直接返回false
            return false 
        }
        if i + nums[i] > end {      // 替换较大者, 保持最远位置
            end =  i + nums[i]
        }
        if end >= n-1 {             // 当前能够到达最远位置就结束
            return true
        }
    }
    return false
}


// 最早到达的位置、贪心算法
// 时间复杂度O(n)
func canJump(nums []int) bool {
    n := len(nums)
    if n == 1 {
        return true
    }
    start := n-1
    for i:=n-2; i>=0; i-- {
        if nums[i] + i >= start {       // 如果当前位置能够到达上一个最早到达的位置,那么就更新
            start = i   
        }
    }
    return start == 0
}
```

