---
title: BM68矩阵的最小路径和
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-03-03 11:26:29
---

## 题目描述

给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。

数据范围: $1 \le n,m\le 500$，矩阵中任意值都满足 $0 \le a_{i,j} \le 100$

要求：时间复杂度$ O(nm)$

例如：当输入[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]时，对应的返回值为12，

所选择的最小累加和路径如下图所示：

![img](http://xwjpics.gumptlu.work/qinniu_uPic/06EB123C153852AF55ED51448BEAD1BA.png)

<!-- more -->

### 示例1

输入：

```
[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]
```

返回值：

```
12
```

### 示例2

输入：

```
[[1,2,3],[1,2,3]]
```

返回值：

```
7
```

## 解题思路及代码

暴力回溯，超时

```go
// 暴力回溯 超时
func minPathSum( matrix [][]int ) int {
    n, m, min := len(matrix), len(matrix[0]), math.MaxInt64
    var backTrack func(i, j, sum int)
    backTrack = func(i, j, sum int) {
        // 递归结束条件
        if i == n || j == m {
            return 
        }
        // 累加本位置值
        sum += matrix[i][j]
        // 到达右下角,统计最小值
        if i==n-1 && j==m-1 {
            if sum < min {
                min = sum
            }
            return
        }
        // 递归
        backTrack(i+1, j, sum)
        backTrack(i, j+1, sum)
        // 回溯
        sum -= matrix[i][j]
    }
    backTrack(0, 0, 0)
    return min
}
```

动态规划

```go
// 方法二：动态规划
// dp[i][j]表示从左上角位置到i,j位置的最小路径和
func minPathSum( matrix [][]int ) int {
    n, m := len(matrix), len(matrix[0])
    dp := make([][]int, n)
    for i:=0; i<n; i++ {
        dp[i] = make([]int, m)
    }
    // 初始化
    dp[0][0] = matrix[0][0]
    // 填表
    for i:=0; i<n; i++ {
        for j:=0; j<m; j++ {
            if i==0 && j==0 {
                continue
            }
            if i-1 < 0 {
                dp[i][j] = dp[i][j-1] + matrix[i][j]       
            }else if j-1 < 0 {
                dp[i][j] = dp[i-1][j] + matrix[i][j]
            }else {
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]
            }
        }
    }
    return dp[n-1][m-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

