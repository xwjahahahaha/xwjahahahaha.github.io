---
title: 爬楼梯
tags:
  - java
categories:
  - technical
  - leetcode
  - 动态规划
toc: true
date: 2020-05-30 11:50:28
---

## 题目描述

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
<!-- more -->
注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。

1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。

1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

## 解题思路
递归、记忆递归、动态规划等


## 代码

```java
//我的理解：  一个数n求其由1和2构成的不同组合
//第一种方法： 暴力递归  时间复杂度O(2的n次方) 空间复杂度O(n)  超时！
//树形递归每次岔开都是2倍的增长，共n个节点，所以时间复杂度为2的次方，树的深度也就为n
//由题意可以推得一下递推式： 
//f(i, n) = f(i+1, n) + f(i+2, n)
//i表示当前楼梯阶数，n表示目标阶数，f计算总的走法个数

class Solution {
    public int helper(int i, int n){
        if(i > n) return 0;
        if(i == n) return 1;
        return helper(i+1, n) + helper(i+2, n);
    } 
    
    public int climbStairs(int n) {
        return helper(0, n);
    }
}
```
```java
//第二种方法： 记忆递归  时间复杂度O(n) 空间复杂度O(n)(树的深度还是为n)
//根据动态规划的原理，第一种暴力递归每次都有重复的计算量，如果将其记忆下来，第二次则不用递归展开，从而可以降到O（n）
class Solution {
    public int helper(int i, int n, int[] nums){
        if(i > n) return 0;
        if(i == n) return 1;
        //不用考虑i+1和i+2有没有，只要考虑当前i有没有
        //如果当前记忆数组已经有值了,不用算了，直接返回
        if(nums[i] > 0)
            return nums[i];
        //如果没有值则计算并记录
        nums[i] = helper(i+1, n, nums) + helper(i+2, n, nums);
        return nums[i];
    }
    
    public int climbStairs(int n) {
        //记忆数组，默认会初始化各个元素为0
        int[] nums = new int[n+1];
        return helper(0, n, nums);
    }
}
```

动态规划二刷:

```go
func climbStairs(n int) int {
    if n == 0 {
        return 1
    }

    // 1. 定义dp
    // dp[i]表示到达第i层有多少种方法
    dp := make([]int, n+1)

    // 2. 递推式
    // dp[i] = dp[i-1] + dp[i-2]
    
    // 3. 初始化
    dp[0], dp[1] = 1, 1
    
    // 4. 填表顺序,不断累积计算，所以从左到右即可
    for i:=2; i<n+1; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    
    // 5. 返回结果
    return dp[n]
}
```

