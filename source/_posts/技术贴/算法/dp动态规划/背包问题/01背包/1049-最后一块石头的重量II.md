---
title: 1049.最后一块石头的重量II
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-07-30 14:03:21
---

## 题目描述

<!-- more -->

[1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

难度中等

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```

**提示：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`

## 解题思路及代码

```go
// 动态规划：01背包，将石头分为重量接近/相同的两堆
func lastStoneWeightII(stones []int) int {
    n := len(stones)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return stones[0]
    }

    // 1. 计算总重量
    sum, target := 0, 0
    for _, s := range stones {
        sum += s  
    }
    target = sum/2

    // 2. 定义dp[i][j]表示对于[0,i]的范围内获取一些石头，装入可承受重量为j的袋子中的最大重量
    dp := make([][]int, n)
    for i:=0; i<n; i++ {
        dp[i] = make([]int, target+1)
    }

    // 3. 初始化
    // i==0，只要小于第0块石头重量的情况都可以装下
    for j:=0; j<=target; j++ {
        if stones[0] <= j {
            dp[0][j] = stones[0]
        }
    }
    // j==0, 都装不下，默认就是0

    // 4. 递推式

    // 5. 填表顺序
    for i:=1; i<n; i++ {
        for j:=1; j<=target; j++ {
            if j<stones[i] {
                // 拿不了
                dp[i][j] = dp[i-1][j]
            }else {
                // 能拿，拿还是不拿, 取差target最小
                dp[i][j] = max(dp[i-1][j-stones[i]]+stones[i], dp[i-1][j])
            }
        }
    }

    // 5. 确定结果
    // 为总重量的一半的最大重量是dp[n-1][target]
    // 那么剩下的就是sum-dp[n-1][target] (剩下的一定比拿走的大，因为拿走的最多的重量也就是target)
    // 然后计算一下这两者之差即可
    return sum-dp[n-1][target] - dp[n-1][target]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

