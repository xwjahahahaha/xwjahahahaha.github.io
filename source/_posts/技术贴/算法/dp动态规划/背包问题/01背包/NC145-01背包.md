---
title: NC145.01背包
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-02-12 00:29:50
---

## 题目描述

[NC145 01背包](https://www.nowcoder.com/practice/2820ea076d144b30806e72de5e5d4bbf)

已知一个背包最多能容纳体积之和为v的物品

现有 n 个物品，第 i 个物品的体积为 vi , 重量为 wi

求当前背包最多能装多大重量的物品?

<!-- more -->

### 示例1

输入：

```
10,2,[[1,3],[10,4]]
```

返回值：4

说明：第一个物品的体积为1，重量为3，第二个物品的体积为10，重量为4。只取第二个物品可以达到最优方案，取物重量为4   

### 示例2

输入：

```
10,2,[[1,3],[9,8]]
```

返回值：11

说明：两个物品体积之和等于背包能装的体积，所以两个物品都取是最优方案  

## 解题思路及代码

https://www.nowcoder.com/practice/2820ea076d144b30806e72de5e5d4bbf?tpId=117&&tqId=1266316

```go
package main

/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 计算01背包问题的结果
 * @param V int整型 背包的体积
 * @param n int整型 物品的个数
 * @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
 * @return int整型
*/
func knapsack( V int ,  n int ,  vw [][]int ) int {
    // write code here
    // 二维dp[i][j] 表示面对第i个物品，此时包剩余j空间大小最重能够装下的大小
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, V+1)
    }
    
    // 填表
    for i:=1; i<=n; i++ {
        for j:=1; j<=V; j++ {
            if j < vw[i-1][0] {
                dp[i][j] = dp[i-1][j]
            }else {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-vw[i-1][0]] + vw[i-1][1])
            }
        }
    }
    
    return dp[n][V]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
} 
```

二刷，动态规划五步走：

```go
package main

/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 计算01背包问题的结果
 * @param V int整型 背包的体积
 * @param n int整型 物品的个数
 * @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
 * @return int整型
*/
func knapsack( V int ,  n int ,  vw [][]int ) int {
    // 1. 定义dp
    // dp[i][j] 表示从[0, i]中的所有物品中选择总容量为j体积个物品的最高重量(物品只有一个)
    dp := make([][]int, n)
    for i:=0; i<n; i++ {
        dp[i] = make([]int, V+1)
    }
    
    // 2. 递推公式
    // dp[i][j]对于当前第i个物品进行考量:
    // 首先如果当前被包容量<物品i的体积，那么一定不能拿i, 则dp[i][j] = dp[i-1][j]
    // 如果当前背包的体积够用，又要有两种情况考虑：
    // 1. 不拿第i个物品：dp[i][j] = dp[i-1][j], 因为不选不会给总体积带来负担,并且总价值不会变
    // 2. 拿第i个物品：dp[i][j] = dp[i-1][j-v(i)] + w(i)  // 牺牲体积换重量
    // 所以递推公式为: dp[i][j] = max(dp[i-1][j], dp[i-1][j-v(i)]+w(i))
    
    // 3. 初始化
    // 首先j==0时，dp[i][0]的值一定为0，因为没容量
    for i:=0; i<n; i++ {
        dp[i][0] = 0            // 默认为0，所以这一步可以省略
    }
    // 再者，i==0时，如果此时被包容量j>=v(0)那么0号物品才能装下，否则就是为0
    for j:=0; j<=V; j++ {
        if j >= vw[0][0] {
            dp[0][j] = vw[0][1]
        }
    }
    
    // 4. 顺序填表，根据递推公式得知，本次状态依赖于左上方的状态，所以按从左到右从上到下的填表顺序即可
    // 先遍历物品，再遍历体积 
    // (其实两个顺序颠倒也都可以，因为本状态只依赖左上角的状态，而这个状态不管何种顺序都会被先初始化)
    for i:=1; i<n; i++ {                // 物品
        for j:=0; j<=V; j++ {            // 体积
            if j < vw[i][0] {    
                // 背包的体积不够，那么直接继承上一个状态
                dp[i][j] = dp[i-1][j]
            }else {
                // 背包的体积足够，那么比较拿或者不拿第i个的最大体积
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-vw[i][0]]+vw[i][1])
            }
        }
    }
    
    return dp[n-1][V]
}

func max(a, b int) int {
    if a < b {
        return b
    }
    
    return a
}
```

优化：一维dp数组（滚动数组）

```go
// knapsack dp状态压缩，使用一维数组
func knapsack( V int ,  n int ,  vw [][]int ) int {
    // 状态转移方式： dp[i][j] = max(dp[i-1][j], dp[i-1][j-v(i)]+w(i))
    // 想象在计算第i行时，先将i-1行复制到第i行，那么状态转移方程就变为：
    // dp[i][j] = max(dp[i][j], dp[i][j-v(i)]+w(i))
    // 与其这样每一行向下拷贝，不如直接使用一个一维数组不断覆盖即可，即dp[j]
    // dp[j] = max(dp[j], dp[j-v(i)]+w(i)), i是物品，j是背包容量
    
    dp := make([]int, V+1)
    
    // 初始化, 因为最小重量就是0，所以都初始化为0即可(如果题目的价值有负数，那么要初始化为最小的负值)
    
    for i:=0; i<n; i++ {
        // 注意：这里的j只能倒叙遍历，因为考虑如下场景
        // 第1块物品的体积是1，重量是15
        // 按从左往右的顺序（只看后半部分，因为初始化都为0）：
        // dp[1] = dp[1-v(1)]+w(1) = 15
        // dp[2] = dp[2-v(1)]+w(1) = dp[1]+w(1) = 30 (i还是为1，因为先遍历的i，还在i==1的循环中) 
        // 由此可以看到在计算dp[2]的时候第一个物品被拿了两次！
        // 因为我们对状态进行了压缩，所以不会像二维数组那样遍历体积的时候顺序无所谓，因为二维的上一层保存了i-1数据
        // 而我们是在复用i层，所以要从后往前遍历
        // 注意：这里也不能先遍历j(背包容量)再遍历物品i
        // 因为想象对于某个容量j，不断遍历i找到最大的重量，最后一定只会放一个物品，所以这是不正确的
        for j:=V; j>=0; j-- {       
            // 当小于的时候就是上一次i-1的值，已经覆盖过来了，所以不考虑
            if j >= vw[i][0] {
                dp[j] = max(dp[j], dp[j-vw[i][0]] + vw[i][1])
            }
        }   
    }
    
    return dp[V]
}

func max(a, b int) int {
    if a < b {
        return b
    }
    
    return a
}
```

