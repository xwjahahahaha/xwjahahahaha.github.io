---
title: 416.分割等和子集
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-07-30 12:58:03
---

## 题目描述

<!-- more -->

[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

难度中等

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

通过次数302,039

提交次数580,437

## 解题思路及代码

```go
func canPartition(nums []int) bool {
    n := len(nums)
    if n < 2 {
        return false
    }
    // 计算数组和和maxNum
    var sum, maxNum int
    for i:=0; i<n; i++ {
        sum += nums[i]
        if nums[i] > maxNum {
            maxNum = nums[i]
        }
    }

    // 如果sum为奇数则一定无法二分为两个集合，如果maxNum > sum那么页一定不能二分为两个集合，排除掉这两种情况
    if sum % 2 != 0 || maxNum > sum {
        return false
    }
    
    // 当前的目标：01背包问题，选择部分数字使得选取的数字总和为target=sum/2
    // 1. dp[i][j] 表示[0,i-1]个数选择总和为j是否可以
    target := sum/2
    dp := make([][]bool, n)
    for i:=0; i<n; i++ {
        dp[i] = make([]bool, target+1)
    }

    // 2. 初始化
    // 考虑j==0
    for i:=0; i<n; i++ {
        // 不选就一定能让总和为0
        dp[i][0] = true
    } 
    // 考虑i==0
    // 只有刚好为nums[0]才为true
    if nums[0] <= target {
        dp[0][nums[0]] = true
    }

    // 3. 推演/填表
    for i:=1; i<n; i++ {
        for j:=1; j<=target; j++ {
            if nums[i] > j {
                // 不能选取
                dp[i][j] = dp[i-1][j]
            }else {
                // 考虑两种情况，只要有一种为true就为true
                // 不拿 || 拿
                dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]
            }
        }
    }

    return dp[n-1][target]
}
```

