---
title: 343.整数拆分
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-07-10 15:14:00
---

## 题目描述

[343. 整数拆分](https://leetcode.cn/problems/integer-break/)

难度中等

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 <!-- more -->

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

**提示:**

- `2 <= n <= 58`

## 解题思路及代码

动态规划

```go
func integerBreak(n int) int {
    // 1. dp[i]表示拆分正整数i后所有数的最大乘积
    dp := make([]int, n+1)
    // 2. 递推公式: 
    // 这里是比较困难的地方
    // 假如拆成两个数(也是拆分最小的情况)：i=a*b,其中a+b=i; 
    // 如果要最大，那么就期望a和b这两块乘积都为最大，那么就需要考虑两件事：
    // 1. a能不能继续拆，能拆则要求拆掉之后的乘积比原本(即a)大
    // 2. 同理,b能不能拆，能拆则要求拆掉之后的乘积比原本(即b)大
    // 对于a来说可以用j=1～i来遍历，代表不断拆a，得到最大值
    // 对于b来说可以用上一次的状态来复用，即比较b本身(也即i-j)大小与dp[b]也即(dp[i-j])谁更大
    // 为什么不用拆分b，因为上一次dp状态已经告诉了我们拆分后的最大乘积是多少了（把握住dp的含义）
    // 所以递推公式: dp[i] = max( for(j = 1~i-1) max(j*(i-j), j*dp[i-j]) )

    // 3. 初始化,为了符合dp的定义，所以不初始化0,1因为这两个数都是不能拆分的，初始化之后是没有意义的
    // dp[2]拆分后的最大乘积就是1
    dp[2] = 1

    // 4. 填表顺序：从左到右
    for i:=3; i<n+1; i++ {
        maxMul := 0
        for j:=1; j<i; j++ {
            nowMul := max(j*(i-j), j*dp[i-j])
            if nowMul > maxMul {
                maxMul = nowMul
            }
        }
        dp[i] = maxMul
    }

    // 5. 计算结果
    return dp[n]
}

func max(a, b int) int {
    if a < b {
        return b
    }

    return a
}
```

