---
title: 63.不同路径II
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-07-09 19:42:13
---

## 题目描述

[63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

难度中等

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

 <!-- more -->

**示例 1：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/robot1.jpg)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

**示例 2：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/robot2.jpg)

```
输入：obstacleGrid = [[0,1],[0,0]]
输出：1
```

 

**提示：**

- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` 为 `0` 或 `1`

## 解题思路及代码

```go
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    m := len(obstacleGrid)
    if m == 0 {
        return 0
    }

    n := len(obstacleGrid[0])

    // 1. 定义dp
    // dp[i][j]表示到(i, j)位置的路径个数
    dp := make([][]int, m)
    for i:=0; i<m; i++ {
        dp[i] = make([]int, n)
    }

    // 2. 递推式
    // dp[i][j] = [dp[i-1][j])] + [dp[i][j-1]]
    
    // 3. 初始化
    if obstacleGrid[0][0] == 1 {
        return 0
    }else {
        dp[0][0] = 1
    }
    
    // 对于第一列，如果有一个障碍物，那么全为0
    for i:=1; i<m && obstacleGrid[i][0] == 0; i++ {     // 一旦有一个为障碍物则后面的都为0即不变
        dp[i][0] = dp[i-1][0]
    }

    // 第一行同理
    for i:=1; i<n && obstacleGrid[0][i] == 0; i++ {
        dp[0][i] = dp[0][i-1]
    }
    
    // 4. 填表顺序
    for i:=1; i<m; i++ {
        for j:=1; j<n; j++ {
            left := dp[i-1][j]
            if obstacleGrid[i-1][j] == 1 {
                left = 0
            }

            top := dp[i][j-1]
            if obstacleGrid[i][j-1] == 1 {
                top = 0
            }
            
            // 判断此位置本身是不是障碍物
            if obstacleGrid[i][j] == 1 {
                dp[i][j] = 0
            }else {
                dp[i][j] = left + top
            }
        }
    }

    // 5. 计算结果
    return dp[m-1][n-1]
}
```

