---
title: 139_单词拆分
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-02-15 00:15:59
---

## 题目描述

[139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

难度中等

给定一个**非空**字符串 *s* 和一个包含**非空**单词的列表 *wordDict*，判定 *s* 是否可以被空格拆分为一个或多个在字典中出现的单词。

<!-- more -->

**说明：**

- 拆分时可以重复使用字典中的单词。
- 你可以假设字典中没有重复的单词。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

## 解题思路及代码

https://leetcode-cn.com/problems/word-break/solution/shou-hui-tu-jie-san-chong-fang-fa-dfs-bfs-dong-tai/

* 方法一： DFS

  构建递归树

  ![ig85fY](http://xwjpics.gumptlu.work/qinniu_uPic/ig85fY.jpg)

  ![IMG_0096](http://xwjpics.gumptlu.work/qinniu_uPic/IMG_0096.jpg)

  避免重复操作，记录中间值

  图中红色代表start

  ![uIWkCz](http://xwjpics.gumptlu.work/qinniu_uPic/uIWkCz.jpg)

  ![DvvXcR](http://xwjpics.gumptlu.work/qinniu_uPic/DvvXcR.jpg)

  ![IMG_0095](http://xwjpics.gumptlu.work/qinniu_uPic/IMG_0095.jpg)
  
  ```go
  //DFS
  //采用单词拆分的方式，画出递归回溯方法
  
  //wordMap是保存当前字符串是否在wordDict中存在，在为true否则为false
  //memo用来记录中间结果，防止超时,标识为start值
  func canBreak(start int, s string, wordMap map[string]bool, memo map[int]bool) bool{
      //空串为true
      if start == len(s) {
          return true
      }
      //先看是否有记录，避免重复耗时
      if res, ok := memo[start]; ok{
          return res
      }
      for i:=start+1; i<=len(s); i++{
          //获取前缀字符串
          prefix := s[start:i]
          //判断前缀字符串是否在wordDict中以及对剩下的字符串进行递归
          if wordMap[prefix] && canBreak(i, s, wordMap, memo){
              //记录
              memo[start] = true
              return true
          }
      }
      //i到底还没有return true那么就返回false
      memo[start] = false
      return false
  }
  
  func wordBreak(s string, wordDict []string) bool {
      wordMap := map[string]bool{}
      for _, v := range wordDict {
          wordMap[v] = true
      }
      return canBreak(0, s, wordMap, make(map[int]bool))
  }
  ```
  
* 方法二：BFS

	![5sqzmo](http://xwjpics.gumptlu.work/qinniu_uPic/5sqzmo.jpg)

	![IMG_0097](http://xwjpics.gumptlu.work/qinniu_uPic/IMG_0097.jpg)

	```go
  //BFS 
  //采用队列结构，唯一返回true的条件是当前前缀合法且下标i越界（到末尾）
  //同样的使用memo记录唯一标识start是否已经被考察，减少重复计算，考察过为true，否则为false
  func wordBreak(s string, wordDict []string) bool {
      length := len(s)
      //同样的创建wordMap来判断当前前缀是否在wordDist存在/合法
      wordMap := make(map[string]bool)
      for _, v := range wordDict {
          wordMap[v] = true
      }
      //创建记忆数组
      memo := make(map[int]bool)
      queue := []int{}
      //插入初始值0
      queue = append(queue, 0)
      for len(queue) > 0 {
          //弹出当前队列元素
          start := queue[0]
          queue = queue[1:]
          //判断是否已经考察过
          if memo[start] {
              continue
          }
          //弹出代表已经被考察过了记录为true
          memo[start] = true
          for i:=start+1; i<=length; i++{
              prefix := s[start:i]
              //只有是合法单词才判断
              if wordMap[prefix] {
                  if i < length {
                      //是合法单词，但是还未切完，那么加入队列继续考察
                      queue = append(queue, i)
                  }else {
                      //是合法单词且i到达末尾，那么就可以返回true
                      
                      return true
                  }
              }
          }
      }
      //如果循环结束还未返回true，则说明无法拆分
      return false
  }
  ```

* 方法三：动态规划

  ```go
  
  // 动态规划
  //当前长度为len的单词是否能用单词表表示问题拆分为子问题：
  //对于划分点j
  //1. 字符串[0:j]是否可以被单词表表示
  //2. [j:len]是否是单词表中的一个单词
  //两者同时满足则整体满足
  //dp[len+1] 表示s[0:len]字符串是否能被表示
  //递推式：dp[i] = dp[j] && s[i:j]是否合法, i表示末尾,一直移动直到length,整体是[0: j: i]
  //base case dp[0] = true空串满足题意
  func wordBreak(s string, wordDict []string) bool {
      length := len(s)
      dp := make([]bool, length+1)
      dp[0] = true
      wordMap := map[string]bool{}
      for _, v := range wordDict{
          wordMap[v] = true
      }
      //i用于考量s(0, i)字符串
      for i:=1; i<=length; i++{
          for j:=i-1; j>=0; j--{
              suffix := s[j:i]
              if dp[j] && wordMap[suffix] {
                  dp[i] = true
                  //此时s(0, i)已经能划分为单词表单词了，所以不必在移动j
                  break
              }
          }
      }
      return dp[length]
  }
  ```

二刷：

```go
// dp[i]表示s[:i]子串(i位置不取)是否能够拼接单词/被表示
func wordBreak(s string, wordDict []string) bool {
    n := len(s)
    dp := make([]bool, n+1)
    // 转换wordDict为map
    wordMap := make(map[string]bool)
    for _, str := range wordDict {
        wordMap[str] = true
    }
    // 初始化
    dp[0] = true
    // 填表
    for i:=1; i<=n; i++ {
        // j表示将s[:i]分为s1=s[:j]=dp[j]和s2=s[j:i]
        for j:=0; j<i; j++ {
            // 一旦有true就为true
            if dp[j] && wordMap[s[j:i]] {
                dp[i] = true
                break
            }
        }
    }
    
    return dp[n]
}
```

