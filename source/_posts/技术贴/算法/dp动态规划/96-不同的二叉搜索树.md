---
title: 96.不同的二叉搜索树
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-07-10 15:18:20
---

## 题目描述

[96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

难度中等

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

 <!-- more -->

**示例 1：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

 

**提示：**

- `1 <= n <= 19`

## 解题思路及代码

动态规划

```go
func numTrees(n int) int {
    //1. dp[i]表示有i个元素组成的二叉搜索树的种树
    dp := make([]int, n+1)

    // 2. 递推公式
    // 观察n=3的树形结构
    // dp[3] = 根为1的所有树种类数量 + 根为2的所有树的种类数量 + 根为3的所有树的种类数量
    // 根为1的所有树的种类数量 = 左子树0个元素的数量(即dp[0]) * 右子树2个元素的数量(即dp[2])
    // 根为2的所有树的种类数量 = 左子树1个元素的数量(即dp[1]) * 右子树1个元素的数量(即dp[1])
    // 根为3的所有树的种类数量 = 左子树2个元素的数量(即dp[2]) * 右子树0个元素的数量(即dp[0])
    // 所以递推公式就为:
    // dp[i] = dp[i] + dp[j]*dp[i-1-j] (j=0~i-1)

    // 3. 初始化
    dp[0], dp[1] = 1, 1

    // 4. 顺序填表
    for i:=2; i<n+1; i++ {
        for j:=0; j<i; j++ {
            dp[i] += dp[j] * dp[i-1-j]
        }
    }
    
    // 5. 返回结果
    return dp[n]
}
```

