---
title: 887-鸡蛋掉落
tags:
  - java
categories:
  - technical
  - leetcode
toc: true
date: 2021-01-26 15:09:43
---

## 题目描述

#### [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

难度困难557

你将获得 `K` 个鸡蛋，并可以使用一栋从 `1` 到 `N` 共有 `N` 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 `F` ，满足 `0 <= F <= N` 任何从高于 `F` 的楼层落下的鸡蛋都会碎，从 `F` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次*移动*，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 `X` 扔下（满足 `1 <= X <= N`）。

你的目标是**确切地**知道 `F` 的值是多少。

无论 `F` 的初始值如何，你确定 `F` 的值的最小移动次数是多少？

 <!-- more -->

**示例 1：**

```
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
```

**示例 2：**

```
输入：K = 2, N = 6
输出：3
```

**示例 3：**

```
输入：K = 3, N = 14
输出：4
```

 

**提示：**

1. `1 <= K <= 100`
2. `1 <= N <= 10000`

## 解题思路及代码

此题较难，见官方题解：

https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/

简单说就是使用动态规划的方法得出以下公式：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20210126151126.png)

![](http://xwjpics.gumptlu.work/qiniu_picGo/20210126151237.png)

![](http://xwjpics.gumptlu.work/qiniu_picGo/20210126151301.png)

公式理解一点:<font color='green'>最坏情况下，就是找两个子状态的取最大值函数（也就是图中蓝线函数）的最小值（图中就是两个函数的交点可以使蓝色函数最小）</font>

再对于公式中![](http://xwjpics.gumptlu.work/qiniu_picGo/20210126151450.png)部分进行优化，不然按序遍历时间复杂度会是N的平方，优化的方式就是二分法。通过离散函数的二分法找最近距离“交点”实现优化的找到最小值。

算法代码：

```java
class Solution {
    public int superEggDrop(int K, int N) {
        return dp(K, N);
    }   
    //唯一记录各个状态,节省动态规划开销
    //key是以 N*100 + K 作为唯一标记， value是当前状态的最少移动次数
    Map<Integer, Integer> memo = new HashMap<>();
    //动态规划函数
    public int dp(int K, int N){
        //判断当前状态是否已经存在
       if(!memo.containsKey(N*100 + K)){
           int ans;
           //计算当前状态的最小次数
           //判断一些特殊情况:
           if(N == 0){
               //只有0层那么就不需要仍鸡蛋，0次
               ans = 0;
           }else if(K == 1){
               //如果只有一个鸡蛋,那么不论N（N>0）层都要试N次(一个鸡蛋只能一层一层试)
               ans = N;
           }else{
               //对公式X的取值遍历区间进行优化
               //二分法查找出符合两个子状态最大值的最小值的X0楼层
               int lo = 1, hi= N;
               while(lo + 1 < hi){
                   int x = (lo + hi) / 2;
                   int t1 = dp(K-1, x-1);       //子状态1: 单调递增     
                   int t2 = dp(K, N-x);         //子状态2: 单调递减
                   if(t1 > t2){
                       hi = x;
                   }else if(t1 < t2){
                       lo = x;
                   }else{
                       lo = hi = x;
                   }
               }
               //计算当前X0 和 X1 (X1就是X0+1) 的两个子状态最大值的最小值
               ans = 1 + Math.min((Math.max(dp(K, N-lo), dp(K-1, lo-1))), (Math.max(dp(K, N-hi), dp(K-1, hi-1))));
           }
           //记录到中间状态
           memo.put(N*100 + K, ans);
           //返回
           return ans;
       } 
       //如果是已经存在就直接返回
       return memo.get(N*100 + K);
    }
}
```





