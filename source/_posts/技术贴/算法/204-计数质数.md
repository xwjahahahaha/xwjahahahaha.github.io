---
title: 204.计数质数
tags:
  - java
categories:
  - technical
  - leetcode
toc: true
date: 2020-06-21 22:19:09
---

## 题目描述

统计所有小于非负整数 n 的质数的数量。

示例:

>输入: 10

>输出: 4

>解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。

<!-- more -->

## 代码

```java
// 直接的思路： 遍历，判断指数累计   s时间复杂度O(N的3/2次方) 空间复杂度O(1)
class Solution {
    public int countPrimes(int n) {
        int count = 0;
        for(int i=2; i<n; i++){
            boolean flag = true;
            for(int j=2; j<=Math.sqrt(i) && flag; j++)
                if(i%j==0) flag = false;
            if(flag)
                count++;
        }
        return count;
    }
}
```


```java
//(构造素数表法)埃拉托色尼筛法 Sieve of Eratosthenes  时间复杂度O(N * loglogN)  空间复杂度O(N)
class Solution {
    public int countPrimes(int n) {
        // 创建空数组，默认初始化就是全0，0为素数，1为合数
        int[] array = new int[n];
        int count = 0;
        // 注意：这里的循环也可以优化到sqrt(n)
        for(int i=2; i<Math.sqrt(n); i++)
            // 如果当前数为素数那么其倍数全部标记为1合数
            if(array[i] == 0)
                // 重点在这里！！！ 优化冗余的计算
                for(int j = i*i; j < n; j+=i)
                    array[j] = 1;       
        // 统计素数总个数
        for(int i=2; i<n; i++)
            if(array[i] == 0)
                ++count;
        return count;
    }
}
```
## 重点分析
第二种筛选法内部循环中的冗余情况：

原版代码：
```java
for(int j = 2*i; j < n; j+=i)
  array[j] = 1;
```
比如 n = 25，i = 4 时算法会标记 4 × 2 = 8，4 × 3 = 12 等等数字，但是这两个数字已经被 i = 2 和 i = 3 的 2 × 4 和 3 × 4 标记了。

从当前素数自身的平方开始筛选，这样能够有效的减少这种冗余计算

```java
for(int j = i*i; j < n; j+=i)
  array[j] = 1;
```

> 作者：gumptlu

> 链接：https://leetcode-cn.com/problems/count-primes/solution/gou-zao-su-shu-biao-shai-xuan-by-gumptlu/

> 来源：力扣（LeetCode）

> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。