---
title: 239.滑动窗口最大值
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-23 13:52:58
---

## 题目描述

[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

难度困难1359

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

<!-- more --> 

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

**示例 3：**

```
输入：nums = [1,-1], k = 1
输出：[1,-1]
```

**示例 4：**

```
输入：nums = [9,11], k = 2
输出：[11]
```

**示例 5：**

```
输入：nums = [4,-2], k = 2
输出：[4]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`

通过次数227,421

提交次数457,169

## 解题思路及代码

```go
// 堆, 维护一个大小为k的大顶堆
// 每次移动,如果此时堆顶不在滑动窗口中，那么删除堆顶直到堆顶元素在窗口中，因为这个数不会在后续成为窗口的最大值了
// 时间复杂度O(NlogN), 空间复杂度O(N)
func maxSlidingWindow(nums []int, k int) []int {
    heap, ans := maxHeap([]*node{&node{}}), make([]int, 0)
    for i, num := range nums {
        // 将前k个加入堆
        if i <= k-1 {
            heap.shiftUp(&node{num, i})
            if i == k-1 {
                ans = append(ans, heap[1].num)
            }
        }else {
            // 加一，删除判断
            heap.shiftUp(&node{num, i})
            // 不断删除
            for len(heap) > 1 && heap[1].index < i-k+1 {
                heap.shiftDown()
            }
            ans = append(ans, heap[1].num)
        }
    }
    return ans
}

type node struct {
    num int
    index int
}

type maxHeap []*node

func (m *maxHeap) shiftUp(newNode *node) {
    *m = append(*m, newNode)
    index := len(*m)-1
    for index > 1 && (*m)[index].num > (*m)[index/2].num {
        (*m)[index], (*m)[index/2] = (*m)[index/2], (*m)[index]
        index /= 2 
    }
}

func (m *maxHeap) shiftDown() {
    (*m)[1] = (*m)[len(*m)-1] 
    *m = (*m)[:len(*m)-1]
    index := 1
    for index < len(*m) {
        maxIndex := index
        if index*2 < len(*m) && (*m)[index*2].num > (*m)[maxIndex].num {
            maxIndex = index*2
        }  
        if index*2+1 < len(*m) && (*m)[index*2+1].num > (*m)[maxIndex].num {
            maxIndex = index*2+1
        }  
        if maxIndex == index {
            break
        }
        (*m)[index], (*m)[maxIndex] = (*m)[maxIndex], (*m)[index]
        index = maxIndex
    }
}



// 方法二：双端递减队列
// 如果当前滑动窗口内的两个下标：i<j两个位置的数nums[i]<=nums[j]，那么只要i的数字还在窗口，那么j也一定在 （i不在了就不一定了）
// 那么，i和j同时在的情况下，i就被j给屏蔽了，窗口的最大值一定是不会是nums[i]，所以可以删除nums[i]
// 所以可以维护一个单调递减栈，栈内单调递减是为了维护窗口可能的最大值（因为小的nums[i]都被删除了，怎么删？见下面）
// 如果窗口滑动遇到下一个数，这个数比栈尾数大，那么就可以排除掉栈中比他小的数了，不断比较直到栈尾数>这个数或者栈==0
// 此时栈顶的数就是滑动窗口的最大值，但是可能不在窗口中了，所以还需要不断出栈首元素直到在窗口中
// 这就是一个双向递减队列
// 时间复杂度O(N), 空间复杂度O(k)
func maxSlidingWindow(nums []int, k int) []int {
    queue := []int{}            // 存放下标
    push := func(index int) {
        // 和队列尾比较大小
        for len(queue) > 0 && nums[index] >= nums[queue[len(queue)-1]] {
            queue = queue[:len(queue)-1]
        }
        // 加入
        queue = append(queue, index)
    }
    // 将前k个加入队列
    for i:=0; i<k; i++ {
        push(i)
    }
    ans := make([]int, len(nums)-k+1)
    ans[0] = nums[queue[0]]
    // 遍历后续
    for i:=k; i<len(nums); i++ {
        push(i)
        // 判断队列头是否在窗口中,比较窗口左侧
        for queue[0] < i-k+1 {
            queue = queue[1:]
        }
        ans[i-k+1] = nums[queue[0]]
    }
    return ans
}
```

二刷

```go
type point struct {
    v int
    idx int             // 下标
}

type maxHeap []*point

func (m *maxHeap) shiftUp(v *point) {
    *m = append(*m, v)
    i := len(*m)-1
    for i>1 && (*m)[i/2].v < (*m)[i].v {
        (*m)[i/2], (*m)[i] = (*m)[i], (*m)[i/2]
        i /= 2
    }
}

func (m *maxHeap) shiftDown() *point {
    if len(*m) <= 1 {
        return nil
    }

    res := (*m)[1]
    (*m)[1] = (*m)[len(*m)-1]
    *m = (*m)[:len(*m)-1]
    i := 1
    for {
        maxIdx := i
        if i*2 < len(*m) && (*m)[i*2].v > (*m)[maxIdx].v {
            maxIdx = i*2
        }
        if i*2+1 < len(*m) && (*m)[i*2+1].v > (*m)[maxIdx].v {
            maxIdx = i*2+1
        }
        if maxIdx == i {
            break
        }

        // swap
        (*m)[maxIdx], (*m)[i] = (*m)[i], (*m)[maxIdx]
        i = maxIdx
    }

    return res
}


// top大问题：堆
func maxSlidingWindow(nums []int, k int) []int {
    newMaxHeap := maxHeap([]*point{&point{}})
    res := make([]int, 0)
    l, r, n := 0, 0, len(nums)

    for r=0; r<n && r<k; r++ {
        newMaxHeap.shiftUp(&point{nums[r], r})
    }

    res = append(res, newMaxHeap[1].v)
    if r == n {
        // k>=n
        return res 
    }

    r--         // 注意上面的r++现在先减回来一个

    // move
    for {
        r++
        if r == n {
            break
        }
        newMaxHeap.shiftUp(&point{nums[r], r})
        l++
        // 当前的l位置与大顶堆位置比较
        for len(newMaxHeap) > 1 && l > newMaxHeap[1].idx {
            // 如果堆顶不在区间范围内，就一直出堆，直到新的堆顶在范围内
            // 为什么新的堆顶一定在区间范围内，因为加入的时候就是按区间加入的
            // 不断出堆才能保证旧的较大的数被区间排除在外
            newMaxHeap.shiftDown()
        }
        
        // 获取当前区间最大值
        res = append(res, newMaxHeap[1].v)
    }

    return res
}
```

