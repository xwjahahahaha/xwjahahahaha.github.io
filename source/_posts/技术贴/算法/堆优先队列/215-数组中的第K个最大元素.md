---
title: 215-数组中的第K个最大元素
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-29 10:52:31
---

## 题目描述

[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

难度中等

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

<!-- more -->

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明:** 

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

## 解题思路及代码

三种方法: 直接排序、最小堆topK、快速选择+随机化

```go
// 直接的思路:排序算法
// 时间复杂度O(nlogn) 空间复杂度O(1)
func findKthLargest(nums []int, k int) int {
    var find_mid func(int, int) int
    var quick_sort func(int, int)
    find_mid = func(l, r int) int {
        pivot := nums[l]
        for l < r {
            for nums[r] >= pivot && l < r {
                r --
            }
            nums[l] = nums[r]
            for nums[l] <= pivot && l < r {
                l ++
            }
            nums[r] = nums[l]
        }
        nums[l] = pivot
        return l      
    }
    quick_sort = func(l, r int) {
        if l <= r {
            mid := find_mid(l, r)
            quick_sort(l, mid-1)
            quick_sort(mid+1, r)
        }
    }
    quick_sort(0, len(nums)-1)
    return nums[len(nums)-k]
}

// 构造规模为k的小顶堆(维护nums中k个最大值,最小堆顶即为第k大元素)
// 时间复杂度O(nlogk) 空间复杂度O(k)
type IntHeap []int
func findKthLargest(nums []int, k int) int {
    // 创建堆
    h := &IntHeap{}
    heap.Init(h)
    for _, v := range nums {
        heap.Push(h, v)
        if h.Len() > k {
            heap.Pop(h)
        }
    }
    return heap.Pop(h).(int)
}
// 实现堆方法
func (h IntHeap)Len() int { return len(h) }
func (h IntHeap)Less(i, j int) bool { return h[i] < h[j] }      // 小顶堆
func (h IntHeap)Swap(i, j int) { h[i], h[j] = h[j], h[i]}
func (h *IntHeap)Push(x interface{}) {
    *h = append(*h, x.(int))
}
func (h *IntHeap)Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[:n-1]
    return x
}


// 快速选择
// 时间复杂度O(N)(加随机) 空间复杂度O(logN)
func findKthLargest(nums []int, k int) int {
    var partition func(int, int) int
    var randomPivot func(int, int)
    var quick_sort func(int, int) int

    partition = func(l, r int) int {
        pivot := nums[l]
        for l < r {
            for nums[r] >= pivot && l < r {
                r --
            }
            nums[l] = nums[r]
            for nums[l] <= pivot && l < r {
                l ++
            }
            nums[r] = nums[l]
        }
        nums[l] = pivot
        return l      
    }

    rand.Seed(time.Now().UnixNano())        // 随机种子
    randomPivot = func(l, r int){
        randIdx := rand.Int() % (r - l + 1) + l             // 随机选择一个下标
        nums[l], nums[randIdx] = nums[randIdx], nums[l]     // 与最左边交换
    } 

    quick_sort = func(l, r int) int {
        if l <= r {
            randomPivot(l, r)                   // 随机化处理
            pivot := partition(l, r)            // 分区
            index := len(nums) - k
            if pivot == index {                 // 判断轴位置,如果满足第k个就直接返回
                return nums[pivot]
            }else if pivot < index {
                return quick_sort(pivot+1, r)   // 轴左,目标在右 
            } 
           return quick_sort(l, pivot-1)        // 轴右,目标在左
        }
        return -1
    } 
    return quick_sort(0, len(nums)-1)
}
```

```go
// 自己构造小顶堆

// topk大使用小顶堆
type minHeap []int

func (h *minHeap) shiftUp(v int) {
    *h = append(*h, v)
    i := len(*h)-1
    // 调整堆结构
    for i > 1 && (*h)[i] < (*h)[i/2] {
        // 与根节点比较
        (*h)[i], (*h)[i/2] = (*h)[i/2], (*h)[i]
        i /= 2
    }
}

func (h *minHeap) shiftDown() {
    // 最后一个节点赋值给根节点
    n := len(*h)
    (*h)[1] = (*h)[n-1]
    // 堆规模减小1
    *h = (*h)[:n-1]
    // 调整堆
    minPoint, i := 1, 1
    for {
        if i*2 < n-1 && (*h)[i] > (*h)[i*2] {
            minPoint = i*2
        }
        if i*2+1 < n-1 && (*h)[minPoint] > (*h)[i*2+1] {
            minPoint = i*2+1
        }
        if minPoint == i {
            break
        }
        (*h)[i], (*h)[minPoint] = (*h)[minPoint], (*h)[i]
        i = minPoint
    }
}

func findKthLargest(nums []int, k int) int {
    myminHeap := minHeap([]int{0})
    for i := range nums {
        myminHeap.shiftUp(nums[i])
        if i >= k {
           myminHeap.shiftDown()
        }
    }
    return myminHeap[1]
}
```



牛客二刷

```go
package main

import "math/rand"

/**
 * 
 * @param a int整型一维数组 
 * @param n int整型 
 * @param K int整型 
 * @return int整型
*/

// 思路：快速选择
// 注意：题目要找的不是去重后的第k大的元素，而是重复也可以的排序后的第k大个元素
func findKth( a []int ,  n int ,  K int ) int {
    return quickChoose(a, 0, n-1, K)
}

func quickChoose(nums []int, l, r, k int) int {
    if l <= r {
        // 获得一个数的绝对位置
        // 随机化
        randIndex := rand.Int() % (r-l+1) + l
        nums[randIndex], nums[l] = nums[l], nums[randIndex]
        numsIndex := getMid(nums, l, r)
        // 判断是否是第k个
        nowLocal := len(nums) - numsIndex
        if nowLocal == k {
            return nums[numsIndex]
        }else if nowLocal < k {
            // 当前位置小于k，递归左边
            return quickChoose(nums, l, numsIndex-1, k)
        }else {
            // 当前位置大于k，递归右边
            return quickChoose(nums, numsIndex+1, r, k)
        }
    }
    return -1
}

// 确定一个数的绝对位置（其前后位置顺序不一定是正确的）
func getMid(nums []int, l, r int) int {
    pivot := nums[l]
    for l < r {
        for l < r && nums[r] >= pivot { r-- }
        nums[l]  = nums[r]
        for l < r && nums[l] <= pivot { l++ }
        nums[r] = nums[l]
    }
    nums[l] = pivot
    return l
}
```

