---
title: 23.合并K个升序链表
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-16 21:44:04
---

## 题目描述

[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

难度困难1691

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

<!-- more --> 

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

 

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

通过次数373,150

提交次数663,044

## 解题思路及代码

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
// 方法一：不断合并两个链表，直到就剩一个链表
// 时间复杂度O(N*k^2),因为每个链表都需要和其他k-1个链表合并一次，所以是k^2
func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    // 不断合并直到为一个
    for len(lists) > 1 {
        lists = append(lists, mergeTwoLists(lists[0], lists[1]))
        lists = lists[2:]
    }
    return lists[0]
}

// 合并两个链表
func mergeTwoLists(one *ListNode, two *ListNode) *ListNode {
    p1, p2, preHead := one, two, &ListNode{}
    p := preHead
    for p1 != nil && p2 != nil {
        if p1.Val < p2.Val {
            p.Next = p1
            p = p1
            p1 = p1.Next
        }else {
            p.Next = p2
            p = p2
            p2 = p2.Next
        }
    }
    if p1 != nil {
        p.Next = p1
    }
    if p2 != nil {
        p.Next = p2
    }
    return preHead.Next
}

// 方法二：使用分治法，两两配对合并，降低k^2复杂度为logk
// 时间复杂度O(Nlogk)
func mergeKLists(lists []*ListNode) *ListNode {
    var merge func(l, r int) *ListNode   // 合并范围[l, r]内的所有链表
    merge = func(l, r int) *ListNode {
        // 递归退出情况
        if l == r { return lists[l] }
        if l > r { return nil }
        // 递归合并左右两半两个链表
        mid := l + (r-l)>>1
        return mergeTwoLists(merge(l, mid), merge(mid+1, r))
    }   
    return merge(0, len(lists)-1)
}


// 方法三：对多个链表同时合并，多个链表的头节点维护一个k大的优先队列/堆，寻找最小的不断连接
// 时间复杂度O(kN * logk)
func mergeKLists(lists []*ListNode) *ListNode {
    // 创建最小堆
    newHeap := minHeap([]*ListNode{&ListNode{}})
    // 创建指针, 指向每个链表头
    preHead := &ListNode{}
    p := preHead
    for _, head := range lists {
        if head != nil {
            // 头节点加入堆中, 维护k大的小顶堆（如果有空链表则小于k个）
            newHeap.shiftUp(head)
        } 
    }
    for len(newHeap) > 1 {      // >1 默认0有一个占位置所以当堆的规模为0时结束（所有指针都为空）
        // 取最小，连接
        minPoint := newHeap[1]
        // fmt.Println(minPoint)
        p.Next = minPoint
        p = p.Next
        // 移动后一节点，加入堆，维护堆(如果指向空,那么就不加入了),然后堆规模-1
        minPoint = minPoint.Next
        if minPoint != nil {
            newHeap.shiftUp(minPoint)   
        }
        newHeap.shiftDown()
    }
    return preHead.Next
}

type minHeap []*ListNode

func (m *minHeap) shiftUp(v *ListNode) {
    *m = append(*m, v)
    // 从底往上判断
    index := len(*m)-1
    for index > 1 && (*m)[index].Val < (*m)[index/2].Val{
        (*m)[index], (*m)[index/2] = (*m)[index/2], (*m)[index]
        index /= 2
    }
}

func (m *minHeap) shiftDown() {
    // 替换最后一个与堆顶
    (*m)[1] = (*m)[len(*m)-1]
    (*m) = (*m)[:len(*m)-1]
    // 从上往下调整
    index := 1
    for index < len(*m) {
        // 找出三个节点中最小的
        minTop := index
        if index*2+1 < len(*m) && (*m)[index*2+1].Val < (*m)[minTop].Val {
            minTop = index*2+1
        }
        if index*2 < len(*m) && (*m)[index*2].Val < (*m)[minTop].Val {
            minTop = index*2
        }
        // 如果本身就是最小则结束
        if minTop == index {
            break
        }
        // 替换
        (*m)[minTop], (*m)[index] = (*m)[index], (*m)[minTop]
        index = minTop
    }
}
```

二刷：

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

type minHeap []*ListNode

func (m *minHeap) shiftUp(v *ListNode) {
    if v == nil {
        return
    }

    *m = append(*m, v)
    i := len(*m)-1
    for i>1 && (*m)[i/2].Val > (*m)[i].Val {
        (*m)[i/2], (*m)[i] = (*m)[i], (*m)[i/2]
        i /= 2
    }
} 

func (m *minHeap) shiftDown() *ListNode {
    if len(*m) == 1 {
        return nil
    }

    res := (*m)[1]
    (*m)[1], (*m)[len(*m)-1] = (*m)[len(*m)-1], (*m)[1]
    *m = (*m)[:len(*m)-1]

    i := 1
    for {
        minIdx := i
        if i*2 < len(*m) && (*m)[i*2].Val < (*m)[minIdx].Val {
            minIdx = i*2
        } 
        if i*2+1 < len(*m) && (*m)[i*2+1].Val < (*m)[minIdx].Val {
            minIdx = i*2+1
        } 
        if minIdx == i {
            break
        }

        // swap
        (*m)[i], (*m)[minIdx] = (*m)[minIdx], (*m)[i]
        i = minIdx
    }

    return res
}

// 使用最小堆小的元素，不断链接
func mergeKLists(lists []*ListNode) *ListNode {
    newMinHeap := minHeap([]*ListNode{&ListNode{}})
    
    newHead := &ListNode{}
    t := newHead

    // add to heap
    for _, node := range lists {
        newMinHeap.shiftUp(node)
    }

    for len(newMinHeap) > 1 {
        // get min
        minNode := newMinHeap.shiftDown()
        t.Next = minNode
        minNode = minNode.Next
        t = t.Next
        // add to heap
        if minNode != nil {
            newMinHeap.shiftUp(minNode)
        }
    }

    return newHead.Next
}
```

