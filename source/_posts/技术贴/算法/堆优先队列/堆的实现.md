---
title: 堆的实现
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-10-27 23:14:33
---

## 题目描述

实现一个建议堆

<!-- more -->

## 解题思路及代码

```go
type Heap interface {
	Len(heap *MyHeap) int
	Swap(i, j int)
	Compare(i, j int) bool
	ShiftUp(value int)
	ShiftDown()
}

// 实现一个小顶堆
type MyHeap struct {
	items []int
	k int
}

// 新建一个堆实例
func NewHeap(size int) *MyHeap {
	return &MyHeap{make([]int, 1), size}
}

// 堆的大小
func (h *MyHeap) Len() int {
	return len(h.items) - 1
}

// 比较堆的两个元素大小
func (h *MyHeap) Compare(i, j int) bool {
	if i <= 0 || j <= 0 || i > h.k || j > h.k {
		fmt.Println("Compare error")
		return false
	}
	return h.items[i] > h.items[j]
}

// 交换元素
func (h *MyHeap) Swap(i, j int) {
	if i <= 0 || j <= 0 || i > h.k || j > h.k {
		fmt.Println("Swap error")
		return
	}
	h.items[i], h.items[j] = h.items[j], h.items[i]
}

// 上浮，新加入一个元素并重新调整堆
func (h *MyHeap) ShiftUp(value int) {
	// 检查堆是否已满
	if h.k == h.Len() {
		fmt.Println("ShiftUp error")
		return
	}
	h.items = append(h.items, value)
	// 调整, 依次将新加入节点与其父节点比较
	index := len(h.items)-1          // 比较过程中使用的指针
	for index > 0 && index>>1 > 0 && h.Compare(index>>1, index) {
		// 如果有父节点并且当前值小于父节点（最小堆）则交换
		h.Swap(index, index>>1)
		index >>= 1
	}
}

// 下沉，删除根节点元素并重新平衡
func (h *MyHeap) ShiftDown() {
	// 检查是否为空堆
	if h.Len() == 0 {
		fmt.Println("ShiftDown error")
		return
	}
	// 将最底部元素替换堆根节点
	h.items[1] = h.items[h.Len()]       // 注意：最后一个元素的下标就是Len
	h.items = h.items[:h.Len()]         // 剔除最后一个元素
	// 重新调整堆结构特性, 从根节点往下
	index, minPos := 1, 1                   // minPos表示三者中最小的位置
	for {
		// 如果左右孩子都存在，那么找到minPos
		if (index << 1) <= h.Len() && h.Compare(index, index << 1) {
			minPos = index << 1
		}
		if (index << 1 | 1) <= h.Len() && h.Compare(minPos, index << 1 | 1) {
			minPos = index << 1 | 1
		}
		// 交换
		if minPos == index {
			// 如果没变化，说明无需调整，已经满足结构特点
			break
		}else {
			h.Swap(minPos, index)
			// 更新下一个调整考察点
			index = minPos
		}
	}
}
```

一般情况下堆的数据结构应该是一个二维数组，一维表示对象名，二维则表示优先值/属性值，可以用空接口实现

堆排序(借助于上面的最小堆)：

```go
func main() {
	arr := []int{8, 1, 4, 5, 12, 9, 9, 7}
	fmt.Println("堆排序结果: ", HeapSort(arr))
}

// 堆排序
func HeapSort(arr []int) []int {
	// 构造小顶堆
	minHeap := NewHeap(len(arr))
	for _, v := range arr {
		minHeap.ShiftUp(v)
	}
	ret := make([]int, 0)
	for range arr {
		// 删除堆顶元素，重新构建堆结构
		// 堆顶加入结果集合
		ret = append(ret, minHeap.ShiftDown())
	}
	return ret
}
```

