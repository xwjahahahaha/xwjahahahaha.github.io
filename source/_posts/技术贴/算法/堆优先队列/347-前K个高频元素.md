---
title: 347-前K个高频元素
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-28 11:24:24
---

## 题目描述

[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

难度中等734

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k`高的元素。你可以按 **任意顺序** 返回答案。

<!-- more --> 

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

 

**进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。




## 解题思路及代码

```go
// 直接的思路:hash表/散列表统计
// 时间复杂度O(k*N), 空间复杂度O(N). 只击败5%..
func topKFrequent(nums []int, k int) (ans []int) {
    record := make(map[int]int)
    for _, v := range nums {
        record[v] = record[v] + 1 
    }
    // 按频率统计前k个
    for i:=0; i<k; i++ {
        maxCount, maxNum := 0, 0
        for num, count := range record {
            if count > maxCount {
                maxCount = count
                maxNum = num
            }
        }
        record[maxNum] = 0
        ans = append(ans, maxNum)
    }
    return 
}

// 堆/优先队列
// 对于统计数组进行堆的topk
// 构建一个小顶堆, 当堆规模 < k 时, 直接添加元素,保持堆属性
// 当堆规模 == k时, 当堆顶 > 新值时, 舍弃该值 (因为整个堆都大于该值即其是第k+1大的数)
// 当堆规模 == k时, 当堆顶 <= 新值时, 删除堆顶值,插入当前值,调整堆属性 (更新这K规模的堆,堆顶最小值可能由此抬高)
// 时间复杂度O(NlogK), 每次堆操作为最大为logK, 最坏N次
func topKFrequent(nums []int, k int) (ans []int) {
    // 统计次数数组
    countMap := make(map[int]int)
    for _, num := range nums {
        countMap[num] ++
    }
    // 初始化堆
    myHeap := &IHeap{}
    heap.Init(myHeap)
    // 遍历次数数组入堆
    for num, count := range countMap {
        heap.Push(myHeap, [2]int{num, count})
        // 大于K个就弹出
        if myHeap.Len() > k {
            heap.Pop(myHeap)
        }
    }
    // 一直弹出,整合结果
    ans = make([]int, k)
    for i:=0; i<k; i++ {
        // 注意倒序、接口断言
        ans[k-i-1] = heap.Pop(myHeap).([2]int)[0] 
    } 
    return 
}

type IHeap [][2]int                 // 二元组,(num, count)
// 实现需要的方法
func (h IHeap)Len() int {
    return len(h)
}
func (h IHeap)Less(i, j int) bool {
    return h[i][1] < h[j][1]        // 小顶堆
}
func (h IHeap)Swap(i, j int) {
    h[i], h[j] = h[j], h[i]
}
func (h *IHeap)Push(x interface{}) {
    *h = append(*h, x.([2]int))     // 断言类型后添加
}
func (h *IHeap)Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    // 弹出
    *h = old[:n-1]
    return x
}
```

二次做：

```go
// topk大问题使用最小堆
func topKFrequent(nums []int, k int) []int {
    // 统计次数数组
    count := make(map[int]int)
    for _, v := range nums {
       count[v] ++
    }
    // 创建最小堆
    newHeap := &IHeap{}
    heap.Init(newHeap)
    // 加入统计数组元素
    for key, value := range count{
        heap.Push(newHeap, [2]int{key, value})
        if newHeap.Len() > k {
            // 保持堆的大小为k个
            heap.Pop(newHeap)
        }
    }
    // 遍历完统计数组的所有元素，最小堆的k个元素就是出现频率前k高的元素
    ret := make([]int, 0)
    for i:=0; i<k; i++ {
        ret = append(ret, heap.Pop(newHeap).([2]int)[0])
    }
    return ret
}

type IHeap [][2]int

func (h IHeap) Len() int           { return len(h) }
func (h IHeap) Less(i, j int) bool { return h[i][1] < h[j][1] }
func (h IHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IHeap) Push(x interface{}) {
    *h = append(*h, x.([2]int))
}

func (h *IHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}
```

二刷：

```go
type node struct {
    v int
    k int
}

type minHeap []*node

func (m *minHeap) shiftUp(v *node) {
    *m = append(*m, v)
    i := len(*m)-1
    for i>1 && (*m)[i/2].v > (*m)[i].v {
        (*m)[i/2], (*m)[i] = (*m)[i], (*m)[i/2]
        i /= 2
    }
} 

func (m *minHeap) shiftDown() *node {
    res := (*m)[1]
    (*m)[1] = (*m)[len(*m)-1]
    *m = (*m)[:len(*m)-1]
    i := 1

    for {
        minIdx := i
        if i*2 < len(*m) && (*m)[i*2].v < (*m)[minIdx].v {
            minIdx = i*2
        }
        if i*2+1 < len(*m) && (*m)[i*2+1].v < (*m)[minIdx].v {
            minIdx = i*2+1
        }
        if minIdx == i {
            break
        }

        (*m)[minIdx], (*m)[i] = (*m)[i], (*m)[minIdx]
        i = minIdx
    }

    return res
}

// topK大 小顶堆
func topKFrequent(nums []int, k int) []int {
    // make map
    count := make(map[int]int)
    for _, num := range nums {
        count[num]++
    }

    newMinHeap := minHeap([]*node{&node{}})
    i := 1          // 统计个数
    for key, value := range count {
        newMinHeap.shiftUp(&node{value, key})
        if i > k {
            newMinHeap.shiftDown()
        }
        i++
    }

    res := make([]int, 0)
    for i:=0; i<k; i++ {
       res = append(res, newMinHeap[1+i].k)
    }

    return res
}
```

