---
title: 73-矩阵置0
tags:
  - java
categories:
  - technical
  - leetcode
toc: true
date: 2020-12-22 19:48:04
---

## 题目描述

#### [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)

难度中等348收藏分享切换为英文接收动态反馈

给定一个 *m* x *n* 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**[原地](http://baike.baidu.com/item/原地算法)**算法**。**

<!-- more -->

**示例 1:**

```
输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
```

**示例 2:**

```
输入: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

**进阶:**

- 一个直接的解决方案是使用  O(*m**n*) 的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 O(*m* + *n*) 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个常数空间的解决方案吗？

## 解题思路及代码

```java
class Solution {

    //直接的思路
    //时间复杂度O(M * N) 空间复杂度O(M + N)
    public void setZeroes(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        Set<Integer> rowSet = new HashSet<>();
        Set<Integer> colSet = new HashSet<>();
        //存储0标记
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(matrix[i][j] == 0){
                    rowSet.add(i);
                    colSet.add(j);
                }
            }
        }
        //行置0
        for(int i : rowSet){
            for(int j=0; j<m; j++){
                matrix[i][j] = 0;
            }
        } 
        //列置0
        for(int j : colSet){
            for(int i=0; i<n; i++){
                matrix[i][j] = 0;
            }
        } 
    }
}

class Solution {
    //用其他值代替替换的0，以此来防止对原本0的影响
    //此方法只能限制于题目中给出了矩阵数据的范围，不然不能使用
    //时间复杂度O(M*N*(M+N))  空间负责度O(1)
    public void setZeroes(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        int tag = -145784564;       //随便取的
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                //把当前需要置0的非0数置为一个标记值，这里就用-145784564
                if(matrix[i][j] == 0){
                    //置行
                    for(int k=0; k<m; k++){
                        if(matrix[i][k] != 0){
                            matrix[i][k] = tag;
                        }
                    }
                    //置列
                    for(int k=0; k<n; k++){
                        if(matrix[k][j] != 0){
                            matrix[k][j] = tag;
                        }
                    }
                }
            }
        }
        //修改tag值为0
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(matrix[i][j] == tag){
                    matrix[i][j] = 0;
                }
            }
        }
    }
}

//第二种方法的不好之处在于，会重复的赋值

class Solution {
    //第三种方法:推迟赋值0
    //时间复杂度O(M*N) 空间复杂度O(1)
    //如果<i, j> == 0 ，那么就将其对应的该行的首元素和该列的首元素赋值为0
    //注意：如果首行或首列中有0，那么置<0, 0>为0的时候，可能会影响到对应的行或列，所以要隔断
    public void setZeroes(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        //如果<0, 0> != 0, 是非0行的第0列或第0行中有0导致的<0, 0>为0，那么就标记行影响为false，列为true
        boolean row_col_cut = false;     
        for(int i=0; i<n; i++){
            if(matrix[i][0] == 0)
                row_col_cut = true;
            //注意：这里是从1开始的
            for(int j=1; j<m; j++){
                if(matrix[i][j] == 0){    
                    matrix[i][0] = 0;   
                    matrix[0][j] = 0;      
                }
            }
        }
        //置0
        //注意！！这里的置0是根据首行首列来的，所以i，j不能从0开始，这样会使首行首列的非0位也变成0，进而导致矩阵全部都是0
        for(int i=1; i<n; i++){
            for(int j=1; j<m; j++){
                if(matrix[0][j] == 0 || matrix[i][0] == 0){
                    matrix[i][j] = 0;
                }
            }
        }
        //对首行，首列进行置0
        //首行
        if (matrix[0][0] == 0) {
            for (int j = 0; j < m; j++) {
                matrix[0][j] = 0;
            }
        }

        //首列
        if (row_col_cut) {
            for (int i = 0; i < n; i++) {
                matrix[i][0] = 0;
            }
        }

        
    }
}
```

