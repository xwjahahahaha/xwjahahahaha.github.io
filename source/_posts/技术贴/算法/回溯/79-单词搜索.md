---
title: 79-单词搜索
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-22 16:04:22
---

## 题目描述

[79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

难度中等

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

<!-- more --> 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

 

**提示：**

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成

 

**进阶：**你可以使用搜索剪枝的技术来优化解决方案，使其在 `board` 更大的情况下可以更快解决问题？



## 解题思路及代码

```go
// 回溯/深度优先
func exist(board [][]byte, word string) bool {
    flag := byte('*')
    // 获取board的大小
    rowSize, columSize, n := len(board), len(board[0]), len(word)
    // 递归函数, 参数(行, 列, word下标)
    var dfs func(int, int, int) bool
    dfs = func(r, c, k int) bool {

        // 剪枝
        // 看判断当前,不符合直接false
        if word[k] != board[r][c] {
            return false
        }
        
        // k到达word长度(说明前面全部都符合)且当前也符合则直接返回true(已找到)
        if k == n-1 {       // 注意n-1 : 因为下标无法到达n
            return true
        }

        // 处理当前, 遍历过打上标记
        t := board[r][c]            
        board[r][c] = flag

        // 递归四个方向
        if c + 1 < columSize && board[r][c+1] != flag {
            // 注意,这里不能直接return dfs(....) 因为false的话不return还要执行其他的方向
            if dfs(r, c+1, k+1) {           
                return true
            }
        }
        if c - 1 >= 0 && board[r][c-1] != flag {
            if dfs(r, c-1, k+1) {
                return true
            }
        }
        if r - 1 >= 0 && board[r-1][c] != flag {
            if dfs(r-1, c, k+1) {
                return true
            }
        }
        if r + 1 < rowSize && board[r+1][c] != flag {
            if dfs(r+1, c, k+1) {
                return true
            }
        }

        // 回溯
        board[r][c] = t         // 恢复未标记

        return false
    }
    // 确定起点
    for i:=0; i<rowSize; i++ {
        for j:=0; j<columSize; j++ {
            if dfs(i, j, 0) {           // 这里也要一有true就返回true
                return true
            }
        }
    }
    return false
}
```

二刷

```go
// 回溯+剪枝
func exist(board [][]byte, word string) bool {
    // 特殊预处理
    if len(board) == 0 || len(board[0]) == 0 {
        return false
    }

    m, n := len(board), len(board[0])
    // 创建访问标记数组
    visited := make([][]bool, m)
    for i := range visited {
        visited[i] = make([]bool, n)
    }

    // 判断下一步是否有效
    isVaild := func(i, j int) bool {
        if i < 0 || i > m-1 || j < 0 || j > n-1 || visited[i][j] {
            return false
        }
        return true
    }
     // 回溯
    var dfs func(i, j int, index int) bool 
    dfs = func(i, j int, index int) bool {
        // 判断本节点
        if word[index] != board[i][j] {
            return false
        }
        
        if index == len(word)-1 {  // 此时字符也相等直接返回true
            return true
        }

        //标记已访问
        visited[i][j] = true

        // 递归变量上下左右四个方向
        if isVaild(i+1, j) {
            if dfs(i+1, j, index+1) {
                return true
            }
        }

        if isVaild(i-1, j) {
            if dfs(i-1, j, index+1) {
                return true
            }
        }

        if isVaild(i, j+1) {
            if dfs(i, j+1, index+1) {
                return true
            }
        }
        
        if isVaild(i, j-1) {
            if dfs(i, j-1, index+1) {
                return true
            }
        }

        visited[i][j] = false   // 回溯
        return false
    }

    for i:=0; i<m; i++ {
        for j:=0; j<n; j++ {
            if dfs(i, j, 0) {
                return true
            }
        }
    }

    return false
}
```

三刷:

```go
func exist(board [][]byte, word string) bool {
    n := len(board)
    if n == 0 {
        return false
    }
    m := len(board[0])
    record := make([][]bool, n)
    for i:=0; i<n; i++ {
        record[i] = make([]bool, m)
    }
    // 判断是否被访问
    isValid := func(i, j int) bool {
        if i < 0 || i >= n || j < 0 || j >= m {
            return false
        }
        if record[i][j] {
            return false
        }
        return true
    }
    // dfs遍历
    var dfs func(i, j, index int) bool 
    dfs = func(i, j, index int) bool {
        // 判断此位置字符是否有效
        if board[i][j] != word[index] {
            // 无效直接剪枝
            return false
        }
        if index == len(word)-1 {
            return true
        }
        // 标记此位置
        record[i][j] = true
        // 判断下面四个位置
        if isValid(i+1, j) && dfs(i+1, j, index+1) {
            return true
        }
        if isValid(i, j+1) && dfs(i, j+1, index+1) {
            return true
        }
        if isValid(i-1, j) && dfs(i-1, j, index+1) {
            return true
        }
        if isValid(i, j-1) && dfs(i, j-1, index+1) {
            return true
        }
        // 回溯，如果所有方向都不能走，那么此位置不可走，向上回溯
        record[i][j] = false
        return false
    }
    // 调用
    for i:=0; i<n; i++ {
        for j:=0; j<m; j++ {
            if len(word) > 0 && word[0] == board[i][j] {
                if dfs(i, j, 0) {
                    return true
                }
            }
        }
    }
    return false
}
```

