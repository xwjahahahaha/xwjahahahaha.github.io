---
title: 47.全排列II
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-03-22 00:00:36
---

## 题目描述

[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

难度中等

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

<!-- more --> 

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**示例 2：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**提示：**

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`

## 解题思路及代码

```go
// 全排列，排序后每次选取数组重复数字集中的最后一个使用
func permuteUnique(nums []int) [][]int {
    n := len(nums)
    // 排序
    quickSort(nums, 0, n-1)
    ans := [][]int{}
    record := make(map[int]bool)        // index:bool 
    var dfs func(idx int, path []int)
    dfs = func(idx int, path []int) {
        // 递归结束条件
        if idx == n {
            // 记录结果
            ans = append(ans, append([]int(nil), path...))
            return
        }
        // 递归
        for i:=0; i<n; i++ {
            // 使用相同数字集中的最后一个
            // 第二个条件表示：如果后一个与此位置数相同并且后一个没使用过，那么此处不使用
            if record[i] || (i<n-1 && nums[i] == nums[i+1] && !record[i+1]) {
                continue
            }
            // 记录当前值
            path = append(path, nums[i])
            record[i] = true
            dfs(idx+1, path)
            // 回溯
            path = path[:len(path)-1]
            record[i] = false
        }
    }  
    dfs(0, []int{})
    return ans   
}


func quickSort(nums []int, l, r int) {
    if l < r {
        mid := getMid(nums, l, r)
        quickSort(nums, l, mid-1)
        quickSort(nums, mid+1, r)
    }
}

func getMid(nums []int, l, r int) int {
    pivot := nums[l]
    for l < r {
        for l < r && nums[r] >= pivot { r-- }
        nums[l] = nums[r]
        for l < r && nums[l] <= pivot { l++ }
        nums[r] = nums[l]
    }
    nums[l] = pivot
    return l
}
```

二刷：

```go
func permuteUnique(nums []int) [][]int {
    res := [][]int{}
    used := make(map[int]bool)

    // 对原数组数据进行排序
    sort.SliceStable(nums, func(i, j int) bool {
        return nums[i] < nums[j]
    })

    var dfs func(path []int)
    dfs = func(path []int) {
        if len(path) == len(nums) {
            // 记录结果
            res = append(res, append([]int(nil), path...))
            return
        }

        // 选择下一个数递归
        for i:=0; i<len(nums); i++ {
            // 去重选择一个
            if used[i] || (i>0 && nums[i] == nums[i-1] && !used[i-1]) {
                continue
            }

            path = append(path, nums[i])
            used[i] = true
            dfs(path)
            // 回溯
            path = path[:len(path)-1]
            used[i] = false
        }
    }

    dfs([]int{})
    return res
}
```

