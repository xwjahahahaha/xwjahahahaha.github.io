---
title: 46-全排列
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-14 17:30:38
---

## 题目描述

[46. 全排列](https://leetcode-cn.com/problems/permutations/)

难度中等

<!-- more -->

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```



## 解题思路及代码

回溯

```go
func permute(nums []int) [][]int {
    if len(nums) == 0 {
        return nil
    }
    // 是否使用过的标记
    used := map[int]bool{}
    res := [][]int{}
    backtrack(nums, used, []int{}, &res)
    return res
}

// userd表示已经使用的数字,使用O(1)的空间去判断(以空间换时间)
func backtrack(nums []int, used map[int]bool, order []int, res *[][]int){
    // 结束判断
    if len(order) == len(nums) {
        temp := make([]int, len(order))
        copy(temp, order) // 因为是使用同一个order,res中保存的是切片/地址,所以需要拷贝新的地址空间,否则都是同一个地址.
        *res = append(*res, temp)
        return
    } 
    // 遍历当前层
    for i:=0; i<len(nums); i++ {
        // 判断是否使用, 使用过就剪枝
        if used[nums[i]] {
            continue		// 注意是continue而不是return
        }
        // 没有使用就加入到序列中
        order = append(order, nums[i])
        used[nums[i]] = true
        // 递归遍历
        backtrack(nums, used, order, res)
        // 回溯状态
        order = order[:len(order)-1]
        used[nums[i]] = false
    }
}
```

