---
title: 46-全排列
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-14 17:30:38
---

## 题目描述

[46. 全排列](https://leetcode-cn.com/problems/permutations/)

难度中等

<!-- more -->

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```



## 解题思路及代码

回溯

```go
func permute(nums []int) [][]int {
    if len(nums) == 0 {
        return nil
    }
    // 是否使用过的标记
    used := map[int]bool{}
    res := [][]int{}
    backtrack(nums, used, []int{}, &res)
    return res
}

// userd表示已经使用的数字,使用O(1)的空间去判断(以空间换时间)
func backtrack(numcs []int, used map[int]bool, order []int, res *[][]int){
    // 结束判断
    if len(order) == len(nums) {
        temp := make([]int, len(order))
        copy(temp, order) // 因为是使用同一个order,res中保存的是切片/地址,所以需要拷贝新的地址空间,否则都是同一个地址.
        *res = append(*res, temp)
        return
    } 
    // 遍历当前层
    for i:=0; i<len(nums); i++ {
        // 判断是否使用, 使用过就剪枝
        if used[nums[i]] {
            continue		// 注意是continue而不是return
        }
        // 没有使用就加入到序列中
        order = append(order, nums[i])
        used[nums[i]] = true
        // 递归遍历
        backtrack(nums, used, order, res)
        // 回溯状态
        order = order[:len(order)-1]
        used[nums[i]] = false
    }
}
```

二刷

```go
// 回溯
func permute(nums []int) [][]int {
    n := len(nums)
    ans, tmp, used := [][]int{}, []int{}, make([]bool, n)
    var dfs func()
    dfs = func() {
        if len(tmp) == n {
            // 统计结果
            ans = append(ans, append([]int(nil), tmp...))
            return
        }
        for i:=0; i<n; i++ {
            // 判断当前数字是否使用过
            if used[i] {
                continue
            }
            tmp = append(tmp, nums[i])
            used[i] = true
            dfs()
            // 回溯
            tmp = tmp[:len(tmp)-1]
            used[i] = false
        }
    }
    dfs()
    return ans
}
```

三刷：

```go
func permute(nums []int) [][]int {
    path, res, used := []int{}, [][]int{}, make(map[int]bool)
    var dfs func()
    dfs = func() {
        if len(path) == len(nums) {
            // 加入到结果集
            res = append(res, append([]int(nil), path...))
            return
        }

        for i:=0; i<len(nums); i++ {
            if used[i] {
                continue
            }

            path = append(path, nums[i])
            used[i] = true
            dfs()
            // 回溯
            path = path[:len(path)-1]
            used[i] = false
        }
    }
    dfs()
    return res
}
```

