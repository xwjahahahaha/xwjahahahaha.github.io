---
title: 78-子集
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-20 14:07:25
---

## 题目描述

[78. 子集](https://leetcode-cn.com/problems/subsets/)

难度中等

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 <!-- more -->

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**




## 解题思路及代码

```go
// 迭代法,二进制位枚举
// 时间复杂度 O(n * 2^n) 空间复杂度 O(n)
func subsets(nums []int) [][]int {
    res := [][]int{}
    // 计算长度
    n := len(nums)
    // 遍历mask(0/1标志符), mask小于2^n
    for mask:=0; mask < (1 << n); mask++ {
        set := []int{}
        // 根据标志符, 遍历数组, 取对应值
        for i, v := range nums {
            // 根据当前数组的下标移位,判断在标志符中是否为1(&)
            if (1 << i) & mask > 0 {
               set = append(set, v)
            }
        }
        // 添加到结果集
        res = append(res, set)
    }
    return res
}


// 递归实现DFS枚举(回溯)
func subsets(nums []int) [][]int {
    res := [][]int{}
    set := []int{}      // 临时数组
    n := len(nums) 
    var dfs func(int)
    // index 目前确定状态的数组下标
    dfs = func(index int) {
        // 递归结束条件: 状态遍历结束
        if index == n {
            // 将临时记录数组添加到结果集, 注意复制(可以用tmp,也可以用append)
            res = append(res, append([]int(nil), set...))
            return
        }
        // 处理当前位置状态, 加入/不加入
        // 1. 加入
        set = append(set, nums[index])
        // 递归下一个位置
        dfs(index + 1)
        // 2. 不加入 (回溯逆操作)
        set = set[:len(set)-1]
        //直接下一个位置
        dfs(index + 1)
    }
    dfs(0)
    return res
}
```

