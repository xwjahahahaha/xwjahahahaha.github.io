---
title: 78-子集
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-20 14:07:25
---

## 题目描述

[78. 子集](https://leetcode-cn.com/problems/subsets/)

难度中等

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 <!-- more -->

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**




## 解题思路及代码

```go
// 迭代法,二进制位枚举
// 时间复杂度 O(n * 2^n) 空间复杂度 O(n)
func subsets(nums []int) [][]int {
    res := [][]int{}
    // 计算长度
    n := len(nums)
    // 遍历mask(0/1标志符), mask小于2^n
    for mask:=0; mask < (1 << n); mask++ {
        set := []int{}
        // 根据标志符, 遍历数组, 取对应值
        for i, v := range nums {
            // 根据当前数组的下标移位,判断在标志符中是否为1(&)
            if (1 << i) & mask > 0 {
               set = append(set, v)
            }
        }
        // 添加到结果集
        res = append(res, set)
    }
    return res
}


// 递归实现DFS枚举(回溯)
func subsets(nums []int) [][]int {
    res := [][]int{}
    set := []int{}      // 临时数组
    n := len(nums) 
    var dfs func(int)
    // index 目前确定状态的数组下标
    dfs = func(index int) {
        // 递归结束条件: 状态遍历结束
        if index == n {
            // 将临时记录数组添加到结果集, 注意复制(可以用tmp,也可以用append)
            res = append(res, append([]int(nil), set...))
            return
        }
        // 处理当前位置状态, 加入/不加入
        // 1. 加入
        set = append(set, nums[index])
        // 递归下一个位置
        dfs(index + 1)
        // 2. 不加入 (回溯逆操作)
        set = set[:len(set)-1]
        //直接下一个位置
        dfs(index + 1)
    }
    dfs(0)
    return res
}
```

二刷

```go
// 二进制遍历
// 时间复杂度O(N*2^N)
func subsets(nums []int) [][]int {
    n := len(nums)
    ans := make([][]int, 0)
    // mask < 2^n, 因为全为1为(2^n)-1
    for mask:=0; mask<(1<<n); mask++ {
        // 从0～n-1遍历mask每一位是否为1
        res := make([]int, 0)
        for i:=0; i<n; i++ {
            if (1 << i) & mask > 0 {     // 注意：这里“与”的结果判断是>0而不能是==1
                // 如果是1，就将数字加入到结果数组中
                res = append(res, nums[i])      // 这里是对称的,写i或者n-i-1均可
            }
        }
        // 加入总结果
        ans = append(ans, res)
    }
    return ans
}

// 递归的思路: 遍历数组元素，每次复制当前所有的子集，将元素加入到所有子集中形成新的子集
// 时间复杂度O(N*2^N)
func subsets(nums []int) [][]int {
    ans := [][]int{[]int{}}     // 最开始只有一个空集作为子集
    for i:=0; i<len(nums); i++ {
        tmpAll:= [][]int{}    
        // 遍历所有子集
        for j:=0; j<len(ans); j++ {
            // 复制当前子集
            tmp := append([]int(nil), ans[j]...)
            // 将元素加入复制的每个子集中
            tmp = append(tmp, nums[i])
            tmpAll = append(tmpAll, tmp)
        }
        // 加入到原来的子集
        ans = append(ans, tmpAll...)
    }
    return ans
}

// 回溯法
// 每个位置考虑加入或者不加入
func subsets(nums []int) [][]int {
    n := len(nums)
    ans := [][]int{}
    var dfs func(index int)
    // index 就是当前数组位置数
    tmp := []int{}
    dfs = func(index int) {
        if index == n {
            // 加入结果集
            ans = append(ans, append([]int(nil), tmp...))
            return
        }
        // 对于当前位置元素，考虑加入或者不加入
        // 加入
        tmp = append(tmp, nums[index])
        dfs(index+1)
        // 回溯
        tmp = tmp[:len(tmp)-1]
        // 不加入, 不用回溯
        dfs(index+1)
    }
    dfs(0)
    return ans
}
```

