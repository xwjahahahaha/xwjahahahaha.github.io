---
title: 面试题08.08.有重复字符串的排列组合
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-03-22 00:19:55
---

## 题目描述

[面试题 08.08. 有重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-ii-lcci/)

难度中等

<!-- more -->

有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。

**示例1:**

```
 输入：S = "qqe"
 输出：["eqq","qeq","qqe"]
```

**示例2:**

```
 输入：S = "ab"
 输出：["ab", "ba"]
```

**提示:**

1. 字符都是英文字母。
2. 字符串长度在[1, 9]之间.

## 解题思路及代码

```go
func permutation(S string) []string {
    n := len(S)
    ans := []string{}
    // 排序
    byteSlice := make([]byte, n)
    for i:=0; i<len(S); i++ {
        byteSlice[i] = S[i]
    }
    quickSort(byteSlice, 0, n-1)
    used := make(map[int]bool)
    var dfs func(idx int, path string)
    dfs = func(idx int, path string) {
        if idx == n {
            ans = append(ans, path)
            return
        }
        for i:=0; i<n; i++ {
            if used[i] || (i>0 && byteSlice[i] == byteSlice[i-1] && !used[i-1]) {
                continue
            }
            path += string(byteSlice[i])
            used[i] = true
            dfs(idx+1, path)
            // 回溯
            path = path[:len(path)-1]
            used[i] = false
        }
    }
    dfs(0, "")
    return ans
}


func quickSort(nums []byte, l, r int) {
    if l < r {
        mid := getMid(nums, l, r)
        quickSort(nums, l, mid-1)
        quickSort(nums, mid+1, r)
    }
}

func getMid(nums []byte, l, r int) int {
    pivot := nums[l]
    for l < r {
        for l < r && nums[r] >= pivot { r-- }
        nums[l] = nums[r]
        for l < r && nums[l] <= pivot { l++ }
        nums[r] = nums[l]
    }
    nums[l] = pivot
    return l
}
```

