---
title: 面试题08.08.有重复字符串的排列组合
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-03-22 00:19:55
---

## 题目描述

[面试题 08.08. 有重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-ii-lcci/)

难度中等

<!-- more -->

有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。

**示例1:**

```
 输入：S = "qqe"
 输出：["eqq","qeq","qqe"]
```

**示例2:**

```
 输入：S = "ab"
 输出：["ab", "ba"]
```

**提示:**

1. 字符都是英文字母。
2. 字符串长度在[1, 9]之间.

## 解题思路及代码

```go
func permutation(S string) []string {
    n := len(S)
    ans := []string{}
    // 排序
    byteSlice := make([]byte, n)
    for i:=0; i<len(S); i++ {
        byteSlice[i] = S[i]
    }
    quickSort(byteSlice, 0, n-1)
    used := make(map[int]bool)
    var dfs func(idx int, path string)
    dfs = func(idx int, path string) {
        if idx == n {
            ans = append(ans, path)
            return
        }
        for i:=0; i<n; i++ {
            if used[i] || (i>0 && byteSlice[i] == byteSlice[i-1] && !used[i-1]) {
                continue
            }
            path += string(byteSlice[i])
            used[i] = true
            dfs(idx+1, path)
            // 回溯
            path = path[:len(path)-1]
            used[i] = false
        }
    }
    dfs(0, "")
    return ans
}


func quickSort(nums []byte, l, r int) {
    if l < r {
        mid := getMid(nums, l, r)
        quickSort(nums, l, mid-1)
        quickSort(nums, mid+1, r)
    }
}

func getMid(nums []byte, l, r int) int {
    pivot := nums[l]
    for l < r {
        for l < r && nums[r] >= pivot { r-- }
        nums[l] = nums[r]
        for l < r && nums[l] <= pivot { l++ }
        nums[r] = nums[l]
    }
    nums[l] = pivot
    return l
}
```

二刷：

```go
// 回溯
func permutation(S string) []string {
    n := len(S)
    res := []string{}
    count := make(map[int]bool)         // 要用位置作为唯一索引，因为有重复元素
    // 排序原字符串
    tmpSlice := []byte{}
    for _, c := range S {
        tmpSlice = append(tmpSlice, byte(c))
    }
    sort.SliceStable(tmpSlice, func(i, j int) bool {
        return tmpSlice[i] < tmpSlice[j]
    })
    var dfs func(path string)
    dfs = func(path string) {
        if len(path) == n {
            res = append(res, path)
            return
        }

        for i:=0; i<n; i++ {
            // 找到下一个不重复字符
            // 后面的!count[i-1]可以改成count[i-1]，这两种情况使用一种即可
            if count[i] || (i>0 && tmpSlice[i-1] == tmpSlice[i] && !count[i-1]) {
                continue
            }

            char := string(tmpSlice[i])
            path += char
            count[i] = true
            dfs(path)
            path = path[:len(path)-1]
            count[i] = false
        }
    }
    dfs("")
    return res
}
```

