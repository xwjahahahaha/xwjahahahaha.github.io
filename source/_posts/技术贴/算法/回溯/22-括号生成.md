---
title: 22-括号生成
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-14 15:29:43
---

## 题目描述

[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

难度中等

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

<!-- more -->

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

**提示：**

- `1 <= n <= 8`

## 解题思路及代码

构造递归树,回溯,剪枝

```go
func generateParenthesis(n int) []string {
    if n == 0 {
        return nil
    }
    res := []string{}
    backtrack(n, "(", "", &res)
    return res
}

func backtrack(n int, c string, s string, res *[]string) {
    // 添加当前字符
    s += c
    // 计算数量
    leftCount, rightCount := strings.Count(s, "("), strings.Count(s, ")")
    // 剪枝判断
    // 右括号大于左括号或者左括号超过总体一半就剪枝
    if rightCount > leftCount || leftCount > n {
        return
    }
    // 叶子结点情况/结束情况
    if len(s) == 2 * n {
        // 判断一下
        if leftCount == rightCount {
            // 只有相同才添加到结果集,否则剪枝
            *res = append(*res, s)
        }
        return
    }
    // 不到叶子结点,递归添加两种子情况
    backtrack(n, "(", s, res)
    backtrack(n, ")", s, res)
}
```

二刷思路：

```go
// 回溯递归、剪枝：当右括号数量大于左括号时不需要再递归
func generateParenthesis(n int) []string {
    ans := make([]string, 0)
    var help func(leftPares, rightPares int, path string)
    help = func(leftPares, rightPares int, path string) {
        // leftPares, rightPares 分别表示剩余左右括号的数量
        // 递归结束条件
        if leftPares == 0 && rightPares == 0 {
            ans = append(ans, path)
            return
        }
        if leftPares == rightPares {
            // 如果剩余左右括号数量相同，那么先添加左括号 (其实就是剪枝)
            help(leftPares-1, rightPares, path+"(")
        }else {
            // 否则分别递归左右括号两种情况
            if leftPares > 0 {
                help(leftPares-1, rightPares, path+"(") // 这里的-1、+"("其实就是回溯
            }
            if rightPares > 0 {
                help(leftPares, rightPares-1, path+")")
            }
        }
    }
    help(n, n, "")
    return ans
}
```

