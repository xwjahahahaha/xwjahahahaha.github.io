---
title: 93.复原IP地址
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-21 00:45:54
---

## 题目描述

[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

难度中等772

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如："0.1.2.201" 和 "192.168.1.1" 是 **有效** IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你不能重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

<!-- more --> 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

**示例 2：**

```
输入：s = "0000"
输出：["0.0.0.0"]
```

**示例 3：**

```
输入：s = "1111"
输出：["1.1.1.1"]
```

**示例 4：**

```
输入：s = "010010"
输出：["0.10.0.10","0.100.1.0"]
```

**示例 5：**

```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

 

**提示：**

- `0 <= s.length <= 20`
- `s` 仅由数字组成

通过次数178,278

提交次数324,460

## 解题思路及代码

```go
// 递归/回溯，构建递归数剪枝，插入三个点
func restoreIpAddresses(s string) []string {
    ans := []string{}
    var help func(s string, dotNum int, ip string)  // dotNum 当前字符串需要添加的点数
    help = func(s string, dotNum int, ip string) {
        // 剪枝操作
        if len(s) < dotNum+1 || len(s) > (dotNum+1)*3 {
            // 需要的最少位数和最多位数
            return
        }
        // 结束条件
        if dotNum == 0 && isValidIPPart(s) {
            // 判断这个字符串是不是合法地址的一段, 加入结果集
            ans = append(ans, ip+s)
            return
        }
        for i:=1; i<=3; i++ {
            if i <= len(s) && isValidIPPart(s[:i]) {
                help(s[i:], dotNum-1, ip+s[:i]+".")
            }
        }
    }
    help(s, 3, "")
    return ans
}

func isValidIPPart(s string) bool {
    if len(s) == 0 {
        return false
    }else if len(s) == 1 {
        return true
    }else if s[0] == '0' {
        return false
    }else if len(s) == 2 {
        return true
    }else if len(s) == 3 {
        if num := strToNum(s); num >=0 && num <= 255 {
            return true
        }else {
            return false
        }
    }else {
        return false
    }
}

func strToNum(s string) int {
    num := 0
    for _, c := range s {
        num = num * 10 + int(c-'0')
    }
    return num
}
```

二刷，更好理解

```go
// 回溯 + 剪枝
func restoreIpAddresses(s string) []string {
    ans := make([]string, 0)
    var help func(dotNum int, s string, path string)
    help = func(dotNum int, s string, path string) {
        if dotNum == 0 {
            if isVaildIPStr(s) {
                path += s
                // 加入到结果集
                ans = append(ans, path)
            }
            return 
        }
        // 剪枝
        if len(s) < (dotNum+1)*1 || len(s) > (dotNum+1)*3 {
            return
        }

        // 处理本次
        for i:=0; i<3; i++ {
            if i+1 <= len(s) && isVaildIPStr(s[:i+1]) {
                path = path + s[:i+1] + "."
                help(dotNum-1, s[i+1:], path)
                path = path[:len(path)-i-2] // 回溯
            }
        }
    }
    help(3, s, "")
    return ans
}

func isVaildIPStr(ipStr string) bool {
    n := len(ipStr)
    if n <= 0 || n > 3 {
        return false
    }
    if n != 3 {
        if n == 2 && ipStr[0] == '0' { // "01"这样是不合法的
            return false
        }
        return true
    }
    // n == 3 转换为数字，判断其是否合法
    num := 0
    for i:=0; i<len(ipStr); i++ {
        num = num*10 + int(ipStr[i]-'0')
    }
    if num >= 100 && num <= 255 {
        return true
    }
    return false
}
```

三刷：

```go
// 回溯
func restoreIpAddresses(s string) []string {
    ans := []string{}
    var dfs func(dotNum int, s string, path string) 
    dfs = func(dotNum int, s string, path string) {
        // 递归结束条件
        if dotNum == 0 {
            // 加上最后一段
            if isValid(s) {
                path += s
                // 记录结果
                ans = append(ans, path)
            }
            return
        }
        // 剪枝
        n := len(s)
        if n > 3*(dotNum+1) || n < dotNum+1 {
            return
        }
        // 处理本次
        for i:=1; i<=3; i++ {       // i表示长度
            if n >= i && isValid(s[:i]) {
                path = path + s[:i] + "."
                dfs(dotNum-1, s[i:], path)
                // 回溯
                path = path[:len(path)-i-1]
            }
        }
    }
    dfs(3, s, "")
    return ans
}

func isValid(s string) bool {
    n := len(s)
    if n == 1 {
        return true
    }else if n == 2 {
        if s[0] == '0' {
            return false
        }
        return true
    }else if n == 3{
        if s[0] == '0' || s[0] > '2' {
            return false
        }
        if s[0] == '2' && (s[1] > '5' || s[1] == '5' && s[2] > '5') {
            return false
        }
        return true
    }else {
        return false
    }
}
```

