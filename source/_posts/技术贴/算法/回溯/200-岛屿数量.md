---
title: 200-岛屿数量
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-09 09:40:00
---

## 题目描述

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

难度中等

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

<!-- more --> 

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3 
```

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`

## 解题思路及代码

深度优先、广度优先

```go
// 深度优先遍历
// 时间复杂度/空间复杂度(栈深度): O(M*N) 最坏全部为1 
func numIslands(grid [][]byte) (count int) {
    // 遍历所有节点,为1则开始Dfs
    for i:=0; i<len(grid); i++ {
        for j:=0; j<len(grid[0]); j++ {
            if grid[i][j] == '1' {
                Dfs(grid, i, j)
                count ++ 
            }
        }
    }
    return
}

// 使用递归,隐性的维护一个栈
func Dfs(grid [][]byte, r, c int){
    // 获取grid的大小,获取边界的大小
    rowLength := len(grid)
    columLength := len(grid[0])
    // 将当前位置节点置为0,代表已遍历
    grid[r][c] = '0'
    // 递归深度遍历起点(dfs)
    // 上下左右递归
    if r-1>=0 && grid[r-1][c] == '1' {
        Dfs(grid, r-1, c)
    }
    if r+1<rowLength && grid[r+1][c] == '1' {
        Dfs(grid, r+1, c)
    }
    if c-1>=0 && grid[r][c-1] == '1' {
        Dfs(grid, r, c-1)
    }
    if c+1<columLength && grid[r][c+1] == '1' {
        Dfs(grid, r, c+1)
    }
}
```
```golang
// BFS广度优先遍历, 维护一个队列
// 时间复杂度O(MN), 空间复杂度O(min(M,N))
func numIslands(grid [][]byte) (count int) {
    queue := [][]int{}
    rowLength := len(grid)
    columLength := len(grid[0])
    for i:=0; i<rowLength; i++ {
        for j:=0; j<columLength; j++ {
            if grid[i][j] == '1' {
                count ++
                // 入队
                loc := []int{i, j}
                queue = append(queue, loc)
                Bfs(grid, queue)
            }
        }
    }
    return 
}

func Bfs(grid [][]byte, queue [][]int){
    rowLength := len(grid)
    columLength := len(grid[0])
    for len(queue) > 0 {
        // 出队
        loc := queue[0]
        queue = queue[1:]
        // 置为0
        r, c := loc[0], loc[1]
        grid[r][c] = '0'
        // 层次遍历, 上下左右
        if r-1 >= 0 && grid[r-1][c] == '1' {
            // 入队
            queue = append(queue, []int{r-1, c})
            grid[r-1][c] = '0'                  // 确定此节点立即置为0, 不然外三层循环(主函数)又会重复
        }
        if r+1<rowLength && grid[r+1][c] == '1' {
            queue = append(queue, []int{r+1, c})
            grid[r+1][c] = '0'
        }
        if c-1>=0 && grid[r][c-1] == '1' {
           queue = append(queue, []int{r, c-1})
           grid[r][c-1] = '0'
        }
        if c+1<columLength && grid[r][c+1] == '1' {
            queue = append(queue, []int{r, c+1})
            grid[r][c+1] = '0'
        }
    }   
}
```

二刷：深度优先，简洁

```go
func numIslands(grid [][]byte) int {
    if len(grid) == 0 || (len(grid)==1 && len(grid[0]) == 0) {
        return 0
    }
    count, marked, m, n := 0, make([][]bool, len(grid)), len(grid), len(grid[0])
    for i:=0; i<len(marked); i++ {
        marked[i] = make([]bool, n)
    }
    var dfs func(int, int)
    dfs = func(i, j int) {
        // 已访问、超边界、当前位置为0
        if i < 0 || i >= m || j < 0 || j >= n || marked[i][j] || grid[i][j] == '0' {
            return
        }
        // 标记当前位置已访问
        marked[i][j] = true
        // 走下一个位置
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    }
    // 遍历开始位置
    for i:=0; i<m; i++ {
        for j:=0; j<n; j++ {
            if grid[i][j] == '1' && !marked[i][j] {
                count ++
                dfs(i, j)
            }
        } 
    }
    return count
}
```

三刷：dfs、bfs

```go
// dfs
func numIslands(grid [][]byte) int {
    n := len(grid)
    if n == 0 {
        return 0
    }
    m := len(grid[0])
    // 已访问数组
    visited := make([][]bool, n)
    for i:=0; i<n; i++ {
        visited[i] = make([]bool, m)
    }
    isValid := func(i, j int) bool {
        if i < 0 || i >= n || j < 0 || j >= m {
            return false
        }
        return true
    }
    // dfs遍历
    var dfs func(i, j int) 
    dfs = func(i, j int) {
        if !isValid(i, j) || visited[i][j] || grid[i][j] == '0' {
            return
        }
        if grid[i][j] == '1' {
            visited[i][j] = true
        }
        // 遍历其他1, 标记已访问
        dfs(i+1, j)
        dfs(i, j+1)
        dfs(i-1, j)
        dfs(i, j-1)
    }
    // 遍历开始位置
    count := 0
    for i:=0; i<n; i++ {
        for j:=0; j<m; j++ {
            if !visited[i][j] && grid[i][j] == '1' {
                count++
                dfs(i, j)
            }
        }
    }
    return count
}


// bfs
func numIslands(grid [][]byte) int {
    n := len(grid)
    if n == 0 {
        return 0
    }
    m := len(grid[0])
    isValid := func(i, j int) bool {
        if i < 0 || i >= n || j < 0 || j >= m {
            return false
        }
        return true
    }
    // bfs遍历
    queue := [][2]int{}         // [2]int为节点坐标
    bfs := func(i, j int) {
        for len(queue) > 0 {
            // 出队
            loc := queue[0]
            queue = queue[1:]
            // 将其设置为0，表示已访问
            r, c := loc[0], loc[1]
            grid[r][c] = '0'
            // 将其所有有效临近位置入队
            if isValid(r+1, c) && grid[r+1][c] != '0' {
                queue = append(queue, [2]int{r+1, c})
                grid[r+1][c] = '0'      // 注意这里如果发现一个就立即要设置为0，不然主函数三重循环会超时
            }
            if isValid(r-1, c) && grid[r-1][c] != '0' {
                queue = append(queue, [2]int{r-1, c})
                grid[r-1][c] = '0'
            }
            if isValid(r, c+1) && grid[r][c+1] != '0' {
                queue = append(queue, [2]int{r, c+1})
                grid[r][c+1] = '0'
            }
            if isValid(r, c-1) && grid[r][c-1] != '0' {
                queue = append(queue, [2]int{r, c-1})
                grid[r][c-1] = '0'
            }
        }
    }
    // 遍历开始位置
    count := 0
    for i:=0; i<n; i++ {
        for j:=0; j<m; j++ {
            if grid[i][j] == '1' {
                count++
                // 将此位置数加入
                queue = append(queue, [2]int{i, j})
                bfs(i, j)
            }
        }
    }
    return count
}
```

四刷：不改变原数组

```go
func numIslands(grid [][]byte) int {
    m, n := len(grid), len(grid[0])
    count := 0
    visited := make([][]bool, m)
    for i:=0; i<m; i++ {
        visited[i] = make([]bool, n)
    }
    var dfs func(i, j int)
    dfs = func(i, j int) {
        if i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || grid[i][j] == '0' {
            return
        }

        visited[i][j] = true
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
        // 注意不要回溯
    }

    for i:=0; i<m; i++ {
        for j:=0; j<n; j++ {
            if grid[i][j] == '1' && !visited[i][j] {
                dfs(i, j)
                count++
            }
        }
    }

    return count
}
```

