---
title: 17-电话号码的字母组合
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-04-14 10:12:49
---

## 题目描述

[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

难度中等

<!-- more -->

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"] 
```

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。

## 解题思路及代码

```go
// 回溯 栈递归,深度优先
var phoneMap = map[string]string{
        "2" : "abc",
        "3" : "def",
        "4" : "ghi",
        "5" : "jkl",
        "6" : "mno",
        "7" : "pqrs",
        "8" : "tuv",
        "9" : "wxyz",
}
func letterCombinations(digits string) (words []string) {
    if len(digits) == 0 {
        return []string{}
    }
    backtrack(digits, 0, &words, "")            // words切片作为参数的话,函数中使用append要传递指针不然会重新创建空间,也可采用全局变量,这样就不用传递指针
    return
}

func backtrack(digits string, index int, words *[]string, word string) {
    if index == len(digits) {       // index是数字开始下标
        // 递归结束/出口
        *words = append(*words, word) 
        return 
    }
    // 获取对应按键对应字母
    letters := phoneMap[string(digits[index])]
    // 遍历字母
    for i:=0; i<len(letters); i++ {
        backtrack(digits, index + 1, words, word + string(letters[i]))
    }
}
```

二刷：

```go
func letterCombinations(digits string) []string {
    n := len(digits)
    ans := []string{}
    var dfs func(index int, path string)
    dfs = func(index int, path string) {
        // 递归结束条件
        if index == n {
            // 加入结果集合
            if path != "" {
                ans = append(ans, path)     // 因为字符串传递会复制一个值，所以不需要重新复制一个
            }
            return
        }
        // 处理本层
        letter := getLetter(digits[index])
        // 递归遍历
        for i:=0; i<len(letter); i++ {
            path += string(letter[i])
            dfs(index+1, path)
            // 回溯
            path = path[:len(path)-1]
        }
    }
    dfs(0, "")
    return ans
}

func getLetter(c byte) string {
    switch c {
        case '2' :
            return "abc"
        case '3' :
            return "def"
        case '4' :
            return "ghi"
        case '5' :
            return "jkl"
        case '6' :
            return "mno"
        case '7' :
            return "pqrs"
        case '8' :
            return "tuv"
        case '9' :
            return "wxyz"
        default:
            return ""
    }
}
```

三刷：

```go
// 回溯
func letterCombinations(digits string) []string {
    n := len(digits)
    if n == 0 {
        return nil
    }

    res := []string{}
    tmp := ""
    var dfs func()
    dfs = func() {
        if len(tmp) == n {
            res = append(res, tmp)
            return
        }

        num := digits[0]
        digits = digits[1:]
        strs := getChars(int(num-'0'))

        for i:=0; i<len(strs); i++ {
            tmp += string(strs[i])
            dfs()
            // 回溯
            tmp = tmp[:len(tmp)-1]
        }
        // 下一层全部递归完之后记得加回来 (最好还是使用index的方式)
        digits = string(num)+digits
    }

    dfs()
    return res
}

func getChars(i int) string {
    switch i {
    case 2:
        return "abc"
    case 3:
        return "def"
    case 4:
        return "ghi"
    case 5:
        return "jkl"
    case 6:
        return "mno"
    case 7:
        return "pqrs"
    case 8:
        return "tuv"
    case 9:
        return "wxyz"
    }
    return ""
}
```



