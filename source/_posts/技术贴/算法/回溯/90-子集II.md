---
title: 90.子集II
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-03-23 00:26:05
---

## 题目描述

[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

难度中等

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

 <!-- more -->

**示例 1：**

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`

## 解题思路及代码

```go
// 排序+二进制+去重
func subsetsWithDup(nums []int) [][]int {
    n := len(nums)
    // 排序
    sort.SliceStable(nums, func(i, j int) bool {
        return nums[i] <= nums[j]
    })
    ans := [][]int{}
    outer:
    for mask:=0; mask<(1<<n); mask++ {
        tmp := []int{}
        for i:=0; i<n; i++ { // i:mask移位的个数
            if (mask>>i) & 1 > 0 {
                // 相同的数字集中只选择第一个数使用，例如[2, 2]只用10而不使用01
                // (mask>>(i-1)) & 1 == 0 的意思就是上一个数没用(0)时此子集不加入
                if i>0 && nums[i] == nums[i-1] && (mask>>(i-1)) & 1 == 0 {
                    continue outer      // 注意这里continue到下一个mask
                }
                tmp = append(tmp, nums[i])
            }
        }
        ans = append(ans, tmp)
    }
    return ans
}

// 回溯+排序+去重
func subsetsWithDup(nums []int) [][]int {
    n := len(nums)
    // 排序
    sort.SliceStable(nums, func(i, j int) bool {
        return nums[i] <= nums[j]
    })
    ans := [][]int{}
    var dfs func(idx int, chosePre bool, path []int) 
    dfs = func(idx int, chosePre bool, path []int) {
        if idx == n {
            ans = append(ans, append([]int(nil), path...))
            return
        }
        // 此位置选或者不选
        dfs(idx+1, false, path)         // 不选
        // 重复数字集中第一个数字才选
        // !chosePre => 表示如果前一个位置没选，此情况剪枝掉
        if idx > 0 && nums[idx] == nums[idx-1] && !chosePre {
            return
        }
        path = append(path, nums[idx])  // 选
        dfs(idx+1, true, path)
    }
    dfs(0, false, []int{})
    return ans
}
```

