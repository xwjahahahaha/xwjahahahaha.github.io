---
title: 148.排序链表
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-16 22:35:07
---

## 题目描述

[148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

难度中等

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

<!-- more --> 

**示例 1：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/sort_list_1.jpg)

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

**示例 2：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/sort_list_2.jpg)

```
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```

**示例 3：**

```
输入：head = []
输出：[]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 5 * 104]` 内
- `-105 <= Node.val <= 105`

 

**进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

## 解题思路及代码

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
// 归并排序，不需要额外空间
// 时间复杂度O(NlogN)
func sortList(head *ListNode) *ListNode {
    // 先找到链表的尾节点
    p := head
    for p != nil && p.Next != nil {
        p = p.Next
    }
    return sortPorcess(head, p)
}

// 排序范围链表，并返回排序后的头节点
func sortPorcess(head, end *ListNode) *ListNode {
    if head == nil || end == nil || head == end {
        return head
    }
    midNode := getListMid(head, end)
    // 断开左右两边连接
    right := midNode.Next
    midNode.Next = nil
    leftHead := sortPorcess(head, midNode)
    rightHead := sortPorcess(right, end)
    return mergeTwoSortList(leftHead, rightHead)
}


// 获得链表的中点
func getListMid(head, end *ListNode) *ListNode {
    p, length := head, 0
    for p != nil && p != end.Next {
        length ++
        p = p.Next
    }
    p = head
    for i:=0; i<length/2-1; i++ {
        p = p.Next
    }
    return p
}

// 合并两个排序链表
func mergeTwoSortList(one, two *ListNode) *ListNode {
    p1, p2, preHead := one, two, &ListNode{}
    p := preHead
    for p1 != nil && p2 != nil {
        if p1.Val < p2.Val {
            p.Next = p1
            p = p.Next
            p1 = p1.Next
        }else {
            p.Next = p2
            p = p.Next
            p2 = p2.Next
        }
    }
    if p1 != nil {
        p.Next = p1
    }
    if p2 != nil {
        p.Next = p2
    }
    return preHead.Next
}
```

