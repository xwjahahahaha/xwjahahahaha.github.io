---
title: 25.k个一组翻转链表
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-02-19 15:47:50
---

## 题目描述

[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

难度困难

给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表。

*k* 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 *k* 的整数倍，那么请将最后剩余的节点保持原有顺序。

**进阶：**

- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？
- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。

 <!-- more -->

**示例 1：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

**示例 3：**

```
输入：head = [1,2,3,4,5], k = 1
输出：[1,2,3,4,5]
```

**示例 4：**

```
输入：head = [1], k = 1
输出：[1]
```



**提示：**

- 列表中节点的数量在范围 `sz` 内
- `1 <= sz <= 5000`
- `0 <= Node.val <= 1000`
- `1 <= k <= sz`

通过次数273,519

提交次数414,016

## 解题思路及代码

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
// 模拟（看ppt理解过程）
// k个一组的链表就是翻转链表的子问题
// 注意点：对于k个一组的链表要注意翻转完之后需要连接前后其他分组链表
func reverseKGroup(head *ListNode, k int) *ListNode {
    hair := &ListNode{-1, head}
    pre, tail, ntx := hair, hair, hair     // pre分组前一个节点，tail分组中的最后一个节点, ntx临时存储分组链表翻转之前的下一个节点
    exit:
    for head != nil {
        // 1. 移动tail
        for i:=0; i<k; i++ {
            tail = tail.Next
            if tail == nil {
                // 如果移动过程中tail为nil，则直接结束，因为后面不够k个了
                break exit
            }
        }
        // 2. 翻转前记录下一个节点
        ntx = tail.Next
        // 3. 翻转
        pre_nxt := pre.Next // 记录翻转前的首节点
        filpList(pre_nxt, tail)
        // 4. 连接
        pre.Next = tail
        pre_nxt.Next = ntx
        // 5. 更新指针，处理下一个分组
        pre, tail = pre_nxt, pre_nxt
    }
    return hair.Next
}

// 翻转链表[head, tail] （前后连接不管）
func filpList(head, tail *ListNode) {
    if head == nil || head.Next == nil {
        return 
    }
    l, f, afterNode := head, head.Next, tail.Next 
    for f != afterNode {
        t := f.Next 
        f.Next = l
        l = f
        f = t
    }
    // 处理头节点
    head.Next = nil
}
```

二刷

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
    preHead := &ListNode{-1, head}
    // preStart指向此次反转部分头节点的前一个
    // start指向此次反转的头节点
    // end指向此次反转的尾节点的下一个
    preStart, start, end := preHead, head, head
    for end != nil {
        start = end              // 移动到下一反转部分的头部
        // end循环走k-1步, 判断此部分是否满足k个
        for i:=0; i<k-1 && end != nil ; i++ { 
            end = end.Next
        }
        if end == nil {         // 不满足直接退出
            break
        }
        end = end.Next        // 再多走一步，到达下一个开始反转部分的尾部，也是下一个反转的头部

        // 反转
        newHead := reverseList(start, end)
        // 旧头变成尾部，连接下一个
        start.Next = end
        // 旧尾变成新头，连接前一个
        preStart.Next = newHead
        preStart = start             // preStart变为此次反转部分的尾部即下一个翻转部分头节点前一个
    }

    return preHead.Next
}

// 反转链表，返回反转后的头节点, 范围[head, end)
func reverseList(head *ListNode, end *ListNode) (newHead *ListNode) {
    if head == nil || head.Next == nil {
        return head
    }

    slow, fast := head, head.Next
    for fast != end {
        t := fast.Next
        fast.Next = slow
        slow = fast
        fast = t
    }

    // 处理头节点
    head.Next = nil
    return slow
}
```

三刷

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
    if head == nil || head.Next == nil || k == 0 {
        return head
    }
    preHead := &ListNode{-1, head}
    pre, tail, nxt := preHead, preHead, preHead
    EXIT:
    for {
        // 1. 向后移动tail k个位置
        for i:=0; i<k; i++ {
            tail = tail.Next
            if tail == nil {
                break EXIT      // 如果为nil说明后续节点数量不够，不必再翻转
            }
        }
        // 2. 记录next下一个节点
        nxt = tail.Next
        // 3. 翻转
        tmp := pre.Next         // 记录
     
        flipList(pre.Next, tail)
        // 4. 连接
        pre.Next.Next = nxt
        pre.Next = tail
        // 5. 赋值
        pre = tmp
        tail = tmp
        // fmt.Println(pre.Val, tail.Val, nxt.Val)
    }
    return preHead.Next
}

// 部分翻转链表
func flipList(head, tail *ListNode) {
    if head == nil || head.Next == nil {
        return 
    }
    l, r, end := head, head.Next, tail.Next     // 注意：这里不可以直接用tail.Next因为tail的next会被改变
    for r != end {
        t := r.Next
        r.Next = l
        l = r
        r = t
    }
    head.Next = nil
}
```

四刷：

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }

    var pre, frist, last, next *ListNode
    preHead := &ListNode{-1, head}
    pre, frist, last = preHead, preHead.Next, preHead
    Exit:
    for {
        // 找到下k个位置
        for i:=0; i<k; i++ {
            last = last.Next
            if last == nil {
                // 节点不够, 结束循环
                break Exit
            }
        }

        next = last.Next
        // 阻断
        last.Next = nil
        // 翻转
        filp(frist)
        // 链接
        pre.Next = last
        frist.Next = next
        // 移动
        pre = frist
        frist = next
        last = pre
    }

    return preHead.Next
}

func filp(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    s, f := head, head.Next
    for f != nil {
        t := f.Next
        f.Next = s
        s = f
        f = t
    }

    head.Next = nil
    return s
}
```

五刷：

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }

    preHead := &ListNode{-1, head}
    preLeft, left, right, nextRight := preHead, preHead.Next, preHead, preHead
    Exit:
    for right != nil {
        // 移动right
        for i:=0; i<k; i++ {
            right = right.Next
            if right == nil {
                break Exit       
            }
        }
        nextRight = right.Next
        // 断开
        right.Next = nil
        // 反转链表
        filpList(left)
        // 衔接
        left.Next = nextRight
        preLeft.Next = right
        // 更新指针位置
        preLeft = left
        right = left
        left = nextRight    
    }

    return preHead.Next
}


func filpList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }

    s, f := head, head.Next
    for f != nil {
        t := f.Next
        f.Next = s
        s = f
        f = t
    }
    head.Next = nil 
    return s
}
```

