---
title: 24.两两交换链表中的节点
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-11-28 23:11:23
---

## 题目描述

[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

难度中等1137

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

<!-- more --> 

**示例 1：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

**进阶：**你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）

## 解题思路及代码

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
// 使用了4个指针
func swapPairs(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    p1, p2, res := head, head.Next, head.Next           // res记录头节点的下一个其为反转后的头节点位置
    var pre *ListNode                                   // 前一对反转的后一个，为了和下一对的第一个连接上
    for p1 != nil && p2 != nil {
        t := p2.Next
        p2.Next = p1
        p1.Next = t
        if pre != nil {
            pre.Next = p2
        }
        pre = p1
        p1 = t
        if t != nil {
            p2 = t.Next
        }
    }
    return res
}
```

二刷：

```go
func swapPairs(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }

    var s, f, pre, res *ListNode
    s, f, res = head, head.Next, head.Next
    for s != nil && f != nil {
        t := f.Next
        f.Next = s
        s.Next = t              
        if pre != nil {
            // 链接
            pre.Next = f
        }
        pre = s                     // 记录上一次一对的最后一个节点
        s = t
        if s != nil {
            f = s.Next
        }
    }

    return res
}
```

