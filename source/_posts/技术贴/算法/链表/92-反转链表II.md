---
title: 92.反转链表II
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-02-16 01:07:46
---

## 题目描述

[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

难度中等1154

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

 <!-- more -->

**示例 1：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

**进阶：** 你可以使用一趟扫描完成反转吗？

## 解题思路及代码

```go
/**
* Definition for singly-linked list.
* type ListNode struct {
*     Val int
*     Next *ListNode
* }
*/
// 区间反转链表
// 遍历了两次（当left，right为链表头尾时）
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    if left == right {
        return head
    }

    // preP1记录p1的前一个位置
    // p1指向left位置的节点
    // p2指向rigth位置后一个节点
    preHead := &ListNode{-1, head}
    preP1, p1, p2 := preHead, preHead, preHead
    for i:=0; i<left; i++ {
        preP1 = preP1.Next
        p1 = p1.Next
    }
    for i:=0; i<right+1; i++ {      // 注意；这里要+1, 因为是next后一个
        p2 = p2.Next
    }

    // 反转链表
    newHead, tail := reverseList(p1, p2)
    // 调整指针
    tail.Next = p2
    preP1.Next = newHead

    return preHead.Next
}

反转链表
func reverseList(head *ListNode, end *ListNode) (*ListNode, *ListNode) {
    if head == nil || head.Next == nil {
        return head, head
    }

    p1, p2 := head, head.Next
    for p2 != end {
        t := p2.Next
        p2.Next = p1
        p1 = p2
        p2 = t
    }
    head.Next = nil

    return p1, head             // 返回头、尾
}

// 头插法，只需要遍历一次
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    // 需要头插的节点的数量 
    num := right-left
    preHead := &ListNode{-1, head}
    pre, tail, curr, new := preHead, preHead, preHead, preHead

    // 移动三个指针到初始位置
    for i:=0; i<left-1; i++ {
        pre = pre.Next
    }
    // curr指向当前头插第一个节点，pre是curr前一个节点
    // tail指向反转区域的最后一个节点(不会变), new是遍历每次需要头插的节点
    tail, curr, new = pre.Next, pre.Next, pre.Next.Next     

    // 头插
    for i:=0; i<num; i++ {
        pre.Next = new
        next := new.Next            // 保存new的下一个节点，用于tail链接
        new.Next = curr
        tail.Next = next
        curr = new
        new = next  
    }

    return preHead.Next
}
```

二刷：

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    var pre, rightNode, next *ListNode
    preHead := &ListNode{-1, head}
    p := preHead
    pre, next = preHead, preHead
    for i:=0; i<=right; i++ {
        if i == left-1 {
            pre = p
        }else if i == right {
            rightNode = p
            next = p.Next
        }
        p = p.Next
    }

    // 断开
    rightNode.Next = nil

    // 翻转并链接
    t := pre.Next
    pre.Next = filp(pre.Next)
    t.Next = next

    return preHead.Next
}

func filp(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }

    s, f := head, head.Next
    for f != nil {
        t := f.Next
        f.Next = s
        s = f
        f = t
    }

    head.Next = nil
    return s
}
```

