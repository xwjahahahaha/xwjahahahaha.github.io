---
title: 86.分隔链表
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-04-07 17:54:56
---

## 题目描述

[86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

难度中等

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

 <!-- more -->

**示例 1：**

![img](http://xwjpics.gumptlu.work/qinniu_uPic/partition.jpg)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

**示例 2：**

```
输入：head = [2,1], x = 2
输出：[1,2]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 200]` 内
- `-100 <= Node.val <= 100`
- `-200 <= x <= 200`

## 解题思路及代码

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func partition(head *ListNode, x int) *ListNode {
    smallHead, largeHead := &ListNode{}, &ListNode{}
    s, l := smallHead, largeHead
    for p:=head; p!=nil; p=p.Next {
        if p.Val < x {
            s.Next = p
            s = s.Next
        }else if p.Val >= x {
            l.Next = p
            l = l.Next
        }
    }
    // 合并
    s.Next = largeHead.Next
    l.Next = nil
    return smallHead.Next
}
```

二刷：

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
// 两个头节点分别链接
func partition(head *ListNode, x int) *ListNode {
    minHead := &ListNode{}
    maxHead := &ListNode{}
    p1, p2 := minHead, maxHead

    for t:=head; t!=nil; t=t.Next {
        if t.Val < x {
            p1.Next = t
            p1 = p1.Next
        }else {
            p2.Next = t
            p2 = p2.Next
        }
    }
    // 清空最后一个节点的next
    p1.Next, p2.Next = nil, nil

    // 合并
    var end *ListNode
    for end=minHead; end.Next!=nil; end=end.Next {}

    // 链接
    end.Next = maxHead.Next
    return minHead.Next
}
```

