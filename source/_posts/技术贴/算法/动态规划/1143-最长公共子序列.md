---
title: 1143.最长公共子序列
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-18 23:38:29
---

## 题目描述

[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

难度中等811

<!-- more -->

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

 

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**示例 2：**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```

**示例 3：**

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

 

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

通过次数188,529

提交次数295,050

## 解题思路及代码

```go
// dp动态规划
// dp[i][j]表示text1[0:i]与text2[0:j]最大子序列长度(注意：i, j取不到)
// 时间复杂度O(MN)
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i:=0; i<m+1; i++ {
        dp[i] = make([]int, n+1)
    }
    // 填表，根据递推式，可以顺序填
    for i:=0; i<m; i++ {
        for j:=0; j<n; j++ {
            // if i == 0 || j == 0 {
            //     // 边界情况，如果有一方为空串则最大子序列一定为0，默认为0可以不初始化
            //     dp[i][j] = 0
            //     continue
            // }
            // 判断当前
            if text1[i] == text2[j] {
                // 1.第一种情况,加上一对相等的数，那么递推式就是简单的+1
                dp[i+1][j+1] = dp[i][j] + 1
            }else {
                // 2. 第二种情况，看减少一个字符的最大情况，要分两种讨论：text1少一个/text2少一个,取最大
                // 注意：这里不比较text1与text2都少一个字符的情况机dp[i][j]的原因在于此题少一个字符的最长子序列一定>=少两个的
                max := dp[i+1][j]
                if dp[i][j+1] > max {
                    max = dp[i][j+1]
                }
                dp[i+1][j+1] = max
            }
        }
    }
    return dp[m][n]
}
```

