---
title: 5-最长回文子串
tags:
  - golang
categories:
  - technical
  - leetcode
toc: true
date: 2021-03-23 12:51:42
---

## 题目描述

[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

难度中等

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

 <!-- more -->

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

**示例 3：**

```
输入：s = "a"
输出："a"
```

**示例 4：**

```
输入：s = "ac"
输出："a"
```

 

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成




## 解题思路及代码

此题目视频题解很详细,建议看视频

### 方法一: 动态规划

![cjc73a](http://xwjpics.gumptlu.work/qinniu_uPic/cjc73a.png)

时间复杂度O(n^2^), 空间复杂度(n^2^)

```go
// 动态规划
func longestPalindrome(s string) string {
    n := len(s)
    width, maxLen := 0, 0
    maxI := 0
    dp := make([][]int, n)
    for i := 0; i < n; i++ {
        dp[i] = make([]int, n)
    }

    // 状态转移
    // dp(i, j) = dp(i+1, j-1) && s[i] == s[j]
    // 注意: 此题的状态转移必须从短串向大串才能可以
    // 从二维数组来看,[i+1][j-1]必须先知道当前数组位置其下右位置的数才能填充此位置,所以需要按列遍历!
    for j:=0; j<n; j++{
        for i:=0; i<=j; i++{
            if i == j {         // 长度为1,单个字母直接赋值为true
                dp[i][j] = 1
            }else if i+1 == j { // 长度为2,两个字母,检查是否相同
                if s[i] == s[j] {
                    dp[i][j] = 1
                }           
            }else {             // 长度>2,状态转移
                if s[i] == s[j] {
                    dp[i][j] = dp[i+1][j-1]
                }
            }
            // 比较长度
            width = j-i+1
            if dp[i][j] == 1 && width > maxLen {
                maxI = i
                maxLen = width
            }
        }
    }
    return s[maxI:maxI+maxLen]
}
```

### 方法二:中心拓展方法

状态转移时,从子串不断向父串拓展,其中**状态转移是连续的**,**一旦子串不满足就不用继续拓展父串了**

*P*(*i*,*j*)←*P*(*i*+1,*j*−1)←*P*(*i*+2,*j*−2)←⋯←某一边界情况

我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案

而边界的情况就是**单字母和双字母(相同)**这两种情况,其实边界问题也就是对应着回文串的中心,这就是中心拓展方法

时间复杂度O(N^2^) 外层N,拓展最长拓展N次

空间复杂度O(1)

```go
// 中心拓展方法
func longestPalindrome(s string) string {
    // 遍历各个中心
    start, maxLen := 0, 0      //最大回文子串的起始位和长度
    // 分为两种
    //1.以单个字母为中心 2.以两个相同的字母为中心
    for i:=0; i<len(s); i++ {
        // 以单个字母为中心
        left_1, right_1 := expandFunc(s, i, i)
        // 以两个字母位中心
        left_2, right_2 := expandFunc(s, i, i+1)
        // 比较两者长度的最大者
        width_1 := right_1 - left_1 + 1
        width_2 := right_2 - left_2 + 1
        if width_1 > maxLen {
            maxLen = width_1
            start = left_1
        }
        if width_2 > maxLen {
            maxLen = width_2
            start = left_2
        }
    }
    return s[start:start+maxLen]
    
}

// 拓展函数
// 返回能拓展的最大长度
func expandFunc(s string, left, right int) (int, int) {
    // 如果碰到边界或者两边字母不相同就退出
    for left >=0 && right < len(s) && s[left] == s[right] {
        left --
        right ++
    }
    return left + 1, right -1
}
```

牛客二刷

```go
package main

/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param A string字符串 
 * @return int整型
*/

// 方法一：暴力 时间复杂度O(N^3) 空间复杂度O(1)
func getLongestPalindrome( A string ) int {
    maxLen := 1        // 默认最大回文长度设置为1
    for i:=0; i<len(A)-1; i++ {    // i表示开始的位置
        for j:=i+1; j<len(A); j++ {
            if j-i+1 > maxLen && isPalindrome(A[i:j+1]) {// 如果长度大于1的子串并且是回文串则记录最大
                maxLen = j-i+1
            }
        }
    }
    return maxLen
}

// 判断是否为回文子串
func isPalindrome(s string) bool {
    i, j := 0, len(s)-1
    for i < j {
        if s[i] != s[j] {
            return false
        }
        i++; j--
    }
    return true
}

// 方法二: 中心扩散法：枚举每个中心位置 时间复杂度O(N^2) 空间复杂度O(1)
func getLongestPalindrome( A string ) int {
    maxLen := 1
    for i:=0; i<len(A)-1; i++ {    // i表示枚举的中心的位置
        // 最长回文子串有奇偶俩种情况
        odd := maxPalidrome(A, i, i)
        even := maxPalidrome(A, i, i+1)
        // 判断两种情况哪个大
        if odd > even && odd > maxLen{
            maxLen = odd
        }else if even > maxLen {
            maxLen = even
        }
    }
    return maxLen
}

// 找到以i，j为中心的最大回文串长度
func maxPalidrome(s string, i, j int) int {
    for i>=0 && j<len(s) {
        if s[i] == s[j] {
            i --; j++
        }else {
            break
        }
    }
    return j-i-1
}

// 方法三：动态规划，核心思路：状态转移规律：一个回文串其去掉首位还是回文串
// dp[i][j] 表示一个[i, j]的子串是否是回文串
// 状态转移方程：dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]
// 注意边界条件：当子串的大小<2就不用判断是否是回文串了，因为一定是回文串, j-1-(i+1)+1<2 => j-i<3  
// 时间复杂度O(N^2) 空间复杂度O(N^2)
func getLongestPalindrome( A string ) int {
    maxLen := 1       // 最大长度
    // 创建dp数组
    dp := make([][]bool, len(A))
    for i:=0; i<len(dp); i++ {
        dp[i] = make([]bool, len(A))
    }
    // 填写dp二维表格，要知道dp[i][j]就需要先知道dp[i+1][j-1]的值，在二维表中就是其左下方的值
    // 只有右上半区的表格需要填写，不能按顺序填写，要按列填写
    for j:=0; j<len(A); j++ {     // 列
        for i:=0; i<j; i++ {      // 行 （i<j，保证在右上半区）
            // 单个字符一定是回文
            if j == i {
                dp[i][j] = true
                continue
            }
            // 使用递归公式计算
            if A[i] == A[j] && (j-i<3 || dp[i+1][j-1]) { // 如果j-i<3就不用判断了（并且利用了短路效应）
                dp[i][j] = true
                if j-i+1 > maxLen {
                    maxLen = j-i+1
                }
            }
        }
    }
    return maxLen
}
```

牛客三刷

```go
package main

import "math"
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param A string字符串 
 * @return int整型
*/

// 中心扩散法：枚举每个中心位置 时间复杂度O(N^2) 空间复杂度O(1)
func getLongestPalindrome( A string ) int {
    expand := func(c1, c2 int) int {
        max := math.MinInt64
        // 左右两个方向拓展
        l, r := c1, c2
        for l>=0 && r<len(A) {
            if A[l] == A[r] {
                // 找最大
                if r-l+1 > max {
                    max = r-l+1
                }
                l--; r++
            }else {
                break
            }
        }
        return max
    }
    // 遍历中心位置
    ans := math.MinInt64
    for i:=0; i<len(A); i++ {
        odd := expand(i, i)
        even := expand(i, i+1)
        ans = max(ans, max(odd, even))
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

// dp动态规划
// dp[i][j]表示一个A[i:j]是一个回文串的长度
func getLongestPalindrome( A string ) int {
    n := len(A)
    dp := make([][]bool, n)
    for i:=0; i<n; i++ {
        dp[i] = make([]bool, n)
    }
    max := math.MinInt64
    for j:=0; j<n; j++ {
        for i:=0; i<=j; i++ {
            if A[i] == A[j] && (j-i<3 || dp[i+1][j-1]) {            // 每次需要依赖左下方，但是左下方不一定构成有效字符串，其子串如果长度<2就判定为true，即(j-1)-(i+1)+1<2
                dp[i][j] = true
                if j-i+1 > max {
                    max = j-i+1
                }
            }
        }
    }
    return max
}
```

### 方法三：线性复杂度的马拉车Manacher算法

* 首先对原始字符串进行预处理

  ![9GksOc](http://xwjpics.gumptlu.work/qinniu_uPic/9GksOc.png)

* 然后再对预处理字符串执行动态规划、中心扩散方法 （如何优化计算上述每一个位置的最长回文子串？）

​		变量定义：

​		![tsazoE](http://xwjpics.gumptlu.work/qinniu_uPic/tsazoE.png)

（以后再来）https://zhuanlan.zhihu.com/p/70532099
