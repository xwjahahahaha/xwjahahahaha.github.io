---
title: 买卖股票的最佳时机123
tags:
  - java
categories:
  - technical
  - leetcode
toc: true
date: 2020-05-29 15:08:15
---

# 买卖股票的最佳时机（一）

## 题目描述

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

<!-- more -->

示例 1:

> **输入**: `[7,1,5,3,6,4]`

>**输出**: 5

>**解释**: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。

>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。


示例 2:

> **输入**: `[7,6,4,3,1]`

> **输出**: 0

> **解释**: 在这种情况下, 没有交易完成, 所以最大利润为 0。

## 解题思路

求序列中下标对（i,j）对应数的差额最大值，且保证i<j

## 代码
```java
class Solution {
    //第一种方法： 暴力枚举法  时间复杂度O(n*n) 空间复杂度O(1)
    public int maxProfit(int[] prices) {
        int i, j, maxPrices = 0;
        for(i = 0; i < prices.length; i++)
            for(j = i+1; j < prices.length; j++)
                if(prices[j] - prices[i] > maxPrices)
                    maxPrices = prices[j] - prices[i];
        return maxPrices;
    }
}
```
```java
class Solution {
    //第二种方法： 一次遍历   时间复杂度O(n) 空间复杂度O(1)
    //遍历每个元素时，判断其是否比当前记录的最小值小，是则记录，否则算差值再比较差值，找出最大差值
    public int maxProfit(int[] prices) {
        //初始化记录的最小值为数值最大值
        int recoMin = Integer.MAX_VALUE;
        int maxPrice = 0;
        for(int i = 0; i < prices.length; i++){
            if(prices[i] < recoMin)
                recoMin = prices[i];
            else if(prices[i] - recoMin > maxPrice)
                maxPrice = prices[i] - recoMin;
        }
        return maxPrice;      
    }
}
```

这一题的最佳解法与**求最大子序列和**的最佳解法（线性复杂度）有异曲同工之妙

点击跳转： [求最大子序列和](https://myblog.gumptlu.work/2020/05/29/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/)

二刷：贪心与dp

```go
package main
import "fmt"
/**
  * 
  * @param prices int整型一维数组 
  * @return int整型
*/
func maxProfit( prices []int ) int {
    min, ans := prices[0], 0 
    for i:=0; i<len(prices); i++ {
        if prices[i] < min {
            min = prices[i]
        }else {
            if prices[i]-min > ans {
                ans = prices[i]-min
            }
        }
    }
    
    return ans
}


// dp的思想做
// dp[i][j]表示到第i天手上的最大现金数量, j只有两个值0，1，0表示今天不持有股票，1表示今天持有股票
// 注意只能买卖一次
func maxProfit( prices []int ) int {
    n := len(prices)
    dp := make([][2]int, n)
    // 初始化
    dp[0][0] = 0
    dp[0][1] = -1*prices[0]
    for i:=1; i<n; i++ {
        // 今天不持股，则分为两种情况：1、昨天持股,今天必须卖出，现金扣除; 2、昨天不持股，今天也不持股
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        // 今天持股，也分为两种情况: 1、昨天不持股，今天必须买入 2、昨天持股，今天什么也不做
        // 注意这里直接用-1*prices[i]而不是通过前一天的现金-今天的买入，因为前一天未持股的现金不一定是0（因为算最大值）
        dp[i][1] = max(-prices[i], dp[i-1][1])        
    }
    // 最后一天不持股的现金就是题目所求
    return dp[n-1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

***

# 买卖股票的最佳时机（二）

## 题目描述

与第一题相同，不同之处在于，**可以多次买卖股票，但是必须在上一次卖出后才能买下一次的股票**

示例 1:

> **输入**: `[7,1,5,3,6,4]`

> **输出**: 7

> **解释**: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

示例 2:

> **输入**: `[1,2,3,4,5]`

> **输出**: 4

> **解释**: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:

> **输入**: `[7,6,4,3,1]`

> **输出**: 0

> **解释**: 在这种情况下, 没有交易完成, 所以最大利润为 0。

## 解题思路

在峰底时买入，在峰顶时卖出, **所有的这样的差值都累加才会使得利润最大**

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200529152315.png)

图中可以看出： A + B > C 
## 代码

```java
class Solution {
    //思路： 在峰底时买入，在峰顶时卖出
    public int maxProfit(int[] prices) {
        int bottom, top, len = prices.length, profit = 0, i = 0;
        while(i < len-1){
            while(i < len-1 && prices[i] >= prices[i+1]) ++i;
            bottom = i;
            while(i < len-1 && prices[i] <= prices[i+1]) ++i;
            top = i;
            profit += prices[top] - prices[bottom];
        }
        return profit;
    }
}
```
牛客二刷

贪心：

```go
package main

/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 计算最大收益
 * @param prices int整型一维数组 股票每一天的价格
 * @return int整型
*/
// 找到所有上升序列, 统计和就是答案
func maxProfit( prices []int ) int {
    l, r, n, sum := 0, 0, len(prices), 0
    for l < n-1 && r < n-1 {
        r = l            // 移动指针
        // 移动右指针找到峰值
        for r < n-1 && prices[r] <= prices[r+1] {
            r ++
        }
        // 累加
        sum += prices[r]-prices[l]
        // 移动左指针找峰底
        l = r            // 移动指针
        for l < n-1 && prices[l] >= prices[l+1] {
            l ++
        }
    }
    return sum
}
```

dp的思想，与第一题思路几乎一样，不同点在于

* 如果只能买卖一次，那么买入时的利润与前一次无关，因为只能一次买入
* 如果能够买卖多次，那么买入时的利润就与前一次最大利润有关，因为可以买入多次

```go
// dp动态规划
// dp[i][0]表示当天未持股的最大现金/利润，dp[i][1]表示当天持股时的最大现金/利润
func maxProfit( prices []int ) int {
    n := len(prices)
    dp := make([][2]int, n)
    // 初始化
    dp[0][0] = 0
    dp[0][1] = -prices[0]
    //填表
    for i:=1; i<n; i++ {
        // 今天不持股，1、昨天不持股：今天什么也不做；2、昨天持股：今天卖出
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        // 今天持股，1、昨天不持股：今天买入；2、昨天持股：今天什么也不做
        dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1])
    }
    // 最后一天不持股就是最大利润
    return dp[n-1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

# 买卖股票的最佳时机（三）（困难）

## 题目描述

## 描述

假设你有一个数组prices，长度为n，其中`prices[i]`是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益

1. 你最多可以对该股票有**两笔**交易操作，一笔交易代表着一次买入与一次卖出，但是再次购买前必须卖出之前的股票
2. 如果不能获取收益，请返回0
3. 假设买入卖出均无手续费

数据范围：$1 \le n \le 10^5$，股票的价格满足 $1 \le val\le 10^4$

要求: 空间复杂度 $O(n)$，时间复杂度 $O(n)$

进阶：空间复杂度 $O(1)$，时间复杂度 $O(n)$

## 解题思路与代码

五个状态dp

```go
package main
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 两次交易所能获得的最大收益
 * @param prices int整型一维数组 股票每一天的价格
 * @return int整型
*/
// dp五种状态, 每种都表示最大利润
// dp[i][0]:从来未操作; dp[i][1]:第一次卖出; 
// dp[i][2]:第一次买入; dp[i][3]:第二次卖出; dp[i][4]:第二次买入
// 注意顺序不能跳着转换：从未操作=>第一次买入=>第一次卖出=>第二次买入=>第二次卖出
func maxProfit( prices []int ) int {
    n := len(prices)
    dp := make([][5]int, n)
    // 初始化
    dp[0][0], dp[0][1], dp[0][2], dp[0][3], dp[0][4] = 0, 0, -prices[0], 0, -prices[0]
    for i:=1; i<n; i++ {
        // 今天啥也不做 = 前一天啥也不做
        dp[i][0] = dp[i-1][0]
        // 今天第一次卖出有两种情况（选最大）：1、前一天已经卖出，今天啥也不做； 2、前一天买入今天卖出
        dp[i][1] = max(dp[i-1][1], dp[i-1][2]+prices[i])
        // 今天第一次买入：1、昨天已经第一次买入了； 2、昨天从未操作，今天第一次买入
        dp[i][2] = max(dp[i-1][2], dp[i-1][0]-prices[i])
        // 今天第二次卖出：1、昨天已经第二次卖出了； 2、昨天第二次买入，今天第二次买入
        dp[i][3] = max(dp[i-1][3], dp[i-1][4]+prices[i])
        // 今天第二次买入：1、昨天已经第二次买入了； 2、昨天第一次买入，现在第二次卖出
        dp[i][4] = max(dp[i-1][4], dp[i-1][1]-prices[i])
    }
    return dp[n-1][3]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```