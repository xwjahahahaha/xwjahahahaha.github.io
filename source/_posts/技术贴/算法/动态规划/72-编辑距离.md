---
title: 72.编辑距离
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-19 00:51:40
---

## 题目描述

[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

难度困难2051

给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2` 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

 <!-- more -->

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

 

**提示：**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成

通过次数202,648

提交次数328,951

## 解题思路及代码

```go
// dp动态规划
// 时间复杂度O(MN)
func minDistance(word1 string, word2 string) int {
    m, n := len(word1), len(word2)
    if m == 0 {
        return n
    }
    if n == 0 {
        return m
    }
    dp := make([][]int, m+1)
    for i:=0; i<m+1; i++ {
        dp[i] = make([]int, n+1)
    }
    // 初始化边界情况
    for i:=0; i<m+1; i++ {
        dp[i][0] = i
    }
    for j:=0; j<n+1; j++ {
        dp[0][j] = j
    }
    // 顺序填表
    for i:=0; i<m; i++ {
        for j:=0; j<n; j++ {
            if word1[i] == word2[j] {
                // 最后一个字母相同, 如果不管哪个只少一个字符都不会比少两个字符的小，所以可以不考虑
                dp[i+1][j+1] = dp[i][j]
            }else {
                // 最后一个字母不同
                min := dp[i][j]             // 替换  两个字符串都最后一个字符
                if dp[i+1][j] < min {       // 删除  word2少一个字符
                    min = dp[i+1][j]    
                }
                if dp[i][j+1] < min {       // 添加  word1少一个字符
                    min = dp[i][j+1]
                }
                dp[i+1][j+1] = min + 1 //+1是因为以上每个操作都需要多一个操作
            }
        }
    }
    return dp[m][n]
}
```

