---
title: 72.编辑距离
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-19 00:51:40
---

## 题目描述

[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

难度困难2051

给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2` 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

 <!-- more -->

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

 

**提示：**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成

通过次数202,648

提交次数328,951

## 解题思路及代码

```go
// dp动态规划
// 时间复杂度O(MN)
func minDistance(word1 string, word2 string) int {
    m, n := len(word1), len(word2)
    if m == 0 {
        return n
    }
    if n == 0 {
        return m
    }
    dp := make([][]int, m+1)
    for i:=0; i<m+1; i++ {
        dp[i] = make([]int, n+1)
    }
    // 初始化边界情况
    for i:=0; i<m+1; i++ {
        dp[i][0] = i
    }
    for j:=0; j<n+1; j++ {
        dp[0][j] = j
    }
    // 顺序填表
    for i:=0; i<m; i++ {
        for j:=0; j<n; j++ {
            if word1[i] == word2[j] {
                // 最后一个字母相同, 如果不管哪个只少一个字符都不会比少两个字符的小，所以可以不考虑
                dp[i+1][j+1] = dp[i][j]
            }else {
                // 最后一个字母不同
                min := dp[i][j]             // 两个字符串都少最后一个字符，不同的替换
                if dp[i+1][j] < min {       // word2少一个字符，然后添加与word1相同字符
                    min = dp[i+1][j]    
                }
                if dp[i][j+1] < min {       // word1少一个字符，然后添加与word2相同字符
                    min = dp[i][j+1]
                }
                dp[i+1][j+1] = min + 1 //+1是因为以上每个操作都需要多一个操作
            }
        }
    }
    return dp[m][n]
}
```

牛客二刷

```go
package main
// import "fmt"

/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param str1 string字符串 
 * @param str2 string字符串 
 * @return int整型
*/
// dp[i][j]表示str1[:i]与str2[:j]两个子串的最小操作数（注意取不到i，j）
func editDistance( str1 string ,  str2 string ) int {
    n, m := len(str1), len(str2)
    dp := make([][]int, n+1)
    for i:=0; i<=n; i++ {
        dp[i] = make([]int, m+1)
    }
    // 初始化
    for i:=0; i<=n; i++ {
        dp[i][0] = i
    }
    for j:=0; j<=m; j++ {
        dp[0][j] = j
    }
    // 填表
    for i:=0; i<n; i++ {
        for j:=0; j<m; j++ {
            if str1[i] == str2[j] {
                // 如果末尾字母相同，那么不需要额外操作即可保持相等，继承上一次最小值
                dp[i+1][j+1] = dp[i][j]
            }else {
                // 末尾两个字符不相同：有三种处理方式，找最小次数
                // dp[i][j]+1:表示都去掉尾部字符后的最小次数 + 替换不同字符串其中一个字符串为另一个字符操作数+1
                // dp[i+1][j]+1:表示字符串2去掉最后一个字符的最小次数 + 再在str2添加str1相同的最后一个字符的操作数1
                // dp[i][j+1]+1:表示字符串1去掉最后字符的最小次数 + 再在str1添加str2相同的最后一个字符的操作数1
                dp[i+1][j+1] = min(dp[i][j], min(dp[i+1][j], dp[i][j+1])) + 1
            }
        }
    }
    return dp[n][m]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```
