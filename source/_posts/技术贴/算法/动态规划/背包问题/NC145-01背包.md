---
title: NC145.01背包
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-02-12 00:29:50
---

## 题目描述

[NC145 01背包](https://www.nowcoder.com/practice/2820ea076d144b30806e72de5e5d4bbf)

已知一个背包最多能容纳体积之和为v的物品

现有 n 个物品，第 i 个物品的体积为 vi , 重量为 wi

求当前背包最多能装多大重量的物品?

<!-- more -->

### 示例1

输入：

```
10,2,[[1,3],[10,4]]
```

返回值：4

说明：第一个物品的体积为1，重量为3，第二个物品的体积为10，重量为4。只取第二个物品可以达到最优方案，取物重量为4   

### 示例2

输入：

```
10,2,[[1,3],[9,8]]
```

返回值：11

说明：两个物品体积之和等于背包能装的体积，所以两个物品都取是最优方案  

## 解题思路及代码

https://www.nowcoder.com/practice/2820ea076d144b30806e72de5e5d4bbf?tpId=117&&tqId=1266316

```go
package main

/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 计算01背包问题的结果
 * @param V int整型 背包的体积
 * @param n int整型 物品的个数
 * @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
 * @return int整型
*/
func knapsack( V int ,  n int ,  vw [][]int ) int {
    // write code here
    // 二维dp[i][j] 表示面对第i个物品，此时包剩余j空间大小最重能够装下的大小
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, V+1)
    }
    
    // 填表
    for i:=1; i<=n; i++ {
        for j:=1; j<=V; j++ {
            if j < vw[i-1][0] {
                dp[i][j] = dp[i-1][j]
            }else {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-vw[i-1][0]] + vw[i-1][1])
            }
        }
    }
    
    return dp[n][V]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
} 
```

