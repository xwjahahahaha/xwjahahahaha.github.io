---
title: 31.下一个排列
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-17 22:56:41
---

## 题目描述

[31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

难度中等1487

实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间

 <!-- more -->

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

通过次数247,973

提交次数665,484

## 解题思路及代码

```go
// 1. 找一个比现在大的序列 => 将前面一个较小的数i与后面一个较大的数j对掉，那么就比现在大
// 2. 只刚刚好比现在的序列大1 => i的位置一定要靠后，j位置的数一定越小越好，交换后[i+1, n)的所有数按升序一定最小（在大于原序列的情况下）
// 3. i的位置靠后 => 从后往前找[i, i+1]顺序对，满足nums[i]<nums[i+1]时i就找到了(最右)，此时[i+1, n)一定是降序
// 4. j位置的数一定越小越好 => j可以为i+1，但是nums[i+1]不一定是最小的大于nums[i]的数 => 从[i+1, n)这个降序序列从后往前找第一个>nums[i]的数就是j
// 5. 交换后[i+1, n)的所有数按升序一定最小 => 经过上面的交换，此时[i+1, n)仍然是一个降序，直接双指针交换即翻转数组可无需排序
func nextPermutation(nums []int)  {
    // 1. 找出i最小数的位置
    n := len(nums)
    if n <= 1 {
        return
    }
    i, j := n-2, n-1
    for i > 0 && nums[i] >= nums[i+1] { i -- }
    // 2. 找到j最大数的位置
    for j > i && nums[j] <= nums[i] { j -- }
    // 3. 交换i,j位置数, 翻转[i+1, n)区域
    nums[i], nums[j] = nums[j], nums[i]
    // 如果原序列是完全降序，那么i=j=0, 此时也是直接翻转数组
    if i == 0 && j == 0 {
        i = -1      // 适配下面的函数
    }
    func(nums []int) {
        n := len(nums)
        for i:=0; i<n/2; i++ {
            nums[i], nums[n-i-1] = nums[n-i-1], nums[i]
        }
    }(nums[i+1:])
}
```

