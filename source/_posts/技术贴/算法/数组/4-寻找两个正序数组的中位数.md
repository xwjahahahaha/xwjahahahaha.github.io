---
title: 4.寻找两个正序数组的中位数
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-23 18:37:39
---

## 题目描述

[4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

难度困难4902

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

 <!-- more -->

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

**示例 3：**

```
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
```

**示例 4：**

```
输入：nums1 = [], nums2 = [1]
输出：1.00000
```

**示例 5：**

```
输入：nums1 = [2], nums2 = []
输出：2.00000
```

 

**提示：**

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-106 <= nums1[i], nums2[i] <= 106`

## 解题思路及代码

```go
// 直接的思路：合并数组再获取中位数
// 时间复杂度O(m+n), 空间复杂度O(m+n)
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    // 合并两个有序数组, 再获得中位数
    return getMedin(mergeNums(nums1, nums2))
}

func mergeNums(nums1, nums2 []int) []int {
    m, n := len(nums1), len(nums2)
    if m == 0 {
        return nums2
    }
    if n == 0 {
        return nums1
    }
    i, j := 0, 0 
    help := make([]int, 0, len(nums1)+len(nums2))
    for i<m && j<n {
        if nums1[i] < nums2[j] {
            help = append(help, nums1[i])
            i ++
        }else {
            help = append(help, nums2[j])
            j ++
        }
    }
    for i<m {
        help = append(help, nums1[i])
        i++
    }
    for j<n {
        help = append(help, nums2[j])
        j++
    }
    return help
}

func getMedin(nums []int) float64 {
    n := len(nums)
    if n == 0 {
        return 0.0
    }
    // 判断奇偶
    if n % 2 == 0 {
        return float64(nums[n/2-1] + nums[(n/2)])/2.0
    }
    return float64(nums[n/2])
}


// 优化思路一：空间复杂度优化，求m+n个数的中位数 等价于 求m+n个数的第k小的数（下标(m+n)/2-1） (如果m+n是偶数那么就是第k和第k+1小的数的平均值)
// 双指针不必完全合并，只需要比较到第k个位置即可
// 时间复杂度O(m+n), 空间复杂度O(1)
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    i, j, count, k := 0, 0, 0, (m+n)/2
    medinLeft, medinRight := 0, 0           // 中位数的两个位置（如果为总长为奇数则right就是中位数）
    for i<m && j<n && count <= k {
        medinLeft = medinRight
        if nums1[i] < nums2[j] {
            medinRight = nums1[i]
            i++
        }else {
            medinRight = nums2[j]
            j++
        }
        count++
    }
    for count <= k && i<m {
        medinLeft = medinRight
        medinRight = nums1[i]
        i++; count++
    }
    for count <= k && j<n {
        medinLeft = medinRight
        medinRight = nums2[j]
        j++; count++
    }
    // 返回值
    if (m+n)%2 == 0 {
        return float64(medinLeft + medinRight)/2.0
    }
    return float64(medinRight)
}

// 二分法查找第k小的数，上面的方法是每次都排除掉一个，其实每次可以排除掉k/2个
// 对两个数组，分别取前k/2个数，一起就是前k个数进行比较，如果nums1[k/2-1] < nums2[k/2-1]那么nums[0~k/2-1]的数都比第k个数小，可以排除一半 （因为找到了比他们大的数nums2[k/2-1]）
// 此时可以迭代将k变为k=k-k/2，然后继续迭代比较k/2位置的数的大小，舍弃一半
// 注意：当k/2-1 >= 数组长度时 取为数组的长度
// 时间复杂度O(log(m+n))
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { 
    m, n := len(nums1), len(nums2)
    var help func(nums1, nums2 []int, k int) int
    help = func(nums1, nums2 []int, k int) int {        // 返回第k小的数
        fmt.Println(nums1, nums2, k)
        // 一旦有一个数组为空就直接返回另一个的第k小
        if len(nums1) == 0 {
            return nums2[k-1]
        }
        if len(nums2) == 0 {
            return nums1[k-1]
        }
        // 递归终止条件
        if k == 1 {
            // 比较两个位置的数谁小即可
            return min(nums1[0], nums2[0])
        }
        preK := k
        k /= 2
        // 比较：防止超出数组范围
        index1, index2 := min(k, len(nums1))-1, min(k, len(nums2))-1
        if nums1[index1] > nums2[index2] {
            k = preK-index2-1               // k减去此次删掉的个数
            nums2 = nums2[index2+1:]
        }else {
            k = preK-index1-1
            nums1 = nums1[index1+1:]
        }
        // 递归
        return help(nums1, nums2, k)
    }
    if (m+n)%2 == 0 {
        return float64(help(nums1, nums2, (m+n)/2) + help(nums1, nums2, (m+n)/2+1))/2.0
    }
    return float64(help(nums1, nums2, (m+n)/2+1))
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

