---
title: 打乱数组
tags:
  - java
categories:
  - technical
  - leetcode
  - 洗牌算法
toc: true
date: 2020-06-06 16:28:37
---

## 题目描述
打乱一个没有重复元素的数组。


示例:

// 以数字集合 1, 2 和 3 初始化数组。
`int[] nums = {1,2,3}`;
`Solution solution = new Solution(nums)`;

<!-- more -->

// 打乱数组` [1,2,3] `并返回结果。任何 `[1,2,3]`的排列返回的概率应该相同。
`solution.shuffle()`;

// 重设数组到它的初始状态`[1,2,3]`。
`solution.reset()`;

// 随机返回数组`[1,2,3]`打乱后的结果。
`solution.shuffle()`;

>来源：力扣（LeetCode）

>链接：https://leetcode-cn.com/problems/shuffle-an-array

>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 代码

```java
class Solution { 
    private int[] nums;
    private int[] preNums;
    private Random r = new Random();

    public Solution(int[] nums) {
        this.nums = nums;
        //复制一份
        this.preNums = nums.clone();
    }
    
    /** Resets the array to its original configuration and return it. */
    public int[] reset() {
        //不能写nums = preNums， 因为这只支持一次修改复原，若复原后再修改nums会和preNums一起改（因为指向同一空间）
        this.nums = preNums.clone(); 
        return this.preNums;
    }
    
    //拷贝数组到list中
    private List<Integer> copyToList(int[] nums){
        List<Integer> resList = new ArrayList<>();
        for(int i=0; i<nums.length; i++){
            resList.add(nums[i]);
        }
        return resList;
    }
    
    /** Returns a random shuffling of the array. */
    //第一种方法： 使用list保存（相当于帽子），随机取一个后删除
    //时间复杂度O(N*N) 空间复杂度O(N)
    public int[] shuffle() {
        List<Integer> copyList = copyToList(nums);
        //随机取一个写到数组中
        for(int i=0; i<nums.length; i++){
            int randomIdx = r.nextInt(copyList.size());
            nums[i] = copyList.get(randomIdx);
            copyList.remove(randomIdx);  //这里是线性的时间
         }
        return nums;
    }
    
    //第二种方法： Fisher-Yates 洗牌算法
    //使用交换来减少时间复杂度和空间复杂度   时间复杂度O(N) 空间复杂度O(N)
    //遍历数组，对于第i个元素，随机数从[i,nums)中随机取一个，取的这个数就相当于从帽子中拿出一个数，交换到前面相当于“删除”
    //注意的细节： 自己可以与自己交换，这样才满足等概率
    public int[] shuffle() {
        for(int i=0; i<nums.length; i++){
            int randomIdx = randomRange(i, nums.length);
            int t = nums[i];
            nums[i] = nums[randomIdx];
            nums[randomIdx] = t;
        }
        
        return nums;
    }
    
    private int randomRange(int min, int max){
        return r.nextInt(max - min) + min;
    } 
    
    
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int[] param_1 = obj.reset();
 * int[] param_2 = obj.shuffle();
 */
```

>作者：gumptlu

>链接：https://leetcode-cn.com/problems/shuffle-an-array/solution/xi-pai-suan-fa-by-gumptlu/

>来源：力扣（LeetCode）

>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。