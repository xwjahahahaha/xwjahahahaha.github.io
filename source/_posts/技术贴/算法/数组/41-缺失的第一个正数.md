---
title: 41.缺失的第一个正数
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-30 20:54:14
---

## 题目描述

[41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

难度困难1328

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

 <!-- more -->

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 5 * 105`
- `-231 <= nums[i] <= 231 - 1`

通过次数187,639

提交次数446,035

## 解题思路及代码

```go
// 暴力hash表
// 时间复杂度O(N), 空间复杂度O(N)
func firstMissingPositive(nums []int) int {
    hashMap := make(map[int]bool)
    // 全部存入hash表
    for _, num := range nums {
        hashMap[num] = true
    }
    // 从1开始比对
    for i:=1; ; i++ {
        if _, has := hashMap[i]; !has {
            return i
        }
    }
    return -1
}

// 原地hash
// 在可修改原数组的前提下实现O(N)的时间复杂度以及O(1)的空间复杂度
// 1. 重要规律：长度为N的数组其最小正整数一定属于[1,N+1]范围内，不可能大于N+1，因为最多只能存储N个数
// 2. 在原地数组实现一个hash表：如果一个数x属于[1,N]，那么就将数组对应x-1位置（数组下标少一）“标记”为存在
// 那么数组下标就对应一个[1,N]范围的hash表，出现了就会被“标记”，如果[1,N]全部被标记，那么N+1就是答案
// 3. “标记”：因为只考虑[1,N]，所以不在此范围内的数就可以用一个数代替（例如N+1）这样就不存在负数了，然后需要标记对应位置的数时就将该数变为负数即算标记上
func firstMissingPositive(nums []int) int {
    n := len(nums)
    // 处理不在范围[1,N]的数
    for i, num := range nums {
        if num < 1 || num > n {
            nums[i] = n+1
        }
    }
    // 标记
    for _, num := range nums {
        if abs(num) != n+1 && nums[abs(num)-1] > 0 {  // 屏蔽[1,N]以外的数以及避免重复标记
            nums[abs(num)-1] *= -1
        } 
    }
    // 扫描
    for i, num := range nums {
        if num > 0 {
            return i+1  
        }
    }
    return n+1  // 都标记了就返回n+1
}

func abs(n int) int {
    if n < 0 {
        return -n
    }
    return n
}
```

