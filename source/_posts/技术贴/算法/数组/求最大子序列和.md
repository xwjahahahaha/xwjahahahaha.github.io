---
title: 求最大子序列和
tags:
  - java
categories:
  - technical
toc: true
date: 2020-05-29 15:26:01
---

[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

## 题目描述

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: `[-2,1,-3,4,-1,2,1,-5,4]`,

输出: 6

解释: 连续子数组 `[4,-1,2,1]` 的和最大，为 6。

<!-- more -->
## 思路

四种方法，从暴力——>DP

## 代码

```java
//第一种方法： 暴力枚举法  时间复杂度O(N*N*N) 空间复杂度O(1)
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum = Integer.MIN_VALUE, sum;
        //i是起点，j是终点
        for(int i=0; i<nums.length; i++){
            for(int j=i; j<nums.length; j++){
                sum = 0;
                for(int k=i; k<=j; k++)
                    sum += nums[k];
                if(sum > maxSum)
                    maxSum = sum;
            }
        }
        return maxSum;
    }
}
```
```java
//第二种方法： 暴力枚举的优化  时间复杂度O(N*N) 空间复杂度O(1)
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum = Integer.MIN_VALUE, sum;
        //i是起点，j是增长
        for(int i=0; i<nums.length; i++){
            sum = 0;
            for(int j=0; j<nums.length-i; j++){
                sum += nums[i+j];
                if(sum > maxSum)
                    maxSum = sum;
            }
        }
        return maxSum;
    }
}
```

```java
//第三种方法： 分治法    时间复杂度O(nlogn) 空间复杂度O(logn)
//分两半，分别求左区间、右区间、以及跨越两个区间的最大值
//注意本题，空子子序列即0不算在内
class Solution {
    public int helper(int[] nums, int left, int right){
        //基本情况，递归出口
        //当left和right相等时，就一个元素,返回其值即为最大子序列
        if(left == right)
            return nums[left];
        
        //对于本轮递归要解决： 跨越中间的部分的最大序列和
        int mid = (left + right) >> 1;
        int leftBorderSum = 0, rightBorderSum = 0;
        int leftBorderMaxSum = Integer.MIN_VALUE, rightBorderMaxSum = Integer.MIN_VALUE;
        int BorderMaxSum = 0;
        
        //左边区间包含中点的最大序列和
        for(int i=mid; i>=left; i--){
            leftBorderSum += nums[i];
            if(leftBorderSum > leftBorderMaxSum)
                leftBorderMaxSum = leftBorderSum;
        }
        //同理，右边区间包含中点的最大序列和
        //这里要注意是mid+1，如果也从mid开始那么mid就计算两次了
        for(int i=mid+1; i<=right; i++){
            rightBorderSum += nums[i];
            if(rightBorderSum > rightBorderMaxSum)
                rightBorderMaxSum = rightBorderSum;
        }
        //如果跨越两头的和都大于0，那么累加，否则为两者较大的那一个
        if(leftBorderMaxSum > 0 && rightBorderMaxSum > 0)
            BorderMaxSum = leftBorderMaxSum + rightBorderMaxSum;
        else
            BorderMaxSum = leftBorderMaxSum > rightBorderMaxSum ? leftBorderMaxSum : rightBorderMaxSum;
            
        //考虑分治：对于左右区间递归求序列和
        //注意左边区间到mid而不是mid-1
        int leftMaxSum = helper(nums, left, mid);
        int rightMaxSum = helper(nums, mid+1, right);
        
        //最后判断三者谁最大
        int chlidMaxSum = leftMaxSum > rightMaxSum ? leftMaxSum : rightMaxSum;
        return chlidMaxSum > BorderMaxSum ? chlidMaxSum : BorderMaxSum;
    }
    
    public int maxSubArray(int[] nums) {
        return helper(nums, 0, nums.length-1);
    }
}
```
**此方法分治法把树构建起来，最后可能就演化成牛逼的数据结构——线段数**

***


```java
//第四种方法： 一次扫描  时间复杂度O(N) 空间复杂度O(1)  (完美的联机算法)
//第一种： 贪心
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length == 1) return nums[0];
        //sum表示当前和，maxSum表示最大和
        //首先将第一个值设置为之前和，以及最大和
        int sum = nums[0], maxSum = nums[0];
        //从i = 1开始判断
        for(int i=1; i<nums.length; i++){
            //如果之前和>0, 那么就累计当前和
            if(sum > 0)
                sum += nums[i];
            //否则抛弃之前的和，记本次值为当前和(下一轮就变为之前和)
            else
                sum = nums[i];
            //判断当前和与最大和的大小
            if(sum > maxSum)
                maxSum = sum;        
        }
        return maxSum;
    }
}

//第二种： 动态规划 
// 如果上一个值>0,就把它加到当前值上
class Solution {
    public int maxSubArray(int[] nums) {
        for(int i=1; i<nums.length; i++)
            if(nums[i-1] > 0)
                nums[i] += nums[i-1];
        Arrays.sort(nums);
        return nums[nums.length-1];
    }
}
```

二刷

```go
func maxSubArray(nums []int) int {
    nowSum, max := nums[0], nums[0]
    for i:=1; i<len(nums); i++ {
        if nowSum < 0 {
            // 如果<0, 就设置为当前值
            nowSum = nums[i]
        }else {
            // 如果>0, 就继续累加
            nowSum += nums[i]
        }
        // 取最大值
        if nowSum > max {
            max = nowSum
        }
    }
    return max
}
```

