---
title: 88-合并两个有序数组
tags:
  - java
categories:
  - technical
  - leetcode
toc: true
date: 2021-02-02 13:03:50
---

## 题目描述

[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

难度简单

给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中*，*使 `nums1` 成为一个有序数组。

初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n` 。你可以假设 `nums1` 的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。

 <!-- more -->

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```

 

**提示：**

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-109 <= nums1[i], nums2[i] <= 109`



## 解题思路及代码

```java
//双指针正向
//时间复杂度O(n+m)
//空间复杂度O(m+n)  (还可以一开始只复制nums1,最后的空间复杂度为m)
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        //特殊情况处理
        if(n == 0) return;
        //创建数组
        int[] mergeArray = new int[m+n];
        //双指针比对
        int p1 = 0, p2 = 0, k = 0;
        while( p1 < m && p2 < n){
            //谁小就放入，后挪
            if(nums1[p1] < nums2[p2]){
                mergeArray[k++] = nums1[p1];
                ++p1;
            }else{
                mergeArray[k++] = nums2[p2];
                ++p2;
            }
        } 
        //一边放完了另一边，没有放完,那么就直接全部放入（有序）
        if(p1 == m && p2 < n){
            System.arraycopy(nums2, p2, mergeArray, k, n-p2);
        }
        if(p2 == n && p1 < m){
           System.arraycopy(nums1, p1, mergeArray, k, m-p1);
        }
        //复制数组到nums1
        System.arraycopy(mergeArray, 0, nums1, 0, m+n);
    }
}

//双指针反向
//时间复杂度O(n+m)
//空间复杂度O(1)
//多用一个指针指向nums1的尾部，双指针分别从尾部开始比较，这样就不需要额外的空间
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        //特殊情况处理
        if(n == 0) return;
        //创建指针，指向尾部
        int p1 = m-1, p2 = n-1, p = n+m-1;
        while(p1 >= 0 && p2 >= 0){
            //谁大谁先放
            if(nums1[p1] < nums2[p2]){
                nums1[p--] = nums2[p2--];
            }else{
                nums1[p--] = nums1[p1--];
            }
        }
        if(p1 < 0 && p2 >= 0){
            System.arraycopy(nums2, 0, nums1, 0, p2+1);
        }
    }
}
```

```go
// 逆向双指针原地排序
func merge(nums1 []int, m int, nums2 []int, n int)  {
    if len(nums2) == 0 {
        return
    }
    // p1, p2都指向数组的尾部
    p1, p2, tail := m-1, len(nums2)-1, len(nums1)-1
    // 较大的放到nums1后面，防止被覆盖
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[tail] = nums1[p1]
            p1--
        }else {
            nums1[tail] = nums2[p2]
            p2--
        }
        tail--
    }
    // 如果p2没走完，p1已经走完了，就需要处理
    for p2 >= 0 {
        nums1[tail] = nums2[p2]
        p2--
        tail--
    }
}
```

