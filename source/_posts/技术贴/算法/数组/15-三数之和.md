---
title: 15-三数之和
tags:
  - java
categories:
  - technical
  - leetcode
toc: true
date: 2021-01-17 16:32:48
---

## 题目描述

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

难度中等

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？请你找出所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

 <!-- more -->

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**示例 2：**

```
输入：nums = []
输出：[]
```

**示例 3：**

```
输入：nums = [0]
输出：[]
```

 

**提示：**

- `0 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`

## 解题思路及代码

![](http://xwjpics.gumptlu.work/qiniu_picGo/20210117163531.png)

```java
class Solution {
    //预排序 + 双指针法
    public List<List<Integer>> threeSum(int[] nums) {
        //特殊输入排除
        int len = nums.length;
        List<List<Integer>> resList = new ArrayList<>();
        if (len < 3){
            return resList;
        }
        //排序数组
        Arrays.sort(nums);
        //循环遍历
        for(int i=0; i<len; i++){   //i不会到len-1，因为到nums[i]>0就停止了
            //如果当前的i指针指向的数大于0，那么因为已经排序，后面的数之和一定不会为0
            if (nums[i] > 0){
                break;
            }
            //已经计算过的i再次出现就跳过,防止重复
            if (i > 0 && nums[i] == nums[i-1]){
                continue;
            }
            int l = i+1, r = len-1;  //初始化两个指针, 不用担心数组下标越界，因为使用下面使用while判断会直接无法通过，不会取越界下标值对应的数组数
            while(l < r){            
                //判断和
                int sum = nums[i] + nums[l] + nums[r];
                //和为0即满足，找到了
                if (sum == 0){
                    //添加到结果数组
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[l]);
                    list.add(nums[r]);
                    resList.add(list);
                    //跳过重复值，避免重复答案
                    while(l < r && nums[l] == nums[l+1]){
                        l++;
                    }
                    while(l < r && nums[r] == nums[r-1]){
                        r--;
                    }
                    //同时移动指针
                    l++;
                    r--;
                }
                //和小于0则nums[l]太小，l右移
                else if (sum < 0){
                    l++;
                }
                //和大于0，则说明num[r]太大，r左移
                else if (sum > 0){
                    r--;
                }
               
            }
        }
        return resList;
    }
}
```

二刷

```go
// 关键在于去重，因为暴力搜索会导致结果集中有重复,例如[-1,0,1],[1,-1,0]
// 排序+双指针
// 首先排序将数组变为有序数组，这样就排除了三个不同数字的重复解问题
// 但是如果数组本身就有重复的数字，那么还是会出现重复
// 所以将排序后连续相同的数字跳过
// 双指针问题解决排序数组的两数之和，双指针分别在前后，如果当前之和<target则左指针右移，大于则右指针左移
func threeSum(nums []int) [][]int {
    if len(nums) < 3 {
        return nil
    }
    // 首先排序
    quickSort(nums, 0, len(nums)-1)
    // 选择一个数作为target
    ans := make([][]int, 0)
    for i:=0; i<len(nums); i++ {
        // 去掉连续重复的数
        // 注意细节：这里比较要往前一个比较，保证即使重复每次也使用出现的第一个数作为target
        // 这样防止后面重复的数没被用上
        if i > 0 && nums[i] == nums[i-1] { 
            continue
        }
        ans = append(ans, twoSum(nums[i+1:], -1*nums[i])...) // 注意这里nums从i+1开始
    }
    return ans
}

// 两数之和
func twoSum(nums []int, target int) [][]int {      // value是第一个数
    i, j := 0, len(nums)-1
    ans := make([][]int, 0)
    for i < j {
        if nums[i] + nums[j] == target {
            // 注意，找到一个结果不能就结束了，还要继续找
            ans = append(ans, []int{-1*target, nums[i], nums[j]})   
            // 移动到下一个不重复的数字
            for i < j && nums[i] == nums[i+1] {
                i ++
            }
            i ++        // 细节：到下一个数
            for i < j && nums[j] == nums[j-1] {
                j --
            }  
            j --  
        }else if nums[i] + nums[j] < target {
            i ++
        }else {
            j --
        }
    }
    return ans
}

func quickSort(nums []int, l, r int) {
    if l < r {
        mid := getMid(nums, l, r)
        quickSort(nums, l, mid-1)
        quickSort(nums, mid+1, r)
    }
}

func getMid(nums []int, l, r int) int {
    pivot := nums[l]
    for l < r {
        for l < r && nums[r] >= pivot { r-- }
        nums[l] = nums[r]
        for l < r && nums[l] <= pivot { l++ }
        nums[r] = nums[l]  
    }
    nums[l] = pivot
    return l
}
```
