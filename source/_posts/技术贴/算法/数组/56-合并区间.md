---
title: 56.合并区间
tags:
  - null
categories:
  - technical
  - leetcode
toc: true
date: 2022-01-13 00:17:30
---

## 题目描述

[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

难度中等

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

 <!-- more -->

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

 

**提示：**

- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 104`

通过次数348,950

提交次数733,759

## 解题思路及代码

```go
// 排序
// 时间复杂度O(NlogN), 空间复杂度O(N)
func merge(intervals [][]int) [][]int {
    // 按第一个位置的数字排序
    quickSort(intervals, 0, len(intervals)-1)
    // 依次扫描合并到ans结果数组
    ans := make([][]int, 0)
    for i:=0; i<len(intervals); i++ {
        n := len(ans)
        // 如果是第一个区间或者当前扫描的区间的开始>结果集合最后一个区间的末尾则直接加入不用合并
        if i == 0 || ans[n-1][1] < intervals[i][0] {
            ans = append(ans, intervals[i])
        }else {
            // 否则一定重合合并
            // 判断两个区间谁的末尾大更新结果数组最后一个区间的末尾值即可！
            big := ans[n-1][1]
            if intervals[i][1] > big {
                big = intervals[i][1]
            } 
            ans[n-1][1] = big
        }
    }   
    return ans
}

func quickSort(intervals [][]int, l, r int) {
    if l < r {
        mid := getMid(intervals, l, r)
        quickSort(intervals, l, mid-1)
        quickSort(intervals, mid+1, r)
    }
}

func getMid(intervals [][]int, l, r int) int {
    pivot := intervals[l]
    for l < r {
        for l < r && intervals[r][0] >= pivot[0] { r -- }
        intervals[l] = intervals[r]
        for l < r && intervals[l][0] <= pivot[0] { l ++ }
        intervals[r] = intervals[l] 
    }
    intervals[l] = pivot
    return l
}
```

二刷

```go
func merge(intervals [][]int) [][]int {
    n := len(intervals)
    if n == 0 {
        return nil
    }
    // 排序
    sort.SliceStable(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    // 合并
    ans := [][]int{intervals[0]}
    for i:=0; i<n; i++ {
        if intervals[i][0] <= ans[len(ans)-1][1] {
            // 合并 重新放回
            // 判断两种情况
            var tmp []int
            if intervals[i][1] >= ans[len(ans)-1][1] {
                tmp = []int{ans[len(ans)-1][0], intervals[i][1]}
            }else {
                tmp = []int{ans[len(ans)-1][0], ans[len(ans)-1][1]}
            }
            ans = ans[:len(ans)-1]
            ans = append(ans, tmp)
        }else {
            ans = append(ans, intervals[i])
        }
    }
    return ans
}
```

