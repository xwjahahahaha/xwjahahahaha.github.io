---
title: CSAPP-1-计算机系统漫游
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2022-05-28 19:09:59
---

[TOC]

<!-- more -->

> 参考：
>
> * 《CSAPP》

# 第一章 计算机系统漫游

## 1. 从Hello Word程序了解程序的生命周期

### 1.1 第一步：源程序/源文件

一切从`hello.c`这个源程序开始：

![image-20220528191231787](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528191231787.png)

#### 源程序是什么？文件是什么？

- 本质是一个位序列，8个位组成一个字节
- 每个字节表示程序文件的文本字符
- 整体上的文件就是一个字节序列

#### 文本文件与二进制文件的区别？

- 由纯ASCII标准字符组成的文件（可读）
- 其他都是二进制文件

#### 上下文环境的作用？

系统中所有的信息都是一串比特流，而决定这一串比特流信息/区别不同数据对象的方法是读到这些数据对象时的上下文环境

一个同样的字节序列可能表示一个整数、浮点数、字符串等等

### 1.2 第二步：被其他程序翻译为不同的格式

每条c语言程序都会被其他程序转换为一系列低级机器语言指令

#### 目标文件是什么？

这些指令被成为“可执行目标程序”的格式打包好，并以二进制磁盘文件的形式存放，这就是目标文件

#### 编译系统详解

过程:

![image-20220528191649482](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528191649482.png)

1. 预处理器`cpp`

   在预处理阶段修改原始程序：例如将#include中引用的头文件内容直接插入程序文本中

2. 编译器`ccl`

   编译阶段，将不同的高级语言的不同编译器提供了通用的输出语言（汇编语言），例如C和Fortran编译器的输出文件是一样的汇编语言

3. 汇编器`as`

   汇编阶段，将hello.s翻译为机器语言指令并打包为一种“可重定位目标程序”

4. 链接器`ld`

   链接阶段，负责链接与合并，将标准库中准备好的printf.o这个单独的预编译目标文件链接合并到我们的hello.o程序中

5. 最终得到可执行程序/可执行目标文件，可以被加载到内存由系统执行

### 1.3 第三步：处理器读并解释/执行储存在内存中的指令

具体可见下面计算机系统

## 2. 计算机系统

### 1. 典型硬件架构是什么样的？

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528192746186.png" alt="image-20220528192746186" style="zoom:50%;" />

总线

- 贯穿系统的管道，用于传输信息字节
- 一般被设计为传输定长的字节块即字，但是一个字是几个字节因系统而异

I/O设备

- 系统与外界信息联系的通道
- 每个I/O设备都需要一个控制器或者适配器与I/O总线连接传输数据

主存

- 临时存储设备，执行程序时存储程序和处理的数据
- 实质：

  - 物理角度： 一组随机存取存储器(DRAM)构成

  - 逻辑角度： 一个线性字节数组，每个字节都有唯一的地址(数组索引)


处理器CPU

- 中央处理单元，用于解释/执行存储在主存中的指令的引擎
- PC：一个字的存储设备/寄存器

  - 作用：指向主存中的某条机器语言指令（即含有该地址）

  - 配合工作：处理器从PC指向的内存地址处读取指令，解释其中的位，然后执行，完毕后更新PC，指向下一个指令（不一定相邻），然后继续执行...


寄存器文件

- 小的存储设备，单个字长

ALU算术/逻辑单元

- 计算新的数据和地址值

各组件配合操作：

![image-20220528192820932](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528192820932.png)

### 2. 指令集架构与微体系架构的不同

- 指令集架构： 每条机器指令的效果

- 微体系结构：处理器实际上如何实现


### 3. 硬件角度描述hello程序的加载与运行？

#### 输入

初始时， shell程序执行它的指令，等待我们输入一个命令 当我们在键盘上输入字符串`"./hello"` 后， shell程序将字符逐一读入寄存器，再把它存放到内存中

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528193401402.png" alt="image-20220528193401402" style="zoom:50%;" />

以此确定了待执行的目标程序

#### 加载

传统方式：

- shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串` "hello, world\n" `（过程类似于上图）

`DMA`(直接存储器存储)：

- `DMA`技术可以让数据可以不通过处理器而直接从磁盘到达主存

#### 运行

- 处理器开始执行 hello 程序 main 程序中的机器语指令。这些指令将 `"hello, world\n" `字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528193440516.png" alt="image-20220528193440516" style="zoom:50%;" />

#### 缺点

数据从一个地方搬到另一个地方，不断的复制花费了大量的时间

解决方法就是出现了高速缓存存储器

### 4. 高速缓存存储器 cache memory

用于存储近期会需要的信息:

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528193537409.png" alt="image-20220528193537409" style="zoom:50%;" />

#### L1与L2

L1高速缓存:

- 位置: 位于处理器芯片上


- 容量数万字节，速度几乎与寄存器相同

L2高速缓存:

- 位置: 一条特殊的总线连接到处理器


- 容量数十万百万字节，速度比L1慢五倍，但是比主存快5～10倍

某些新的处理器还有L3级缓存, 其都属于**静态随机访问存储器SRAM**；都借助于**局部性原理**

#### 存储器的层次结构

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528193728242.png" alt="image-20220528193728242" style="zoom:50%;" />

上一层作为下一层的高速缓存

### 5. 软件：操作系统

操作系统用于管理硬件：

- 上述的过程中shell和hello并没有直接操作访问键盘、主存和显示器等硬件，其都是借助操作系统提供的服务
- 操作系统是应用程序与硬件之间的一层软件层，负责代处理对硬件的操作

#### 基本功能

- 防止被应用程序滥用
- 向上提供简单单一机制来屏蔽底层复杂且较大差异的硬件

#### 抽象概念

![image-20220528193842111](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528193842111.png)

##### 进程

一个程序成为一个进程，在cpu上运行，给出一种假象，整个系统只有这一个进程在运行，实际上一个系统运行的进程数大于其cpu个数，而这背后是操作系统在调度，负责实现并发运行，核心在于进程的上下文切换。

上下文/进程状态有哪些？

- 一个进程的所有信息：pc、寄存器、主存等等

进程的切换由内核管理

> 内核：不是一个独立的进程，而是操作系统管理全部进程所用代码和数据结构的集合

多线程：共享进程的上下文，实现多个控制流

##### 虚拟内存

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528194118982.png" alt="image-20220528194118982" style="zoom:50%;" />

- 给每个进程提供一种假象：独占和使用主存；并且每个进程看到的内存是一致的即虚拟地址空间

##### 文件

- 就是字节序列，但是为应用程序提供了统一的视图，屏蔽了各式各样的I/O设备细节

##### 网络通信

- 系统并非一个孤立的硬件与软件的集合，系统之间通过网络通信传递信息


## 3. 其他概念

### Amdahl定律

核心思想：

![image-20220528194246254](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528194246254.png)

总结：要想显著加速整个系统，必须提升全系统中相当大的部分的速度，否则并不会那么的显著

### 并发和并行

不同抽象层级的并发

#### 线程级别并发

在进程这个抽象层次上，多个程序同时执行，并且单个进程中有多个线程控制流

多核处理器：

- 将多个CPU/核集成到一个集成电路上

  <img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528194355162.png" alt="image-20220528194355162" style="zoom:50%;" />

超线程：

又叫同时多线程，允许一个CPU执行多个控制流的技术，也就是一个CPU能够并行跑多个线程

- 将CPU某些硬件多个备份，例如pc、寄存器文件，但是有一些硬件只有一份，例如浮点算数运算单元
- 例如4核8线程就是指每个核可以并行跑两个线程

#### 指令级别并行

将一条指令的活动划分为不同的阶段并行执行，以此来实现加速执行速度

超标量处理器：可以达到比一个时钟周期一条指令更快的执行速率的处理器

#### 单指令、多数据并行

允许一条指令产生多个可以并行执行的操作

### 抽象

抽象是计算机系统中最为关键的思路，根据抽象的层次可以总结为：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220528194518499.png" alt="image-20220528194518499" style="zoom:50%;" />
