---
title: 3-程序的基石-硬件
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2022-07-19 15:24:48
---

[TOC]


<!-- more -->

> 学习自：
>
> * 极客时间-《操作系统45讲》
>   * 购买地址： https://time.geekbang.org/column/intro/100078401 
>   * 作者：LMOS

本篇文章的内容较为硬核，所以需要多读几遍多次理解加深…

# 一、**CPU**工作模式:执行程序的三种模式

CPU 的工作模式有**实模式、保护模式、长模式**，在这几种工作模式下，CPU执行程序的方式截然不同

## 实模式

实模式又称实地址模式，实，即真实，这个真实分为两个方面：

* 一个方面是运行真实的指令，对指令的动作不作区分，直接执行指令的真实功能
* 另一方面是发往内存的地址是真实的，对任何地址不加限制地发往内存

### 实模式寄存器

由于 CPU 是根据指令完成相应的功能，举个例子:`ADD AX,CX;`这条指令完成加法操作，AX、CX 为 ADD 指令的操作数，可以理解为 ADD 函数的两个参数，其功能就是把 AX、CX 中的数据相加

**指令的操作数，可以是寄存器、内存地址、常数**，其实通常情况下是寄存器，AX、CX 就 是 x86 CPU 中的寄存器

x86实模式下的寄存器，每个寄存器都是16位的：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220719165631046.png" alt="image-20220719165631046" style="zoom: 33%;" />

> <font color='#39b54a'>注意：CS、DS、ES等存放的直接是一个内存段的基地址</font>

### 实模式下访问内存

虽然有了寄存器，但是数据和指令都是存放在内存中的。通常情况下，需要把数据装载进寄存器中才能操作，还要有**获取指令（取指）**的动作，这些都要访问内存才行，而我们知道访问内存靠的是地址值，那问题来了，这个地址值是如何计算的呢？

取指以及访问内存数据的具体过程如下：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220719170007902.png" alt="image-20220719170007902" style="zoom: 50%;" />

> 可以看出来：
>
> * CS代码段寄存器负责取指
> * 其他例如DS、SS等负责取数据

所有的内存地址都是由**段寄存器左移 4 位**，然后再将其值加上一个通用寄存器中的值或者常数形成地址，然后由这个地址去访问内存。这就是大名鼎鼎的**分段内存管理模型**，只不过这里要特别注意的是，<font color='#39b54a'>**代码段是由 CS 和 IP 确定的，而栈段是由 SS 和 SP 段确定的**</font>

> <font color='#39b54a'>为什么要左移4位？</font>
>
> * 左移四位是为了将16位地址拓展到20位（原因在于地址总线使用了20根），下面这个图片很好的解释了这一点：
>
>   <img src="http://xwjpics.gumptlu.work/qinniu_uPic/o1usAA.jpg" alt="o1usAA" style="zoom: 67%;" />
>
> <font color='#39b54a'>实模式下的可寻址空间是多大？</font>
>
> * 4（左移4位）+16（16位寄存器）=20位也就是1MB的空间

下面是一个工作在**实模式**下的汇编代码：

```assembly
data SEGMENT ; 定义一个数据段存放hello,world!
    hello DB 'Hello, World!$' ;以$表示结束
data ENDS
code SEGMENT  ; 定义一个代码段存放程序指令
    ASSUME CS:CODE, DS:DATA     ;告诉汇编程序，DS指向数据段，CS指向代码段
start:
    MOV AX, data        ; 将data段首地址赋值给AX
    MOV DS, AX          ; 将AX赋值给DS，使DS指向data段
    LEA DX, hello       ; 使DX指向hello首地址(LEA是取地址指令)
    MOV AH, 09h         ; 给AH设置参数09H，AH是AX高8位，AL是AX低8位，其他类似
    INT 21h             ; 执行DOS中断输出DS指向的DX指向的字符串hello
    MOV AX, 4C00h       ; 给AH设置参数4C00h
    INT 21h             ; 调用4C00h号功能，结束程序
code ENDS
END start
```

其中 LEA 是 取地址指令，MOV 是数据传输指令，就是 INT 中断你可能还不太明白，下面我们就来研究它

### 实模式中断

中断的产生：

* 硬件中断：中断控制器给CPU发送了中断信号
* 软中断：操作系统执行到了`INT`指令，这个指令之后有一个中断号

中断就是停止当前执行的代码，然后去处理运行特定的代码的过程，在实模式下，基本的操作就是保存`CS`和`IP`的值然后切换到另一个`CS`和`IP`

中断处理中存储的支持（也就是保存）：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220722194138600.png" alt="image-20220722194138600" style="zoom:67%;" />

需要使用一个**中断向量表（存储在内存中）**来映射中断号与中断处理函数的对应关系，这个表的地址（所在的位置/基址）和长度（界限）存储在IDTR寄存器（或者说由此寄存器指向），实模式下表中的一个条目由*代码段地址和段内偏移构成*

> 中断向量表的作用在于存储中断处理之**前**的段基地址和段偏移

一个中断处理的大致流程在于：

* 根据中断号，读取IDTR寄存器，从而找到中断向量表在内存的位置，并计算偏移条目
* 根据偏移条目，存储当前的CS和IP到对应条目，然后响应中断

## 保护模式

在计算机的不断发展之后，对于内存的容量大小不断拓展，就由16位逐渐向32位拓展，内存一大就需要解决寻址的问题，实模式已经不能满足需求，并且直接地址访问以及cpu指令不加以区分实无法保证安全性的，所以就逐渐出现了**保护模式**

保护模式下拓展了所有通用寄存器为32位（如果是16位也可以只使用低16位，值得注意的是段寄存器还是16位）：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220722200345648.png" alt="image-20220722200345648" style="zoom:50%;" />

### 特权级别

为了区分指令，出现了特权级别，其核心作用就是指定哪些指令只可以访问哪些资源

特权分为R0～R3，R0级别可以执行所有指令，随后一次递减，只能执行上一个级别指令数量的子集

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220722200851279.png" alt="image-20220722200851279" style="zoom:33%;" />

### 段描述符（保护模式下）

保护模式下的段描述符（当前也仅讨论或者说默认还是分段模型），所以对内存的保护也就是对段的保护

在实模式中可以直接使用段寄存器保存一个内存段的基址，但是在拓展了内存的32位环境中就没办法这样做了，因为仍然是**16位的段寄存器无法存储32位的地址（或者说寻址空间不够）**

所以就需要使用内存来存储，也就是**段描述符**：专门用于描述一个段的信息，保护模式下的段描述符的结构如下：

（段描述符也只是全局描述符表中的一项）

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220722201302375.png" alt="image-20220722201302375" style="zoom:67%;" />

多个段描述符在内存中构成全局段描述符表，其（该表）由GDTR寄存器指定（指定基址与界限）：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220722202112561.png" alt="image-20220722202112561" style="zoom:67%;" />

所以可以看出，这些段寄存器不再存放段基址而是存储段的索引，或者说是**段选择符/（或者这里叫的段选择子）**，其结构具体如下图：

> <font color='#39b54a'>例如，原来实模式下16位的CS直接存储段基址即可，而现在保护模式下则其16位存储内容如下图</font>

![image-20220722202303978](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220722202303978.png)

影子寄存器其实也就是《深入理解linux内核》第二章中介绍的**非编程寄存器**，主要用于快速缓存映射地址从而避免每次都查表

**CS和SS中的RPL就构成了CPL也就是当前权限级别，如果CPL大于目标段描述符中的DPL时不可访问，否则可以**（因为特权级别越小级别越高）

> 在《深入理解linux内核》一书中，详细的介绍了逻辑地址到线性地址的转换过程，也就是分段的映射过程，这里的CS就是代码段寄存器，存储的是代码段选择符，其映射到对应GDT的某一项段描述表项，该表项中就包含了此段的基址地址，最后拼接上偏移量，就可以获得当前的内存中的物理地址，具体过程如下图：
>
> <img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20220709220831509.png" alt="image-20220709220831509" style="zoom:50%;" />
>
> <font color='#e54d42'>这里的选择符就是段选择子/段选择符（对应CS等段寄存器），offset就是段偏移量（对应IP/EIP、ESP等寄存器）</font>

### 保护模式平坦模型

现代计算机大多使用分页模型，但是x86 CPU不能直接使用分页模型，而是要在分段模型的前提下，根据需要决定是否开启分页，这是硬件决定的。

所以我们需要使用一种方法**将分段成为一种虚设**，其实也就是linux中的分段设置，将**所有**的段基地址设置为0，段的长度为`0xFFFFF`，让所有段都指向同一个字节大小的地址空间，再在其上实现分页即可（这样也实现了**逻辑地址与线性地址的一致性**）

根据前面的描述，我们发现 CPU 32 位的寄存器最多只能产生 4GB 大小的地址，而一个段长度也只能是 4GB，所以我们把所有段的基地址设为 0，段的长度设为` 0xFFFFF`，段长度的粒度设为 4KB，这样所有的段都指向同一个（0~4GB-1）字节大小的地址空间

可以看到之前helloOS中的一处段描述符：

```assembly
GDT_START:
knull_dsc: dq 0
;第一个段描述符CPU硬件规定必须为0
kcode_dsc: dq 0x00cf9e000000ffff		;设置代码段为0～ffff
;上面地址的位解析：
;段基地址=0，段长度=0xfffff
;G=1,D/B=1,L=0,AVL=0 
;P=1,DPL=0,S=1
;T=1,C=1,R=1,A=0		T=1表示代码段
kdata_dsc: dq 0x00cf92000000ffff		;设置代码段为0～ffff
;上面地址的位解析：
;段基地址=0，段长度=0xfffff
;G=1,D/B=1,L=0,AVL=0 
;P=1,DPL=0,S=1
;T=0,C=0,R=1,A=0		T=0表示数据段
GDT_END:
GDT_PTR:
GDTLEN  dw GDT_END-GDT_START-1
GDTBASE  dd GDT_START
```

上面代码中注释已经很明白了，段长度需要和 G 位配合，若 G 位为 1 则段长度等于 0xfffff 个 4KB。上面段描述符的 DPL=0，这说明需要最高权限即 CPL=0 才能访问

### 保护模式中断处理

在之前的实模式下，因为实模式下 CPU 中断不需要做权限检查，所以它可以直接通过中断向量表中的值装载CS和IP寄存器就好了（记录中断前的CS和IP）

而保护模式下的中断要**权限检查**，还有**特权级的切换**，所以就需要扩展中断向量表的信息，即每个中断用一个**中断门描述符**来表示，也可以简称为中断门，中断门描述符依然有自己的格式，如下图所示：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221024201523144.png" alt="image-20221024201523144" style="zoom:50%;" />

同样的，保护模式要实现中断，也必须在内存中有一个**中断向量表**，同样是由 IDTR 寄存器指向，只不过中断向量表中的**条目变成了中断门描述符**，如下图所示：

> <font color='#39b54a'>由简单的段基址+偏移 => 中断门描述符（其中包含了原来的这两项，但是添加了很多新的字段，用于保护或者说权限检查）</font>

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221024201717308.png" alt="image-20221024201717308" style="zoom:50%;" />

产生中断后，会做一系列的检查工作：

* CPU 首先会检查中断号是否大于**最后一个中断门描述符**，x86 CPU 最大支持 256 个中断源（即中断号：0~255），然后检查描述符类型（是否是中断门或者陷阱门）、是否为系统描述符，是不是存在于内存中
* 接着，检查中断门描述符中的段选择子指向的段描述符

* 最后做**权限检查**，**如果 CPL 小于等于中断门的 DPL 并且 CPL 大于等于中断门中的段选择子**，就指向段描述符的 DPL（表示中断门描述符的权限足够访问）。进一步的，CPL 等于中断门中的段选择子指向段描述符的 DPL，则为**同级权限不进行栈切换**，否则进行栈切换。如果进行栈切换，还需要从 TSS 中加载具体权限的 SS、ESP，当然也要对 SS 中段选择子指向的段描述符进行检查

做完这一系列检查之后，CPU 才会加载中断门描述符中**目标代码段选择子**到 CS 寄存器中，把**目标代码段偏移**加载到 EIP 寄存器中

> <font color='#39b54a'>也就是说检查的是待替换地址的权限，如果权限足够再替换</font>

### 实模式切换到保护模式

x86 CPU 在第一次加电和每次 reset 后，都会自动进入实模式，要想进入保护模式，就需要程序员写代码实现从实模式切换到保护模式。切换到保护模式的步骤如下:

第一步，**准备全局段描述符表**，代码如下（也就是上面的代码）：

```assembly
GDT_START:
knull_dsc: dq 0
kcode_dsc: dq 0x00cf9e000000ffff
kdata_dsc: dq 0x00cf92000000ffff
GDT_END:
GDT_PTR:

GDTLEN  dw GDT_END-GDT_START-1
GDTBASE  dd GDT_START
```

第二步，**加载设置 GDTR 寄存器**，使之指向全局段描述符表：

```assembly
lgdt [GDT_PTR]
```

第三步，**设置 CR0 寄存器**，开启保护模式（最关键的一步）:

```assembly
;开启 PE
mov eax, cr0
bts eax, 0                      ; CR0.PE =1 => 表示启动保护模式
mov cr0, eax         
```

第四步，进行**长跳转**，加载 CS 段寄存器，即段选择子/段选择符：

```assembly
jmp dword 0x8 :_32bits_mode ;_32bits_mode为32位代码标号即段偏移
```

你也许会有疑问，为什么要进行长跳转，这是因为我们**无法直接或间接 mov 一个数据到 CS 寄存器中**，因为刚刚开启保护模式时，**CS 的影子寄存器（用作段选择符的缓存）还是实模式下的值**，**所以需要告诉 CPU 加载新的段信息**

接下来，CPU 发现了CR0寄存器第 0 位的值是 1，就会按 GDTR 的指示找到全局描述符表，然后根据索引值 8（`0x8`），把新的段描述符信息加载到 CS 影子寄存器，当然这里的前提是进行一系列合法的检查

到此为止，CPU 真正进入了保护模式，CPU 也有了 32 位的处理能力

## 长模式

长模式又名` AMD64`，因为这个标准是 AMD 公司最早定义的，它使 CPU 在现有的基础上有了 **64 位**的处理能力，既能完成 64 位的数据运算，也能寻址 64 位的地址空间。这在大型计算机上犹为重要，因为它们的物理内存通常有几百 GB。

### 长模式寄存器

长模式相比于保护模式，增加了一些通用寄存器，并扩展通用寄存器的位宽，所有的通用寄存器都是 64 位，还可以单独使用低 32 位。

这个低 32 位可以拆分成一个低 16 位寄存器，低 16 位又可以拆分成两个 8 位寄存器，如下表:

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221024205834273.png" alt="image-20221024205834273" style="zoom:50%;" />

### 长模式段描述符

长模式依然具备保护模式绝大多数特性，如特权级和权限检查。相同的部分就不再重述了，这里只会说明长模式和保护模式下的差异

下面我们来看看长模式下**段描述符**的格式，如下图所示:

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221024210008911.png" alt="image-20221024210008911" style="zoom:50%;" />

在长模式下，CPU 不再对段基址和段长度进行检查（所以上图中变成了无效），只对 DPL 进行相关的检查，这个检查流程和保护模式下一样

当描述符中的 L=1，D/B=0 时，就是 64 位代码段，DPL 还是 0~3 的特权级。然后有多个段描述在内存中形成一个全局段描述符表，同样由 CPU 的 GDTR 寄存器指向

下面我们来写一个长模式下的段描述符表，加深一下理解，如下所示：

```assembly
ex64_GDT:
null_dsc:  dq 0
;第一个段描述符CPU硬件规定必须为0
c64_dsc:dq 0x0020980000000000  ;64位代码段，基址～界限都是0，因为不检查所以无效（不检查的原因是用了分页而不用分段了）
;无效位填0
;D/B=0,L=1,AVL=0 
;P=1,DPL=0,S=1
;T=1,C=0,R=0,A=0
d64_dsc:dq 0x0000920000000000  ;64位数据段
;无效位填0
;P=1,DPL=0,S=1
;T=0,C/E=0,R/W=1,A=0
eGdtLen   equ $ - null_dsc  ;GDT长度
eGdtPtr:dw eGdtLen - 1  ;GDT界限
dq ex64_GDT
```

上面代码中注释已经很清楚了，段长度和段基址都是无效的填充为0，CPU 不做检查

但是上面段描述符的 DPL=0，这说明需要最高权限即 CPL=0 才能访问。若是数据段的话，G、D/B、L 位都是无效的。

### 长模式中断

保护模式下为了实现对中断进行权限检查，实现了中断门描述符，在中断门描述符中存放了对应的段选择子和其段内偏移，还有 DPL 权限，如果权限检查通过，则用对应的段选择子和其段内偏移装载` CS:EIP `寄存器

如果你还记得中断门描述符，就会发现其中的段内偏移只有 32 位，但是长模式支持 64 位内存寻址，所以**要对中断门描述符进行修改和扩展**，下面我们就来看看长模式下的中断门描述符的格式，如下图所示：

<img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221024211450008.png" alt="image-20221024211450008" style="zoom:50%;" />

结合上图，我们可以看出**长模式下中断门描述符的格式变化**。

首先为了支持 64 位寻址中断门描述符**在原有基础上增加 8 字节，用于存放目标段偏移的高 32 位值**。其次，目标代码段选择子对应的代码段描述符必须是 64 位的代码段。最后其中的 IST 是 64 位 TSS 中的 IST 指针，因为我们不使用这个特性，所以不作详细介绍。

长模式也同样在内存中有一个中断门描述符表，只不过表中的条目（如上图所示）是 16 字节大小，最多支持 256 个中断源，对中断的响应和相关权限的检查和保护模式一样，这里不再赘述。

### 切换到长模式

我们**既可以从实模式直接切换到长模式，也可以从保护模式切换长模式**。切换到长模式的步骤如下：

第一步，**准备长模式全局段描述符表**。

```assembly
ex64_GDT:
null_dsc:  dq 0
;第一个段描述符CPU硬件规定必须为0
c64_dsc:dq 0x0020980000000000  ;64位代码段
d64_dsc:dq 0x0000920000000000  ;64位数据段
eGdtLen   equ $ - null_dsc  ;GDT长度
eGdtPtr:dw eGdtLen - 1  ;GDT界限
     dq ex64_GDT
```

第二步，准备长模式下的 MMU 页表，这个是为了开启分页模式，**切换到长模式必须要开启分页**，想想看，<font color='#39b54a'>长模式下已经不对段基址和段长度进行检查了，那么内存地址空间就得不到保护了，所以必须要开启分页</font>

而**长模式下内存地址空间的保护交给了 MMU**，MMU 依赖页表对地址进行转换，页表有特定的格式存放在内存中，其地址由 CPU 的 CR3 寄存器指向，这在后面讲 MMU 的那节课会专门讲

```assembly
mov eax, cr4
bts eax, 5   ;CR4.PAE = 1	（PAE物理地址拓展机制）
mov cr4, eax ;开启 PAE
mov eax, PAGE_TLB_BADR ;页表物理地址
mov cr3, eax
```

第三步，**加载 GDTR 寄存器**，使之指向全局段描述表：

```assembly
lgdt [eGdtPtr]
```

第四步，**开启长模式，要同时开启保护模式和分页模式**，在实现长模式时定义了MSR寄存器，需要用专用的指令 `rdmsr、wrmsr `进行读写，`IA32_EFER `寄存器的地址为 `0xC0000080`，它的第 8 位决定了是否开启长模式

```assembly
;开启 64位长模式
mov ecx, IA32_EFER
rdmsr
bts eax, 8  ;IA32_EFER.LME =1
wrmsr
;开启 保护模式和分页模式
mov eax, cr0
bts eax, 0    ;CR0.PE =1 => 表示启动保护模式
bts eax, 31
mov cr0, eax 
```

第五步，进行跳转，加载 CS 段寄存器，刷新其影子寄存器

```assembly
jmp 08:entry64 ;entry64为程序标号即64位偏移地址
```

切换到长模式和切换保护模式的流程差不多，只是需要准备的段描述符有所区别，还有就是要注意**同时开启保护模式和分页模式**。原因在上面已经说明了

## 总结

这三种模式梳理如下：

1. 实模式，早期 CPU 是为了支持**单道程序**运行而实现的，单道程序能掌控计算机所有的资源，早期的软件规模不大，内存资源也很少，所以实模式极其简单，仅支持 **16 位**地址空间，分段的内存模型，**对指令不加限制地运行，对内存没有保护隔离作用**。

2. 保护模式，随着**多道程序**的出现，就需要操作系统了。内存需求量不断增加，所以 CPU 实现了保护模式以支持这些需求。

   保护模式包含**特权级**，对指令及其访问的资源进行控制，**对内存段与段之间的访问进行严格检查，没有权限的绝不放行**，对中断的响应也要进行严格的权限检查，扩展了 CPU 寄存器位宽，使之能够寻址 32 位的内存地址空间和处理 32 位的数据，从而 CPU 的性能大大提高。

3. 长模式，又名 **AMD64 模式**，最早由 AMD 公司制定。由于软件对 CPU 性能需求永无止境，所以长模式在保护模式的基础上，把寄存器扩展到 64 位同时增加了一些寄存器，使 CPU 具有了能处理 64 位数据和寻址 64 位的内存地址空间的能力。

   长模式**弱化段模式管理**，只保留了权限级别的检查，忽略了段基址和段长度，而地址的检查则交给了 `MMU`
