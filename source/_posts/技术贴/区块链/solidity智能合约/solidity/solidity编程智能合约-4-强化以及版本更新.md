---
title: solidity编程智能合约-4-强化以及版本更新
tags:
  - solidity
categories:
  - technical
  - solidity
toc: true
declare: true
date: 2021-04-29 13:38:43
---

# 一、知识点强化

## 合约存储

### 存储，内存和栈

**每个账户**有一块**持久化内存区**称为<font color='#39b54a'>**存储**</font>  。 存储是将**256位字映射到256位字的键值存储区**。 **在合约中枚举存储是不可能的**，且读存储的相对开销很高，修改存储的开销甚至更高。合约只能读写存储区内属于自己的部分。

第二个内存区称为<font color='#39b54a'>**内存**</font>  ，合约会试图**为每一次消息调用获取一块被重新擦拭干净的内存实例**。 **内存是线性的**，可按字节级寻址，但**读的长度被限制为256位，而写的长度可以是8位或256位。**当访问（无论是读还是写）之前从未访问过的内存字（word）时（无论是偏移到该字内的任何位置），内存将按字进行扩展（每个字是256位）。扩容也将消耗一定的gas。 随着内存使用量的增长，其费用也会增高（以平方级别）。

**EVM 不是基于寄存器的，而是基于栈的**，因此所有的计算都在一个被称为<font color='#39b54a'> **栈（stack）** </font>的区域执行。 栈最大有1024个元素，每个元素长度是一个字（256位）。对栈的访问只限于其顶端，限制方式为：允许拷贝最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的两个（或一个，或更多，取决于具体的操作）元素，运算后，把结果压入栈顶。当然可以把栈上的元素放到存储或内存中。但是无法只访问栈上指定深度的那个元素，除非先从栈顶移除其他元素。

## 合约间消息调用

**合约可以通过消息调用的方式来调用其它合约或者发送以太币到非合约账户**。消息调用和交易非常类似，它们都有一个源、目标、数据、以太币、gas和返回数据。事实上每个交易都由一个顶层消息调用组成，这个消息调用又可创建更多的消息调用。

合约可以决定在其内部的消息调用中，对于剩余的 **gas** ，应发送和保留多少。如果在内部消息调用时发生了out-of-gas异常（或其他任何异常），这将由一个被压入栈顶的错误值所指明。此时，**只有与该内部消息调用一起发送的gas会被消耗掉。**并且，Solidity中，发起调用的合约默认会触发一个手工的异常，以便异常可以从调用栈里“冒泡出来”。 如前文所述，被调用的合约（可以和调用者是同一个合约）会获得一块刚刚清空过的内存，并可以访问调用的payload——由被称为 calldata 的独立区域所提供的数据。调用执行结束后，返回数据将被存放在调用方预先分配好的一块内存中。 调用深度被 **限制** 为 1024 ，**因此对于更加复杂的操作，我们应使用循环而不是递归。**

## 委托调用/代码调用和库

有一种特殊类型的消息调用，被称为 **委托调用(delegatecall)** 。它和一般的消息调用的区别在于，**目标地址的代码将在发起调用的合约的上下文中执行**，并且 `msg.sender` 和 `msg.value` 不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这**使得 Solidity 可以实现”库“能力**：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。

## 日志

有一种特殊的可索引的数据结构，其存储的数据可以一路映射直到区块层级。这个特性被称为 **日志(logs)** ，Solidity用它来实现 **事件(events)** 。**合约创建之后就无法访问日志数据，但是这些数据可以从区块链外高效的访问**。因为部分日志数据被存储在 [布隆过滤器（Bloom filter)](https://en.wikipedia.org/wiki/Bloom_filter) 中，我们可以高效并且加密安全地搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。

## 合约创建

**合约甚至可以通过一个特殊的指令来创建其他合约（不是简单的调用零地址）**。创建合约的调用 **create calls** 和普通消息调用的唯一区别在于，**负载会被执行，执行的结果被存储为合约代码**，调用者/创建者在栈上得到新合约的地址。

# 二、新版本特性

solidity版本更新较快,幅度也比较大,记录一下新增的内容和遇到的问题

> 官方文档: https://docs.soliditylang.org/en/v0.8.4/050-breaking-changes.html

<!-- more -->

## v0.5.0版本

### 特点

仍然可以使用旧版本的编译器, 但是合约函数需要添加数据位置、可变性、可见性说明符

### 语法改变

1. 有符号右移现在使用正确的算术移位，即舍入到负无穷，而不是舍入到零。
2. do…while中的continue语句While循环现在跳转到条件，这是这种情况下的常见行为。它过去常常跳转到循环体。因此，如果条件为假，循环终止。
3. 函数.call()， .delegatecall()和.staticcall()在给定单个字节形参时不再填充。

