---
title: 微支付通道合约
tags:
  - solidity
categories:
  - technical
  - solidity
toc: true
declare: true
date: 2021-05-12 16:54:58
---

除了比特币的链下闪电网络,以太坊也有链下扩容的许多方式,微支付通道合约就是其中的一种方式

https://learnblockchain.cn/docs/solidity/solidity-by-example.html#id7

<!-- more -->

# 创建与验证签名

**具体大量详细内容见上方链接**

合约工作有以下几步：

> 1. Alice 部署 `ReceiverPays` 合约, 并附上足够的以太来负担支付通道的付款。
> 2. Alice 通过自己的私钥签名来授权一个支付。
> 3. Alice 发送签名信息给Bob，这个信息是不需要保密的（稍后解释），用什么发送也无关紧要。
> 4. Bob 通过把签名信息提交给合约来索取这笔支付， 合约将验证信息的真实性并发送金额。

![IMG_A6808C913C17-1](http://xwjpics.gumptlu.work/qinniu_uPic/IMG_A6808C913C17-1.jpeg)

```js
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 < 0.9.0;

contract ReceivePays {
    // 支付方
    address owner = msg.sender;
    
    // nonce标记map
    mapping(uint256 => bool) usedNonces;
    
    // 构造函数需要payable, 构造就需要转钱
    constructor () payable {}
    
    // claimPayment 收款方提取付款调用此函数
    // amount : 金额, nonce : 随机数, signature : 待验证签名信息 
    function claimPayment(uint256 amount, uint256 nonce, bytes memory signature) public {
        // 判断nonce是否已使用
        require(!usedNonces[nonce]);
        // 标记此nonce的使用
        usedNonces[nonce] = true;
        
        // 合约中重建客户端签名信息(取hash)
        // 签名的数据有: 1. 收款人地址 2. 数额 3. 随机数 4. 本合约地址
        bytes32 message = prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, this)));
        // 验证与参数签名信息是否为支付者
        require(recoverSigner(message, signature) == owner);
        // 验证成功支付
        payable(msg.sender).transfer(amount);
    }

    // 加入一个前缀，因为在eth_sign签名的时候会加上。
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }

    // 验证签名,并返回签名者地址
    function recoverSigner(bytes32 message, bytes memory signature) internal pure returns (address) {
        // 分离签名
        (uint8 v, bytes32 r, bytes32 s) = splitSignature(signature);
        return ecrecover(message, v, r, s);
    }
    
    // 分离签名
    function splitSignature(bytes memory signature) internal pure returns (uint8 v, bytes32 r, bytes32 s) {
        require(signature.length == 65);
        assembly {
            // 前32个字节，在长度前缀之后。
            r := mload(add(signature, 32))
            // 第二个32字节
            s := mload(add(signature, 64))
            // 最后一个byte,在随后32字节的第一个字节
            v := byte(0, mload(add(signature, 96)))
        }
        return (v, r, s);
    }

    // 支付方销毁合约,收回剩余资金
    function kill() public {
        require(msg.sender == owner);
        selfdestruct(payable(msg.sender));
    }
}
```

# 微支付通道

## **什么是支付通道？**

支付通道允许在无需发生交易的情况下多次转移以太。这意味着可以避免与交易相关的延迟和费用。 我们将探讨两方（Alice和Bob）之间的简单单向支付通道。 它涉及三个步骤：

> 1. Alice 附加一些以太创建智能合约，可以称为“打开”了支付通道
> 2. Alice会签署一些消息指明给接收者付款金额。 每次付款都会重复此步骤。
> 3. Bob“关闭”支付通道，取回以太币，并将剩余部分发送回发送者。

注解

> 只有步骤1和3需要以太坊交易，步骤2意味着发送者通过离线方法（例如电子消息）将加密签名的消息发送给接收者。 这意味着只需要两个交易就可以支持任意数量（次数）的以太币转账。

Bob 保证会收到资金，因为智能合约托管以太并根据合法的签名消息来执行。 合约<font color='#39b54a'>**还可以强制超时执行，**</font>即使收款人拒绝关闭通道，Alice也能保证最终收回资金。 付款通道的参与者可以决定支付通道打开的持续时间。 对于短期交易，例如为网络访问的每一分钟支付一次网费，或者是长期的，例如向员工支付小时工资，支付可能持续数月或数年。

## 打开支付通道

要打开支付通道，Alice 需要部署智能合约，附加要托管的以太币并指定预期的收款人，以及通道存在有效时间。 合约的 `SimplePaymentChannel` 函数就是来做这个事情，代码在本节末尾。

## 进行支付

Alice 通过向 Bob 发送签名消息来付款。<font color='#e54d42'>该步骤完全在以太坊网络之外执行。</font> 消息由发送者以加密方式签名，然后直接传输给收款人。

每条消息都包含以下信息：

> - 智能合约的地址，用于防止交叉合约重放攻击。
> - 到目前为止所发送的以太总量。

**在一系列转账结束时，付款通道仅需关闭一次**。因此，<font color='#e54d42'>**只有一条消息被兑换。**</font> 这就是为什么**每条消息都指定了以太的累计总量，而不是每次的微支付金额**。 收款人自然而然的会选择兑换最新消息，因为这是以太总数最高的消息。 **每条信息包含的nonce 将不再需要，因为智能合约仅执行一条信息。**

> <font color='#e54d42'>**注意这里的要点： 1.每条消息中指定的以太的累积总量而不是每次的增量或减少量； 2.每一个通道对应一个智能合约，每个智能合约只能执行一次消息，一旦兑换即通道关闭合约关闭**</font>

**包含合约地址用于防止一个支付通道的消息被用于不同的通道。**

以下是修改后的JavaScript代码，用于对上一节中的消息进行加密签名：

```js
function constructPaymentMessage(contractAddress, amount) {
    return abi.soliditySHA3(
        ["address", "uint256"],
        [contractAddress, amount]
    );
}

function signMessage(message, callback) {
    web3.eth.personal.sign(
        "0x" + message.toString("hex"),
        web3.eth.defaultAccount,
        callback
    );
}

// contractAddress is used to prevent cross-contract replay attacks.
// amount, in wei, specifies how much Ether should be sent.

function signPayment(contractAddress, amount, callback) {
    var message = constructPaymentMessage(contractAddress, amount);
    signMessage(message, callback);
}
```

### 关闭状态通道

当Bob准备好收到他们的资金时，就可以通过调用智能合约上的 `关闭` 功能来关闭支付通道。 关闭通道会向接收方支付所欠的以太币并销毁合约，剩余的以太币返回Alice。为了关闭通道，Bob需要提供 Alice 签名过的消息。

智能合约必须验证信息是否包含发送者的有效签名。执行此验证的过程与上面收款人使用的方法相同。 Solidity函数 `isValidSignature` 和 `recoverSigner` 就是完成这个工作。

**只有付款通道收款人可以调用 `close` 函数**，其会选择最近的付款消息，因为该消息有最高的付款总额。 如果允许发送者调用此函数，他们可以提供较低金额的消息，来欺骗收款人。

函数会验证签名的消息是否与给定的参数匹配，如果匹配，收款人将收到应得的部分，余下的部分通过 `selfdestruct` 返还给发送者。 可以在完整的合约代码中看到 `close` 函数。

### 通道有效期

Bob可以随时关闭支付通道，但如果他没有这样做，Alice 需要一种方法来收回他们托管的资金。 一个方法是在合约部署时设置 *到期时间* ，一旦达到那个时间，Alice 就可以调用 `claimTimeout`收回他们的资金。 可以在完整的合约代码中查看 `claimTimeout` 函数。

调用此功能后，Bob无法再接收任何以太币，因此，Bob必须在到期前关闭频道。

### 完整链上合约

```js
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.6 <0.9.0;

contract PaymentChannel {
    // 支付者
    address payable sender;
    // 接受者
    address payable recipient;
    // 结束期限, 到时间会强制结束通道
    uint256 public expiration;
    
    constructor (address payable _recipient, uint256 duration) public payable {
        sender = payable(msg.sender);
        recipient = payable(_recipient);
        expiration = block.timestamp + duration;
    }

    // 验证是否是有效的签名
    function isValidSignature(uint256 amount, bytes memory signature) internal view returns(bool) {
        // 取hash
        bytes32 message = prefixed(keccak256(abi.encodePacked(this, amount)));
        return recoverSigner(message, signature) == sender;
    }
    
    // 加入一个前缀，因为在eth_sign签名的时候会加上。
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }

    // 验证签名,并返回签名者地址
    function recoverSigner(bytes32 message, bytes memory signature) internal pure returns (address) {
        // 分离签名
        (uint8 v, bytes32 r, bytes32 s) = splitSignature(signature);
        return ecrecover(message, v, r, s);
    }

    // 分离签名
    function splitSignature(bytes memory signature) internal pure returns (uint8 v, bytes32 r, bytes32 s) {
        require(signature.length == 65);
        assembly {
            // 前32个字节，在长度前缀之后。
            r := mload(add(signature, 32))
            // 第二个32字节
            s := mload(add(signature, 64))
            // 最后一个byte,在随后32字节的第一个字节
            v := byte(0, mload(add(signature, 96)))
        }
        return (v, r, s);
    }

    // 接受者关闭通道, 接受者可以用任意的签名信息来获得自己的余额(一般选择余额最大的), 如果有剩余则会返还给发送者
    function close(uint256 amount, bytes memory signature) public {
        // 必须是接受者调用, 不能是支付者
        require(msg.sender == recipient);
        // 验证签名有效性
        require(isValidSignature(amount, signature));
        // 接受者返还金额
        recipient.transfer(amount);
        // 销毁合约并且支付者返还余额
        selfdestruct(sender);
    }

    // 支付者可以随时延长最后期限时间, 但是接受者可以在最后期限之前随时关闭通道而不受其限制
    function extend(uint256 newExpiration) public {
        // 必须是支付者
        require(msg.sender == sender);
        require(newExpiration > expiration);
        expiration = newExpiration;
    }

    // 到达最后期限时间, 任何人都可以关闭通道, 直接将剩下的钱返还给sender
    function claimTimeout() public {
        require(block.timestamp >= expiration);
        selfdestruct(sender);
    }
}
```

注解

> 函数 `splitSignature` 没有做足够的安全检查，完整的产品里应该使用严格测试的库，如：[openzepplin 的版本](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ECRecovery.sol) 。

### 验证支付(链下)

**与上一节不同，付款通道中的消息不是马上赎回。** **收款人会跟踪最新消息及在关闭付款通道时兑换它。 这意味着接收者对每条消息进行验证就至关重要。** 否则，无法保证收款人能够最终获得付款。

收款人使用以下过程验证每条消息：

> 1. 验证信息中的合约地址是否与付款通道匹配。
> 2. 验证新金额是否为预期金额。
> 3. 确认新金额不超过托管的以太币总额。
> 4. 验证签名是否有效并来自通道的付款方。

我们使用 [ethereumjs-util](https://github.com/ethereumjs/ethereumjs-util) 库来编写验证过程，这里使用 JavaScript ，当然实现的方式有很多。下面的代码借鉴了 上面的 constructMessage 函数:

```js
// this mimics the prefixing behavior of the eth_sign JSON-RPC method.
function prefixed(hash) {
    return ethereumjs.ABI.soliditySHA3(
        ["string", "bytes32"],
        ["\x19Ethereum Signed Message:\n32", hash]
    );
}

function recoverSigner(message, signature) {
    var split = ethereumjs.Util.fromRpcSig(signature);
    var publicKey = ethereumjs.Util.ecrecover(message, split.v, split.r, split.s);
    var signer = ethereumjs.Util.pubToAddress(publicKey).toString("hex");
    return signer;
}

function isValidSignature(contractAddress, amount, signature, expectedSigner) {
    var message = prefixed(constructPaymentMessage(contractAddress, amount));
    var signer = recoverSigner(message, signature);
    return signer.toLowerCase() ==
        ethereumjs.Util.stripHexPrefix(expectedSigner).toLowerCase();
}
```

