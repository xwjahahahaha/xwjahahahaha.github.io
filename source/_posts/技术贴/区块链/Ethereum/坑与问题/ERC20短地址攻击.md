---
title: ERC20短地址攻击
tags:
  - block_chain
categories:
  - technical
  - block_chain
toc: true
declare: true
date: 2020-08-02 01:04:55
---


# ERC20短地址攻击

参考博客可见：https://blog.csdn.net/xq723310/article/details/82844958

### calldata域的结构

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200730221545.png)

原始形式是一个4（函数名）+32（转出地址）+32（金额）字节的域。

<!-- more -->

### 原因所在

对转出地址做了手脚。因为这68个字节是连续放置的，然后再补零（不足32字节）。

如果转出地址的最后几位是0，那么拼接到一起回误把转账金额32字节前面的0最后其补全。并在转账金额后面补上缺少的0。

第一步，你的有一个地址以00结尾的账户地址，为什么？暂且不表；先说说怎么得到这种地址，你要是牛逼点，自己写个代码，很快就生成里，笔者实验了一下也就生产了2000个地址就会出现这种地址；你要是不会呢，有个叫“币合钱包”的工具打开后，选择“靓号生成器选项卡”就可以生产你想要的地址了。就以上例地址为例，你获得了一个641988625108585185752230bde001b3ebd0fc00的地址。

第二步，你把这个地址发给别人，但是以这种形式641988625108585185752230bde001b3ebd0fc；发现没有最后的两个零没写，为啥呢？接着看。

第三步，这就和你没关系啦，对方拿到这个地址后要转erc20的代币，他会创建input data，但是结果确实这样的。

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200730222029.png)

第二部分少了两个零，怎么办，后边补啊；相当于蓝色这两个补到了地址上，地址后边又补了两个；学过计算机的都知道，左移8位相当于乘256，就是你原来想转一个，变成了转256了。


### 防止办法

转账前先检查后面32+32的位数个数是否正确：

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200730222116.png)

![](http://xwjpics.gumptlu.work/qiniu_picGo/20200730222141.png)

