---
title: 2.log日志包
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2022-05-11 10:34:45
---

[TOC]

包路径：`pkg/log`

> * https://github.com/google/gvisor

# 一、总体结构

先上`UML`图:

![image-20220511193429641](http://xwjpics.gumptlu.work/qinniu_uPic/image-20220511193429641.png)

<!-- more -->

## 1. 图的解释

* 符号：
  * `S`: 结构体
  * `I`: 接口
  * `T`: 用`type`重命名的新变量类型
  * `C`: 变量
* 指示:
  * 空心箭头：所有方法都实现的接口实现关系
  * 实心箭头：嵌套接口隐性实现的接口实现关系

## 2. 父级接口：

### `Emitter`

* 功能：抽象出的日志发送器，实现方法为`Emit`即向某个目的地（这里就是`Writer`）写入日志

### `Logger`

* 功能：上层高级日志接口，基于此接口实现了一个基本`BasicLogger`用于整个`log`包的向外服务

### `TestLogger`

* 功能：测试日志专门的抽象(`test.T`、`test.B`)

## 3. 实现类

所有的实现类都实现了`Emitter`接口，所以都会有一个日志目的地

### Writer

```go
// Writer 根据给定的writer向其中写入输出
type Writer struct {
	Next io.Writer

	// mu 用于保护下面的atomicErrors
	mu sync.Mutex

	// atomicErrors 记录写入日志失败的次数，以便在重新工作的时候报告；使用上面的互斥锁保证安全性
	atomicErrors int32
}
```

* 目的地：`Next`，就是一个`io.Writer`

* 功能：分别实现了标准写入接口方法`io.Writer`、`Emitter`接口方法；并且对于写入函数还设置了错误统计次数字段`atomicErrors`

  ```go
  // io
  type Writer interface {
  	Write(p []byte) (n int, err error)
  }
  ```

### BasicLogger

```go
// BasicLogger 是Logger的默认实现
type BasicLogger struct {
	Level
	Emitter
}
```

* 目的地：`Emitter`接口的具体实现的目的地
* 功能：实现高级日志接口`Logger`，并通过`atomic.Value`封装实现整个`log`包的的对外服务函数

### TestEmitter

```go
// TestLogger 测试日志由 testing.T 和 testing.B 实现
type TestLogger interface {
	Logf(format string, v ...interface{})
}

type TestEmitter struct {
	TestLogger // 结构体内嵌接口，假设实现了这个接口，但是实际不需要实现所有接口函数（能够骗过编译期）
}

func (t *TestEmitter) Emit(_ int, level Level, timestamp time.Time, format string, v ...interface{}) {
	t.Logf(format, v...)
}
```

* 目的地：`stdout`（直接通过`t.Logf(format, v...)`输出）
* 功能：适配测试类日志

### GoogleEmitter、JSONEmitter、K8sJSONEmitter

这三者都是通过继承`Writer`类完成对`Emitter`接口的实现，可以直接作为`BasicLogger.Emitter`字段的实现

* `GoogleEmitter`：谷歌默认日志格式封装，是`BasicLogger.Emitter`接口的默认实现
* `JSONEmitter`:  json序列化格式后的日志输出
* `K8sJSONEmitter`: 特配k8s的json日志输出

## 4. 其他

### Level

```go
// Level 日志等级
type Level uint32

// 以下级别是固定的，不能更改。由于某些控制rpc允许将级别更改为整数，所以只能添加额外的级别，不能删除现有的级别。
const (
	// Warning 警告表示应该始终发出输出
	Warning Level = iota

	// Info 表示通常发送输出
	Info

	// Debug 表示一般不发送输出
	Debug
)
```

表示日志等级，并且在`log/json.go`中对其进行了序列化适配以此来适应`json.Marshal` (也就是实现了`Marshal`、`Unmarshal`两个接口)

# 二、代码重点细节

## 1.`runtime.Caller`的理解？

> 参考资料：
>
> * https://blog.csdn.net/skh2015java/article/details/100042494

在`log/glog`的`Emit`函数中有一块代码：

```go
func (g GoogleEmitter) Emit(depth int, level Level, timestamp time.Time, format string, args ...interface{}) {
	// log level
	...

	// Timestamp
	...
	// runtime.Caller: 获取当前goroutine有关调用堆栈上的信息包括：pc、函数调用的文件、行号信息
	// 其参数skip表示层数： 0 表示当前层， 1 上一层函数
	_, file, line, ok := runtime.Caller(depth + 1)
	if ok {
		slash := strings.LastIndexByte(file, byte('/'))
		if slash >= 0 {
			// 表示找到了/,截取最后的文件名
			file = file[slash+1:]
		}
	}else {
		// 未知的文件
		file = "???"
		line = 0
	}

	...
}
```

其中`runtime.Caller`函数的作用是获取当前`goroutine`有关调用堆栈上（或者说栈帧）的信息包括：`pc`、函数调用的文件、行号信息:

```go
// Caller reports file and line number information about function invocations on
// the calling goroutine's stack. The argument skip is the number of stack frames
// to ascend, with 0 identifying the caller of Caller.  (For historical reasons the
// meaning of skip differs between Caller and Callers.) The return values report the
// program counter, file name, and line number within the file of the corresponding
// call. The boolean ok is false if it was not possible to recover the information.
func Caller(skip int) (pc uintptr, file string, line int, ok bool) {
	rpc := make([]uintptr, 1)
	n := callers(skip+1, rpc[:])
	if n < 1 {
		return
	}
	frame, _ := CallersFrames(rpc).Next()
	return frame.PC, frame.File, frame.Line, frame.PC != 0
}
```

此处就是使用其获取到执行的文件和行数，将其标准谷歌日志输出的部分

一个小demo：

```go
package main
 
import (
	"fmt"
	"runtime"
)
 
func main() {
	for i := 0 ; i< 4; i++ {
		test(i)
	}
}
 
func test(skip int) {
	call(skip)
}
 
func call(skip int) {
	pc,file,line,ok := runtime.Caller(skip)
	pcName := runtime.FuncForPC(pc).Name()  //获取函数名
	fmt.Println(fmt.Sprintf("%v   %s   %d   %t   %s",pc,file,line,ok,pcName))
}
```

输出：

```txt
4339765207   /Users/.../go_projects/src/test/test.go   19   true   main.call
4339765123   /Users/.../go_projects/src/test/test.go   15   true   main.test
4339765112   /Users/.../go_projects/src/test/test.go   10   true   main.main
4339383443   /Users/.../sdk/go1.17.1/src/runtime/proc.go   255   true   runtime.main
```

解释：

函数调用关系：`main() => test() => call()`，也是依次押入栈帧中，刚好对应上面的调用栈输出

## 2. `Emit`函数为何需要/设计一个`depth`参数/`depth`的作用？

`depth`就是整个程序调用栈的某一层，或者说每个函数的日志输出

```go
// DebugfAtDepth 记录特定深度的debug日志
func (l *BasicLogger) DebugfAtDepth(depth int, format string, v ...interface{}) {
	if l.IsLogging(Debug) {
		// 如果正在调用debug，则往下继续调用(depth+1)
		l.Emit(1+depth, Debug, time.Now(), format, v...)
	}
}
```

第一层是0，每一层+1

```go
func Debugf(format string,v ...interface{}) {
	Log().DebugfAtDepth(1, format, v...)
}

func Infof(format string, v ...interface{}) {
	Log().InfofAtDepth(1, format, v...)
}

func Warningf(format string, v ...interface{}) {
	Log().WarningfAtDepth(1, format, v...)
}

// DebugfAtDepth logs to the global logger.
func DebugfAtDepth(depth int, format string, v ...interface{}) {
	Log().DebugfAtDepth(1+depth, format, v...)
}

// InfofAtDepth logs to the global logger.
func InfofAtDepth(depth int, format string, v ...interface{}) {
	Log().InfofAtDepth(1+depth, format, v...)
}

// WarningfAtDepth logs to the global logger.
func WarningfAtDepth(depth int, format string, v ...interface{}) {
	Log().WarningfAtDepth(1+depth, format, v...)
}
```

所以，外部使用`log`包的时候，第一个调用就是第一层，往下每个函数再次调用就是第二层…..

```go
func A(format string, args ...interface{}) subcommands.ExitStatus {
	log.Warningf(format, args...)				// depth = 0
	...
  B()
}

func B(){
  format, args = _, _
  log.Warningf(format, args...)				// depth = 1
}
```

## 3. `struct`嵌套接口`interface`的适用场景、好处？

相关代码：（`log.go`中有非常多这样的实现，对应`UML`图的实心黑线）

```go
type BasicLogger struct {
	Level
	Emitter				// Emitter 是一个接口
}
```

一个接口的实例是必须要实现其所有方法的，但是也可以通过将接口作为参数的方式从而避免实现其所有方法但可称之为“实现了此接口”, 因为当创建这个结构体实例的时候，还是需要设置一个此接口的实现完成此字段的赋值，例如：

```go
func init() {
	// 初始化创建基本logger
	log.Store(&BasicLogger{
		Level:   Info,
		Emitter: GoogleEmitter{&Writer{Next: os.Stderr}},			
	})
}
```

`Emitter`: 这里就将`GoogleEmitter`实例作为了`Emitter`接口的实现，所以`BasicLogger`一定会实现`Emitter`接口，只是不是自己实现而是通过其字段实例实现

此外代码还设置了`SetTarget`方法，可以重置为其他`Emitter`实例，如`JSONEmitter、K8sJSONEmitter`

```go
// SetTarget 设置日志目标。这不是线程安全的，不应与任何日志记录调用同时调用
func SetTarget(target Emitter) {
	logMu.Lock()
	defer logMu.Unlock()
	oldLog := Log()
	log.Store(&BasicLogger{Level: oldLog.Level, Emitter: target})
}
```

场景：

* 自己不实现所有接口所有方法但是想成为此接口实例

好处：

* 灵活，任何实现了此接口的实例都可以使用
* 编译期不会因为未实现此接口的所有方法而报错，如果未初始化接口字段而去调用接口方法，因为未实现，所以在运行期会报错

## 4. `atomic.Value`的使用技巧,适用场景？

> 参考资料：
>
> * https://blog.betacat.io/post/golang-atomic-value-exploration/

代码中用`atomic.Value`加载和存储了`BasicLogger`

```go
//  atomic.Value 提供了任意类型值的原子性加载和存储.这里就是BasicLogger
var log atomic.Value

func Log() *BasicLogger {
	return log.Load().(*BasicLogger)																// 加载
}


func SetTarget(target Emitter) {
	...
	log.Store(&BasicLogger{Level: oldLog.Level, Emitter: target})		// 存储
}
```

目的就是原子性的存储和加载任一类型值

> <font color='#39b54a'>原子性：简单理解就是操作要么全部正确完成，要么从未开始，在os中就是保证某些指令在执行的间隙不会被中断从而造成并发安全问题</font>

使用场景：

* `atomic`包将硬件的原子性操作封装成为了go函数,但是只是在一些特定的类型下，所有后来就提供了`atomic.Value`的方式去适应任何类型值，其可以看作是一个容器，可以原子性的存储和加载任何类型的值

为何有时使用`atmoic.Value`而不使用`Mutex`？

* 因为`atmoic.Value`的实现是直接借助于硬件的原子性保证，而`Mutex`是操作系统的调度器实现的。`Mutexes do no scale. Atomic loads do.`
* 锁应当用来保护一段逻辑，**对于一个变量更新的保护，原子操作通常会更有效率**，并且更能利用计算机多核的优势，如果要更新的是一个复合对象，则应当使用`atomic.Value`封装好的实现。

使用姿势：

`atomic.Value`类型对外暴露的方法就两个：

- `v.Store(c)` - 写操作，将原始的变量`c`存放到一个`atomic.Value`类型的`v`里。
- `c = v.Load()` - 读操作，从线程安全的`v`中读取上一步存放的内容。

简洁的接口使得它的使用也很简单，只需将需要作并发保护的变量读取和赋值操作用`Load()`和`Store()`代替就行了。

## 5. 自定义字段如何被`json`序列化？

实现两个接口（也就是对应的两个接口方法）：

```go
// Marshaler is the interface implemented by types that
// can marshal themselves into valid JSON.
type Marshaler interface {
	MarshalJSON() ([]byte, error)
}

type Unmarshaler interface {
	UnmarshalJSON([]byte) error
}
```

例如`log`包中的`Level`代码实现:

```go
// MarshalJSON 让Level实现json.Marshaler接口的MarashalJSON方法从而实现此接口，防止json序列化失败
func (l Level) MarshalJSON() ([]byte, error) {
	switch l {
	case Warning:
		return []byte(`"warning"`), nil
	case Info:
		return []byte(`"info"`), nil
	case Debug:
		return []byte(`"debug"`), nil
	default:
		return nil, fmt.Errorf("unknown level %v", l)
	}
}

// UnmarshalJSON implements json.Unmarshaler.UnmarshalJSON.  It can unmarshal from both string names and integers.
func (l *Level) UnmarshalJSON(b []byte) error {
	switch s := string(b); s {
	case "0", `"warning"`:
		*l = Warning
	case "1", `"info"`:
		*l = Info
	case "2", `"debug"`:
		*l = Debug
	default:
		return fmt.Errorf("unknown level %q", s)
	}
	return nil
}
```

如果未实现，序列化阶段报错
