---
title: 2-实现解析前端和虚拟机
tags:
  - null
categories:
  - technical
  - null
toc: true
declare: true
date: 2022-11-29 21:54:21
---

[TOC]


<!-- more -->

> 参考：
>
> * https://zhuanlan.zhihu.com/p/463791156

# 一、修改测试代码

因为是测试驱动，所以第一步修改我们的测试代码以适配新的需求开发：

```rb
describe 'database' do
    def run_script(commands)
        raw_output = nil
        IO.popen("./db", "r+") do |pipe|
            commands.each do |command|
                pipe.puts command
            end
            
            pipe.close_write

            # Read entire ouput
            raw_output = pipe.gets(nil)
        end
        raw_output.split("\n")
    end

    it 'test exit and unrecognized command' do 
        result = run_script([
            "hello world",
            ".HELLO WORLD",
            ".exit",
        ])
        expect(result).to match_array([
            "db > Unrecognized keyword at start of 'hello world'.",
            "db > Unrecognized command: .HELLO WORLD",
            "db > Bye!",
        ])
    end

    it 'test insert and select' do
        result = run_script([
            "insert 1 user1",
            "select",
            ".exit",
        ])
        expect(result).to match_array([
            "db > Executing insert statement",
            "db > Executing select statement",
            "db > Bye!",
        ])
    end
end
```

# 二、解析前端

* SQL的解析前端是什么？

它将传统输入的`string`字符串，解析成可被机器识别的字节码内部表现形式，并传递给虚拟机进一步执行

* 怎么实现一个SQL的解析前端？

先从我们上一章所解析的`command`来看起。我们将以`.`开头的非sql语句称作元命令 ***(meta command)*** 所以我们在一开始就检查是否以其开头，并单独封装一个`do_meta_command`函数来处理它

前端需要修改的所有代码如下所示：

```cpp
#include <iostream>
#include <string>
using namespace std;

// 元命令结果
enum MetaCommandResult {
    META_COMMAND_SUCCESS,
    META_COMMAND_UNRECONGNIZED,
};

// sql前端解析结果
enum PrepareResult {
    PREPARE_SUCCESS,
    PREPARE_UNRECONGNIZED,
};

// sql状态类型
enum StatementType {
    STATEMENT_INSERT,
    STATEMENT_SELECT,
};

class Statement {
public:
    StatementType type;  
};

class DB {
private:
    bool parse_meta_command(string);
    MetaCommandResult do_meta_command(string);
    PrepareResult prepare_statement(string&, Statement&);
    bool parse_statement(string&, Statement&);
    void execute_statement(Statement&); 
public:
    void start();
    void print_prompt();
};

void DB::print_prompt() {
   cout << "db > ";
}

// 解析元命令
bool DB::parse_meta_command(string command) {
    if (command[0] == '.') {
        switch (do_meta_command(command.substr(1))) {
        case META_COMMAND_SUCCESS:
        case META_COMMAND_UNRECONGNIZED:
            cout << "Unrecognized command: " << command << endl;    
        }
        return true;            // 只要前缀是.则都属于元命令
    }
    return false;
}

// 执行元命令
MetaCommandResult DB::do_meta_command(string command) {
    if (command == "exit") {
        cout << "Bye!" << endl;
        exit(EXIT_SUCCESS);
    }else {
        return META_COMMAND_UNRECONGNIZED;
    }
}

// 判断前端状态
PrepareResult DB::prepare_statement(string &input_line, Statement &statement) {
    if (!input_line.compare(0, 6, "insert")) {        // 只有相同为0时才进入
        statement.type = STATEMENT_INSERT;
        return PREPARE_SUCCESS;
    } else if (!input_line.compare(0, 6, "select")) {
        statement.type = STATEMENT_SELECT;
        return PREPARE_SUCCESS;
    } else {
        return PREPARE_UNRECONGNIZED;
    }
}

// 解析前端状态
bool DB::parse_statement(string &input_line, Statement &statement) {
    switch (prepare_statement(input_line, statement)) {
    case PREPARE_SUCCESS:
        return true;               
    case PREPARE_UNRECONGNIZED:
        cout << "Unrecognized keyword at start of '" << input_line << "'." << endl;
        return false;             
    }   
    return false;
}
```

根据代码以及注释来看，理解起来应该不是很难，据此我们能够根据输入获得当前的状态

# 三、虚拟机

其实感觉这里叫“虚拟机”可能叫做状态机更加合适一点，目前此部分仅仅是简单的演示（输出）一下sql执行

```c++
// 执行当前状态
void DB::execute_statement(Statement &statement) {
    switch (statement.type) {
    case STATEMENT_INSERT:
        cout << "Executing insert statement" << endl;
        break;
    case STATEMENT_SELECT:
        cout << "Executing select statement" << endl;
        break;
    }
}

void DB::start() {
    while(true) {
        print_prompt();

        string input_line;
        getline(cin, input_line);

        // 解析元命令
        if (parse_meta_command(input_line)) {
            continue;
        }

        Statement statement;
        // 解析状态
        if (parse_statement(input_line, statement)) {
            execute_statement(statement);           // 解析后执行状态
        }
    }
}
```

最后跑一下测试案例：

```shell
g++ db.cpp -o db
rspec spec db_test.rb
```

![image-20221129231530718](http://xwjpics.gumptlu.work/qinniu_uPic/image-20221129231530718.png)



