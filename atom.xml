<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识与头发不可兼得</title>
  
  <subtitle>文杰的博客</subtitle>
  <link href="https://xwjahahahaha.github.io/atom.xml" rel="self"/>
  
  <link href="https://xwjahahahaha.github.io/"/>
  <updated>2021-07-21T01:39:16.440Z</updated>
  <id>https://xwjahahahaha.github.io/</id>
  
  <author>
    <name>DDDemons hide</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日记_0202</title>
    <link href="https://xwjahahahaha.github.io/2021/07/21/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0202/"/>
    <id>https://xwjahahahaha.github.io/2021/07/21/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0202/</id>
    <published>2021-07-21T01:39:01.000Z</published>
    <updated>2021-07-21T01:39:16.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input checked="" disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input disabled="" type="checkbox"> 零知识证明</li><li><input disabled="" type="checkbox"> 论文</li><li><input disabled="" type="checkbox"> tendermint项目解读2</li><li><input disabled="" type="checkbox"> 一小时阅读</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Decentralized_Privacy_Using_Blockchain-Enabled_Federated_Learning_in_Fog_Computing》精读</title>
    <link href="https://xwjahahahaha.github.io/2021/07/20/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E8%AE%BA%E6%96%87/FL%20And%20BlockChain/%E3%80%8ADecentralized-Privacy-Using-Blockchain-Enabled-Federated-Learning-in-Fog-Computing%E3%80%8B%E7%B2%BE%E8%AF%BB/"/>
    <id>https://xwjahahahaha.github.io/2021/07/20/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E8%AE%BA%E6%96%87/FL%20And%20BlockChain/%E3%80%8ADecentralized-Privacy-Using-Blockchain-Enabled-Federated-Learning-in-Fog-Computing%E3%80%8B%E7%B2%BE%E8%AF%BB/</id>
    <published>2021-07-20T07:40:34.000Z</published>
    <updated>2021-07-21T02:16:02.996Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>论文地址：<a href="https://ieeexplore.ieee.org/document/9019859" target="_blank" rel="noopener">https://ieeexplore.ieee.org/document/9019859</a></p></blockquote><h1 id="一、基本信息、前置知识"><a href="#一、基本信息、前置知识" class="headerlink" title="一、基本信息、前置知识"></a>一、基本信息、前置知识</h1><h2 id="1-1-基本信息"><a href="#1-1-基本信息" class="headerlink" title="1.1 基本信息"></a>1.1 基本信息</h2><p>《Decentralized Privacy Using Blockchain-Enabled Federated Learning in Fog Computing》</p><p>作者：<a href="https://ieeexplore.ieee.org/author/37086113748" target="_blank" rel="noopener">Youyang Qu</a>; <a href="https://ieeexplore.ieee.org/author/37400376100" target="_blank" rel="noopener">Longxiang Gao</a>; <a href="https://ieeexplore.ieee.org/author/37085345130" target="_blank" rel="noopener">Tom H. Luan</a>; <a href="https://ieeexplore.ieee.org/author/37286573200" target="_blank" rel="noopener">Yong Xiang</a>; <a href="https://ieeexplore.ieee.org/author/37405530700" target="_blank" rel="noopener">Shui Yu</a>; <a href="https://ieeexplore.ieee.org/author/37088420381" target="_blank" rel="noopener">Bai Li</a>; <a href="https://ieeexplore.ieee.org/author/37088420573" target="_blank" rel="noopener">Gavin Zheng</a></p><p>出版刊物：<a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6488907" target="_blank" rel="noopener">IEEE Internet of Things Journal</a> ( Volume: 7, <a href="https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=9115800" target="_blank" rel="noopener">Issue: 6</a>)</p><p>年份：June 2020</p><p>期刊影响因子/分区：2021年9.47/<strong>Q1</strong></p><a id="more"></a><h2 id="1-2-前置知识"><a href="#1-2-前置知识" class="headerlink" title="1.2 前置知识"></a>1.2 前置知识</h2><h3 id="雾计算"><a href="#雾计算" class="headerlink" title="雾计算"></a>雾计算</h3><blockquote><p>百度百科：</p><p>雾计算（Fog Computing），在该模式中数据、（数据）处理和<a href="https://baike.baidu.com/item/应用程序集/3491931" target="_blank" rel="noopener">应用程序集</a>中在<strong>网络边缘的设备</strong>中，而不是几乎全部保存在云中，是<a href="https://baike.baidu.com/item/云计算/9969353" target="_blank" rel="noopener">云计算</a>（Cloud Computing）的延伸概念，由<a href="https://baike.baidu.com/item/思科/454822" target="_blank" rel="noopener">思科</a>（Cisco）提出的。这个因“云”而“雾”的命名源自“雾是更贴近地面的云”这一名句。</p><p>雾计算和云计算一样，十分形象。云在天空飘浮，高高在上，遥不可及，刻意抽象；而雾却现实可及，贴近地面，就在你我身边。雾计算并非由性能强大的服务器组成，而是由<strong>性能较弱、更为分散的各类功能计算机组成</strong>，渗入工厂、汽车、电器、街灯及人们物质生活中的各类用品。</p></blockquote><p>雾计算不是具体的一种算法，而是偏向一种新型的应用概念</p><h1 id="二、解决的问题"><a href="#二、解决的问题" class="headerlink" title="二、解决的问题"></a>二、解决的问题</h1><ol><li><p>分布式隐私：融合区块链和联邦学习框架解决雾计算的单点隐私问题, 通过区块链解决隐私保护 </p><blockquote><p><font color='#39b54a'>去中心化实现的隐私保护</font></p></blockquote></li><li><p>投毒攻击证明：区块链系统提供non-tempering特点实现投毒攻击的评估</p></li><li><p>高效率：一方面联邦学习只交换梯度参数，第二方面区块链只存储指针，数据通过<strong>链下的分布式Hash表存储</strong></p></li></ol><h1 id="三、创新的方法"><a href="#三、创新的方法" class="headerlink" title="三、创新的方法"></a>三、创新的方法</h1><h2 id="3-1-FL-Block体系框架"><a href="#3-1-FL-Block体系框架" class="headerlink" title="3.1 FL-Block体系框架"></a>3.1 FL-Block体系框架</h2><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;论文地址：&lt;a href=&quot;https://ieeexplore.ieee.org/document/9019859&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ieeexplore.ieee.org/document/9019859&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、基本信息、前置知识&quot;&gt;&lt;a href=&quot;#一、基本信息、前置知识&quot; class=&quot;headerlink&quot; title=&quot;一、基本信息、前置知识&quot;&gt;&lt;/a&gt;一、基本信息、前置知识&lt;/h1&gt;&lt;h2 id=&quot;1-1-基本信息&quot;&gt;&lt;a href=&quot;#1-1-基本信息&quot; class=&quot;headerlink&quot; title=&quot;1.1 基本信息&quot;&gt;&lt;/a&gt;1.1 基本信息&lt;/h2&gt;&lt;p&gt;《Decentralized Privacy Using Blockchain-Enabled Federated Learning in Fog Computing》&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://ieeexplore.ieee.org/author/37086113748&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Youyang Qu&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37400376100&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Longxiang Gao&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37085345130&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tom H. Luan&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37286573200&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yong Xiang&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37405530700&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Shui Yu&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37088420381&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bai Li&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37088420573&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gavin Zheng&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出版刊物：&lt;a href=&quot;https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6488907&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IEEE Internet of Things Journal&lt;/a&gt; ( Volume: 7, &lt;a href=&quot;https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=9115800&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Issue: 6&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;年份：June 2020&lt;/p&gt;
&lt;p&gt;期刊影响因子/分区：2021年9.47/&lt;strong&gt;Q1&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="knowledge" scheme="https://xwjahahahaha.github.io/categories/knowledge/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer17.打印从1到最大的n位数</title>
    <link href="https://xwjahahahaha.github.io/2021/07/20/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <id>https://xwjahahahaha.github.io/2021/07/20/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</id>
    <published>2021-07-20T03:47:16.000Z</published>
    <updated>2021-07-21T02:08:18.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 17. 打印从1到最大的n位数</a></p><p>难度简单</p><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure> <a id="more"></a><p>说明：</p><ul><li>用返回一个整数列表来代替打印</li><li>n 为正整数</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>本题乍一看非常简单，但是核心考察的是<strong>大数溢出问题</strong></p><p>不论是int64还是其他语言，变量都有上限，在输入n很大的情况下就会导致溢出，所以大数溢出问题的解决：</p><ul><li><font color='#e54d42'>字符数组表示数字，由低到高</font></li></ul><p>在编写代码时还需要注意两个细节：</p><ol><li><p>例如n=3， 从1～999怎样判断该字符数组到达999？</p><p>使用循环逐位判断’9’复杂度为O(n)，不是很好的办法。当其再加一就会导致进位，判断其进位是否到达最高位的上一位即可（即判断再加1是否到1000），这样时间复杂度为O(1)</p></li><li><p>初始化字符数组都为’0’，如果数字没有n位，那么前面会有多个无意义的0，对于输出来说不合适，所以在字符数组大数转为对应的数字时需要清除掉前面的0 （虽然Go的Atoi自动会清除）</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直观的思路</span></span><br><span class="line"><span class="comment">// 但是没有考虑大数溢出问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建结果数组</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=<span class="keyword">int</span>(math.Pow10(n)<span class="number">-1</span>); i++ &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 </span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法二：字符串模拟构造大数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    numString := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n+<span class="number">1</span>)    <span class="comment">// 多设置一位是为了判断循环是否结束</span></span><br><span class="line">    <span class="comment">// 全部位初始化为0，即使达不到n位，前面也为0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(numString); i++ &#123;</span><br><span class="line">        numString[i] = <span class="keyword">byte</span>(<span class="string">'0'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> !Increment(&amp;numString) &#123;</span><br><span class="line">        <span class="comment">// 将输出存储</span></span><br><span class="line">        <span class="comment">// 排除前面的0, 找到第一个1</span></span><br><span class="line">        vaildIndex := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(numString); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> numString[i] != <span class="string">'0'</span> &#123;</span><br><span class="line">                vaildIndex = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num, _ := strconv.Atoi(<span class="keyword">string</span>(numString[vaildIndex:]))</span><br><span class="line">        res = <span class="built_in">append</span>(res, num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串数字 +1 函数</span></span><br><span class="line"><span class="comment">// 注意为了改变原字节数组，所以传递指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Increment</span><span class="params">(numString *[]<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">byte</span>          <span class="comment">// 进位</span></span><br><span class="line">    carry = <span class="number">0</span>  </span><br><span class="line">    n := <span class="built_in">len</span>(*numString)<span class="number">-1</span>     </span><br><span class="line">    <span class="keyword">for</span> i:=n; i&gt;=<span class="number">0</span>; i-- &#123;       <span class="comment">// 此循环为了进位</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 到达最高位即可让外层循环退出，最高位(数组中下标为1)的上一位(数组中下标为0)为1，产生进位，所以结束</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取当前位置数</span></span><br><span class="line">        num := (*numString)[i] - <span class="string">'0'</span> </span><br><span class="line">        <span class="comment">// +1 只在末位(数组中下标为n)</span></span><br><span class="line">        <span class="keyword">if</span> i == n &#123;</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加上进位</span></span><br><span class="line">        num += carry</span><br><span class="line">        <span class="comment">// 计算新的进位</span></span><br><span class="line">        <span class="keyword">if</span> num &gt;= <span class="number">10</span> &#123;</span><br><span class="line">            carry = <span class="number">1</span></span><br><span class="line">            num -= <span class="number">10</span></span><br><span class="line">            (*numString)[i] = <span class="string">'0'</span> + num     <span class="comment">// 将当前位写上，进位还有继续循环计算 </span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 变回字符串</span></span><br><span class="line">            (*numString)[i] = <span class="string">'0'</span> + num     <span class="comment">// 将当前位写上，已无进位，结束循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一次+1 计算完毕，无溢出返回falsefalse，让外层循环继续写入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于使用字符串表示大数，本题的大数每一位都是’0’～’9’字符的排列，所以可以看作全排列来减少代码量</p><p>全排列使用递归会更加的好写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大数字符串的递归全排列</span></span><br><span class="line"><span class="comment">// 每一位都是字符0～1的全排列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    numString := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">    <span class="comment">// 递归函数</span></span><br><span class="line">    <span class="keyword">var</span> recursive <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span> </span><br><span class="line">    recursive = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> index == n &#123;</span><br><span class="line">            <span class="comment">// 记录当前值（除去开头无效0）</span></span><br><span class="line">            vaildStart := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> numString[i] != <span class="string">'0'</span> &#123;</span><br><span class="line">                    vaildStart = i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num, _ := strconv.Atoi(<span class="keyword">string</span>(numString[vaildStart:]))</span><br><span class="line">            res = <span class="built_in">append</span>(res, num)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=<span class="number">9</span>; i++ &#123;</span><br><span class="line">            <span class="comment">// 存储当前下标位置字符</span></span><br><span class="line">            numString[index] = <span class="string">'0'</span> + <span class="keyword">byte</span>(i)</span><br><span class="line">            <span class="comment">// 向下一位递归</span></span><br><span class="line">            recursive(index+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    recursive(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">1</span>:]  <span class="comment">// 此处去除掉最开始的0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='#39b54a'>本题直接用数字遍历到n位在时间上肯定会比字符串大数来的快，但是安全性上是有所缺陷的并且对于项目来说可能是致命的，具体场景要具体适用</font></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 17. 打印从1到最大的n位数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度简单&lt;/p&gt;
&lt;p&gt;输入数字 &lt;code&gt;n&lt;/code&gt;，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: n &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2,3,4,5,6,7,8,9]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0201</title>
    <link href="https://xwjahahahaha.github.io/2021/07/20/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0201/"/>
    <id>https://xwjahahahaha.github.io/2021/07/20/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0201/</id>
    <published>2021-07-20T01:08:42.000Z</published>
    <updated>2021-07-21T01:38:55.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input checked="" disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input disabled="" type="checkbox"> 零知识证明</li><li><input checked="" disabled="" type="checkbox"> 论文</li><li><input disabled="" type="checkbox"> tendermint项目解读2</li><li><input disabled="" type="checkbox"> 一小时阅读</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>零知识证明</title>
    <link href="https://xwjahahahaha.github.io/2021/07/19/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"/>
    <id>https://xwjahahahaha.github.io/2021/07/19/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</id>
    <published>2021-07-19T08:40:51.000Z</published>
    <updated>2021-07-20T06:45:35.897Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.bilibili.com/video/BV18y4y1v7Ai" target="_blank" rel="noopener">https://www.bilibili.com/video/BV18y4y1v7Ai</a></p><p><a href="https://cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography/" target="_blank" rel="noopener">https://cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography/</a></p><p><a href="https://cloud.tencent.com/developer/article/1779901" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1779901</a></p><p><a href="https://www.cnblogs.com/Lands-ljk/p/11718235.html" target="_blank" rel="noopener">https://www.cnblogs.com/Lands-ljk/p/11718235.html</a></p></blockquote><blockquote><p>本文资料多来自2019年ALON ROSEN教授的“第九届BIU密码学冬令营-Zero Knowledge专题”, 该课程从<strong>复杂性理论</strong>切入，较难理解</p></blockquote><h1 id="一、Zero-Knowledge基础"><a href="#一、Zero-Knowledge基础" class="headerlink" title="一、Zero-Knowledge基础"></a>一、Zero-Knowledge基础</h1><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/7INqR5.png" alt="7INqR5"></p><a id="more"></a><p>零知识证明：证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV18y4y1v7Ai&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/BV18y4y1v7Ai&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1779901&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cloud.tencent.com/developer/article/1779901&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Lands-ljk/p/11718235.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/Lands-ljk/p/11718235.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;本文资料多来自2019年ALON ROSEN教授的“第九届BIU密码学冬令营-Zero Knowledge专题”, 该课程从&lt;strong&gt;复杂性理论&lt;/strong&gt;切入，较难理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、Zero-Knowledge基础&quot;&gt;&lt;a href=&quot;#一、Zero-Knowledge基础&quot; class=&quot;headerlink&quot; title=&quot;一、Zero-Knowledge基础&quot;&gt;&lt;/a&gt;一、Zero-Knowledge基础&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/7INqR5.png&quot; alt=&quot;7INqR5&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/categories/technical/golang/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer16.数值的整数次方</title>
    <link href="https://xwjahahahaha.github.io/2021/07/19/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>https://xwjahahahaha.github.io/2021/07/19/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</id>
    <published>2021-07-19T03:05:02.000Z</published>
    <updated>2021-07-19T03:17:45.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a></p><p>难度中等</p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>-104 &lt;= xn &lt;= 104</code></li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>此题细节非常多，考察的不仅仅是简单的求整数次方，要着重考虑<strong>边界情况与优化</strong></p><p>细节注意点：</p><ol><li>输入的指数n是否可能为负数，负数要怎样处理？</li><li>输入的底数x是否可能为0，n为负数，那么就会导致分母为0的情况，所以对于x为0统一的处理方式是返回0（$0^0$在数学上没有意义）</li><li>浮点数的等值判断是否可以直接用等号？显然是不合适的</li><li>求数值的整数次方时间上是否可以优化？</li><li>除2以及求余函数是否可以优化？</li></ol><p>求整数倍的优化算法是：<br>$$<br>a^n = \begin{cases}a^{n/2} * a^{n/2} &amp; n为偶数 \ a^{(n-1)/2} * a^{(n-1)/2} * a &amp; n为奇数 \end{cases}<br>$$<br>详情可见下方代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MIN = <span class="number">0.00000000000001</span>        <span class="comment">// 比较的精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个浮点数是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsEqual</span><span class="params">(f1, f2 <span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f1 &gt; f2 &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Dim(f1, f2) &lt; MIN</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Dim(f2, f1) &lt; MIN</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值整数次方计算函数</span></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">uint</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右移代替除二</span></span><br><span class="line">    res := MyPow(x, n&gt;&gt;<span class="number">1</span>)</span><br><span class="line">    res = res * res</span><br><span class="line">    <span class="comment">// 判断奇偶，奇数再乘本身一次</span></span><br><span class="line">    <span class="comment">// 位与运算代替求余</span></span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">0x1</span> == <span class="number">1</span> &#123;</span><br><span class="line">        res *= x</span><br><span class="line">    &#125;             </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> IsEqual(x, <span class="number">0.0</span>) &#123;       <span class="comment">// 如果底数为0，则无意义直接返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;                <span class="comment">// 如果底数不为0，但指数为负数，那么处理底数与指数</span></span><br><span class="line">        x = <span class="number">1.0</span> / x</span><br><span class="line">        n *= <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求整数倍的优化算法</span></span><br><span class="line">    <span class="keyword">return</span> MyPow(x, <span class="keyword">uint</span>(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 16. 数值的整数次方&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;实现 &lt;a href=&quot;https://www.cplusplus.com/reference/valarray/pow/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pow(&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;)&lt;/a&gt; ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0200</title>
    <link href="https://xwjahahahaha.github.io/2021/07/19/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0200/"/>
    <id>https://xwjahahahaha.github.io/2021/07/19/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0200/</id>
    <published>2021-07-19T01:10:48.000Z</published>
    <updated>2021-07-20T01:08:34.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input disabled="" type="checkbox"> 零知识证明</li><li><input checked="" disabled="" type="checkbox"> BlockFLA论文</li><li><input disabled="" type="checkbox"> tendermint项目解读2</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LibP2P包的学习</title>
    <link href="https://xwjahahahaha.github.io/2021/07/17/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E5%8C%85%E5%AD%A6%E4%B9%A0/libp2p%E5%8C%85%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://xwjahahahaha.github.io/2021/07/17/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E5%8C%85%E5%AD%A6%E4%B9%A0/libp2p%E5%8C%85%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-17T10:32:16.000Z</published>
    <updated>2021-07-19T13:30:50.466Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习资料来源：</p><p><a href="https://zhuanlan.zhihu.com/p/49062384" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49062384</a></p><p><a href="https://colobu.com/2018/03/26/distributed-hash-table/" target="_blank" rel="noopener">https://colobu.com/2018/03/26/distributed-hash-table/</a></p><p>libp2p官方文档</p></blockquote><p>本篇文章涵盖内容：</p><ul><li>分布式Hash表、Kademlia算法</li><li>Libp2p的基本、核心概念</li><li>Libp2p的一个简单使用流程（手动编写ping协议实现）</li><li>基本的主机配置</li></ul><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>万事万物都要从其概念学起…</p><h2 id="1-1-前置概念"><a href="#1-1-前置概念" class="headerlink" title="1.1 前置概念"></a>1.1 前置概念</h2><h3 id="分布式Hash表"><a href="#分布式Hash表" class="headerlink" title="分布式Hash表"></a>分布式Hash表</h3><hr><p><em>查表式与计算式</em></p><p>关于分布式多节点情景下数据如何布局，主要有两种思路：<strong>查表式和计算式</strong>。</p><p>所谓查表式，即通过维护<strong>全局统一的映射表</strong>，需要访问数据时，先查询该表定位数据所在节点。<br>计算式无需维护该映射表，需要访问数据时，通过<strong>一定规则</strong>计算出数据所在位置。</p><p>查表式和计算式各有优劣：</p><p>查表式需要一个中心服务器维护全局的映射表信息，这可能成为系统的瓶颈；<br>而计算式的主要问题在于存储节点的变更可能带来大量的数据迁移，增加系统复杂度。</p><p><font color='#e54d42'>分布式Hash就是一种典型的<strong>计算式</strong>数据布局算法</font></p><hr><p><em>官方概念：</em></p><blockquote><p><strong>分布式哈希表（distributed hash table，缩写DHT）</strong>是分布式计算系统中的一类，用来将一个键（key）的集合分散到所有在分布式系统中的节点。这里的节点类似哈希表中的存储位置。分布式哈希表通常是为了拥有大量节点的系统，而且系统的节点常常会加入或离开。</p><p>其主要的动机是为了开发<strong>点对点</strong>系统。</p></blockquote><hr><p><em>算法过程：</em></p><p>DHT算法大致可以描述为以下两个子算法：</p><ul><li>建立节点的位置算法</li><li>确定查询节点位置算法</li><li>确定存储对象的位置算法 =&gt; 提供服务</li></ul><p>下面以Dynamo使用的结构举例：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/ZTQGjf.png" alt="ZTQGjf"></p><blockquote><p><strong>注意：这里的Ring结构只是举个例子，并不是所有的DHT都使用此结构</strong></p></blockquote><p>所有的分布式节点都遵循这样的一套规则进行数据的存储与查询，整体向外提供高容灾性的服务。</p><hr><p><em>特性：</em></p><p>分布式Hash表本质上强调以下特性：</p><ul><li><strong>离散性</strong>：构成系统的节点并没有任何中央式的协调机制</li><li><strong>伸缩性</strong>：即使有成千上万个节点，系统仍然应该十分有效率</li><li><strong>容错性</strong>：即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度</li></ul><p>对于分布式Hash表有一个基本的了解即可，这里不再继续展开。。。</p><hr><h3 id="Kademlia算法"><a href="#Kademlia算法" class="headerlink" title="Kademlia算法"></a>Kademlia算法</h3><p><em>维基官方定义如下：</em></p><blockquote><p><font color='#e54d42'><strong>Kademlia</strong>（简称kad）是一种通过 DHT 的协议算法</font>，它是由Petar和David在2002年为P2P网络而设计的。Kademlia规定了网络的结构，也规定了通过节点查询进行信息交换的方式。<br>Kademlia网络节点之间使用<strong>UDP</strong>进行通讯。参与通讯的所有节点形成一张虚拟网（或者叫做覆盖网）。这些节点通过一组数字（或称为节点ID）来进行身份标识。节点ID不仅可以用来做身份标识，还可以用来进行值定位（值通常是文件的散列或者关键词）。</p><p>当我们在网络中搜索某些值（即通常搜索存储文件散列或关键词的节点）的时候，Kademlia算法需要知道与这些值相关的键，然后逐步在网络中开始搜索。每一步都会找到一些节点，这些节点的ID与键更为接近，如果有节点直接返回搜索的值或者再也无法找到与键更为接近的节点ID的时候搜索便会停止。</p></blockquote><hr><p><em>节点距离计算规则：</em></p><p>距离是指节点之间的<strong>跳数</strong></p><p>精妙的与<strong>异或算法</strong>结合：</p><ul><li><code>(A ⊕ B) == (B ⊕ A)</code>: XOR 符合“交换律”，具备对称性。A和B的距离从哪一个节点计算都是相同的。</li><li><code>(A ⊕ A) == 0</code>: 反身性，自己和自己的距离为零。</li><li><code>(A ⊕ B) &gt; 0</code>: 两个不同的 key 之间的距离必大于零。</li><li><code>(A ⊕ B) + (B ⊕ C) &gt;= (A ⊕ C)</code>: 三角不等式, A经过B到C的距离总是大于A直接到C的距离。</li></ul><hr><p><em>映射规则 / 节点位置计算方法：</em></p><p>Kad使用160位的Hash算法，完整的Key有160二进制位，所以最多可以容纳$2^{160}$个节点</p><p>Kad将所有的Key都映射到一个二叉树，每一个<strong>Key都是二叉树的叶子</strong></p><blockquote><p><font color='#e54d42'><strong>一个Key对应于一个节点</strong>，当然也可能会有虚拟节点</font></p><p><font color='#e54d42'><strong>注意:</strong>上方距离DHT的时候使用的是Ring结构，这里Kad算法使用的二叉树而不是Ring</font></p></blockquote><p>将Key看作160位的二进制，二叉树的第n层就对应了第n位，可以按照左0右1的规则如下分割下去：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/k2P4PD.png" alt="k2P4PD"></p><p>分割完之后<strong>叶子节点到根节点的路径</strong>就对应于一个完整的Key，代表着该系统分布式的一个节点</p><hr><p><em>拆子树与K桶：</em></p><ul><li><p>拆子树</p><ul><li><p>每个节点按照<strong>自己的角度</strong>去拆分子树，从根节点开始看，如果其右子树不包含自己那么就将其左子树拆分出来，依此类推往下拆分直到只有自己</p></li><li><p>因为Kad的Key一共是160位，其二叉树就是160层，那么对于一个节点来说最多拆分出来的子树有160个（每层拆一个）（当然实际情况节点数远小于$2^{160}$个，节点拆分子树的个数也不会是160个）</p></li><li><p>对于一个节点的n个拆分子树，如果都知道里面的一个节点，那么就可以利用这n个节点进行<strong>递归路由</strong>从而找到整个二叉树的所有节点(也即到达每一个节点)</p></li></ul></li><li><p>K桶<code>（K-bucket）</code></p><ul><li>仅知道子树中的一个节点不够健壮(考虑到意外宕机等), 多个才安全</li><li>K就是指知道K个节点来保证健壮性(考虑实际情况K只是一个<strong>上限</strong>)，其K为一个系统级别的常量</li><li>K桶的概念其实就是<strong>路由表</strong>，节点需要知道n个子树就需要维护n个路由表/K桶，每个路由表/桶的上限大小是K</li><li>选择K个节点：选择<strong>长时间在线</strong>的节点，如果当前K桶满了就将新的节点放入<strong>缓存</strong>，待有节点断连就将新节点更换之</li></ul></li></ul><hr><p><em>Kad协议消息类型：</em></p><p>共四种：</p><ul><li><strong>PING</strong>消息: 用来测试节点<u>是否仍然在线</u>。</li><li><strong>STORE</strong>消息: 在某个节点中<u>存储</u>一个键值对。</li><li><strong>FIND_NODE</strong>消息: 消息请求的接收者将返回自己桶中<u>离请求键值最<strong>近</strong></u>的K个节点。</li><li><strong>FIND_VALUE</strong>消息: 与FIND_NODE一样，不过当请求的接收者存有请求者所请求的键的时候，它将返回相应键的值。</li></ul><p>每一个RPC消息中都包含一个发起者加入的<strong>随机值</strong>，这一点确保响应消息在收到的时候能够与前面发送的请求消息<strong>匹配</strong></p><hr><p><em>定位最近节点:</em></p><p>查询可以异步也可同步</p><ol><li>查询发起者节点从自己的K桶中筛选出离目标Id最近的一些节点，并发起异步查询请求</li><li>被查询节点收到请求后，从自己的K桶中找出自己知道的与查询ID最近的若干个节点返回给发起者</li><li>发起者收到后更新自己的结果列表，再次筛选出离目标最近的若干未请求过的节点重复步骤一</li><li>直到找不到最近的未请求过的节点为止</li><li>查询过程中未响应的节点会被立即排除；查询者需要最终获得的K个节点都是活动的</li></ol><hr><p><em>定位资源：</em></p><p>定位资源时，如果一个节点存有相应的资源的值的时候，它就返回该资源，搜索便结束了，除了该点以外，<strong>定位资源与定位离键最近的节点的过程相似。</strong></p><p>考虑到节点未必都在线的情况，<strong>资源的值被存在多个节点上（节点中的K个）</strong>，并且，为了提供冗余，还有可能在更多的节点上储存值。储存值的节点将定期搜索网络中与储存值所对应的键接近的K个节点并且把值复制到这些节点上，这些节点可作为那些下线的节点的补充。另外还有缓存技术。</p><hr><p><em>加入网络：</em></p><ol><li>新节点A必须知道某个引导节点B，并把它加入到自己相应的K-桶中</li><li>生成一个随机的节点ID,直到离开网络，该节点会一直使用该ID号</li><li>向B（A目前知道的唯一节点）发起一个查询请求（FIND_NODE），请求的ID是自己（就是查询自己）</li><li>B收到该请求之后，会先把A的ID加入自己的相应的 K-桶中。并且根据 FIND_NODE 请求的约定，B会找到K个最接近 A 的节点，并返回给 A</li><li>A收到这K个节点的ID之后，把他们加入自己的 K-桶</li><li>然后A会继续向刚刚拿到的这批节点(还未发送过请求的节点)发送查询请求（协议类型 FIND_NODE），如此往复，直至A建立了足够详细的路由表。</li><li>这种<font color='#e54d42'>“<strong>自我定位</strong>”</font>将使得Kad的其他节点（收到请求的节点）能够使用A的ID填充他们的K-桶，同时也能够使用那些查询过程的中间节点来填充A的K-桶。这已过程既让A获得了详细的路由表，也让其它节点知道了A节点的加入</li></ol><h2 id="1-2-LibP2P基本概念"><a href="#1-2-LibP2P基本概念" class="headerlink" title="1.2 LibP2P基本概念"></a>1.2 LibP2P基本概念</h2><p>Libp2p是Protocol Labs旗下的五个明星项目之一，五个项目彼此独立而又相互联系，旨在建立一个更安全、高效、开放的网络。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/QBObqG.png" alt="QBObqG"></p><p>Libp2p是一个<strong><font color='#e54d42'>模块化</font>的网络栈</strong>，通过将各种传输协议和P2P协议结合在一起，开发人员能够构建大型、健壮的P2P网络。</p><a id="more"></a><p><strong>Libp2p是IPFS的网络层,主要负责发现节点、连接节点、发现数据、传输数据</strong></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/H2RaTm.png" alt="H2RaTm"></p><blockquote><p>Libp2p官方网站: <a href="https://libp2p.io" target="_blank" rel="noopener">https://libp2p.io</a></p><p>github(go版本): <a href="https://github.com/libp2p/go-libp2p" target="_blank" rel="noopener">https://github.com/libp2p/go-libp2p</a></p></blockquote><p><font color='#e54d42'><strong>LibP2P实现了基于Kademlia-base的分布式Hash表</strong></font></p><h1 id="二、LibP2P核心概念"><a href="#二、LibP2P核心概念" class="headerlink" title="二、LibP2P核心概念"></a>二、LibP2P核心概念</h1><p>此章介绍LibP2P中的一些核心概念，此部分大多来自官网翻译，知道大意即可</p><h2 id="2-1-Transport-传输"><a href="#2-1-Transport-传输" class="headerlink" title="2.1 Transport 传输"></a>2.1 Transport 传输</h2><p>网络中不同电脑之间的数据传播很可能使用的就是TCP/IP协议, 当然要求快速但不可靠的服务可能会用到UDP</p><p>虽然TCP和UDP(连同IP)是目前最常用的协议，但它们绝不是唯一的选择。</p><p>备选方案存在于较低的级别(例如发送原始以太网数据包或蓝牙帧)和较高的级别(例如QUIC，它是在UDP之上分层的)。</p><p>在libp2p中，我们将这些围绕传输移动比特的基本协议称为基础协议，libp2p的核心需求之一是<strong>与传输无关</strong>。这意味着<strong>使用什么传输协议取决于开发人员</strong>，事实上<strong>一个应用程序可以同时支持许多不同的传输</strong>。</p><p>传输具有两个核心的操作实现：<strong>监听</strong>和<strong>拨号</strong></p><p>libp2p 实现中的<strong>每个传输都将共享相同的编程接口。</strong></p><p>监听和拨号都需要知道如何联系他们，libp2p 使用一种称为“<code>multiaddr</code>多地址”的约定或对许多不同的寻址方案进行编码。</p><p>例子：<code>/ip4/7.7.7.7/tcp/6543</code> 其表示<code>7.7.7.7</code>属于IPv4协议, 6543属于tcp</p><p>包含<code>PeerId</code>的例子：<code>/ip4/1.2.3.4/tcp/4321/p2p/QmcEPrat8ShnCph8WjkREzt5CPXF2RwhYxYBALDcLC1iV6</code></p><p>其添加了公钥的Hash唯一标识远程对等方</p><p><font color='#39b54a'>当<strong>对等路由</strong>启动后，只需要使用PeerId即可拨打给对等方，而无需事先知道他们的传输地址</font></p><h2 id="2-2-NAT穿透"><a href="#2-2-NAT穿透" class="headerlink" title="2.2 NAT穿透"></a>2.2 NAT穿透</h2><p>NAT(网络地址转换)简单来说就是一个局域网内的主机共享一个对外的公网IP，当需要数据传出时将公共IP替换成内部IP，当数据从另一端返回时，路由器将转换回内部IP</p><p>NAT的转出一般是透明的，转入则需要一些配置，指定到一些特定的端口中, 通常是通过将一个或多个 TCP 或 UDP 端口从公共 IP 映射到内部端口。</p><p><strong>自动路由器配置</strong>：许多路由器支持端口转发的自动配置协议，最常见的是 <a href="https://en.wikipedia.org/wiki/Universal_Plug_and_Play" target="_blank" rel="noopener">UPnP</a> 或者 <a href="https://en.wikipedia.org/wiki/NAT_Port_Mapping_Protocol" target="_blank" rel="noopener">nat-pmp。</a>如果你的路由器支持这些协议之一，那么libp2p将会自动配置端口映射，无需其他操作。</p><p>当使用 IP 支持的传输时，libp2p 将尝试通过<strong>使用相同的端口进行拨号和侦听</strong>，使用名为的套接字选项 <a href="https://lwn.net/Articles/542629/" target="_blank" rel="noopener"><code>SO_REUSEPORT</code></a>.</p><p>libp2p 的核心协议之一是<a href="https://github.com/libp2p/specs/pull/97" target="_blank" rel="noopener">identify protocol (识别协议)</a>，这允许一个对等点向另一个点询问一些识别信息。当发送他们的<a href="https://docs.libp2p.io/concepts/peer-id/" target="_blank" rel="noopener">公钥</a> 和一些其他有用的信息，被识别的对等方包括它为提出问题的对等方观察到的地址集。</p><p>虽然 <a href="https://github.com/libp2p/specs/pull/97" target="_blank" rel="noopener">识别协议</a> 上面描述的让对等点相互通知他们观察到的网络地址，并非所有网络都允许在用于拨出的同一端口上进行传入连接。</p><p>其他对等点可以帮助我们观察我们的情况，这一次是通过尝试通过我们观察到的地址拨打我们的电话。如果这成功了，我们就可以<strong>依靠其他节点也可以拨打我们的电话</strong>，然后我们就可以开始宣传我们的收听地址了。</p><p>一个名为 AutoNAT 的 libp2p 协议允许对等方从提供 AutoNAT 服务的对等方请求回拨。</p><p>在某些情况下，对等方将无法以可公开访问的方式遍历其 NAT。</p><p>libp2p 提供了一个 <a href="https://docs.libp2p.io/concepts/circuit-relay/" target="_blank" rel="noopener">电路中继协议</a> 这允许<strong>对等点通过有用的中间对等点进行间接通信。</strong></p><h2 id="2-3-电路继电器-中继节点"><a href="#2-3-电路继电器-中继节点" class="headerlink" title="2.3 电路继电器(中继节点)"></a>2.3 电路继电器(中继节点)</h2><p>电路继电器是一种 <a href="https://docs.libp2p.io/concepts/transport/" target="_blank" rel="noopener">传输协议</a> 通过第三方“中继”对等体在两个对等体之间路由流量。</p><p>中继连接是<strong>端到端加密</strong>的，这意味着充当中继的对等方无法读取或篡改流经连接的任何流量。</p><p>中继协议的一个重要方面是它不是“透明的”。换句话说，源和目的地都知道正在中继流量。这很有用，因为目的地可以看到用于打开连接的中继地址，并且可以潜在地使用它来构造返回源的路径。它也不是匿名的——所有参与者都使用他们的对等 ID 进行识别，包括中继节点。</p><p>假设我有一个 peer 的 peer id <code>QmAlice</code>。我想把我的地址给我的朋友<code>QmBob</code>，但我(Alice)在一个不允许任何人直接给我拨号的 NAT 后面。</p><p><code>p2p-circuit</code>我可以构造的最基本的地址如下所示：</p><p><code>/p2p-circuit/p2p/QmAlice</code></p><p>上面的地址很有趣，因为<strong>它不包含任何 <a href="https://docs.libp2p.io/concepts/transport/" target="_blank" rel="noopener">运输</a>我们要联系的对等点 ( <code>QmAlice</code>) 或将传送流量的中继对等点的地址</strong>。如果没有这些信息，对等方拨打我的唯一机会就是<strong>发现中继并希望他们与我建立联系</strong>。</p><p>更好的地址应该是<code>/p2p/QmRelay/p2p-circuit/p2p/QmAlice</code>. 这包括<strong>特定中继对等体</strong>的身份<code>QmRelay</code>。如果对等方已经知道如何打开与 连接<code>QmRelay</code>，他们将能够联系到我们。</p><blockquote><p><font color='#39b54a'>指定特定的中继</font></p></blockquote><p><strong>更好的是在地址中包含中继对等方的传输地址</strong>。假设我已经使用 peer id 建立了到特定中继的连接<code>QmRelay</code>。他们通过识别协议告诉我，他们正在侦听<code>7.7.7.7</code>IPv4 地址<code>55555</code>端口上的TCP 连接。我可以构建一个地址，描述通过该传输的特定中继到达我的路径：</p><p><code>/ip4/7.7.7.7/tcp/55555/p2p/QmRelay/p2p-circuit/p2p/QmAlice</code></p><p>在<code>/p2p-circuit/</code><strong>之前的所有内容都是中继对等体的地址</strong>，其中包括传输地址和它们的peer id <code>QmRelay</code>。在<code>/p2p-circuit/</code>之后的是我在线路另一端的peer的peer ID，即<code>QmAlice</code>.</p><p>通过将完整的中继路径提供给我的朋友<code>QmBob</code>，他们能够快速建立中继连接，而无需“四处询问”具有到<code>QmAlice</code>.</p><p>Autorelay 是一项功能（目前在 go-libp2p 中实现），peer 可以启用它以尝试使用 libp2p 发现中继 peer <a href="https://docs.libp2p.io/concepts/content-routing/" target="_blank" rel="noopener">内容路由</a> 界面。</p><p>启用自动中继后，对等方将尝试发现一个或多个公共中继并打开中继连接。如果成功，对等方将使用 libp2p 的<a href="https://docs.libp2p.io/concepts/peer-routing/" target="_blank" rel="noopener">对等路由</a> 系统。</p><blockquote><p><font color='#39b54a'>中继节点其实简单来说就是<strong>代理</strong>的作用</font></p></blockquote><h2 id="2-4-协议"><a href="#2-4-协议" class="headerlink" title="2.4 协议"></a>2.4 协议</h2><p>当您编写网络应用程序时，到处都有协议，而 libp2p 中的协议尤其丰富。</p><p>本文所关注的协议类型是使用 libp2p 本身构建的协议，使用核心 libp2p 抽象，如 <a href="https://docs.libp2p.io/concepts/transport" target="_blank" rel="noopener">运输</a>, <a href="https://docs.libp2p.io/concepts/peer-id/" target="_blank" rel="noopener">对等身份</a>, <a href="https://docs.libp2p.io/concepts/addressing/" target="_blank" rel="noopener">寻址</a>， 等等。</p><p>在本文中，我们将这种使用 libp2p<strong>构建的协议</strong>称为<strong>libp2p 协议</strong>，但您也可能将它们称为“线路协议”或“应用程序协议”。</p><p>libp2p 协议具有以下关键特性：</p><h3 id="协议ID"><a href="#协议ID" class="headerlink" title="协议ID"></a>协议ID</h3><p>按照惯例，协议 ID 具有类似路径的结构，版本号作为最终组成部分：</p><p><code>/my-app/amazing-protocol/1.0.1</code></p><h3 id="核心libp2p协议"><a href="#核心libp2p协议" class="headerlink" title="核心libp2p协议"></a>核心libp2p协议</h3><p>除了您在开发 libp2p 应用程序时编写的协议之外，libp2p 本身还定义了几个用于核心功能的基础协议。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/mYLLgf.png" alt="mYLLgf"></p><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec</th><th align="left"></th><th align="left"></th><th align="left">implementations</th></tr></thead><tbody><tr><td align="left"><code>/ipfs/ping/1.0.0</code></td><td align="left">N/A</td><td align="left"><a href="https://github.com/libp2p/go-libp2p/tree/master/p2p/protocol/ping" target="_blank" rel="noopener">go</a></td><td align="left"><a href="https://github.com/libp2p/js-libp2p-ping" target="_blank" rel="noopener">js</a></td><td align="left"><a href="https://github.com/libp2p/rust-libp2p/blob/master/protocols/ping/src/lib.rs" target="_blank" rel="noopener">rust</a></td></tr></tbody></table><p>ping 协议是一个简单的活动检查，点可以用来快速查看另一个点是否在线。</p><h4 id="Identify"><a href="#Identify" class="headerlink" title="Identify"></a>Identify</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec</th><th align="left"></th><th align="left"></th><th align="left">implementations</th></tr></thead><tbody><tr><td align="left"><code>/ipfs/id/1.0.0</code></td><td align="left"><a href="https://github.com/libp2p/specs/pull/97/files" target="_blank" rel="noopener">identify spec</a></td><td align="left"><a href="https://github.com/libp2p/go-libp2p/tree/master/p2p/protocol/identify" target="_blank" rel="noopener">go</a></td><td align="left"><a href="https://github.com/libp2p/js-libp2p-identify" target="_blank" rel="noopener">js</a></td><td align="left"><a href="https://github.com/libp2p/rust-libp2p/tree/master/protocols/identify/src" target="_blank" rel="noopener">rust</a></td></tr></tbody></table><p>该<code>identify</code>协议允许对等方交换有关彼此的信息，尤其是他们的<strong>公钥和已知网络地址</strong>。</p><h4 id="identify-push"><a href="#identify-push" class="headerlink" title="identify/push"></a>identify/push</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec &amp; implementations</th></tr></thead><tbody><tr><td align="left"><code>/ipfs/id/push/1.0.0</code></td><td align="left">same as <a href="https://docs.libp2p.io/concepts/protocols/#identify" target="_blank" rel="noopener">identify above</a></td></tr></tbody></table><p>与<code>identify</code>稍有变化，<code>identify/push</code>协议发送相同的<code>Identify</code>消息，但它是主动发送的，而不是响应请求。</p><h4 id="secio"><a href="#secio" class="headerlink" title="secio"></a>secio</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec</th><th align="left"></th><th align="left"></th><th align="left">implementations</th></tr></thead><tbody><tr><td align="left"><code>/secio/1.0.0</code></td><td align="left"><a href="https://github.com/libp2p/specs/pull/106" target="_blank" rel="noopener">secio spec</a></td><td align="left"><a href="https://github.com/libp2p/go-libp2p-secio" target="_blank" rel="noopener">go</a></td><td align="left"><a href="https://github.com/libp2p/js-libp2p-secio" target="_blank" rel="noopener">js</a></td><td align="left"><a href="https://github.com/libp2p/rust-libp2p/tree/master/protocols/secio" target="_blank" rel="noopener">rust</a></td></tr></tbody></table><p><code>secio</code>（安全输入/输出的缩写）是一种类似于 TLS 1.2 的加密通信协议，但没有证书颁发机构的要求。因为每个 libp2p peer 都有一个PeerID这是从他们的公钥派生的，通过<strong>使用他们的公钥来验证签名的消息</strong>，<strong>可以在不需要证书颁发机构的情况下验证对等方的身份。</strong></p><blockquote><p>虽然 secio 是目前 libp2p 使用的默认加密协议，但将 TLS 1.3 集成到 libp2p 的工作正在进行中，预计一旦完成，它将成为默认加密协议。</p></blockquote><h4 id="kad-dht"><a href="#kad-dht" class="headerlink" title="kad-dht"></a>kad-dht</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec</th><th align="left"></th><th align="left"></th><th align="left">implementations</th></tr></thead><tbody><tr><td align="left"><code>/ipfs/kad/1.0.0</code></td><td align="left"><a href="https://github.com/libp2p/specs/pull/108" target="_blank" rel="noopener">kad-dht spec</a></td><td align="left"><a href="https://github.com/libp2p/go-libp2p-kad-dht" target="_blank" rel="noopener">go</a></td><td align="left"><a href="https://github.com/libp2p/js-libp2p-kad-dht" target="_blank" rel="noopener">js</a></td><td align="left"><a href="https://github.com/libp2p/rust-libp2p/tree/master/protocols/kad" target="_blank" rel="noopener">rust</a></td></tr></tbody></table><p><code>kad-dht</code> 是一个 <a href="https://en.wikipedia.org/wiki/Distributed_hash_table" target="_blank" rel="noopener">分布式哈希表DHT</a> 基于 <a href="https://en.wikipedia.org/wiki/Kademlia" target="_blank" rel="noopener">Kademlia</a> 路由算法，<strong>有一些修改</strong>。</p><p>libp2p 使用 DHT 作为其基础 <a href="https://docs.libp2p.io/concepts/peer-routing/" target="_blank" rel="noopener">对等路由</a> 和 <a href="https://docs.libp2p.io/concepts/content-routing/" target="_blank" rel="noopener">内容路由</a> 功能。</p><h4 id="Circuit-Relay"><a href="#Circuit-Relay" class="headerlink" title="Circuit Relay"></a>Circuit Relay</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec</th><th align="left"></th><th align="left">implementations</th></tr></thead><tbody><tr><td align="left"><code>/libp2p/circuit/relay/0.1.0</code></td><td align="left"><a href="https://github.com/libp2p/specs/tree/master/relay" target="_blank" rel="noopener">circuit relay spec</a></td><td align="left"><a href="https://github.com/libp2p/go-libp2p-circuit" target="_blank" rel="noopener">go</a></td><td align="left"><a href="https://github.com/libp2p/js-libp2p-circuit" target="_blank" rel="noopener">js</a></td></tr></tbody></table><p>如中所述 <a href="https://docs.libp2p.io/concepts/circuit-relay/" target="_blank" rel="noopener">电路继电器篇</a>，libp2p 提供了一个协议，<strong>当两个对等点无法直接相互连接时，通过中继对等点传输流量。</strong></p><h2 id="2-5-PeerID"><a href="#2-5-PeerID" class="headerlink" title="2.5 PeerID"></a>2.5 PeerID</h2><p>对等身份（通常写作<code>PeerId</code>）是对整个对等网络中特定对等的唯一引用。</p><p>除了充当每个对等点的唯一标识符外，PeerId 还是<strong>对等点与其公共加密密钥之间的可验证链接</strong>。</p><p>每个 libp2p peer 控制一个私钥，它对所有其他 peer 保密。每个私钥都有一个对应的公钥，与其他对等方共享。</p><p>公钥和私钥（或“密钥对”）一起允许对等方建立 <a href="https://docs.libp2p.io/concepts/secure-comms/" target="_blank" rel="noopener">安全通讯</a> 通道相互。</p><p>从概念上讲，PeerId 是一个 <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener">加密散列</a>对等方的公钥。当对等方建立安全通道时，散列可用于验证用于保护通道的公钥是否与用于识别对等方的公钥相同。</p><p>PeerIds 使用 <a href="https://docs.libp2p.io/reference/glossary/#multihash" target="_blank" rel="noopener">多重散列</a> 格式，<strong>它向散列本身添加一个小标头，用于标识用于生成它的散列算法</strong>。</p><p>PeerId被编码成Base-58然后表示为字符串（这与比特币类似）:    <code>QmYyQSo1c1Ym7orWxLYvCrM2EmxFTANf8wXmmE7DWjhx5N</code></p><blockquote><p><font color='#e54d42'>PeerID生成的过程：创建私钥 =&gt; 导出公钥 =&gt; hash函数 =&gt; Base58编码</font></p></blockquote><h2 id="2-6-内容路由"><a href="#2-6-内容路由" class="headerlink" title="2.6 内容路由"></a>2.6 内容路由</h2><p>针对查找的<strong>内容</strong>进行路由</p><h2 id="2-7-节点路由"><a href="#2-7-节点路由" class="headerlink" title="2.7 节点路由"></a>2.7 节点路由</h2><p>针对<strong>节点</strong>发现进行路由</p><h2 id="2-8-发布与订阅"><a href="#2-8-发布与订阅" class="headerlink" title="2.8 发布与订阅"></a>2.8 发布与订阅</h2><p>节点可以发布topic，在网络中不断传递，当有一些人订阅之后就会收到消息 （类似mqtt）</p><h2 id="2-9-数据流的多路复用"><a href="#2-9-数据流的多路复用" class="headerlink" title="2.9 数据流的多路复用"></a>2.9 数据流的多路复用</h2><p>A节点与B节点之间建立流通道，不断的传输数据流，但是A、B之间的应用可能是多个，那么在此数据流通道Libp2p就实现了数据流的多路复用</p><p>使用<strong>协议号</strong>来标识不同应用的流</p><h1 id="三、快速开始-Go"><a href="#三、快速开始-Go" class="headerlink" title="三、快速开始(Go)"></a>三、快速开始(Go)</h1><h2 id="2-1-前置要求"><a href="#2-1-前置要求" class="headerlink" title="2.1 前置要求"></a>2.1 前置要求</h2><ul><li><p>go语言最低要求：&gt;= 1.11</p></li><li><p>使用Go module模式编写代码</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建空文件夹，名字自定</span></span><br><span class="line">mkdir libp2p &amp;&amp; cd libp2p</span><br><span class="line">go mod init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载包环境</span></span><br><span class="line">go get -u github.com/libp2p/go-libp2p</span><br></pre></td></tr></table></figure><h2 id="2-2-开启libp2p节点"><a href="#2-2-开启libp2p节点" class="headerlink" title="2.2 开启libp2p节点"></a>2.2 开启libp2p节点</h2><p>编写main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个背景上下文环境</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一个默认配置的libp2p节点</span></span><br><span class="line">node, err := libp2p.New(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出节点监听地址</span></span><br><span class="line">fmt.Println(<span class="string">"Listen Address: "</span>, node.Addrs())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止节点</span></span><br><span class="line"><span class="keyword">if</span> err := node.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">go run main.go                       </span><br><span class="line">Listen Address:  [/ip4/192.168.3.30/tcp/58048 /ip4/127.0.0.1/tcp/58048 /ip6/::1/tcp/58049]</span><br></pre></td></tr></table></figure><h2 id="2-3-配置节点"><a href="#2-3-配置节点" class="headerlink" title="2.3 配置节点"></a>2.3 配置节点</h2><p>新建节点时，添加配置，例如：第二个参数设置监听</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node, err := libp2p.New(ctx, libp2p.ListenAddrStrings(<span class="string">"/ip4/127.0.0.1/tcp/2000"</span>))</span><br></pre></td></tr></table></figure><p>重新运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">Listen Address:  [/ip4/127.0.0.1/tcp/2000]</span><br></pre></td></tr></table></figure><h2 id="2-4-等待信号"><a href="#2-4-等待信号" class="headerlink" title="2.4 等待信号"></a>2.4 等待信号</h2><p>给节点设置等待OS的信号再停止</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待SIGINT或SIGTERM信号</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 当收到ctrl + c时将信号写入通道</span></span><br><span class="line">signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">&lt;- ch<span class="comment">// 等待阻塞</span></span><br><span class="line">fmt.Println(<span class="string">"Received signal, shutting down..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止节点</span></span><br><span class="line"><span class="keyword">if</span> err := node.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">Listen Address:  [/ip4/127.0.0.1/tcp/2000]</span><br><span class="line">^CReceived signal, shutting down...</span><br></pre></td></tr></table></figure><h2 id="2-5-运行ping协议"><a href="#2-5-运行ping协议" class="headerlink" title="2.5 运行ping协议"></a>2.5 运行ping协议</h2><p>下面开始通信, 以go-libp2p启动的节点将默认运行自己的ping协议，但让我们禁用它并手动设置它，通过<strong>注册流处理程序</strong>来演示运行协议的过程。</p><blockquote><p><font color='#39b54a'><strong>将原本的ping协议取消，下面手动演示手动编写一个ping协议</strong></font></p></blockquote><h3 id="2-5-1-设置Steam-handler"><a href="#2-5-1-设置Steam-handler" class="headerlink" title="2.5.1 设置Steam handler"></a>2.5.1 设置Steam handler</h3><p>从<code>libp2p.New</code>返回的对象实现了Host接口，我们将使用<code>SetStreamHandler</code>方法为我们的ping协议设置一个处理程序。</p><p>配置禁止自带的Ping协议，并设置tcp监听的端口为随机（为了在单机上模拟开启多个节点时端口不冲突）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启一个默认配置的libp2p节点</span></span><br><span class="line">node, err := libp2p.New(ctx,</span><br><span class="line">libp2p.ListenAddrStrings(<span class="string">"/ip4/127.0.0.1/tcp/0"</span>),<span class="comment">// 0表示随机</span></span><br><span class="line">libp2p.Ping(<span class="literal">false</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置我们自己的ping协议</span></span><br><span class="line">pingService := &amp;ping.PingService&#123;Host: node&#125;</span><br><span class="line">node.SetStreamHandler(ping.ID, pingService.PingHandler)</span><br></pre></td></tr></table></figure><h3 id="2-5-2-连接peer节点"><a href="#2-5-2-连接peer节点" class="headerlink" title="2.5.2 连接peer节点"></a>2.5.2 连接peer节点</h3><p>运行Ping协议，首先要连接上其他节点</p><p>首先替换节点打印日志的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 更改节点打印内容</span></span><br><span class="line"><span class="comment">// 构建打印Info</span></span><br><span class="line">peerInfo := peer.AddrInfo&#123;</span><br><span class="line">  ID: node.ID(),</span><br><span class="line">  Addrs: node.Addrs(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增加日志输出</span></span><br><span class="line">addrs, err := peer.AddrInfoToP2pAddrs(&amp;peerInfo)</span><br><span class="line">fmt.Println(<span class="string">"libp2p node address: "</span>, addrs[<span class="number">0</span>])</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">libp2p node address:  /ip4/127.0.0.1/tcp/63726/p2p/Qma3pW4kM46cELahGAQrN23mM4zBbrjyq2GEQnNfLAThze</span><br></pre></td></tr></table></figure><p>然后，设置命令行操作(发送ping和监听)，其中使用<code>github.com/multiformats/go-multiaddr</code>包来解析收到的multiaddr格式地址</p><p>安装依赖包：<code>go get -u github.com/multiformats/go-multiaddr</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p-core/peer"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p/p2p/protocol/ping"</span></span><br><span class="line">multiaddr <span class="string">"github.com/multiformats/go-multiaddr"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/signal"</span></span><br><span class="line"><span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个背景上下文环境</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一个默认配置的libp2p节点</span></span><br><span class="line">node, err := libp2p.New(ctx,</span><br><span class="line">libp2p.ListenAddrStrings(<span class="string">"/ip4/127.0.0.1/tcp/0"</span>),</span><br><span class="line">libp2p.Ping(<span class="literal">false</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置我们自己的ping协议</span></span><br><span class="line">pingService := &amp;ping.PingService&#123;Host: node&#125;</span><br><span class="line">node.SetStreamHandler(ping.ID, pingService.PingHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改节点打印内容</span></span><br><span class="line"><span class="comment">// 构建打印Info</span></span><br><span class="line">peerInfo := peer.AddrInfo&#123;</span><br><span class="line">ID: node.ID(),</span><br><span class="line">Addrs: node.Addrs(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增加日志输出</span></span><br><span class="line">addrs, err := peer.AddrInfoToP2pAddrs(&amp;peerInfo)</span><br><span class="line">fmt.Println(<span class="string">"libp2p node address: "</span>, addrs[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果命令行中包含需要连接的节点就连接，并发送5个ping消息，否则监听OS中断消息</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// 解析参数</span></span><br><span class="line">addr, err := multiaddr.NewMultiaddr(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把multiaddr格式转换为AddrInfo格式</span></span><br><span class="line">peer, err := peer.AddrInfoFromP2pAddr(addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 连接节点</span></span><br><span class="line"><span class="keyword">if</span> err := node.Connect(ctx, *peer); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"sending 5 ping messages to"</span>, addr)</span><br><span class="line"><span class="comment">// 发起Ping服务，将结果写入channel</span></span><br><span class="line">ch := pingService.Ping(ctx, peer.ID)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line">res := &lt;-ch</span><br><span class="line">fmt.Println(<span class="string">"got ping response!"</span>, <span class="string">"RTT:"</span>, res.RTT)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 等待SIGINT或SIGTERM信号</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 当收到ctrl + c时将信号写入通道</span></span><br><span class="line">signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">&lt;- ch<span class="comment">// 等待阻塞</span></span><br><span class="line">fmt.Println(<span class="string">"Received signal, shutting down..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止节点</span></span><br><span class="line"><span class="keyword">if</span> err := node.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-运行"><a href="#2-5-3-运行" class="headerlink" title="2.5.3 运行"></a>2.5.3 运行</h3><p>第一个节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build ./ </span><br><span class="line">./libp2p</span><br><span class="line">libp2p node address:  /ip4/127.0.0.1/tcp/49904/p2p/Qmaeyg7CEBpe7TE6eCGsmomBLHotU6GergoX2kz3cCmbGr</span><br></pre></td></tr></table></figure><p>第二个节点(新开一个命令行窗口):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./libp2p /ip4/127.0.0.1/tcp/49904/p2p/Qmaeyg7CEBpe7TE6eCGsmomBLHotU6GergoX2kz3cCmbGr</span><br><span class="line">sending 5 ping messages to /ip4/127.0.0.1/tcp/49904/p2p/Qmaeyg7CEBpe7TE6eCGsmomBLHotU6GergoX2kz3cCmbGr</span><br><span class="line">got ping response! RTT: 120µs</span><br><span class="line">got ping response! RTT: 120.875µs</span><br><span class="line">got ping response! RTT: 120.167µs</span><br><span class="line">got ping response! RTT: 62.125µs</span><br><span class="line">got ping response! RTT: 135.792µs</span><br></pre></td></tr></table></figure><p>更多的演示案例：<a href="https://github.com/libp2p/go-libp2p/tree/master/examples" target="_blank" rel="noopener">https://github.com/libp2p/go-libp2p/tree/master/examples</a></p><blockquote><p><font color='#39b54a'>这里虽然说是我们手动实现了Ping协议，但是其实应该明白的是服务的创建和处理函数都是调用原来写好的，所以真正完全的实现一个协议还需要学习后续的案例， 后续也会持续的更新。。。</font></p></blockquote><h1 id="四、主机配置"><a href="#四、主机配置" class="headerlink" title="四、主机配置"></a>四、主机配置</h1><p>主机配置即当前节点的一般配置，如果不使用默认的配置则一般会用到以下的配置：</p><p>所有配置见；<a href="https://godoc.org/github.com/libp2p/go-libp2p" target="_blank" rel="noopener">see the different options in the docs</a>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p"</span></span><br><span class="line">connmgr <span class="string">"github.com/libp2p/go-libp2p-connmgr"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p-core/crypto"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p-core/host"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p-core/peer"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p-core/routing"</span></span><br><span class="line">dht <span class="string">"github.com/libp2p/go-libp2p-kad-dht"</span></span><br><span class="line">libp2pquic <span class="string">"github.com/libp2p/go-libp2p-quic-transport"</span></span><br><span class="line">secio <span class="string">"github.com/libp2p/go-libp2p-secio"</span></span><br><span class="line">libp2ptls <span class="string">"github.com/libp2p/go-libp2p-tls"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 上下文管理libp2p节点的生命周期。</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">// 延迟停止node</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个自己配置的节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置自己的公私钥对</span></span><br><span class="line">priv, _, err := crypto.GenerateKeyPair(</span><br><span class="line">crypto.Ed25519,</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> idht *dht.IpfsDHT</span><br><span class="line"></span><br><span class="line">node, err := libp2p.New(ctx,</span><br><span class="line"><span class="comment">// 使用自己生成的私钥</span></span><br><span class="line">libp2p.Identity(priv),</span><br><span class="line"><span class="comment">// 设置Multiple格式监听地址</span></span><br><span class="line">libp2p.ListenAddrStrings(</span><br><span class="line"><span class="string">"/ip4/0.0.0.0/tcp/9000"</span>,<span class="comment">// tcp连接</span></span><br><span class="line"><span class="string">"/ip4/0.0.0.0/udp/9000/quic"</span>,<span class="comment">// 用于QUIC传输的UDP端点</span></span><br><span class="line">),</span><br><span class="line"><span class="comment">// 支持TLS连接</span></span><br><span class="line">libp2p.Security(libp2ptls.ID, libp2ptls.New),</span><br><span class="line"><span class="comment">// 支持secio连接</span></span><br><span class="line">libp2p.Security(secio.ID, secio.New),</span><br><span class="line"><span class="comment">// 支持QUIC（该功能还在实验中）</span></span><br><span class="line">libp2p.Transport(libp2pquic.NewTransport),</span><br><span class="line"><span class="comment">// 支持其他默认传输协议（tcp）</span></span><br><span class="line">libp2p.DefaultTransports,</span><br><span class="line"><span class="comment">// 防止peer节点连接过多的其他对等节点，设置连接管理器</span></span><br><span class="line">libp2p.ConnectionManager(connmgr.NewConnManager(</span><br><span class="line"><span class="number">100</span>, <span class="comment">// 下限</span></span><br><span class="line"><span class="number">400</span>,<span class="comment">// 上限</span></span><br><span class="line">time.Minute,<span class="comment">// 连接新连接之前的设置的宽限期</span></span><br><span class="line">)),</span><br><span class="line"><span class="comment">// 尝试为NAT主机使用uPNP打开端口（自动路由）</span></span><br><span class="line">libp2p.NATPortMap(),</span><br><span class="line"><span class="comment">// 为该节点使用DHT去找到其他节点</span></span><br><span class="line">libp2p.Routing(<span class="function"><span class="keyword">func</span><span class="params">(h host.Host)</span> <span class="params">(routing.PeerRouting, error)</span></span> &#123;</span><br><span class="line">idht, err = dht.New(ctx, h)</span><br><span class="line"><span class="keyword">return</span> idht, err</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 开启中继防止节点处于NAT网络下</span></span><br><span class="line">libp2p.EnableRelay(),</span><br><span class="line"><span class="comment">// 节点可以帮助其他在NAT下的节点中继，开启自己的AutoNAT中继服务端 (这个服务本身带有限制，不会产生很大的开销)</span></span><br><span class="line">libp2p.EnableNATService(),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接网络中的引导节点或者其他节点</span></span><br><span class="line"><span class="comment">// 连接公共引导节点</span></span><br><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> dht.DefaultBootstrapPeers&#123;</span><br><span class="line">fmt.Println(<span class="string">"defaultBootstrapPeer : "</span>, addr)</span><br><span class="line"><span class="comment">// 格式转换为AddrInfo</span></span><br><span class="line">p1, _ := peer.AddrInfoFromP2pAddr(addr)</span><br><span class="line"><span class="comment">// 连接(忽略连接不上的引导节点)</span></span><br><span class="line">node.Connect(ctx, *p1)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"My Host ID is %s\n"</span>, node.ID())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49062384&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/49062384&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://colobu.com/2018/03/26/distributed-hash-table/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://colobu.com/2018/03/26/distributed-hash-table/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;libp2p官方文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章涵盖内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分布式Hash表、Kademlia算法&lt;/li&gt;
&lt;li&gt;Libp2p的基本、核心概念&lt;/li&gt;
&lt;li&gt;Libp2p的一个简单使用流程（手动编写ping协议实现）&lt;/li&gt;
&lt;li&gt;基本的主机配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h1&gt;&lt;p&gt;万事万物都要从其概念学起…&lt;/p&gt;
&lt;h2 id=&quot;1-1-前置概念&quot;&gt;&lt;a href=&quot;#1-1-前置概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 前置概念&quot;&gt;&lt;/a&gt;1.1 前置概念&lt;/h2&gt;&lt;h3 id=&quot;分布式Hash表&quot;&gt;&lt;a href=&quot;#分布式Hash表&quot; class=&quot;headerlink&quot; title=&quot;分布式Hash表&quot;&gt;&lt;/a&gt;分布式Hash表&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;em&gt;查表式与计算式&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;关于分布式多节点情景下数据如何布局，主要有两种思路：&lt;strong&gt;查表式和计算式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所谓查表式，即通过维护&lt;strong&gt;全局统一的映射表&lt;/strong&gt;，需要访问数据时，先查询该表定位数据所在节点。&lt;br&gt;计算式无需维护该映射表，需要访问数据时，通过&lt;strong&gt;一定规则&lt;/strong&gt;计算出数据所在位置。&lt;/p&gt;
&lt;p&gt;查表式和计算式各有优劣：&lt;/p&gt;
&lt;p&gt;查表式需要一个中心服务器维护全局的映射表信息，这可能成为系统的瓶颈；&lt;br&gt;而计算式的主要问题在于存储节点的变更可能带来大量的数据迁移，增加系统复杂度。&lt;/p&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;分布式Hash就是一种典型的&lt;strong&gt;计算式&lt;/strong&gt;数据布局算法&lt;/font&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;官方概念：&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;分布式哈希表（distributed hash table，缩写DHT）&lt;/strong&gt;是分布式计算系统中的一类，用来将一个键（key）的集合分散到所有在分布式系统中的节点。这里的节点类似哈希表中的存储位置。分布式哈希表通常是为了拥有大量节点的系统，而且系统的节点常常会加入或离开。&lt;/p&gt;
&lt;p&gt;其主要的动机是为了开发&lt;strong&gt;点对点&lt;/strong&gt;系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;算法过程：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;DHT算法大致可以描述为以下两个子算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立节点的位置算法&lt;/li&gt;
&lt;li&gt;确定查询节点位置算法&lt;/li&gt;
&lt;li&gt;确定存储对象的位置算法 =&amp;gt; 提供服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面以Dynamo使用的结构举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/ZTQGjf.png&quot; alt=&quot;ZTQGjf&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：这里的Ring结构只是举个例子，并不是所有的DHT都使用此结构&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有的分布式节点都遵循这样的一套规则进行数据的存储与查询，整体向外提供高容灾性的服务。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;特性：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;分布式Hash表本质上强调以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;离散性&lt;/strong&gt;：构成系统的节点并没有任何中央式的协调机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;伸缩性&lt;/strong&gt;：即使有成千上万个节点，系统仍然应该十分有效率&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容错性&lt;/strong&gt;：即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于分布式Hash表有一个基本的了解即可，这里不再继续展开。。。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Kademlia算法&quot;&gt;&lt;a href=&quot;#Kademlia算法&quot; class=&quot;headerlink&quot; title=&quot;Kademlia算法&quot;&gt;&lt;/a&gt;Kademlia算法&lt;/h3&gt;&lt;p&gt;&lt;em&gt;维基官方定义如下：&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;&lt;strong&gt;Kademlia&lt;/strong&gt;（简称kad）是一种通过 DHT 的协议算法&lt;/font&gt;，它是由Petar和David在2002年为P2P网络而设计的。Kademlia规定了网络的结构，也规定了通过节点查询进行信息交换的方式。&lt;br&gt;Kademlia网络节点之间使用&lt;strong&gt;UDP&lt;/strong&gt;进行通讯。参与通讯的所有节点形成一张虚拟网（或者叫做覆盖网）。这些节点通过一组数字（或称为节点ID）来进行身份标识。节点ID不仅可以用来做身份标识，还可以用来进行值定位（值通常是文件的散列或者关键词）。&lt;/p&gt;
&lt;p&gt;当我们在网络中搜索某些值（即通常搜索存储文件散列或关键词的节点）的时候，Kademlia算法需要知道与这些值相关的键，然后逐步在网络中开始搜索。每一步都会找到一些节点，这些节点的ID与键更为接近，如果有节点直接返回搜索的值或者再也无法找到与键更为接近的节点ID的时候搜索便会停止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;节点距离计算规则：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;距离是指节点之间的&lt;strong&gt;跳数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;精妙的与&lt;strong&gt;异或算法&lt;/strong&gt;结合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ B) == (B ⊕ A)&lt;/code&gt;: XOR 符合“交换律”，具备对称性。A和B的距离从哪一个节点计算都是相同的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ A) == 0&lt;/code&gt;: 反身性，自己和自己的距离为零。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ B) &amp;gt; 0&lt;/code&gt;: 两个不同的 key 之间的距离必大于零。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ B) + (B ⊕ C) &amp;gt;= (A ⊕ C)&lt;/code&gt;: 三角不等式, A经过B到C的距离总是大于A直接到C的距离。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;映射规则 / 节点位置计算方法：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Kad使用160位的Hash算法，完整的Key有160二进制位，所以最多可以容纳$2^{160}$个节点&lt;/p&gt;
&lt;p&gt;Kad将所有的Key都映射到一个二叉树，每一个&lt;strong&gt;Key都是二叉树的叶子&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;&lt;strong&gt;一个Key对应于一个节点&lt;/strong&gt;，当然也可能会有虚拟节点&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;&lt;strong&gt;注意:&lt;/strong&gt;上方距离DHT的时候使用的是Ring结构，这里Kad算法使用的二叉树而不是Ring&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将Key看作160位的二进制，二叉树的第n层就对应了第n位，可以按照左0右1的规则如下分割下去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/k2P4PD.png&quot; alt=&quot;k2P4PD&quot;&gt;&lt;/p&gt;
&lt;p&gt;分割完之后&lt;strong&gt;叶子节点到根节点的路径&lt;/strong&gt;就对应于一个完整的Key，代表着该系统分布式的一个节点&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;拆子树与K桶：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;拆子树&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每个节点按照&lt;strong&gt;自己的角度&lt;/strong&gt;去拆分子树，从根节点开始看，如果其右子树不包含自己那么就将其左子树拆分出来，依此类推往下拆分直到只有自己&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为Kad的Key一共是160位，其二叉树就是160层，那么对于一个节点来说最多拆分出来的子树有160个（每层拆一个）（当然实际情况节点数远小于$2^{160}$个，节点拆分子树的个数也不会是160个）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于一个节点的n个拆分子树，如果都知道里面的一个节点，那么就可以利用这n个节点进行&lt;strong&gt;递归路由&lt;/strong&gt;从而找到整个二叉树的所有节点(也即到达每一个节点)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;K桶&lt;code&gt;（K-bucket）&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅知道子树中的一个节点不够健壮(考虑到意外宕机等), 多个才安全&lt;/li&gt;
&lt;li&gt;K就是指知道K个节点来保证健壮性(考虑实际情况K只是一个&lt;strong&gt;上限&lt;/strong&gt;)，其K为一个系统级别的常量&lt;/li&gt;
&lt;li&gt;K桶的概念其实就是&lt;strong&gt;路由表&lt;/strong&gt;，节点需要知道n个子树就需要维护n个路由表/K桶，每个路由表/桶的上限大小是K&lt;/li&gt;
&lt;li&gt;选择K个节点：选择&lt;strong&gt;长时间在线&lt;/strong&gt;的节点，如果当前K桶满了就将新的节点放入&lt;strong&gt;缓存&lt;/strong&gt;，待有节点断连就将新节点更换之&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;Kad协议消息类型：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;共四种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PING&lt;/strong&gt;消息: 用来测试节点&lt;u&gt;是否仍然在线&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STORE&lt;/strong&gt;消息: 在某个节点中&lt;u&gt;存储&lt;/u&gt;一个键值对。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIND_NODE&lt;/strong&gt;消息: 消息请求的接收者将返回自己桶中&lt;u&gt;离请求键值最&lt;strong&gt;近&lt;/strong&gt;&lt;/u&gt;的K个节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIND_VALUE&lt;/strong&gt;消息: 与FIND_NODE一样，不过当请求的接收者存有请求者所请求的键的时候，它将返回相应键的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一个RPC消息中都包含一个发起者加入的&lt;strong&gt;随机值&lt;/strong&gt;，这一点确保响应消息在收到的时候能够与前面发送的请求消息&lt;strong&gt;匹配&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;定位最近节点:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;查询可以异步也可同步&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查询发起者节点从自己的K桶中筛选出离目标Id最近的一些节点，并发起异步查询请求&lt;/li&gt;
&lt;li&gt;被查询节点收到请求后，从自己的K桶中找出自己知道的与查询ID最近的若干个节点返回给发起者&lt;/li&gt;
&lt;li&gt;发起者收到后更新自己的结果列表，再次筛选出离目标最近的若干未请求过的节点重复步骤一&lt;/li&gt;
&lt;li&gt;直到找不到最近的未请求过的节点为止&lt;/li&gt;
&lt;li&gt;查询过程中未响应的节点会被立即排除；查询者需要最终获得的K个节点都是活动的&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;定位资源：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;定位资源时，如果一个节点存有相应的资源的值的时候，它就返回该资源，搜索便结束了，除了该点以外，&lt;strong&gt;定位资源与定位离键最近的节点的过程相似。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑到节点未必都在线的情况，&lt;strong&gt;资源的值被存在多个节点上（节点中的K个）&lt;/strong&gt;，并且，为了提供冗余，还有可能在更多的节点上储存值。储存值的节点将定期搜索网络中与储存值所对应的键接近的K个节点并且把值复制到这些节点上，这些节点可作为那些下线的节点的补充。另外还有缓存技术。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;加入网络：&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新节点A必须知道某个引导节点B，并把它加入到自己相应的K-桶中&lt;/li&gt;
&lt;li&gt;生成一个随机的节点ID,直到离开网络，该节点会一直使用该ID号&lt;/li&gt;
&lt;li&gt;向B（A目前知道的唯一节点）发起一个查询请求（FIND_NODE），请求的ID是自己（就是查询自己）&lt;/li&gt;
&lt;li&gt;B收到该请求之后，会先把A的ID加入自己的相应的 K-桶中。并且根据 FIND_NODE 请求的约定，B会找到K个最接近 A 的节点，并返回给 A&lt;/li&gt;
&lt;li&gt;A收到这K个节点的ID之后，把他们加入自己的 K-桶&lt;/li&gt;
&lt;li&gt;然后A会继续向刚刚拿到的这批节点(还未发送过请求的节点)发送查询请求（协议类型 FIND_NODE），如此往复，直至A建立了足够详细的路由表。&lt;/li&gt;
&lt;li&gt;这种&lt;font color=&#39;#e54d42&#39;&gt;“&lt;strong&gt;自我定位&lt;/strong&gt;”&lt;/font&gt;将使得Kad的其他节点（收到请求的节点）能够使用A的ID填充他们的K-桶，同时也能够使用那些查询过程的中间节点来填充A的K-桶。这已过程既让A获得了详细的路由表，也让其它节点知道了A节点的加入&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-2-LibP2P基本概念&quot;&gt;&lt;a href=&quot;#1-2-LibP2P基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.2 LibP2P基本概念&quot;&gt;&lt;/a&gt;1.2 LibP2P基本概念&lt;/h2&gt;&lt;p&gt;Libp2p是Protocol Labs旗下的五个明星项目之一，五个项目彼此独立而又相互联系，旨在建立一个更安全、高效、开放的网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/QBObqG.png&quot; alt=&quot;QBObqG&quot;&gt;&lt;/p&gt;
&lt;p&gt;Libp2p是一个&lt;strong&gt;&lt;font color=&#39;#e54d42&#39;&gt;模块化&lt;/font&gt;的网络栈&lt;/strong&gt;，通过将各种传输协议和P2P协议结合在一起，开发人员能够构建大型、健壮的P2P网络。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/categories/technical/golang/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0199</title>
    <link href="https://xwjahahahaha.github.io/2021/07/17/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0199/"/>
    <id>https://xwjahahahaha.github.io/2021/07/17/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0199/</id>
    <published>2021-07-17T09:59:12.000Z</published>
    <updated>2021-07-19T01:10:32.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> go p2p -1- 基本概念和使用</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>同态加密</title>
    <link href="https://xwjahahahaha.github.io/2021/07/16/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    <id>https://xwjahahahaha.github.io/2021/07/16/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/</id>
    <published>2021-07-16T03:01:23.000Z</published>
    <updated>2021-07-16T07:48:18.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习资料来源：</p><p>知乎VenusBlockChain: <a href="https://zhuanlan.zhihu.com/p/110210315" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110210315</a></p><p>知乎刘巍然：<a href="https://www.zhihu.com/question/27645858/answer/37598506" target="_blank" rel="noopener">https://www.zhihu.com/question/27645858/answer/37598506</a></p><p><a href="https://blog.csdn.net/Gouph/article/details/106179325" target="_blank" rel="noopener">https://blog.csdn.net/Gouph/article/details/106179325</a></p></blockquote><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-1-同态加密"><a href="#1-1-同态加密" class="headerlink" title="1.1 同态加密"></a>1.1 同态加密</h2><p><strong><em>什么是同态加密？</em></strong></p><p>提出第一个构造出全同态加密（Fully Homomorphic Encryption）[Gen09]的Craig Gentry给出的直观定义最好：</p><blockquote><p>A way to delegate processing of your data, without giving away access to it.</p><p>一种委托数据处理的方法，但是让你不丧失对数据的所有权</p></blockquote><p><font color='#e54d42'>同态加密对于数据安全来说，不像一般的加密方案只关注<strong>数据存储安全</strong>，攻击者无法从密文中获得任何信息, 对加密数据的任何改动操作都会造成解密的错误。而同态加密关注于<strong>数据的处理安全</strong>，其提供了一种对加密数据处理的功能，且处理过程中无法得知原始内容，同时数据经过操作后还能够解密得到处理好的结果。</font></p><p>同态加密（Homomorphic Encryption）允许对密文处理后仍然是加密的结果。即对密文直接进行处理，跟对明文进行处理后再对处理结果加密，得到的结果相同。从抽象代数的角度讲，保持了同态性。</p><p>同态加密是<strong>基于数学难题</strong>的计算复杂性理论的密码学技术，它的概念可以简单的解释为：对经过同态加密的数据进行密文运算处理得到一个输出，这一输出解密结果与用同一方法处理未加密的原始数据得到的输出结果是一样的。</p><a id="more"></a><p>可以定一个运算符$\Delta$ , 对应的加密算法E和解密算法D, 同态加密满足: $E(x\Delta y) = E(x) \Delta E(y)$</p><p><strong><em>一个例子：</em></strong></p><p>(刘老师的例子非常贴切)</p><p>Alice想让工人加工自己的金子但是不信任工人，害怕其在操作过程中偷取自己的金子，那么就相出了以下的办法：</p><ul><li>Alice将金子锁在一个密闭的盒子里面，这个盒子安装了一个手套。</li><li>工人可以带着这个手套，对盒子内部的金子进行处理。但是盒子是锁着的，所以工人不仅拿不到金块，连处理过程中掉下的任何金子都拿不到。</li><li>加工完成后。Alice拿回这个盒子，把锁打开，就得到了金子。</li></ul><p>这个盒子的样子大概是这样的：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/GiDNiP.png" alt="GiDNiP"></p><p>这里面的对应关系是：</p><ul><li>Alice：数据持有方</li><li>工人： 不可信的服务提供第三方</li></ul><ul><li>盒子：加密算法</li><li>盒子上的锁：用户密钥</li><li>将金块放在盒子里面并且用锁锁上：将数据用同态加密方案进行加密</li><li>加工：应用同态特性，在无法取得数据的条件下直接对加密结果进行处理</li><li>开锁：对结果进行解密，直接得到处理后的结果</li></ul><h2 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h2><p>同态性来自代数领域，一般包括四种类型：加法同态、乘法同态、减法同态和除法同态。</p><p>同时满足加法同态和乘法同态，则意味着是代数同态，称为<strong>全同态</strong>(Full Homomorphic)</p><p>同时满足四种同态性，则称为<strong>算数同态</strong>。</p><p><font color='#e54d42'>对于计算机来说，实现了全同态就可以实现所有操作的同态性</font></p><p>只实现部分特定操作的同态性称为<strong>特定同态</strong>, 对于特定同态特性的算法，如RSA，Elgamal，Paillier、Pedersen Commitment等等。</p><p>目前业界使用的较多的还是特定同态/部分同态，而斯坦福大学的博士生Craig Gentry基于<strong>理想格</strong>提出一个全同态加密方案。Fully Homomorphic Encryption Using Ideal Lattices. In the 41st ACM Symposium on Theory of Computing (STOC), 2009.</p><p>所谓的格（Lattice）就是整系数基的线性组合构成的点，也就是一个空间中的一些离散有规律的点。离散的点之间的距离产生了一些困难问题，例如：最短向量问题(SVP)。</p><p>如果是一个二维平面，那么寻找在格上寻找最短向量问题是简单的，但是当维数变大的时候，例如200多维，寻找格上的最短向量问题就变的异常困难，称之为格上标准困难问题，是一个指数级的困难问题。 </p><p>Gentry首次设计出一个真正的全同态加密体制，即可以在不解密的条件下对加密数据进行任何可以在明文上进行的运算，使得对加密信息仍能进行深入和无限的分析，而不会影响其保密性。</p><blockquote><p>IBM公布的开源代码：FHE ：<a href="https://github.com/IBM/fhe-toolkit-linux" target="_blank" rel="noopener">https://github.com/IBM/fhe-toolkit-linux</a></p></blockquote><h2 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1.3 应用"></a>1.3 应用</h2><p><strong><em>云计算</em></strong></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/rb1HwZ.png" alt="rb1HwZ"></p><p>Alice通过Cloud，以Homomorphic Encryption（以下简称HE）处理数据的整个处理过程大致是这样的：</p><ol><li>Alice对数据进行加密。并把加密后的数据发送给Cloud；</li><li>Alice向Cloud提交数据的处理方法，这里用函数f来表示；</li><li>Cloud在函数f下对数据进行处理，并且将处理后的结果发送给Alice；</li><li>Alice对数据进行解密，得到结果。</li></ol><p>可想而之，在未来如果实现了真正可以实用的全同态技术(加强环节中的f()的操作空间)，那么一款完全不会泄漏个人数据隐私的云计算服务的市场竞争有多大！</p><blockquote><p>对于Function f()是否也可以进行加密呢，这样云服务器连操作都不会知晓</p></blockquote><p><strong><em>区块链</em></strong></p><p>使用同态加密技术，运行在区块链上的<strong>智能合约可以处理密文</strong>，<strong>而无法获知真实数据</strong>，极大地提高了隐私安全性。</p><p>这样的优点是，用户将交易数据提交到区块链网络之前，可使用相应的加密算法对交易数据进行加密，数据以密文的形式存在，即使被攻击者获取，也不会泄露用户的任何隐私信息，同时密文运算结果与明文运算结果一致。</p><p>数据的操作还可以与区块链的<strong>智能合约</strong>相关联</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/TZ7T29.png" alt="TZ7T29"></p><p>华为区块链提供同态加密库，对用户的交易数据用其公钥进行加密保护，交易的时候都是密文运算，最终账本中加密保存，即使节点被攻破，获取到账本记录也无法解密。</p><p>趣链Hyperchain通过同态加密（采用Paillier同态加密算法）的加密思想实现区块中交易金额和账户余额的加密。其白皮书声称经过同态加密的交易验证时间约为10微秒，可以满足Hyperchain每秒上万笔交易的需求。</p><p>BCOS也采用了Paillier同态加密算法，并开源出了加法同态解说使用说明[1]，以及Paillier同态加密算法JAVA版实现[2]。当然还有其他产品，此处不再一一列举。</p><h1 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h1><p>同态加密也有很多的实现算法</p><h2 id="2-1-Paillier"><a href="#2-1-Paillier" class="headerlink" title="2.1 Paillier"></a>2.1 Paillier</h2><p>类别:  <font color='#fbbd08'><strong>加法</strong>同态加密算法</font></p><p>困难：分解两个大质数</p><p>Paillier加密算法[3]是1999年Paillier发明的基于复合剩余类的困难问题的加法同态加密算法</p><h3 id="算法生成过程："><a href="#算法生成过程：" class="headerlink" title="算法生成过程："></a>算法生成过程：</h3><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/dQbHXB.png" alt="dQbHXB"></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul><li>明文m, 0&lt;=m&lt;=n</li><li>随机数r, 0&lt;r&lt;n, 且gcd(r, n) =1</li><li>加密结果: $c = g^m * r ^n mod n^2$</li></ul><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><ul><li>解密结果：$m = L(c^\lambda)modn^2 * \mu  mod n$</li></ul><h3 id="同态性的证明"><a href="#同态性的证明" class="headerlink" title="同态性的证明"></a>同态性的证明</h3><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/0idXJv.png" alt="0idXJv"></p><h2 id="2-2-ElGamal"><a href="#2-2-ElGamal" class="headerlink" title="2.2 ElGamal"></a>2.2 ElGamal</h2><p>类别：<font color='#fbbd08'><strong>乘法</strong>同态加密算法</font></p><p>困难：离散对数问题</p><p>ELGamal密码是除了RSA之外最有代表性的公开密钥密码之一，是一种公认安全的公钥密码。</p><h3 id="离散对数问题"><a href="#离散对数问题" class="headerlink" title="离散对数问题"></a>离散对数问题</h3><p>设p为素数，若存在一个正整数α，使得 $a,a^2,a^3,…,a^{p-1}$ 关于模p互不同余，则称α为模p的一个<strong>原根</strong>。于是有如下运算：</p><p>a的幂乘运算： $y = a^xmod p , 1 \leqslant x \leqslant{p-1}$</p><p>a的对数运算： $x = log_a^y, \ 1 \leqslant y \leqslant {p-1}$</p><p>只要p足够大，求解离散对数问题时相当复杂的。离散对数问题具有较好的单向性。</p><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><ul><li>随机地选择一个大素数p，且要求p-1有大素数因子，将p公开。</li><li>选择一个模p的原根α，并将α公开。</li><li>随机地选择一个整数d（1＜d＜p-1）作为私钥，并对d保密。</li><li>计算公钥$y=a^d(modp)$ ，并将y公开。</li></ul><h3 id="加密-1"><a href="#加密-1" class="headerlink" title="加密"></a>加密</h3><ul><li><p>对于待加密明文M，随机地选取一个整数k（1＜k＜p-1）。</p></li><li><p>计算$U= a^kmodp 、C_1=a^kmodp 、C_2=U*Mmodp$</p></li><li><p>取(C1,C2)作为密文。</p></li></ul><h4 id="解密-1"><a href="#解密-1" class="headerlink" title="解密"></a>解密</h4><p>计算$V = C_1^dmodp$</p><p>解密结果: $M = C_2V^{-1}modp$</p><h3 id="同态性的证明-1"><a href="#同态性的证明-1" class="headerlink" title="同态性的证明"></a>同态性的证明</h3><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/OmOuqx.png" alt="OmOuqx"></p><h1 id="三、golang代码实现"><a href="#三、golang代码实现" class="headerlink" title="三、golang代码实现"></a>三、golang代码实现</h1><h2 id="3-1-Paillier"><a href="#3-1-Paillier" class="headerlink" title="3.1 Paillier"></a>3.1 Paillier</h2><p>代码库：<a href="https://github.com/Roasbeef/go-go-gadget-paillier" target="_blank" rel="noopener">https://github.com/Roasbeef/go-go-gadget-paillier</a></p><p>采用Go语言实现的加法同态加密算法Paillier </p><p>其主要可以实现以下操作：</p><ul><li><p>可以将加密的整数加在一起 </p></li><li><p>加密的整数可以与未加密的整数相<strong>乘</strong> </p></li><li><p>加密的整数和未加密的整数可以加在一起</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>go get github.com/roasbeef/go-go-gadget-paillier</code></p><h3 id="测试Demo"><a href="#测试Demo" class="headerlink" title="测试Demo"></a>测试Demo</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_homomorphicCrypto</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个128位的私钥</span></span><br><span class="line">privKey, _ := paillier.GenerateKey(rand.Reader, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公钥加密明文：数字15</span></span><br><span class="line">m15 := <span class="built_in">new</span>(big.Int).SetInt64(<span class="number">15</span>)</span><br><span class="line">c15, _ := paillier.Encrypt(&amp;privKey.PublicKey, m15.Bytes())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私钥解密密文：15</span></span><br><span class="line">d, _ := paillier.Decrypt(privKey, c15)</span><br><span class="line">plainText := <span class="built_in">new</span>(big.Int).SetBytes(d)</span><br><span class="line">fmt.Println(<span class="string">"Decryption Result of 15: "</span>, plainText.String()) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 公钥加密数字20</span></span><br><span class="line">m20 := <span class="built_in">new</span>(big.Int).SetInt64(<span class="number">20</span>)</span><br><span class="line">c20, _ := paillier.Encrypt(&amp;privKey.PublicKey, m20.Bytes())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将15的密文与20的密文相加（注意都是同一公钥）</span></span><br><span class="line">plusM16M20 := paillier.AddCipher(&amp;privKey.PublicKey, c15, c20)</span><br><span class="line"><span class="comment">// 使用私钥解密和的明文结果</span></span><br><span class="line">decryptedAddition, _ := paillier.Decrypt(privKey, plusM16M20)</span><br><span class="line">fmt.Println(<span class="string">"Result of 15+20 after decryption: "</span>,</span><br><span class="line"><span class="built_in">new</span>(big.Int).SetBytes(decryptedAddition).String()) <span class="comment">// 35!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将15密文与10明文常数相加</span></span><br><span class="line">plusE15and10 := paillier.Add(&amp;privKey.PublicKey, c15, <span class="built_in">new</span>(big.Int).SetInt64(<span class="number">10</span>).Bytes())</span><br><span class="line">decryptedAddition, _ = paillier.Decrypt(privKey, plusE15and10)</span><br><span class="line">fmt.Println(<span class="string">"Result of 15+10 after decryption: "</span>,</span><br><span class="line"><span class="built_in">new</span>(big.Int).SetBytes(decryptedAddition).String()) <span class="comment">// 25!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将15密文与10明文常数相乘</span></span><br><span class="line">mulE15and10 := paillier.Mul(&amp;privKey.PublicKey, c15, <span class="built_in">new</span>(big.Int).SetInt64(<span class="number">10</span>).Bytes())</span><br><span class="line">decryptedMul, _ := paillier.Decrypt(privKey, mulE15and10)</span><br><span class="line">fmt.Println(<span class="string">"Result of 15*10 after decryption: "</span>,</span><br><span class="line"><span class="built_in">new</span>(big.Int).SetBytes(decryptedMul).String()) <span class="comment">// 150!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 结果显示</span></span><br><span class="line">=== RUN   Test_homomorphicCrypto</span><br><span class="line">Decryption Result of 15:  15</span><br><span class="line">Result of 15+20 after decryption:  35</span><br><span class="line">Result of 15+10 after decryption:  25</span><br><span class="line">Result of 15*10 after decryption:  150</span><br><span class="line">--- PASS: Test_homomorphicCrypto (0.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>值得注意的是该包的作者说其用于课程教学，实际的生产环境则不太适合</p><h1 id="四、当下挑战"><a href="#四、当下挑战" class="headerlink" title="四、当下挑战"></a>四、当下挑战</h1><p>同态加密最大的问题是效率</p><p>效率。效率一词包含两个方面，一个是<strong>加密数据的处理速度</strong>，一个是这个<strong>加密方案的数据存储量</strong>。</p><ul><li><p>工人戴着手套加工金子，肯定没有直接加工来得快嘛~ 也就是说，隔着手套处理，精准度会变差（<strong>现有构造会有误差传递问题</strong>），加工的时间也会变得更长（<strong>密文的操作花费更长的时间</strong>），工人需要隔着操作，因此也需要更专业（<strong>会正确调用算法</strong>）。</p></li><li><p>金子放在盒子里面，为了操作，总得做一个稍微大一点的盒子吧，要不然手操作不开啊（<strong>存储空间问题</strong>）。里面也要放各种工具吧，什么电钻啦，锉刀啦，也需要空间吧？</p></li></ul><p>2011年，Gentry和Halevi在IBM尝试实现了两个HE方案：Smart-Vercauteren的SWHE方案[SV10]以及Gentry的FHE方案[Gen09]，并公布了效率。结果如何呢？我们给出Gentry公布的数据（原始数据可以在<a href="https://link.zhihu.com/?target=http%3A//crypto.biu.ac.il/winterschool2012/">2nd Bar-Ilan Winter School on Cryptography</a>找到）Smart-Vercauteren的SWHE方案效率如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/IsCUut.png" alt="IsCUut"></p><p>看着好像还行，不过这Dimension有点夸张啊…也就是说公钥很长…那么，Gentry的FHE方案如何呢？效率如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/69jQG9.png" alt="69jQG9"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;p&gt;知乎VenusBlockChain: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/110210315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/110210315&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;知乎刘巍然：&lt;a href=&quot;https://www.zhihu.com/question/27645858/answer/37598506&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/27645858/answer/37598506&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Gouph/article/details/106179325&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/Gouph/article/details/106179325&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-同态加密&quot;&gt;&lt;a href=&quot;#1-1-同态加密&quot; class=&quot;headerlink&quot; title=&quot;1.1 同态加密&quot;&gt;&lt;/a&gt;1.1 同态加密&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;什么是同态加密？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提出第一个构造出全同态加密（Fully Homomorphic Encryption）[Gen09]的Craig Gentry给出的直观定义最好：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A way to delegate processing of your data, without giving away access to it.&lt;/p&gt;
&lt;p&gt;一种委托数据处理的方法，但是让你不丧失对数据的所有权&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;同态加密对于数据安全来说，不像一般的加密方案只关注&lt;strong&gt;数据存储安全&lt;/strong&gt;，攻击者无法从密文中获得任何信息, 对加密数据的任何改动操作都会造成解密的错误。而同态加密关注于&lt;strong&gt;数据的处理安全&lt;/strong&gt;，其提供了一种对加密数据处理的功能，且处理过程中无法得知原始内容，同时数据经过操作后还能够解密得到处理好的结果。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;同态加密（Homomorphic Encryption）允许对密文处理后仍然是加密的结果。即对密文直接进行处理，跟对明文进行处理后再对处理结果加密，得到的结果相同。从抽象代数的角度讲，保持了同态性。&lt;/p&gt;
&lt;p&gt;同态加密是&lt;strong&gt;基于数学难题&lt;/strong&gt;的计算复杂性理论的密码学技术，它的概念可以简单的解释为：对经过同态加密的数据进行密文运算处理得到一个输出，这一输出解密结果与用同一方法处理未加密的原始数据得到的输出结果是一样的。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/categories/technical/golang/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer15.二进制中1的个数</title>
    <link href="https://xwjahahahaha.github.io/2021/07/16/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://xwjahahahaha.github.io/2021/07/16/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2021-07-16T02:16:29.000Z</published>
    <updated>2021-07-16T02:19:57.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 15. 二进制中1的个数</a></p><p>难度简单</p><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">汉明重量</a>).）。</p><a id="more"></a><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用 <a href="https://baike.baidu.com/item/二进制补码/5295284" target="_blank" rel="noopener">二进制补码</a> 记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 11 (控制台输入 00000000000000000000000000001011)</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 128 (控制台输入 00000000000000000000000010000000)</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n &#x3D; -3）</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>本题依托一种算法：  <a href="https://myblog.gumptlu.work/2020/07/03/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/" target="_blank" rel="noopener">布赖恩·克尼根算法</a>， 位运算中需要掌握的一种算法</p><p>作用： 将一个数的二进制从右往左看最后一个1变为0</p><p>原理：将一个数-1，在二进制上的表现就是最后一位1变为0，此位后面的所有0变为1，此位前面的二进制位数字不动</p><p>使用： x &amp; (x-1)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">0</span>  &#123;</span><br><span class="line">        <span class="comment">// x &amp; (x-1) 可以去除掉最后一位1</span></span><br><span class="line">        num &amp;= (num<span class="number">-1</span>)</span><br><span class="line">        count ++ </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 15. 二进制中1的个数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度简单&lt;/p&gt;
&lt;p&gt;编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 &lt;a href=&quot;http://en.wikipedia.org/wiki/Hamming_weight&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汉明重量&lt;/a&gt;).）。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0198</title>
    <link href="https://xwjahahahaha.github.io/2021/07/16/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0198/"/>
    <id>https://xwjahahahaha.github.io/2021/07/16/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0198/</id>
    <published>2021-07-16T01:13:02.000Z</published>
    <updated>2021-07-16T08:40:31.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input checked="" disabled="" type="checkbox"> 隐私计算-同态加密</li><li><input disabled="" type="checkbox"> BlockFLA论文</li><li><input disabled="" type="checkbox"> tendermint项目解读2</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>隐私计算</title>
    <link href="https://xwjahahahaha.github.io/2021/07/15/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    <id>https://xwjahahahaha.github.io/2021/07/15/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/</id>
    <published>2021-07-15T06:04:05.000Z</published>
    <updated>2021-07-16T03:05:44.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习材料：</p><p><a href="https://zhuanlan.zhihu.com/p/138630291" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/138630291</a></p><p><a href="https://zhuanlan.zhihu.com/p/110210315" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110210315</a></p></blockquote><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><ul><li><p>区块链本身的公开性与隐私保护的冲突：</p><ul><li>区块链的隐私保护与传统隐私保护不同：上链数据需要多节点的验证共识, 链上的数据是公开透明的</li></ul></li><li><p>区块链隐私保护策略：</p><ol><li>链上链下分割, 分别设计隐私数据的保护策略</li><li>访问控制</li></ol></li><li><p>隐私保护策略的实现需要密码学技术的支持：</p><ol><li><p>同态加密：加密后的数据计算与原数据的直接计算同态</p></li><li><p>零知识证明：不泄漏数据本身的任何信息的情况下实现某些信息的证明</p></li><li><p>安全多方计算: 在隐私保护的情况下多方之间协同计算 (<em>一般基于<strong>混淆电路</strong>和<strong>不经意传输</strong>等技术实现</em>)</p></li><li><p>TEE(如SGX): 信任硬件设备:</p><p>在信任特定硬件设备（如 Intel 芯片的 SGX 功能）难以攻破的前提下选择在受硬件保护的 Enclave 环境中解密外部输入数据、执行智能合约代码、加密输出数据，此过程中<strong>明文信息只出现在 Enclave 中</strong>但不能被外部看到。</p><blockquote><p><font color='#39b54a'>加解密在硬件中，让明文只在硬件中暴露</font></p></blockquote></li></ol></li></ul><a id="more"></a><ul><li><p>区块链隐私主要分为身份隐私和交易隐私</p><ul><li>身份隐私：区块链地址与真实地址的映射关系隐私</li><li>交易隐私： 区块链上公开的信息，例如比特币的输入输出地址、金额暴露的支付关系</li></ul></li><li><p>交易数据的加密可以实现隐私保护，但是密文又会给验证交易带来困难</p><blockquote><p>如果比特币的金额都是加密的，那么核对账户余额以及扣款等就会相对变得更加复杂</p></blockquote><p>同态加密可以解决这个问题</p></li></ul><p>文章针对 ACCOUNT 模型，设计一种交易金额的同态加密计算和基于 FO 承诺的零知识证明方案。</p><blockquote><p>详细的加密工具的基本详解与使用，见下方链接：</p><ol><li>同态加密：</li><li>零知识证明：</li><li>安全多方计算：</li><li>查分隐私：</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习材料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/138630291&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/138630291&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/110210315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/110210315&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;区块链本身的公开性与隐私保护的冲突：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区块链的隐私保护与传统隐私保护不同：上链数据需要多节点的验证共识, 链上的数据是公开透明的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;区块链隐私保护策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;链上链下分割, 分别设计隐私数据的保护策略&lt;/li&gt;
&lt;li&gt;访问控制&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隐私保护策略的实现需要密码学技术的支持：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;同态加密：加密后的数据计算与原数据的直接计算同态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;零知识证明：不泄漏数据本身的任何信息的情况下实现某些信息的证明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安全多方计算: 在隐私保护的情况下多方之间协同计算 (&lt;em&gt;一般基于&lt;strong&gt;混淆电路&lt;/strong&gt;和&lt;strong&gt;不经意传输&lt;/strong&gt;等技术实现&lt;/em&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TEE(如SGX): 信任硬件设备:&lt;/p&gt;
&lt;p&gt;在信任特定硬件设备（如 Intel 芯片的 SGX 功能）难以攻破的前提下选择在受硬件保护的 Enclave 环境中解密外部输入数据、执行智能合约代码、加密输出数据，此过程中&lt;strong&gt;明文信息只出现在 Enclave 中&lt;/strong&gt;但不能被外部看到。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#39b54a&#39;&gt;加解密在硬件中，让明文只在硬件中暴露&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="solidity" scheme="https://xwjahahahaha.github.io/categories/technical/solidity/"/>
    
    
    <category term="solidity" scheme="https://xwjahahahaha.github.io/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer14-II.剪绳子II</title>
    <link href="https://xwjahahahaha.github.io/2021/07/14/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer14-II-%E5%89%AA%E7%BB%B3%E5%AD%90II/"/>
    <id>https://xwjahahahaha.github.io/2021/07/14/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer14-II-%E5%89%AA%E7%BB%B3%E5%AD%90II/</id>
    <published>2021-07-14T06:18:34.000Z</published>
    <updated>2021-07-14T06:29:07.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 14- II. 剪绳子 II</a></p><p>难度中等125</p><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><font color='#e54d42'>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</font></p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 1000</code></li></ul><p>注意：本题与主站 343 题相同：<a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-break/</a></p><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>循环求余法除去溢出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此题不在适合动态规划，要用贪心算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cuttingRope</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    mod := <span class="number">1000000007</span></span><br><span class="line">    timesOf3 := n/<span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> n- (<span class="number">3</span> * timesOf3) == <span class="number">1</span> &#123;</span><br><span class="line">        timesOf3 -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timesOf2 := (n - <span class="number">3</span> * timesOf3) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求指数的时候，进行循环求模处理</span></span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=timesOf3; i++ &#123;</span><br><span class="line">        res = (res * <span class="number">3</span>) % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=timesOf2; i++ &#123;</span><br><span class="line">        res = (res * <span class="number">2</span>) % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % mod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 14- II. 剪绳子 II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等125&lt;/p&gt;
&lt;p&gt;给你一根长度为 &lt;code&gt;n&lt;/code&gt; 的绳子，请把绳子剪成整数长度的 &lt;code&gt;m&lt;/code&gt; 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 &lt;code&gt;k[0],k[1]...k[m - 1]&lt;/code&gt; 。请问 &lt;code&gt;k[0]*k[1]*...*k[m - 1]&lt;/code&gt; 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。&lt;/p&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0197</title>
    <link href="https://xwjahahahaha.github.io/2021/07/14/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0197/"/>
    <id>https://xwjahahahaha.github.io/2021/07/14/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0197/</id>
    <published>2021-07-14T03:21:17.000Z</published>
    <updated>2021-07-16T01:09:25.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 英语</li><li><input checked="" disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input checked="" disabled="" type="checkbox"> 华为比赛</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer14-I.剪绳子</title>
    <link href="https://xwjahahahaha.github.io/2021/07/13/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer14-I-%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <id>https://xwjahahahaha.github.io/2021/07/13/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer14-I-%E5%89%AA%E7%BB%B3%E5%AD%90/</id>
    <published>2021-07-13T09:02:06.000Z</published>
    <updated>2021-07-13T09:15:48.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 14- I. 剪绳子</a></p><p>难度中等</p><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code>。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 58</code></li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><h3 id="方法一：-动态规划"><a href="#方法一：-动态规划" class="headerlink" title="方法一： 动态规划"></a>方法一： 动态规划</h3><p>时间复杂度O($n^2$), 空间复杂度O(n)</p><p><font color='#e54d42'><strong>从上往下分析，从下往上编写</strong></font> (避免重复计算)</p><ul><li>对于dp[i]长度的绳子，可从k位置开始剪开，则k的范围为[1, i)</li><li>在第k个位置剪开，[k, i]长度的绳子可以剪也可以不剪，选择大者。则状态转移方程为: $dp[i] = max(k<em>dp[i-k], k</em>(i-k))$</li><li>对于所有的k位置，取最大为当前dp[i]的最大乘积，所以状态转移方程变为:$dp[i] = max(dp[i], max(k<em>dp[i-k], k</em>(i-k)))$</li><li>优化: 对于长度为i的绳子，剪为长度k与(i-k) 和 剪为长度(i-k)和k是一样的，所以第k个位置剪开只需要考虑到i/2不用到i</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划 时间复杂度O(n2), 空间复杂度O(n)</span></span><br><span class="line"><span class="comment">// 构建动态规划方程：</span></span><br><span class="line"><span class="comment">// dp[i] = max&#123;dp[i], max&#123;k*dp[i-k], k*(i-k)&#125;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cuttingRope</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建动态规划数组</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 初始化情况</span></span><br><span class="line">    <span class="comment">// 长度为2最大乘积为1</span></span><br><span class="line">    dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">1</span>           </span><br><span class="line">    <span class="comment">// 从下往上构建,避免重复计算</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">3</span>; i&lt;=n; i++ &#123;</span><br><span class="line">        <span class="comment">// 遍历切的位置k</span></span><br><span class="line">        max := <span class="number">0</span></span><br><span class="line">        <span class="comment">// 此循环优化：不用到达i，切到中间后面都是一样的</span></span><br><span class="line">        <span class="keyword">for</span> k:=<span class="number">1</span>; k&lt;=i/<span class="number">2</span>; k++ &#123;</span><br><span class="line">            <span class="comment">// [k, i]部分裁剪</span></span><br><span class="line">            clip := k * dp[i-k]</span><br><span class="line">            <span class="comment">// [k, i]部分不裁剪</span></span><br><span class="line">            no_clip := k * (i-k)</span><br><span class="line">            <span class="comment">// 选择最大的</span></span><br><span class="line">            <span class="keyword">if</span> clip &gt; no_clip &#123;</span><br><span class="line">                dp[i] = clip</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = no_clip</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找出所有裁剪位置的最大值</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; max &#123;</span><br><span class="line">                max = dp[i]</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = max</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度优化思路加一：</p><ul><li>考虑遍历过程前后是否有重复，有的话可以只遍历一半，甚至开根</li></ul></blockquote><h3 id="方法二-贪心算法"><a href="#方法二-贪心算法" class="headerlink" title="方法二 贪心算法"></a>方法二 贪心算法</h3><p>时间复杂度O（n）</p><p>尽可能把绳子分成长度为3的小段，这样乘积最大，当最后为4时分为两个2最大</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心算法 时间复杂度O（n）</span></span><br><span class="line"><span class="comment">// 尽可能把绳子分成长度为3的小段，这样乘积最大</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cuttingRope</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 直接返回一些特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 计算3的次数</span></span><br><span class="line">    timesOf3 := n / <span class="number">3</span></span><br><span class="line">    <span class="comment">// 如果最后一次为4，那么就改为2*2</span></span><br><span class="line">    <span class="keyword">if</span> n - timesOf3 * <span class="number">3</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 现将最后一次剪次数扣除</span></span><br><span class="line">        timesOf3 -= <span class="number">1</span>       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算余下2的次数，要么为一次(余2)，要么为2次(余4)</span></span><br><span class="line">    timesOf2 := (n - timesOf3 * <span class="number">3</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(<span class="keyword">float64</span>(<span class="number">3</span>), <span class="keyword">float64</span>(timesOf3))) * <span class="keyword">int</span>(math.Pow(<span class="keyword">float64</span>(<span class="number">2</span>), <span class="keyword">float64</span>(timesOf2)))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jian-sheng-zi-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 14- I. 剪绳子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给你一根长度为 &lt;code&gt;n&lt;/code&gt; 的绳子，请把绳子剪成整数长度的 &lt;code&gt;m&lt;/code&gt; 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 &lt;code&gt;k[0],k[1]...k[m-1]&lt;/code&gt;。请问 &lt;code&gt;k[0]*k[1]*...*k[m-1]&lt;/code&gt; 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0196</title>
    <link href="https://xwjahahahaha.github.io/2021/07/13/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0196/"/>
    <id>https://xwjahahahaha.github.io/2021/07/13/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0196/</id>
    <published>2021-07-13T01:55:26.000Z</published>
    <updated>2021-07-14T03:21:34.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 英语</li><li><input checked="" disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input checked="" disabled="" type="checkbox"> 论文BlockFLA系统架构部分</li><li><input checked="" disabled="" type="checkbox"> mqtt go语言实现</li><li><input disabled="" type="checkbox"> 项目Tendermint</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>拒绝年费自己组建MarkdownNice转微信公众号格式神器</title>
    <link href="https://xwjahahahaha.github.io/2021/07/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E6%8B%92%E7%BB%9D%E5%B9%B4%E8%B4%B9%E8%87%AA%E5%B7%B1%E7%BB%84%E5%BB%BAMarkdownNice%E8%BD%AC%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%A0%BC%E5%BC%8F%E7%A5%9E%E5%99%A8/"/>
    <id>https://xwjahahahaha.github.io/2021/07/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E6%8B%92%E7%BB%9D%E5%B9%B4%E8%B4%B9%E8%87%AA%E5%B7%B1%E7%BB%84%E5%BB%BAMarkdownNice%E8%BD%AC%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%A0%BC%E5%BC%8F%E7%A5%9E%E5%99%A8/</id>
    <published>2021-07-12T06:12:29.000Z</published>
    <updated>2021-07-12T06:38:35.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>资料来源：</p><p><a href="https://cloud.tencent.com/developer/article/1811081" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1811081</a></p></blockquote><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>墨滴的公众号排版格式转换服务非常的好用，对于一些带有公式的Markdown也能够完美的转换成为公众号的格式</p><p>它的简单功能介绍可见连接：<a href="https://zhuanlan.zhihu.com/p/104209040" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/104209040</a></p><p>总之，如果你喜欢用Markdown写公众号，那么这个是你的不二之选</p><p>但是，官方的app软件只有试用期7天，年费的开销也挺大, 在线转网站必须要登陆等等限制（且自动会把内容发到社区）。。。</p><p>好在其代码开源，所以我们可以自己搭建一个mdnice服务</p><a id="more"></a><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/8pVlof.png" alt="8pVlof"></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>一台云服务器，或者有公网IP带域名解析的服务器主机</p><p>建议阿里云、腾讯等学生机，便宜够用。</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>有一个注册的域名</p><p>nodejs npm 环境需要提前安装. (如果不会也可跳过)</p><h1 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h1><h2 id="1-下载官方包"><a href="#1-下载官方包" class="headerlink" title="1. 下载官方包"></a>1. 下载官方包</h2><p>下载官方的压缩包， 链接： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fmdnice%2Fmarkdown-nice%2Farchive%2Frefs%2Fheads%2Fmaster.zip" target="_blank" rel="noopener">https://github.com/mdnice/markdown-nice/archive/refs/heads/master.zip</a></p><p>进入文件夹，下载依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖包</span></span><br><span class="line">npm i</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译软件, 获得可直接部署的项目文件夹</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>没有环境的可以直接下载编译好的文件链接：  <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fzhaoolee.lanzoui.com%2FiZqoQnqrt9e" target="_blank" rel="noopener">https://zhaoolee.lanzoui.com/iZqoQnqrt9e</a></p><p>正确完整的文件目录如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/mEouy8.png" alt="mEouy8"></p><h2 id="2-部署"><a href="#2-部署" class="headerlink" title="2. 部署"></a>2. 部署</h2><p>发送到你的云服务器中，放置到如下目录</p><p><code>/usr/share/nginx/mdnice</code>    (文件夹名称可自行命名, 我就叫mdnice)</p><h2 id="3-添加域名解析"><a href="#3-添加域名解析" class="headerlink" title="3. 添加域名解析"></a>3. 添加域名解析</h2><p>在你的云服务器服务商网站中找到域名解析，以阿里云为例：</p><p>添加一个你喜欢子域名前缀，这里我就是<code>mdnice.gumptlu.work</code></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/uo4FFB.png" alt="uo4FFB"></p><h2 id="4-nginx配置"><a href="#4-nginx配置" class="headerlink" title="4. nginx配置"></a>4. nginx配置</h2><p>在云服务器的<code>/etc/nginx/conf.d</code>目录下添加一个conf后缀文件, 这里命名就以<code>mdnice.gumptlu.work.conf</code>为例</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/nalT1T.png" alt="nalT1T"></p><p>文件中写入解析内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80; </span><br><span class="line">  server_name mdnice.gumptlu.work;</span><br><span class="line">  charset  utf-8;</span><br><span class="line"> </span><br><span class="line">  location / &#123; </span><br><span class="line">    root /usr/share/nginx/mdnice;# 要与部署的路径对应</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试配置文件</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启nginx</span></span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h2 id="5-访问地址"><a href="#5-访问地址" class="headerlink" title="5. 访问地址"></a>5. 访问地址</h2><p><code>http://mdnice.gumptlu.work</code></p><p>ok!</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/s6284p.png" alt="s6284p"></p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>如果之前开启过ssl用于https，那么需要关闭ssl，否则80端口会被自动转发到443, The plain HTTP request was sent to HTTPS port</p><p>解决：</p><p>开配置文件，查看HTTPS server段的配置：</p><p>修改前：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改方式，将监听端口后的“ssl”删除，即：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       443;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;资料来源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1811081&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cloud.tencent.com/developer/article/1811081&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h1&gt;&lt;p&gt;墨滴的公众号排版格式转换服务非常的好用，对于一些带有公式的Markdown也能够完美的转换成为公众号的格式&lt;/p&gt;
&lt;p&gt;它的简单功能介绍可见连接：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/104209040&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/104209040&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总之，如果你喜欢用Markdown写公众号，那么这个是你的不二之选&lt;/p&gt;
&lt;p&gt;但是，官方的app软件只有试用期7天，年费的开销也挺大, 在线转网站必须要登陆等等限制（且自动会把内容发到社区）。。。&lt;/p&gt;
&lt;p&gt;好在其代码开源，所以我们可以自己搭建一个mdnice服务&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="markdown" scheme="https://xwjahahahaha.github.io/categories/technical/markdown/"/>
    
    
    <category term="markdown" scheme="https://xwjahahahaha.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>m1芯片Mac无法调试Goland的解决方案</title>
    <link href="https://xwjahahahaha.github.io/2021/07/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%B0%8F%E6%8A%80%E5%B7%A7/m1%E8%8A%AF%E7%89%87Mac%E6%97%A0%E6%B3%95%E8%B0%83%E8%AF%95Goland%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://xwjahahahaha.github.io/2021/07/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%B0%8F%E6%8A%80%E5%B7%A7/m1%E8%8A%AF%E7%89%87Mac%E6%97%A0%E6%B3%95%E8%B0%83%E8%AF%95Goland%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-07-12T03:20:31.000Z</published>
    <updated>2021-07-12T03:47:33.328Z</updated>
    
    <content type="html"><![CDATA[<p>查询了很多资料文章，下面这篇给了启发，记录一下我的解决方案</p><p><a href="https://blog.csdn.net/zsi386/article/details/116357850?spm=1001.2014.3001.5501" target="_blank" rel="noopener">https://blog.csdn.net/zsi386/article/details/116357850?spm=1001.2014.3001.5501</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>我的环境：</p><ul><li><p>go version :  go1.16.5 darwin/arm64.  (下载时记得下载arm架构的)</p></li><li><p>goland version: 2020.3</p></li><li><p>mac version:Big Sur 11.4 MacBook Air m1芯片</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/MvQldJ.png" alt="MvQldJ"> </p></li></ul><a id="more"></a><p>调试出现的问题：</p><p><font color='#e54d42'>可以断点停下来，但是无法<strong>下一步和查看变量</strong>，无报错</font></p><blockquote><p>断点都不可以停下的需要检查一下go的版本是否下载的arm架构</p><p><a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/SjFTRk.png" alt="SjFTRk"></p></blockquote><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>下载go-delve/delve</p><p><code>git clone https://github.com/go-delve/delve.git</code></p><p>下载慢的可以用这个：<code>git clone https://github.com.cnpmjs.org/go-delve/delve.git</code></p><p>可以把它放在了GOPATH下的src/github.com//go-delve下，进入clone下来的delve中（<code>cd delve</code>），切换分支：</p><p><code>git checkout -b darwin-arm64-lldb</code></p><p>然后进入工程目录<code>cd ./cmd/dlv/</code>，重新编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build</span><br><span class="line">go install</span><br></pre></td></tr></table></figure><p>(不需要修改代码，目前1205 bug估计已修复)</p><p>会在你的<code>GOPATH/bin</code>下重新生成二进制文件<code>dlv</code></p><p>我的版本信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Delve Debugger</span><br><span class="line">Version: 1.6.1</span><br><span class="line">Build: $Id: 114218c22f3791287c4bc2f4ff35a846a1416ee9 $</span><br></pre></td></tr></table></figure><p>设置你的goland (<code>Help&gt;Edit custom properties</code>)指向它就可以：</p><p><code>dlv.path=/path/to/dlv</code> (<font color='#e54d42'>路径要改</font>)，然后可以debug了：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/DHncf0.png" alt="DHncf0"></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/VWLHrO.png" alt="VWLHrO"></p><h1 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h1><p>dlv老版本bug：</p><p>Big Sur11.3，lldb成了1205，dlv处理了1200，没处理1205</p><p>更新版本即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;查询了很多资料文章，下面这篇给了启发，记录一下我的解决方案&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zsi386/article/details/116357850?spm=1001.2014.3001.5501&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/zsi386/article/details/116357850?spm=1001.2014.3001.5501&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;我的环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;go version :  go1.16.5 darwin/arm64.  (下载时记得下载arm架构的)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;goland version: 2020.3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mac version:Big Sur 11.4 MacBook Air m1芯片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/MvQldJ.png&quot; alt=&quot;MvQldJ&quot;&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>mqtt协议与go语言实现</title>
    <link href="https://xwjahahahaha.github.io/2021/07/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/mqtt%E5%8D%8F%E8%AE%AE%E4%B8%8Ego%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
    <id>https://xwjahahahaha.github.io/2021/07/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/mqtt%E5%8D%8F%E8%AE%AE%E4%B8%8Ego%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-07-12T01:11:57.000Z</published>
    <updated>2021-07-13T16:25:09.781Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习资料：</p><p><a href="https://studygolang.com/articles/14452" target="_blank" rel="noopener">https://studygolang.com/articles/14452</a></p><p><a href="https://blog.csdn.net/jacky128256/article/details/105610456" target="_blank" rel="noopener">https://blog.csdn.net/jacky128256/article/details/105610456</a></p></blockquote><h1 id="一、什么是MQTT"><a href="#一、什么是MQTT" class="headerlink" title="一、什么是MQTT"></a>一、什么是MQTT</h1><p><strong>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议）</strong>，是一种<strong>基于发布/订阅（publish/subscribe）模式</strong>的“轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。</p><p>MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用</p><p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用</p><blockquote><p><font color='#39b54a'>MQTT还有一个特点就是客户端之间不用相互通信, MQTT通信更像是邮箱服务，发布者发布消息到服务器，接收者只要订阅了其服务在线后即可收到</font></p></blockquote><p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：<strong>发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）</strong>。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p><p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p><p>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</p><p>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</p><blockquote><p><font color='#39b54a'>Topic就是消息名，payload就是消息体</font></p></blockquote><a id="more"></a><p>MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个<strong>有序的、无损的、基于字节流的双向传输。</strong></p><p>当应用数据通过MQTT网络发送时，MQTT会把与之相关的<strong>服务质量（QoS）</strong>和<strong>主题名（Topic）</strong>相关连。</p><h1 id="二、Go语言MQTT服务器Broker的搭建"><a href="#二、Go语言MQTT服务器Broker的搭建" class="headerlink" title="二、Go语言MQTT服务器Broker的搭建"></a>二、Go语言MQTT服务器Broker的搭建</h1><p>服务端用erlang编写的一个开源项目：emqqtd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载安装包</span></span><br><span class="line">wget https://github.com/emqx/emqx/releases/download/v4.0.4/emqx-ubuntu18.04-v4.0.4.zip</span><br><span class="line">cd mqttd/emqx</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── data</span><br><span class="line">├── erts-10.5.2</span><br><span class="line">├── etc</span><br><span class="line">├── lib</span><br><span class="line">├── log</span><br><span class="line">└── releases</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启服务</span></span><br><span class="line">./bin/emqx start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">./bin/emqx_ctl status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止服务</span></span><br><span class="line">./bin/emqx stop</span><br></pre></td></tr></table></figure><p>找到自己的IP，访问<code>http://[你的IP]:18083/#/clients</code></p><ul><li>用户名：admin</li><li>密码：public</li></ul><p>即可进入服务器的控制台</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/RYTlik.png" alt="RYTlik"></p><h1 id="三、Go客户端访问简单API"><a href="#三、Go客户端访问简单API" class="headerlink" title="三、Go客户端访问简单API"></a>三、Go客户端访问简单API</h1><p>客户端用golang客户端的库：“github.com/eclipse/paho.mqtt.golang”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载依赖包</span></span><br><span class="line">go get -u github.com/eclipse/paho.mqtt.golang</span><br></pre></td></tr></table></figure><p>实例如下：</p><p>编写了两个函数一个发布一个订阅，传入参数即可服务</p><p>修改<code>EMQServerAddress</code>为你服务器的IP</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与后端mqtt服务交互</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">mqtt <span class="string">"github.com/eclipse/paho.mqtt.golang"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EMQServerAddress = <span class="string">"你的IP"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建全局mqtt publish消息处理 handler</span></span><br><span class="line"><span class="keyword">var</span> messagePubHandler mqtt.MessageHandler = <span class="function"><span class="keyword">func</span><span class="params">(client mqtt.Client, msg mqtt.Message)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Push Message:"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"TOPIC: %s\n"</span>, msg.Topic())</span><br><span class="line">fmt.Printf(<span class="string">"MSG: %s\n"</span>, msg.Payload())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建全局mqtt sub消息处理 handler</span></span><br><span class="line"><span class="keyword">var</span> messageSubHandler mqtt.MessageHandler = <span class="function"><span class="keyword">func</span><span class="params">(client mqtt.Client, msg mqtt.Message)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"收到订阅消息:"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"Sub Client Topic : %s \n"</span>, msg.Topic())</span><br><span class="line">fmt.Printf(<span class="string">"Sub Client msg : %s \n"</span>, msg.Payload())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接的回掉函数</span></span><br><span class="line"><span class="keyword">var</span> connectHandler mqtt.OnConnectHandler =<span class="function"><span class="keyword">func</span><span class="params">(client mqtt.Client)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"新的连接!"</span> + <span class="string">" Connected"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 丢失连接的回掉函数</span></span><br><span class="line"><span class="keyword">var</span> connectLostHandler mqtt.ConnectionLostHandler = <span class="function"><span class="keyword">func</span><span class="params">(client mqtt.Client, err error)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Connect loss: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 配置错误提示</span></span><br><span class="line">mqtt.DEBUG = log.New(os.Stdout, <span class="string">"[mqttDEBUG]"</span>, <span class="number">0</span>)</span><br><span class="line">mqtt.ERROR = log.New(os.Stdout, <span class="string">" [mqttERROR]"</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Description: 发布订阅</span></span><br><span class="line"><span class="comment"> * @param clientID</span></span><br><span class="line"><span class="comment"> * @param addr</span></span><br><span class="line"><span class="comment"> * @param topic</span></span><br><span class="line"><span class="comment"> * @param payload</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(topic <span class="keyword">string</span>, qos <span class="keyword">byte</span>, retain <span class="keyword">bool</span>, payload <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// opts ClientOptions 用于设置 broker，端口，客户端 id ，用户名密码等选项</span></span><br><span class="line">opts := mqtt.NewClientOptions().AddBroker(<span class="string">"tcp://"</span> + EMQServerAddress + <span class="string">":1883"</span>).SetClientID(<span class="string">"test_push"</span>)</span><br><span class="line">opts.SetKeepAlive(<span class="number">60</span> * time.Second)</span><br><span class="line"><span class="comment">// Message callback handler，在没有任何订阅时，发布端调用此函数</span></span><br><span class="line">opts.SetDefaultPublishHandler(messagePubHandler)</span><br><span class="line">opts.SetPingTimeout(<span class="number">1</span> * time.Second)</span><br><span class="line">opts.OnConnect = connectHandler</span><br><span class="line">opts.OnConnectionLost = connectLostHandler</span><br><span class="line">client := mqtt.NewClient(opts)</span><br><span class="line"><span class="keyword">if</span> token := client.Connect(); token.Wait() &amp;&amp; token.Error() != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(token.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发布消息</span></span><br><span class="line"><span class="comment">// qos是服务质量: ==1: 一次, &gt;=1: 至少一次, &lt;=1:最多一次</span></span><br><span class="line"><span class="comment">// retained: 表示mqtt服务器要保留这次推送的信息，如果有新的订阅者出现，就会把这消息推送给它（持久化推送）</span></span><br><span class="line">token := client.Publish(topic, qos, retain, payload)</span><br><span class="line">token.Wait()</span><br><span class="line">fmt.Println(<span class="string">"Push Data : "</span>+topic, <span class="string">"Data Size is "</span>+strconv.Itoa(<span class="built_in">len</span>(payload)))</span><br><span class="line">fmt.Println(<span class="string">"Disconnect with broker"</span>)</span><br><span class="line">client.Disconnect(<span class="number">250</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Description: 订阅或取消订阅</span></span><br><span class="line"><span class="comment"> * @param clientID</span></span><br><span class="line"><span class="comment"> * @param addr</span></span><br><span class="line"><span class="comment"> * @param topic</span></span><br><span class="line"><span class="comment"> * @param isSub</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Subscription</span><span class="params">(topic <span class="keyword">string</span>, qos <span class="keyword">byte</span>, isSub <span class="keyword">bool</span>, handleFun <span class="keyword">func</span>([]<span class="keyword">byte</span>)</span>)</span> &#123;</span><br><span class="line">opts := mqtt.NewClientOptions().AddBroker(<span class="string">"tcp://"</span> + EMQServerAddress + <span class="string">":1883"</span>).SetClientID(<span class="string">"sub_test"</span>)</span><br><span class="line">opts.SetKeepAlive(<span class="number">60</span> * time.Second)</span><br><span class="line">opts.SetPingTimeout(<span class="number">1</span> * time.Second)</span><br><span class="line">opts.OnConnect = <span class="function"><span class="keyword">func</span><span class="params">(client mqtt.Client)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"New Subscription! Connected"</span> + <span class="string">" =&gt; "</span> + topic)</span><br><span class="line">&#125;</span><br><span class="line">opts.OnConnectionLost = connectLostHandler</span><br><span class="line">client := mqtt.NewClient(opts)</span><br><span class="line"><span class="keyword">if</span> token := client.Connect(); token.Wait() &amp;&amp; token.Error() != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(token.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isSub &#123;</span><br><span class="line"><span class="comment">// 订阅消息</span></span><br><span class="line"><span class="keyword">if</span> token := client.Subscribe(topic, qos, <span class="function"><span class="keyword">func</span><span class="params">(client mqtt.Client, msg mqtt.Message)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Receive Subscribe Message :"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"Sub Client Topic : %s, Data size is  %d \n"</span>, msg.Topic(), <span class="built_in">len</span>(msg.Payload()))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(msg.Payload()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">handleFun(msg.Payload())</span><br><span class="line">&#125;</span><br><span class="line">&#125;); token.Wait() &amp;&amp; token.Error() != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(token.Error())</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line"><span class="keyword">if</span> token := client.Unsubscribe(topic); token.Wait() &amp;&amp; token.Error() != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(token.Error())</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://studygolang.com/articles/14452&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://studygolang.com/articles/14452&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jacky128256/article/details/105610456&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/jacky128256/article/details/105610456&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、什么是MQTT&quot;&gt;&lt;a href=&quot;#一、什么是MQTT&quot; class=&quot;headerlink&quot; title=&quot;一、什么是MQTT&quot;&gt;&lt;/a&gt;一、什么是MQTT&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议）&lt;/strong&gt;，是一种&lt;strong&gt;基于发布/订阅（publish/subscribe）模式&lt;/strong&gt;的“轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。&lt;/p&gt;
&lt;p&gt;MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用&lt;/p&gt;
&lt;p&gt;MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#39b54a&#39;&gt;MQTT还有一个特点就是客户端之间不用相互通信, MQTT通信更像是邮箱服务，发布者发布消息到服务器，接收者只要订阅了其服务在线后即可收到&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：&lt;strong&gt;发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）&lt;/strong&gt;。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。&lt;/p&gt;
&lt;p&gt;MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：&lt;/p&gt;
&lt;p&gt;（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；&lt;/p&gt;
&lt;p&gt;（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#39b54a&#39;&gt;Topic就是消息名，payload就是消息体&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/categories/technical/golang/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
