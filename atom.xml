<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识与头发不可兼得</title>
  
  <subtitle>文杰的博客</subtitle>
  <link href="https://xwjahahahaha.github.io/atom.xml" rel="self"/>
  
  <link href="https://xwjahahahaha.github.io/"/>
  <updated>2021-11-09T12:44:04.117Z</updated>
  <id>https://xwjahahahaha.github.io/</id>
  
  <author>
    <name>DDDemons hide</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2-构造容器</title>
    <link href="https://xwjahahahaha.github.io/2021/11/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker/%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5%E4%B8%80%E4%B8%AAdocker%E7%B3%BB%E5%88%97/2-%E6%9E%84%E9%80%A0%E5%AE%B9%E5%99%A8/"/>
    <id>https://xwjahahahaha.github.io/2021/11/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker/%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5%E4%B8%80%E4%B8%AAdocker%E7%B3%BB%E5%88%97/2-%E6%9E%84%E9%80%A0%E5%AE%B9%E5%99%A8/</id>
    <published>2021-11-09T12:01:57.000Z</published>
    <updated>2021-11-09T12:44:04.117Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习自《自己动手写Docker》</p><p>作者：<a href="https://www.zhihu.com/people/chen-xian-lu-10/activities" target="_blank" rel="noopener">陈显鹭（花名：遥鹭）-阿里云高级研发工程师</a>等</p><p>京东购买链接：<a href="https://item.jd.com/10033552355433.html" target="_blank" rel="noopener">https://item.jd.com/10033552355433.html</a></p><p>其他链接:</p><ul><li></li></ul></blockquote><p>[TOC]</p><a id="more"></a><h1 id="一、构造实现run命令版本的容器"><a href="#一、构造实现run命令版本的容器" class="headerlink" title="一、构造实现run命令版本的容器"></a>一、构造实现run命令版本的容器</h1><p>本节代码获取方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/xianlubird/mydocker.git</span><br><span class="line">git checkout code-3.1</span><br></pre></td></tr></table></figure><h2 id="1-1-Linux-proc文件系统"><a href="#1-1-Linux-proc文件系统" class="headerlink" title="1.1 Linux proc文件系统"></a>1.1 Linux proc文件系统</h2><p>开始之前，还是再补充一点基本知识。<strong><code>/proc</code>文件系统是由内核提供的，不是一个真正的文件系统，它只包含了系统运行时的信息（系统内存、mount设备信息、一些硬件配置等）。它只存在于内存中而不占用系统的外存空间</strong>。<strong>它以文件系统的形式为访问内核数据的操作提供借接口。</strong>实际上很多工具都是简单的去读取这个文件系统中的文件内容。</p><p>遍历<code>/proc</code>目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /proc/</span></span><br><span class="line">1      15     215    28     4    529  728   89         crypto       irq          meminfo       slabinfo       version_signature</span><br><span class="line">10     15445  22     2812   485  546  729   9          devices      kallsyms     misc          softirqs       vmallocinfo</span><br><span class="line">11     16     23     2856   486  550  7668  916        diskstats    kcore        modules       stat           vmstat</span><br><span class="line">115    164    23064  29     489  575  78    921        dma          keys         mounts        swaps          zoneinfo</span><br><span class="line">11638  17     24     2962   490  6    79    98         driver       key-users    mtrr          sys</span><br><span class="line">12     18     249    2995   491  617  799   acpi       execdomains  kmsg         net           sysrq-trigger</span><br><span class="line">1230   184    25     30     495  678  8     buddyinfo  fb           kpagecgroup  pagetypeinfo  sysvipc</span><br><span class="line">13     185    25393  31836  497  679  80    bus        filesystems  kpagecount   partitions    thread-self</span><br><span class="line">13253  19     255    34     498  680  81    cgroups    fs           kpageflags   sched_debug   timer_list</span><br><span class="line">1343   2      26     35     499  688  82    cmdline    interrupts   loadavg      schedstat     tty</span><br><span class="line">1344   20     2680   36     500  7    83    consoles   iomem        locks        scsi          uptime</span><br><span class="line">14     21     27     399    501  707  8565  cpuinfo    ioports      mdstat       self          versio</span><br></pre></td></tr></table></figure><p>这些数字都是为每个进程创建的空间，数字就是他们的PID</p><p>对于一个进程<code>N</code>比较重要的部分文件解释：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211109202447524.png" alt="image-20211109202447524" style="zoom: 50%;" /><h2 id="1-2-实现Run命令"><a href="#1-2-实现Run命令" class="headerlink" title="1.2 实现Run命令"></a>1.2 实现Run命令</h2><p>首先实现一个简单版本的run命令，类似于<code>docker run -it [command]</code>。后面会逐步添加<code>network</code>、<code>mount filesystem</code>等功能。该版本参考<code>run C</code>实现</p><p>代码目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Godeps</span><br><span class="line">│   ├── Godeps.json</span><br><span class="line">│   └── Readme</span><br><span class="line">├── README.md</span><br><span class="line">├── container</span><br><span class="line">│   ├── container_process.go</span><br><span class="line">│   └── init.go</span><br><span class="line">├── main.go</span><br><span class="line">├── main_command.go</span><br><span class="line">├── network</span><br><span class="line">│   └── test_linux.go</span><br><span class="line">├── run.go</span><br><span class="line">└── vendor</span><br><span class="line">    ├── github.com</span><br><span class="line">    └── golang.org</span><br></pre></td></tr></table></figure><p>入口<code>main</code>文件：</p><p>书本中使用的是<code>github.com/urfave/cli</code>实现的命令行，我采用<code>cobra</code>实现</p><pre><code class="go"></code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习自《自己动手写Docker》&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://www.zhihu.com/people/chen-xian-lu-10/activities&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;陈显鹭（花名：遥鹭）-阿里云高级研发工程师&lt;/a&gt;等&lt;/p&gt;
&lt;p&gt;京东购买链接：&lt;a href=&quot;https://item.jd.com/10033552355433.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://item.jd.com/10033552355433.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他链接:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>415.字符串相加</title>
    <link href="https://xwjahahahaha.github.io/2021/11/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
    <id>https://xwjahahahaha.github.io/2021/11/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</id>
    <published>2021-11-09T07:54:07.000Z</published>
    <updated>2021-11-09T07:54:59.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></p><p>难度简单</p><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 &#x3D; &quot;11&quot;, num2 &#x3D; &quot;123&quot;</span><br><span class="line">输出：&quot;134&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 &#x3D; &quot;456&quot;, num2 &#x3D; &quot;77&quot;</span><br><span class="line">输出：&quot;533&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 &#x3D; &quot;0&quot;, num2 &#x3D; &quot;0&quot;</span><br><span class="line">输出：&quot;0&quot;</span><br></pre></td></tr></table></figure><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="keyword">string</span>, num2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ret, carry := <span class="string">""</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">// 创建两个指针分别指向尾部</span></span><br><span class="line">    p1, p2 := <span class="built_in">len</span>(num1)<span class="number">-1</span>, <span class="built_in">len</span>(num2)<span class="number">-1</span>  </span><br><span class="line">    <span class="keyword">for</span> p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span> &#123;      </span><br><span class="line">        <span class="comment">// 注意carry &gt; 0，即使两个指针都达到了最前面，可能还有进位没处理</span></span><br><span class="line">        <span class="comment">// 取值相加</span></span><br><span class="line">        n1, n2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> p1 &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            n1 = <span class="keyword">int</span>(num1[p1] - <span class="string">'0'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p2 &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            n2 = <span class="keyword">int</span>(num2[p2] - <span class="string">'0'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算和</span></span><br><span class="line">        sum := n1 + n2 + carry</span><br><span class="line">        <span class="comment">// 取进位</span></span><br><span class="line">        carry = sum/<span class="number">10</span></span><br><span class="line">        <span class="comment">// 加到结果集前面</span></span><br><span class="line">        ret = strconv.Itoa(sum%<span class="number">10</span>) + ret</span><br><span class="line">        <span class="comment">// 同步向前移动</span></span><br><span class="line">        p1--; p2--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;415. 字符串相加&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度简单&lt;/p&gt;
&lt;p&gt;给定两个字符串形式的非负整数 &lt;code&gt;num1&lt;/code&gt; 和&lt;code&gt;num2&lt;/code&gt; ，计算它们的和并同样以字符串形式返回。&lt;/p&gt;
&lt;p&gt;你不能使用任何內建的用于处理大整数的库（比如 &lt;code&gt;BigInteger&lt;/code&gt;）， 也不能直接将输入的字符串转换为整数形式。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>12-runtime-2-内存分配原理</title>
    <link href="https://xwjahahahaha.github.io/2021/11/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/12-runtime-2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86/"/>
    <id>https://xwjahahahaha.github.io/2021/11/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/12-runtime-2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-09T05:09:42.000Z</published>
    <updated>2021-11-09T06:50:39.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习自：</p><ul><li>极客时间《go进阶训练营》</li><li></li></ul></blockquote><a id="more"></a><h1 id="一、堆栈-amp-逃逸分析"><a href="#一、堆栈-amp-逃逸分析" class="headerlink" title="一、堆栈 &amp; 逃逸分析"></a>一、堆栈 &amp; 逃逸分析</h1><h2 id="1-堆和栈的定义"><a href="#1-堆和栈的定义" class="headerlink" title="1. 堆和栈的定义"></a>1. 堆和栈的定义</h2><p>Go 有两个地方可以分配内存：一个全局堆空间用来动态分配内存，另一个是每个 goroutine 都有的自身栈空间。</p><ul><li><p>栈</p><pre><code>栈区的内存一般由编译器自动进行分配和释放，&lt;u&gt;其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而销毁。&lt;/u&gt;(通过 CPU push &amp; release)。一个函数可以通过帧指针直接访问帧内的内存，但是访问帧外的内存需要间接访问。</code></pre><p>​    <strong>栈的内存分配是从高位往低位拓展，堆则是反过来。</strong></p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/nmjzK3.png" alt="nmjzK3" style="zoom: 33%;" /><p>​    <strong>栈帧</strong>：用来给函数运行<strong>提供内存空间</strong>。取内存于stack上。当函数调用时，产生栈帧，当函数调用结束时，释放栈帧。</p><p>​    <strong>栈帧存储：</strong>1.局部变量 2.形参（与局部变量地位等同） 3. 内存字段描述值</p><p>​    一个函数就对应一个栈</p><p>​    以32位的内存4G的空间为例：</p><p>​    <img src="http://xwjpics.gumptlu.work/qinniu_uPic/OnTiL2.png" alt="OnTiL2" style="zoom: 33%;" /></p></li><li><p>堆</p><pre><code>堆区的内存一般由编译器和工程师自己共同进行管理分配，**交给 Runtime GC 来释放**。&lt;u&gt;堆上分配必须找到一块足够大的内存来存放新的变量数据。后续释放时，垃圾回收器扫描堆空间寻找不再被使用的对象。&lt;/u&gt;   </code></pre><blockquote><p><strong>任何时候一个值在函数的堆栈框架的范围之外被共享，它将被放置(或分配)在堆上。</strong><br><font color='#39b54a'>在go语言中，编译器分析出局部变量产生了逃逸的行为，那么会将该变量设置在堆上（逃逸分析）。这是go的编译器自动实现的，而在C语言中，这需要程序员手动操作，否则会发生错误。</font></p></blockquote><p><strong>栈分配廉价，堆分配昂贵</strong>。stack allocation is cheap and heap allocation is expensive.</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/CUd4Vj.png" alt="CUd4Vj" style="zoom:50%;" /></li></ul><h2 id="2-逃逸分析"><a href="#2-逃逸分析" class="headerlink" title="2. 逃逸分析"></a>2. 逃逸分析</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>​    写过其他语言，比如 C 的同学都知道，有明确的栈和堆的相关概念。而 <strong>Go 声明语法并没有提到栈和堆，而是交给 Go 编译器决定在哪分配内存，保证程序的正确性</strong>，在 <u>Go FAQ</u> 里面提到这么一段解释：</p><p>​    从正确的角度来看，你不需要知道。<strong>Go 中的每个变量只要有引用就会一直存在。变量的存储位置(堆还是栈)和语言的语义无关。</strong><font color='#e54d42'>go语言中，<strong>堆栈空间的分配</strong>不依靠语法上的关键字<strong>即由系统分配（编译器分析代码）而不是代码层面上的指定</strong></font></p><p>​    存储位置对于写出高性能的程序确实有影响。如果可能，Go 编译器将为该函数的堆栈侦(stack frame)中的函数分配本地变量。但是<u>如果编译器在函数返回后无法证明变量未被引用，则编译器必须在会被垃圾回收的堆上分配变量以避免悬空指针错误</u>。此外，<u>如果局部变量非常大，将它存储在堆而不是栈上可能更有意义。</u></p><p>​    <u>在当前编译器中，如果变量存在取址，则该变量是堆上分配的候选变量。</u>（取地址不一定就会分配到堆上，只是候选）但是基础的逃逸分析可以将那些生存不超过函数返回值的变量识别出来，并且因此可以分配在栈上。</p><p>堆栈的分配规则如下：</p><ul><li><p>函数退出后不再使用则将该变量<strong>优先</strong>分配在栈中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数退出之后<strong>返回了该变量的引用或者把指针赋值给全局变量等继续引用的方式</strong>，那么<strong>一定</strong>就会把该变量分配在堆中（因为后续还要使用，所以不会放在栈上）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">return</span> a<span class="comment">// 继续引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者这样的逃逸</span></span><br><span class="line"><span class="keyword">var</span> global *<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">  x = <span class="number">1</span></span><br><span class="line">  global = &amp;x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>逃逸</strong>：当一个对象的指针被多个方法、线程引用时，就可以称这个指针发生了逃逸</p><blockquote><p><font color='#e54d42'>“通过检查<strong>变量的作用域是否超出了它所在的栈</strong>来决定是否将它分配在堆上”的技术，其中“变量的作用域超出了它所在的栈”这种行为即被称为<strong>逃逸</strong></font></p></blockquote><p><strong>逃逸分析</strong>：分析一个变量是分配在栈上还是堆上。逃逸分析在大多数语言里属于静态分析：在编译期由静态代码分析来决定一个值是否能被分配在栈帧上，还是需要“逃逸”到堆上。</p><p><strong>为什么要逃逸分析</strong>：让合适的变量存在合适的地方，节省GC内存回收的压力</p><p><strong>编译器逃逸分析原理：</strong> 就是上面的分配原则，如果函数中的变量被多个引用就分配到堆上，Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。</p><h3 id="2-查看是否逃逸的方法"><a href="#2-查看是否逃逸的方法" class="headerlink" title="2. 查看是否逃逸的方法"></a>2. 查看是否逃逸的方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    t := <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> &amp;t  <span class="comment">//返回对局部变量的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := foo()</span><br><span class="line">    fmt.Println(*x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//-m: 查看逃逸过程；-l: 禁止函数内联</span><br><span class="line"><span class="meta">$</span><span class="bash"> go build -gcflags <span class="string">'-m -l'</span> main.go</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">command</span>-line-arguments</span></span><br><span class="line">./main.go:11:2: moved to heap: t// t 逃逸到了堆上</span><br><span class="line">./main.go:17:13: ... argument does not escape </span><br><span class="line">./main.go:17:14: *x escapes to heap// x 逃逸到了堆上</span><br></pre></td></tr></table></figure><p>逃逸我们可以理解，x逃逸是因为fmt输出语句的参数为空接口类型，编译期间很难确定其参数的具体类型，也会发生逃逸。</p><h3 id="3-逃逸案例"><a href="#3-逃逸案例" class="headerlink" title="3. 逃逸案例"></a>3. 逃逸案例</h3><img src="http://xwjpics.gumptlu.work/qinniu_uPic/UsG3l0.png" alt="UsG3l0" style="zoom:50%;" /><ul><li><p>需要手动切换堆栈的问题: <strong>超过栈帧(stack frame)</strong></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/vqctDy.png" alt="vqctDy"></p><p>当一个函数被调用时，会在两个相关的帧边界间进行上下文切换。从调用函数切换到被调用函数，如果函数调用时需要传递参数，那么这些参数值也要传递到被调用函数的帧边界中。<strong>Go 语言中帧边界间的数据传递是按*<u>值</u>*传递的。</strong>任何在函数 getRandom 中的变量在函数返回时，都将不能访问。Go 查找所有变量超过当前函数栈侦的，把它们分配到堆上，避免 outlive 变量。</p></li><li><p>go编译器的逃逸分析的作用</p><p>上述情况中，num 变量不能指向之前的栈。<strong>Go 查找所有变量超过当前函数栈侦的，把它们分配到堆上，避免 outlive 变量。变量 tmp 在栈上分配，<font color='#e54d42'>但是它包含了指向堆内存的地址</font>，</strong>所以可以安全的从一个函数的栈侦复制到另外一个函数的栈帧。</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/OqdYP8.png" alt="OqdYP8" style="zoom: 33%;" /></li></ul><p>还存在大量其他的 case 会出现逃逸，比较典型的就是 “<strong>多级间接赋值容易导致逃逸</strong>”，<u><strong>这里的多级间接指的是，对某个引用类对象中的引用类成员进行赋值</strong></u>。</p><blockquote><p><strong><font color='#e54d42'>记住公式：<code>Data.Field=Value</code>如果<code>Data.Field</code>都是引用类的数据类型，则会导致<code>Value</code>的逃逸</font></strong></p></blockquote><p>Go 语言中的引用类数据类型有 func, interface, slice, map, chan, *Type ：</p><ul><li>一个值被分享到函数栈帧范围之外</li><li>在 for 循环外申明，在 for 循环内分配，同理闭包</li><li>发送指针或者带有指针的值到 channel 中</li><li>在一个切片上存储指针或带指针的值</li><li>slice 的背后数组被重新分配了</li><li><em>在 interface 类型上调用方法</em></li><li>….</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol><li>Go编译器会在编译期对考察变量的作用域，并作一系列检查，如果<strong>它的作用域</strong>在运行期间对编译器一直是可知的，那么就会分配到栈上；</li><li>堆上动态分配内存比栈上静态分配内存，开销大很多；尽可能的将不使用的变量减少引用，放在栈上减少GC的压力，栈会随函数执行完毕后直接回收。</li><li>变量分配在栈上需要能在编译期确定它的作用域，否则会分配到堆上；</li><li><font color='#e54d42'><strong>函数传递变量的指针可以避免复制值的开销，但是这种情况不是一定的，因为复制值的过程在栈上进行这个的开销远比变量逃逸后在堆上动态分配内存少的多</strong></font></li></ol><h1 id="二、连续栈"><a href="#二、连续栈" class="headerlink" title="二、连续栈"></a>二、连续栈</h1><h1 id="三、内存结构"><a href="#三、内存结构" class="headerlink" title="三、内存结构"></a>三、内存结构</h1><h1 id="四、优化实践"><a href="#四、优化实践" class="headerlink" title="四、优化实践"></a>四、优化实践</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;极客时间《go进阶训练营》&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0244</title>
    <link href="https://xwjahahahaha.github.io/2021/11/09/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0244/"/>
    <id>https://xwjahahahaha.github.io/2021/11/09/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0244/</id>
    <published>2021-11-09T00:44:53.000Z</published>
    <updated>2021-11-09T14:24:08.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经<ul><li><input checked="" disabled="" type="checkbox"> 调度算法结束，内存刚开始</li></ul></li><li><input checked="" disabled="" type="checkbox"> 下午：刷leetcode<ul><li><input checked="" disabled="" type="checkbox"> 字符串相加</li><li><input checked="" disabled="" type="checkbox"> 最长回文子串  一种方法</li></ul></li><li><input checked="" disabled="" type="checkbox"> 晚上：做项目<ul><li><input checked="" disabled="" type="checkbox"> 基本构建</li></ul></li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>236.二叉树的最近公共祖先</title>
    <link href="https://xwjahahahaha.github.io/2021/11/08/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>https://xwjahahahaha.github.io/2021/11/08/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2021-11-08T14:55:13.000Z</published>
    <updated>2021-11-08T14:56:47.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></p><p>难度中等</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="comment">// 依靠递归遍历，构建子节点与父节点的关系映射</span></span><br><span class="line"><span class="comment">// 然后分别从p, q出发寻找是否有重复的父节点</span></span><br><span class="line"><span class="comment">// 时间、空间复杂度O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    fatherMap := <span class="built_in">make</span>(<span class="keyword">map</span>[*TreeNode]*TreeNode)</span><br><span class="line">    fatherMap[root] = <span class="literal">nil</span>       <span class="comment">// 初始化根节点的父节点为空</span></span><br><span class="line">    <span class="comment">// 构建父节点映射</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode, *TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node, fatherNode *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        <span class="keyword">if</span> fatherNode != <span class="literal">nil</span> &#123;</span><br><span class="line">            fatherMap[node] = fatherNode</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归左右节点</span></span><br><span class="line">        dfs(node.Left, node)</span><br><span class="line">        dfs(node.Right, node)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 遍历q寻找其父节点，构建路径访问记录</span></span><br><span class="line">    qVisited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> node:=q; node!=<span class="literal">nil</span>; node=fatherMap[node] &#123;</span><br><span class="line">        qVisited[node.Val] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历p查找共同访问的节点</span></span><br><span class="line">    <span class="keyword">for</span> node:=p; node!=<span class="literal">nil</span>; node=fatherMap[node] &#123;</span><br><span class="line">        <span class="keyword">if</span> qVisited[node.Val] &#123;     <span class="comment">// 找到共同访问过的节点</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="comment">// 分析出规律：最近公共祖先一定是下面的两种情况之一:</span></span><br><span class="line"><span class="comment">// 1. p和q分别在自己的左右子树中出现</span></span><br><span class="line"><span class="comment">// 2. 自己是p或是q，并且子树有p或q，那么自己就是最近公共祖先</span></span><br><span class="line"><span class="comment">// 为什么一定是最近？毫无疑问第二种自己是公共祖先一定是最近的；对于第一种，最近的公共祖先一定是第一次相交的节点，那么p、q一定分别在左右两侧，再往上的祖先就不是最近也不会分别在两边了。</span></span><br><span class="line"><span class="comment">// 将递归函数返回值设置为：是否有p或者q</span></span><br><span class="line"><span class="comment">// 时间、空间复杂度O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前节点是p或q，则一定自己是最近公共祖先(因为树从上往下遍历）</span></span><br><span class="line">    <span class="keyword">if</span> root == p || root == q &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于当前节点，得到其左右子树的最近公共祖先</span></span><br><span class="line">    left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">    right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">    <span class="comment">// 判断:</span></span><br><span class="line">    <span class="comment">// 如果都不为nil，则说明是第一种情况</span></span><br><span class="line">    <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有一个子树有结果</span></span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不可能出现两个都是nil, 因为一定有公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;236. 二叉树的最近公共祖先&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度百科&lt;/a&gt;中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;strong&gt;一个节点也可以是它自己的祖先&lt;/strong&gt;）。”&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>20.有效的括号</title>
    <link href="https://xwjahahahaha.github.io/2021/11/08/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://xwjahahahaha.github.io/2021/11/08/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2021-11-08T13:38:45.000Z</published>
    <updated>2021-11-08T13:39:36.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h4><p>难度简单</p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code>，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li><p>左括号必须用相同类型的右括号闭合。</p></li><li><p>左括号必须以正确的顺序闭合。</p><a id="more"></a></li></ol><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;([)]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]{}&#39;</code> 组成</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">    isLeft := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    matched := <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l == <span class="string">'('</span> &amp;&amp; r == <span class="string">')'</span> || l == <span class="string">'['</span> &amp;&amp; r == <span class="string">']'</span> || l == <span class="string">'&#123;'</span> &amp;&amp; r == <span class="string">'&#125;'</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> []<span class="keyword">byte</span>(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> isLeft(c) &#123;</span><br><span class="line">            <span class="comment">// 左边直接入栈</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, c)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack)&gt;<span class="number">0</span> &amp;&amp; matched(stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>], c)&#123;</span><br><span class="line">            <span class="comment">// 右边则判断</span></span><br><span class="line">            <span class="comment">// 匹配则出栈</span></span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈必须全部合并完才算正确</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;20-有效的括号&quot;&gt;&lt;a href=&quot;#20-有效的括号&quot; class=&quot;headerlink&quot; title=&quot;20. 有效的括号&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;20. 有效的括号&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度简单&lt;/p&gt;
&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;{&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;}&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;[&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;]&amp;#39;&lt;/code&gt; 的字符串 &lt;code&gt;s&lt;/code&gt;，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;左括号必须用相同类型的右括号闭合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;左括号必须以正确的顺序闭合。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0243</title>
    <link href="https://xwjahahahaha.github.io/2021/11/08/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0243/"/>
    <id>https://xwjahahahaha.github.io/2021/11/08/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0243/</id>
    <published>2021-11-08T01:08:03.000Z</published>
    <updated>2021-11-08T14:57:25.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 上午：看go、面经</li><li><input checked="" disabled="" type="checkbox"> 下午：刷leetcode<ul><li><input checked="" disabled="" type="checkbox"> 二叉树锯齿层级遍历</li><li><input checked="" disabled="" type="checkbox"> 有效的括号</li><li><input checked="" disabled="" type="checkbox"> 二叉树的最近公共祖先</li></ul></li><li><input checked="" disabled="" type="checkbox"> 晚上：做项目<ul><li><input checked="" disabled="" type="checkbox"> docker基础原理结束</li></ul></li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mysql面经</title>
    <link href="https://xwjahahahaha.github.io/2021/11/07/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%9D%A2%E7%BB%8F/mysql%E9%9D%A2%E7%BB%8F/"/>
    <id>https://xwjahahahaha.github.io/2021/11/07/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%9D%A2%E7%BB%8F/mysql%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-11-07T12:04:36.000Z</published>
    <updated>2021-11-07T12:07:53.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：捏捏小肥脸<br>链接：<a href="https://www.nowcoder.com/discuss/735199?channel=-1&amp;source_id=profile_follow_post_nctrack" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/735199?channel=-1&amp;source_id=profile_follow_post_nctrack</a><br>来源：牛客网</p></blockquote><p>[TOC]</p><a id="more"></a><h3 id="什么是MySQL？-＊"><a href="#什么是MySQL？-＊" class="headerlink" title="什么是MySQL？　＊"></a>什么是MySQL？　＊</h3><p><a href="">百度</a>百科上的解释：MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。</p><h3 id="MySQL常用的存储引擎有什么？它们有什么区别？-＊＊＊"><a href="#MySQL常用的存储引擎有什么？它们有什么区别？-＊＊＊" class="headerlink" title="MySQL常用的存储引擎有什么？它们有什么区别？　＊＊＊"></a>MySQL常用的存储引擎有什么？它们有什么区别？　＊＊＊</h3><ul><li><p>InnoDB</p><p>InnoDB是MySQL的默认存储引擎，支持事务、行锁和外键等操作。</p></li><li><p>MyISAM</p><p>MyISAM是MySQL5.1版本前的默认存储引擎，MyISAM的并发性比较差，不支持事务和外键等操作，默认的锁的粒度为表级锁。</p></li></ul><table><thead><tr><th></th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>事务</td><td>支持</td><td>不支持</td></tr><tr><td>锁</td><td>支持表锁和行锁</td><td>支持表锁</td></tr><tr><td>可恢复性</td><td>根据事务日志进行恢复</td><td>无事务日志</td></tr><tr><td>表结构</td><td>数据和索引是集中存储的，.ibd和.frm</td><td>数据和索引是分开存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td></tr><tr><td>查询性能</td><td>一般情况相比于MyISAM较差</td><td>一般情况相比于InnoDB较差</td></tr><tr><td>索引</td><td>聚簇索引</td><td>非聚簇索引</td></tr></tbody></table><h3 id="数据库的三大范式-＊＊"><a href="#数据库的三大范式-＊＊" class="headerlink" title="数据库的三大范式　＊＊"></a>数据库的三大范式　＊＊</h3><ul><li>第一范式：确保每列保持原子性，数据表中的所有字段值都是不可分解的原子值。 </li><li>第二范式：确保表中的每列都和主键相关 </li><li>第三范式：确保每列都和主键列直接相关而不是间接相关 </li></ul><h3 id="MySQL的数据类型有哪些-＊＊"><a href="#MySQL的数据类型有哪些-＊＊" class="headerlink" title="MySQL的数据类型有哪些　＊＊"></a>MySQL的数据类型有哪些　＊＊</h3><ul><li><p>整数</p><p>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT分别占用8、16、24、32、64位存储空间。值得注意的是，INT(10)中的10只是表示显示字符的个数，并无实际意义。一般和UNSIGNED ZEROFILL配合使用才有实际意义，例如，数据类型INT(3)，属性为UNSIGNED ZEROFILL，如果插入的数据为3的话，实际存储的数据为003。</p></li><li><p>浮点数</p><p>FLOAT、DOUBLE及DECIMAL为浮点数类型，DECIMAL是利用字符串进行处理的，能存储精确的小数。相比于FLOAT和DOUBLE，DECIMAL的效率更低些。FLOAT、DOUBLE及DECIMAL都可以指定列宽，例如FLOAT(5,2)表示一共5位，两位存储小数部分，三位存储整数部分。</p></li><li><p>字符串</p><p>字符串常用的主要有CHAR和VARCHAR，VARCHAR主要用于存储可变长字符串，相比于定长的CHAR更节省空间。CHAR是定长的，根据定义的字符串长度分配空间。</p><p>应用场景：对于经常变更的数据使用CHAR更好，CHAR不容易产生碎片。对于非常短的列也是使用CHAR更好些，CHAR相比于VARCHAR在效率上更高些。一般避免使用TEXT/BLOB等类型，因为查询时会使用临时表，造成严重的性能开销。</p></li><li><p>日期</p><p>比较常用的有year、time、date、datetime、timestamp等，datetime保存从1000年到9999年的时间，精度位秒，使用8字节的存储空间，与时区无关。timestamp和UNIX的时间戳相同，保存从1970年1月1日午夜到2038年的时间，精度到秒，使用四个字节的存储空间，并且与时区相关。</p><p>应用场景：尽量使用timestamp，相比于datetime它有着更高的空间效率。</p></li></ul><h3 id="索引-＊＊＊"><a href="#索引-＊＊＊" class="headerlink" title="索引　＊＊＊"></a>索引　＊＊＊</h3><h4 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？　"></a>什么是索引？　</h4><p><a href="">百度</a>百科的解释：索引是对数据库表的一列或者多列的值进行<a href="">排序</a>一种结构，使用索引可以快速访问数据表中的特定信息。</p><h4 id="索引的优缺点？"><a href="#索引的优缺点？" class="headerlink" title="索引的优缺点？"></a>索引的优缺点？</h4><p>优点：</p><ul><li>大大加快数据检索的速度。 </li><li>将随机I/O变成顺序I/O(因为B+树的叶子节点是连接在一起的) </li><li>加速表与表之间的连接 </li></ul><p>缺点：</p><ul><li>从空间角度考虑，建立索引需要占用物理空间 </li><li>从时间角度 考虑，创建和维护索引都需要花费时间，例如对数据进行增删改的时候都需要维护索引。 </li></ul><h4 id="索引的数据结构？"><a href="#索引的数据结构？" class="headerlink" title="索引的数据结构？"></a>索引的数据结构？</h4><p>索引的数据结构主要有B+树和<a href="">哈希表</a>，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。</p><ul><li><p>B+树索引</p><p>熟悉数据结构的同学都知道，B+树、<a href="">平衡二叉树</a>、<a href="">红黑树</a>都是经典的数据结构。在B+树中，所有的记录节点都是按照键值大小的顺序放在叶子节点上，如下图。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/24783735B8B2682EC29D80A8FF420764.png" alt="图片说明"></p><p>从上图可以看出 ，因为B+树具有有序性，并且所有的数据都存放在叶子节点，所以查找的效率非常高，并且支持<a href="">排序</a>和范围查找。</p><p>B+树的索引又可以分为主索引和辅助索引。其中主索引为聚簇索引，辅助索引为非聚簇索引。聚簇索引是以主键作为B+ 树索引的键值所构成的B+树索引，聚簇索引的叶子节点存储着完整的数据记录；非聚簇索引是以非主键的列作为B+树索引的键值所构成的B+树索引，非聚簇索引的叶子节点存储着主键值。所以使用非聚簇索引进行查询时，会先找到主键值，然后到根据聚簇索引找到主键对应的数据域。上图中叶子节点存储的是数据记录，为聚簇索引的结构图，非聚簇索引的结构图如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/AC627F27D40B84EDFDEA2ABF1B4FFB18.png" alt="图片说明"></p><p>上图中的字母为数据的非主键的列值，假设要查询该列值为B的信息，则需先找到主键7，在到聚簇索引中查询主键7所对应的数据域。</p></li><li><p>哈希索引</p><p>哈希索引是基于<a href="">哈希表</a>实现的，对于每一行数据，存储引擎会对索引列通过哈希<a href="">算法</a>进行哈希计算得到哈希码，并且哈希<a href="">算法</a>要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为<a href="">哈希表</a>的key值，将指向数据行的指针作为<a href="">哈希表</a>的value值。这样查找一个数据的时间复杂度就是o(1)，一般多用于精确查找。</p></li></ul><h4 id="Hash索引和B-树的区别？"><a href="#Hash索引和B-树的区别？" class="headerlink" title="Hash索引和B+树的区别？"></a>Hash索引和B+树的区别？</h4><p>因为两者数据结构上的差异导致它们的使用场景也不同，哈希索引一般多用于精确的等值查找，B+索引则多用于除了精确的等值查找外的其他查找。在大多数情况下，会选择使用B+树索引。</p><ul><li>哈希索引不支持<a href="">排序</a>，因为<a href="">哈希表</a>是无序的。 </li><li>哈希索引不、支持范围查找。 </li><li>哈希索引不支持模糊查询及多列索引的最左前缀匹配。 </li><li>因为<a href="">哈希表</a>中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点 </li></ul><h4 id="索引的类型有哪些"><a href="#索引的类型有哪些" class="headerlink" title="索引的类型有哪些?"></a>索引的类型有哪些?</h4><p>MySQL主要的索引类型主要有FULLTEXT，HASH，BTREE，RTREE。</p><ul><li><p>FULLTEXT</p><p>FULLTEXT即全文索引，MyISAM存储引擎和InnoDB存储引擎在MySQL5.6.4以上版本支持全文索引，一般用于查找文本中的关键字，而不是直接比较是否相等，多在CHAR，VARCHAR，TAXT等数据类型上创建全文索引。全文索引主要是用来解决WHERE name LIKE “%zhang%”等针对文本的模糊查询效率低的问题。</p></li><li><p>HASH</p><p>HASH即哈希索引，哈希索引多用于等值查询，时间复杂夫为o(1)，效率非常高，但不支持<a href="">排序</a>、范围查询及模糊查询等。</p></li><li><p>BTREE</p><p>BTREE即B+树索引，INnoDB存储引擎默认的索引，支持<a href="">排序</a>、分组、范围查询、模糊查询等，并且性能稳定。</p></li><li><p>RTREE</p><p>RTREE即空间数据索引，多用于地理数据的存储，相比于其他索引，空间数据索引的优势在于范围查找</p></li></ul><h4 id="索引的种类有哪些？"><a href="#索引的种类有哪些？" class="headerlink" title="索引的种类有哪些？"></a>索引的种类有哪些？</h4><ul><li>主键索引：数据列不允许重复，不能为NULL，一个表只能有一个主键索引 </li><li>组合索引：由多个列值组成的索引。 </li><li>唯一索引：数据列不允许重复，可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值的组合必须唯一。 </li><li>全文索引：对文本的内容进行搜索。 </li><li>普通索引：基本的索引类型，可以为NULL </li></ul><h4 id="B树和B-树的区别？"><a href="#B树和B-树的区别？" class="headerlink" title="B树和B+树的区别？"></a>B树和B+树的区别？</h4><p>B树和B+树最主要的区别主要有两点：</p><ul><li><p>B树中的内部节点和叶子节点均存放键和值，而B+树的内部节点只有键没有值，叶子节点存放所有的键和值。</p></li><li><p>B＋树的叶子节点是通过相连在一起的，方便顺序检索。</p><p>两者的结构图如下。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/24783735B8B2682EC29D80A8FF420764-20211107200511877.png" alt="图片说明"></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/01CD8E56F28A87FA55C72932A70142E7.png" alt="图片说明"></p></li></ul><h4 id="数据库为什么使用B-树而不是B树？"><a href="#数据库为什么使用B-树而不是B树？" class="headerlink" title="数据库为什么使用B+树而不是B树？"></a>数据库为什么使用B+树而不是B树？</h4><ul><li>B树适用于随机检索，而B+树适用于随机检索和顺序检索 </li><li>B+树的空间利用率更高，因为B树每个节点要存储键和值，而B+树的内部节点只存储键，这样B+树的一个节点就可以存储更多的索引，从而使树的高度变低，减少了I/O次数，使得数据检索速度更快。 </li><li>B+树的叶子节点都是连接在一起的，所以范围查找，顺序查找更加方便 </li><li>B+树的性能更加稳定，因为在B+树中，每次查询都是从根节点到叶子节点，而在B树中，要查询的值可能不在叶子节点，在内部节点就已经找到。 </li></ul><p>那在什么情况适合使用B树呢，因为B树的内部节点也可以存储值，所以可以把一些频繁访问的值放在距离根节点比较近的地方，这样就可以提高查询效率。综上所述，B+树的性能更加适合作为数据库的索引。</p><h4 id="什么是聚簇索引，什么是非聚簇索引？"><a href="#什么是聚簇索引，什么是非聚簇索引？" class="headerlink" title="什么是聚簇索引，什么是非聚簇索引？"></a>什么是聚簇索引，什么是非聚簇索引？</h4><p>聚簇索引和非聚簇索引最主要的区别是<strong>数据和索引是否分开存储</strong>。</p><ul><li>聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。 </li><li>非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址。 </li></ul><p>在InnoDB存储引擎中，默认的索引为B+树索引，利用主键创建的索引为主索引，也是聚簇索引，在主索引之上创建的索引为辅助索引，也是非聚簇索引。为什么说辅助索引是在主索引之上创建的呢，因为辅助索引中的叶子节点存储的是主键。</p><p>在MyISAM存储引擎中，默认的索引也是B+树索引，但主索引和辅助索引都是非聚簇索引，也就是说索引结构的叶子节点存储的都是一个指向数据行的地址。并且使用辅助索引检索无需访问主键的索引。</p><p>可以从非常经典的两张图看看它们的区别(图片来源于网络)：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/E8B5126C6C720C4643F2543CB83781CB.png" alt="图片说明"></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/70BCE6DF348B8AAF62246C6079F56E09.png" alt="图片说明"></p><h4 id="非聚簇索引一定会进行回表查询吗？"><a href="#非聚簇索引一定会进行回表查询吗？" class="headerlink" title="非聚簇索引一定会进行回表查询吗？"></a>非聚簇索引一定会进行回表查询吗？</h4><p>上面是说了非聚簇索引的叶子节点存储的是主键，也就是说要先通过非聚簇索引找到主键，再通过聚簇索引找到主键所对应的数据，后面这个再通过聚簇索引找到主键对应的数据的过程就是回表查询，那么非聚簇索引就一定会进行回表查询吗？</p><p>答案是不一定的，这里涉及到一个索引覆盖的问题，如果查询的数据再辅助索引上完全能获取到便不需要回表查询。例如有一张表存储着个人信息包括id、name、age等字段。假设聚簇索引是以ID为键值构建的索引，非聚簇索引是以name为键值构建的索引，<code>select id,name from user where name = &#39;zhangsan&#39;;</code>这个查询便不需要进行回表查询因为，通过非聚簇索引已经能全部检索出数据，这就是索引覆盖的情况。如果查询语句是这样，<code>select id,name,age from user where name = &#39;zhangsan&#39;;</code>则需要进行回表查询，因为通过非聚簇索引不能检索出age的值。那应该如何解决那呢？只需要将索引覆盖即可，建立age和name的联合索引再使用<code>select id,name,age from user where name = &#39;zhangsan&#39;;</code>进行查询即可。</p><p>所以通过索引覆盖能解决非聚簇索引回表查询的问题。</p><h4 id="索引的使用场景有哪些？"><a href="#索引的使用场景有哪些？" class="headerlink" title="索引的使用场景有哪些？"></a>索引的使用场景有哪些？</h4><ul><li>对于中大型表建立索引非常有效，对于非常小的表，一般全部表扫描速度更快些。 </li><li>对于超大型的表，建立和维护索引的代价也会变高，这时可以考虑分区技术。 </li><li>如何表的增删改非常多，而查询需求非常少的话，那就没有必要建立索引了，因为维护索引也是需要代价的。 </li><li>一般不会出现再where条件中的字段就没有必要建立索引了。 </li><li>多个字段经常被查询的话可以考虑联合索引。 </li><li>字段多且字段值没有重复的时候考虑唯一索引。 </li><li>字段多且有重复的时候考虑普通索引。 </li></ul><h4 id="索引的设计原则？"><a href="#索引的设计原则？" class="headerlink" title="索引的设计原则？"></a>索引的设计原则？</h4><ul><li>最适合索引的列是在where后面出现的列或者连接句子中指定的列，而不是出现在SELECT关键字后面的选择列表中的列。 </li><li>索引列的基数越大，索引的效果越好，换句话说就是索引列的区分度越高，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差，因为列的基数最多也就是三种，大多不是男性就是女性。 </li><li>尽量使用短索引，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，并且索引高速缓存中的块可以容纳更多的键值，会使得查询速度更快。 </li><li>尽量利用最左前缀。 </li><li>不要过度索引，每个索引都需要额外的物理空间，维护也需要花费时间，所以索引不是越多越好。 </li></ul><h4 id="如何对索引进行优化？"><a href="#如何对索引进行优化？" class="headerlink" title="如何对索引进行优化？"></a>如何对索引进行优化？</h4><p>对索引的优化其实最关键的就是要符合索引的设计原则和应用场景，将不符合要求的索引优化成符合索引设计原则和应用场景的索引。</p><p>除了索引的设计原则和应用场景那几点外，还可以从以下两方面考虑。</p><ul><li>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，因为这样无法使用索引。例如<code>select * from table_name where a + 1 = 2</code></li><li>将区分度最高的索引放在前面 </li><li>尽量少使用select* </li></ul><p>索引的使用场景、索引的设计原则和如何对索引进行优化可以看成一个问题。</p><h4 id="如何创建-删除索引？"><a href="#如何创建-删除索引？" class="headerlink" title="如何创建/删除索引？"></a>如何创建/删除索引？</h4><p>创建索引：</p><ul><li><p>使用CREATE INDEX 语句</p><p><code>CREATE INDEX index_name ON table_name (column_list);</code></p></li><li><p>在CREATE TABLE时创建</p><p><a href="#">复制代码</a></p><p><code>``CREATE</code> <code>TABLE</code> <code>user``(``  ``id ``INT</code> <code>PRIMARY</code> <code>KEY``,``  ``information text,``  ``FULLTEXT ``KEY</code> <code>(information)``);</code></p></li><li><p>使用ALTER TABLE创建索引</p><p><code>ALTER TABLE table_name ADD INDEX index_name (column_list);</code></p></li></ul><p>删除索引：</p><ul><li><p>删除主键索引</p><p><code>alter table 表名 drop primary key</code></p></li><li><p>删除其他索引</p><p><code>alter table 表名 drop key 索引名</code></p></li></ul><h4 id="使用索引查询时性能一定会提升吗？"><a href="#使用索引查询时性能一定会提升吗？" class="headerlink" title="使用索引查询时性能一定会提升吗？"></a>使用索引查询时性能一定会提升吗？</h4><p>不一定，前面在索引的使用场景和索引的设计原则中已经提到了如何合理地使用索引，因为创建和维护索引需要花费空间和时间上的代价，如果不合理地使用索引反而会使查询性能下降。</p><h4 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h4><p>前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。</p><p>使用场景：前缀的区分度比较高的情况下。</p><p>建立前缀索引的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD KEY(column_name(prefix_length));</span><br></pre></td></tr></table></figure><p>这里面有个prefix_length参数很难确定，这个参数就是前缀长度的意思。通常可以使用以下方法进行确定，先计算全列的区分度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT column_name) &#x2F; COUNT(*) FROM table_name;</span><br></pre></td></tr></table></figure><p>然后在计算前缀长度为多少时和全列的区分度最相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) &#x2F; COUNT(*) FROM table_name;</span><br></pre></td></tr></table></figure><p>不断地调整prefix_length的值，直到和全列计算出区分度相近。</p><h4 id="什么是最左匹配原则？"><a href="#什么是最左匹配原则？" class="headerlink" title="什么是最左匹配原则？"></a>什么是最左匹配原则？</h4><p>最左匹配原则：从最左边为起点开始连续匹配，遇到范围查询（&lt;、&gt;、between、like）会停止匹配。</p><p>例如建立索引(a,b,c)，大家可以猜测以下几种情况是否用到了索引。</p><ul><li><p>第一种</p><p><a href="#">复制代码</a></p><p><code>select</code> <code>* ``from</code> <code>table_name ``where</code> <code>a = 1 ``and</code> <code>b = 2 ``and</code> <code>c = 3 ``select</code> <code>* ``from</code> <code>table_name ``where</code> <code>b = 2 ``and</code> <code>a = 1 ``and</code> <code>c = 3</code></p><p>上面两次查询过程中所有值都用到了索引，where后面字段调换不会影响查询结果，因为MySQL中的优化器会自动优化查询顺序。</p></li><li><p>第二种</p><p><a href="#">复制代码</a></p><p><code>select</code> <code>* ``from</code> <code>table_name ``where</code> <code>a = 1``select</code> <code>* ``from</code> <code>table_name ``where</code> <code>a = 1 ``and</code> <code>b = 2 ``select</code> <code>* ``from</code> <code>table_name ``where</code> <code>a = 1 ``and</code> <code>b = 2 ``and</code> <code>c = 3</code></p><p>答案是三个查询语句都用到了索引，因为三个语句都是从最左开始匹配的。</p></li><li><p>第三种</p><p><a href="#">复制代码</a></p><p><code>select</code> <code>* ``from</code> <code>table_name ``where</code> <code>b = 1 ``select</code> <code>* ``from</code> <code>table_name ``where</code> <code>b = 1 ``and</code> <code>c = 2</code></p><p>答案是这两个查询语句都没有用到索引，因为不是从最左边开始匹配的</p></li><li><p>第四种</p><p><a href="#">复制代码</a></p><p><code>select</code> <code>* ``from</code> <code>table_name ``where</code> <code>a = 1 ``and</code> <code>c = 2</code></p><p>这个查询语句只有a列用到了索引，c列没有用到索引，因为中间跳过了b列，不是从最左开始连续匹配的。</p></li><li><p>第五种</p><p><a href="#">复制代码</a></p><p><code>select</code> <code>* ``from</code> <code>table_name ``where</code> <code>a = 1 ``and</code> <code>b &lt; 3 ``and</code> <code>c &lt; 1</code></p><p>这个查询中只有a列和b列使用到了索引，而c列没有使用索引，因为根据最左匹配查询原则，遇到范围查询会停止。</p></li><li><p>第六种</p><p><a href="#">复制代码</a></p><p><code>select</code> <code>* ``from</code> <code>table_name ``where</code> <code>a ``like</code> <code>&#39;ab%&#39;``; ``select</code> <code>* ``from</code> <code>table_name ``where</code> <code>a ``like</code> <code>&#39;%ab&#39;``select</code> <code>* ``from</code> <code>table_name ``where</code> <code>a ``like</code> <code>&#39;%ab%&#39;</code></p><p>对于列为字符串的情况，只有前缀匹配可以使用索引，中缀匹配和后缀匹配只能进行全表扫描。</p></li></ul><h4 id="索引在什么情况下会失效？"><a href="#索引在什么情况下会失效？" class="headerlink" title="索引在什么情况下会失效？"></a>索引在什么情况下会失效？</h4><p>在上面介绍了几种不符合最左匹配原则的情况会导致索引失效，除此之外，以下这几种情况也会导致索引失效。</p><ul><li>条件中有or，例如<code>select * from table_name where a = 1 or b = 3</code></li><li>在索引上进行计算会导致索引失效，例如<code>select * from table_name where a + 1 = 2</code></li><li>在索引的类型上进行数据类型的隐形转换，会导致索引失效，例如字符串一定要加引号，假设 <code>select * from table_name where a = &#39;1&#39;</code>会使用到索引，如果写成<code>select * from table_name where a = 1</code>则会导致索引失效。 </li><li>在索引中使用函数会导致索引失效，例如<code>select * from table_name where abs(a) = 1</code></li><li>在使用like查询时以%开头会导致索引失效 </li><li>索引上使用！、=、&lt;&gt;进行判断时会导致索引失效，例如<code>select * from table_name where a != 1</code></li><li>索引字段上使用 is null/is not null判断时会导致索引失效，例如<code>select * from table_name where a is null</code></li></ul><h3 id="数据库的事务-＊＊＊"><a href="#数据库的事务-＊＊＊" class="headerlink" title="数据库的事务　＊＊＊"></a>数据库的事务　＊＊＊</h3><h4 id="什么是数据库的事务？"><a href="#什么是数据库的事务？" class="headerlink" title="什么是数据库的事务？"></a>什么是数据库的事务？</h4><p><a href="">百度</a>百科的解释：数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p><h4 id="事务的四大特性是什么？"><a href="#事务的四大特性是什么？" class="headerlink" title="事务的四大特性是什么？"></a>事务的四大特性是什么？</h4><ul><li>原子性：原子性是指包含事务的操作要么全部执行成功，要么全部失败回滚。 </li><li>一致性：一致性指事务在执行前后状态是一致的。 </li><li>隔离性：一个事务所进行的修改在最终提交之前，对其他事务是不可见的。 </li><li>持久性：数据一旦提交，其所作的修改将永久地保存到数据库中。 </li></ul><h4 id="数据库的并发一致性问题"><a href="#数据库的并发一致性问题" class="headerlink" title="数据库的并发一致性问题"></a>数据库的并发一致性问题</h4><p>当多个事务并发执行时，可能会出现以下问题：</p><ul><li>脏读：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚了，事务B读取到的数据就成为脏数据了。 </li><li>不可重复读：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交了，导致事务A多次读取到的数据并不一致。 </li><li>幻读：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时发现多了几条数据，和之前读取的数据不一致。 </li><li>丢失修改：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改覆盖了事务A的修改。 </li></ul><p>不可重复度和幻读看起来比较像，它们主要的区别是：在不可重复读中，发现数据不一致主要是数据被更新了。在幻读中，发现数据不一致主要是数据增多或者减少了。</p><h4 id="数据库的隔离级别有哪些？"><a href="#数据库的隔离级别有哪些？" class="headerlink" title="数据库的隔离级别有哪些？"></a>数据库的隔离级别有哪些？</h4><ul><li>未提交读：一个事务在提交前，它的修改对其他事务也是可见的。 </li><li>提交读：一个事务提交之后，它的修改才能被其他事务看到。 </li><li>可重复读：在同一个事务中多次读取到的数据是一致的。 </li><li>串行化：需要加锁实现，会强制事务串行执行。 </li></ul><p>数据库的隔离级别分别可以解决数据库的脏读、不可重复读、幻读等问题。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>提交读</td><td>不允许</td><td>允许</td><td>允许</td></tr><tr><td>可重复读</td><td>不允许</td><td>不允许</td><td>允许</td></tr><tr><td>串行化</td><td>不允许</td><td>不允许</td><td>不允许</td></tr></tbody></table><p><strong>MySQL的默认隔离级别是可重复读。</strong></p><h4 id="隔离级别是如何实现的？"><a href="#隔离级别是如何实现的？" class="headerlink" title="隔离级别是如何实现的？"></a>隔离级别是如何实现的？</h4><p>事务的隔离机制主要是依靠锁机制和MVCC(多版本并发控制)实现的，提交读和可重复读可以通过MVCC实现，串行化可以通过锁机制实现。</p><h4 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h4><p>MVCC(multiple version concurrent control)是一种控制并发的方法，主要用来提高数据库的并发性能。</p><p>在了解MVCC时应该先了解当前读和快照读。</p><ul><li>当前读：读取的是数据库的最新版本，并且在读取时要保证其他事务不会修该当前记录，所以会对读取的记录加锁。 </li><li>快照读：不加锁读取操作即为快照读，使用MVCC来读取快照中的数据，避免加锁带来的性能损耗。 </li></ul><p>可以看到MVCC的作用就是在不加锁的情况下，解决数据库读写冲突问题，并且解决脏读、幻读、不可重复读等问题，但是不能解决丢失修改问题。</p><p>MVCC的实现原理：</p><ul><li><p>版本号</p><p>系统版本号：是一个自增的ID，每开启一个事务，系统版本号都会递增。</p><p>事务版本号：事务版本号就是事务开始时的系统版本号，可以通过事务版本号的大小判断事务的时间顺序。</p></li><li><p>行记录隐藏的列</p><p>DB_ROW_ID：所需空间6byte，隐含的自增ID，用来生成聚簇索引，如果数据表没有指定聚簇索引，InnoDB会利用这个隐藏ID创建聚簇索引。</p><p>DB_TRX_ID：所需空间6byte，最近修改的事务ID，记录创建这条记录或最后一次修改这条记录的事务ID。</p><p>DB_ROLL_PTR：所需空间7byte，回滚指针，指向这条记录的上一个版本。</p><p>它们大致长这样，省略了具体字段的值。·</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/645F5FB8B1503B9EA3849A4BDF315BFD.png" alt="图片说明"></p></li><li><p>undo日志</p><p>MVCC做使用到的快照会存储在Undo日志中，该日志通过回滚指针将一个一个数据行的所有快照连接起来。它们大致长这样。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/9BA0A205B4355751D260B8C4D297AF84.png" alt="图片说明"></p></li></ul><p>举一个简单的例子说明下，比如最开始的某条记录长这样</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/4A47A0DB6E60853DEDFCFDF08A5CA249.png" alt="图片说明"></p><p>现在来了一个事务对他的年龄字段进行了修改，变成了这样</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/FB5C81ED3A220004B71069645F112867.png" alt="图片说明"></p><p>现在又来了一个事务2对它的性别进行了修改，它又变成了这样</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/10FB15C77258A991B0028080A64FB42D.png" alt="图片说明"></p><p>从上面的分析可以看出，事务对同一记录的修改，记录的各个会在Undo日志中连接成一个线性表，在表头的就是最新的旧纪录。</p><p>在重复读的隔离级别下，InnoDB的工作流程：</p><ul><li><p>SELECT</p><p>作为查询的结果要满足两个条件：</p><ol><li>当前事务所要查询的数据行快照的创建版本号必须小于当前事务的版本号，这样做的目的是保证当前事务读取的数据行的快照要么是在当前事务开始前就已经存在的，要么就是当前事务自身插入或者修改过的。 </li><li>当前事务所要读取的数据行快照的删除版本号必须是大于当前事务的版本号，如果是小于等于的话，表示该数据行快照已经被删除，不能读取。 </li></ol></li><li><p>INSERT</p><p>将当前系统版本号作为数据行快照的创建版本号。</p></li><li><p>DELETE</p><p>将当前系统版本号作为数据行快照的删除版本号。</p></li><li><p>UPDATE</p><p>保存当前系统版本号为更新前的数据行快照创建行版本号，并保存当前系统版本号为更新后的数据行快照的删除版本号，其实就是，先删除在插入即为更新。</p></li></ul><p>总结一下，MVCC的作用就是在避免加锁的情况下最大限度解决读写并发冲突的问题，它可以实现提交读和可重复度两个隔离级。</p><h3 id="数据库的锁-＊＊＊"><a href="#数据库的锁-＊＊＊" class="headerlink" title="数据库的锁　＊＊＊"></a>数据库的锁　＊＊＊</h3><h4 id="什么是数据库的锁？"><a href="#什么是数据库的锁？" class="headerlink" title="什么是数据库的锁？"></a>什么是数据库的锁？</h4><p>当数据库有并发事务的时候，保证数据访问顺序的机制称为锁机制。</p><h4 id="数据库的锁与隔离级别的关系？"><a href="#数据库的锁与隔离级别的关系？" class="headerlink" title="数据库的锁与隔离级别的关系？"></a>数据库的锁与隔离级别的关系？</h4><table><thead><tr><th>隔离级别</th><th>实现方式</th></tr></thead><tbody><tr><td>未提交读</td><td>总是读取最新的数据，无需加锁</td></tr><tr><td>提交读</td><td>读取数据时加共享锁，读取数据后释放共享锁</td></tr><tr><td>可重复读</td><td>读取数据时加共享锁，事务结束后释放共享锁</td></tr><tr><td>串行化</td><td>锁定整个范围的键，一直持有锁直到事务结束</td></tr></tbody></table><h4 id="数据库锁的类型有哪些？"><a href="#数据库锁的类型有哪些？" class="headerlink" title="数据库锁的类型有哪些？"></a>数据库锁的类型有哪些？</h4><p>按照锁的粒度可以将MySQL锁分为三种：</p><table><thead><tr><th>MySQL锁类别</th><th>资源开销</th><th>加锁速度</th><th>是否会出现死锁</th><th>锁的粒度</th><th>并发度</th></tr></thead><tbody><tr><td>表级锁</td><td>小</td><td>快</td><td>不会</td><td>大</td><td>低</td></tr><tr><td>行级锁</td><td>大</td><td>慢</td><td>会</td><td>小</td><td>高</td></tr><tr><td>页面锁</td><td>一般</td><td>一般</td><td>不会</td><td>一般</td><td>一般</td></tr></tbody></table><p>MyISAM默认采用表级锁，InnoDB默认采用行级锁。</p><p>从锁的类别上区别可以分为共享锁和排他锁</p><ul><li>共享锁：共享锁又称读锁，简写为S锁，一个事务对一个数据对象加了S锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加S锁，不能加X锁。 </li><li>排他锁：排他锁又称为写锁，简写为X锁，一个事务对一个数据对象加了X锁，可以对这个对象进行读取和更新操作，加锁期间，其他事务不能对该数据对象进行加X锁或S锁。 </li></ul><p>它们的兼容情况如下（不太会用excel，图太丑了）：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/30BFE0930A0D97BAA1D99DD150E3FCD1.png" alt="图片说明"></p><h4 id="MySQL中InnoDB引擎的行锁模式及其是如何实现的？"><a href="#MySQL中InnoDB引擎的行锁模式及其是如何实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁模式及其是如何实现的？"></a>MySQL中InnoDB引擎的行锁模式及其是如何实现的？</h4><p><strong>行锁模式</strong></p><p>在存在行锁和表锁的情况下，一个事务想对某个表加X锁时，需要先检查是否有其他事务对这个表加了锁或对这个表的某一行加了锁，对表的每一行都进行检测一次这是非常低效率的，为了解决这种问题，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，两种意向锁都是表锁。</p><ul><li>意向共享锁：简称IS锁，一个事务打算给数据行加共享锁前必须先获得该表的IS锁。 </li><li>意向排他锁：简称IX锁，一个事务打算给数据行加排他锁前必须先获得该表的IX锁。 </li></ul><p>有了意向锁，一个事务想对某个表加X锁，只需要检查是否有其他事务对这个表加了X/IX/S/IS锁即可。</p><p>锁的兼容性如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/83AD9A58DAAD28E8781CC364F1785EE2.png" alt="图片说明"></p><p>行锁实现方式：INnoDB的行锁是通过给索引上的索引项加锁实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录进行加锁。</p><p>InnoDB行锁主要分三种情况：</p><ul><li>Record lock：对索引项加锁 </li><li>Grap lock：对索引之间的“间隙”、第一条记录前的“间隙”或最后一条后的间隙加锁。 </li><li>Next-key lock：前两种放入组合，对记录及前面的间隙加锁。 </li></ul><p>InnoDB行锁的特性：如果不通过索引条件检索数据，那么InnoDB将对表中所有记录加锁，实际产生的效果和表锁是一样的。</p><p>MVCC不能解决幻读问题，在可重复读隔离级别下，使用MVCC+Next-Key Locks可以解决幻读问题。</p><h4 id="什么是数据库的乐观锁和悲观锁，如何实现？"><a href="#什么是数据库的乐观锁和悲观锁，如何实现？" class="headerlink" title="什么是数据库的乐观锁和悲观锁，如何实现？"></a>什么是数据库的乐观锁和悲观锁，如何实现？</h4><p>乐观锁：系统假设数据的更新在大多数时候是不会产生冲突的，所以数据库只在更新操作提交的时候对数据检测冲突，如果存在冲突，则数据更新失败。</p><p>乐观锁实现方式：一般通过版本号和CAS<a href="">算法</a>实现。</p><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。通俗讲就是每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。</p><p>悲观锁的实现方式：通过数据库的锁机制实现，对查询语句添加for updata。</p><h4 id="什么是死锁？如何避免？"><a href="#什么是死锁？如何避免？" class="headerlink" title="什么是死锁？如何避免？"></a>什么是死锁？如何避免？</h4><p>死锁是指两个或者两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。在MySQL中，MyISAM是一次获得所需的全部锁，要么全部满足，要么等待，所以不会出现死锁。在InnoDB存储引擎中，除了单个SQL组成的事务外，锁都是逐步获得的，所以存在死锁问题。</p><p>如何避免MySQL发生死锁或锁冲突：</p><ul><li>如果不同的程序并发存取多个表，尽量以相同的顺序访问表。</li><li>在程序以批量方式处理数据的时候，如果已经对数据<a href="">排序</a>，尽量保证每个线程按照固定的顺序来处理记录。</li><li>在事务中，如果需要更新记录，应直接申请足够级别的排他锁，而不应该先申请共享锁，更新时在申请排他锁，因为在当前用户申请排他锁时，其他事务可能已经获得了相同记录的共享锁，从而造成锁冲突或者死锁。</li><li>尽量使用较低的隔离级别</li><li>尽量使用索引访问数据，使加锁更加准确，从而减少锁冲突的机会</li><li>合理选择事务的大小，小事务发生锁冲突的概率更低</li><li>尽量用相等的条件访问数据，可以避免Next-Key锁对并发插入的影响。</li><li>不要申请超过实际需要的锁级别，查询时尽量不要显示加锁</li><li>对于一些特定的事务，可以表锁来提高处理速度或减少死锁的概率。</li></ul><h3 id="SQL语句基础知识"><a href="#SQL语句基础知识" class="headerlink" title="SQL语句基础知识"></a>SQL语句基础知识</h3><h4 id="SQL语句主要分为哪几类-＊"><a href="#SQL语句主要分为哪几类-＊" class="headerlink" title="SQL语句主要分为哪几类　＊"></a>SQL语句主要分为哪几类　＊</h4><ul><li>数据据定义语言DDL（Data Definition Language）：主要有CREATE，DROP，ALTER等对逻辑结构有操作的，包括表结构、视图和索引。 </li><li>数据库查询语言DQL（Data Query Language）：主要以SELECT为主 </li><li>数据操纵语言DML（Data Manipulation Language）：主要包括INSERT，UPDATE，DELETE </li><li>数据控制功能DCL（Data Control Language）：主要是权限控制能操作，包括GRANT，REVOKE，COMMIT，ROLLBACK等。 </li></ul><h4 id="SQL约束有哪些？-＊＊"><a href="#SQL约束有哪些？-＊＊" class="headerlink" title="SQL约束有哪些？　＊＊"></a>SQL约束有哪些？　＊＊</h4><ul><li>主键约束：主键为在表中存在一列或者多列的组合，能唯一标识表中的每一行。一个表只有一个主键，并且主键约束的列不能为空。 </li><li>外键约束：外键约束是指用于在两个表之间建立关系，需要指定引用主表的哪一列。只有主表的主键可以被从表用作外键，被约束的从表的列可以不是主键，所以创建外键约束需要先定义主表的主键，然后定义从表的外键。 </li><li>唯一约束：确保表中的一列数据没有相同的值，一个表可以定义多个唯一约束。 </li><li>默认约束：在插入新数据时，如果该行没有指定数据，系统将默认值赋给该行，如果没有设置没默认值，则为NULL。 </li><li>Check约束：Check会通过逻辑表达式来判断数据的有效性，用来限制输入一列或者多列的值的范围。在列更新数据时，输入的内容必须满足Check约束的条件。 </li></ul><h4 id="什么是子查询？-＊＊"><a href="#什么是子查询？-＊＊" class="headerlink" title="什么是子查询？　＊＊"></a>什么是子查询？　＊＊</h4><p>子查询：把一个查询的结果在另一个查询中使用</p><p>子查询可以分为以下几类：</p><ul><li><p>标量子查询：指子查询返回的是一个值，可以使用 =,&gt;,&lt;,&gt;=,&lt;=,&lt;&gt;等操作符对子查询标量结果进行比较，一般子查询会放在比较式的右侧。</p><p><a href="#">复制代码</a></p><p><code>SELECT</code> <code>* ``FROM</code> <code>user</code> <code>WHERE</code> <code>age = (``SELECT</code> <code>max``(age) ``from</code> <code>user``) //查询年纪最大的人</code></p></li><li><p>列子查询：指子查询的结果是n行一列，一般应用于对表的某个字段进行查询返回。可以使用IN、ANY、SOME和ALL等操作符，不能直接使用</p><p><a href="#">复制代码</a></p><p><code>SELECT</code> <code>num1 ``FROM</code> <code>table1 ``WHERE</code> <code>num1 &gt; ``ANY</code> <code>(``SELECT</code> <code>num2 ``FROM</code> <code>table2)</code></p></li><li><p>行子查询：指子查询返回的结果一行n列</p><p><a href="#">复制代码</a></p><p><code>SELECT</code> <code>* ``FROM</code> <code>user</code> <code>WHERE</code> <code>(age,sex) = (``SELECT</code> <code>age,sex ``FROM</code> <code>user</code> <code>WHERE</code> <code>name``=``&quot;zhangsan&quot;``)</code></p></li><li><p>表子查询：指子查询是n行n列的一个数据表</p><p><a href="#">复制代码</a></p><p><code>SELECT</code> <code>* ``FROM</code> <code>student ``WHERE</code> <code>(``name``,age,sex) ``IN</code> <code>(``SELECT</code> <code>name``,age,sex ``FROM</code> <code>class1) //在学生表中找到班级在1班的学生</code></p></li></ul><h4 id="了解MySQL的几种连接查询吗？-＊＊＊"><a href="#了解MySQL的几种连接查询吗？-＊＊＊" class="headerlink" title="了解MySQL的几种连接查询吗？　＊＊＊"></a>了解MySQL的几种连接查询吗？　＊＊＊</h4><p>MySQl的连接查询主要可以分为外连接，内连接，交叉连接</p><ul><li><p>外连接</p><p>外连接主要分为左外连接(LEFT JOIN)、右外连接(RIGHT JOIN)、全外连接。</p><p>左外连接：显示左表中所有的数据及右表中符合条件的数据，右表中不符合条件的数据为null。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/31A7605403B42A797C4D2838845A4C0E.png" alt="图片说明"></p><p>右外连接：显示左表中所有的数据及右表中符合条件的数据，右表中不符合条件的数据为null。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/F266ACF7331F5927C24175458BB90AB5.png" alt="图片说明"></p><p>MySQL中不支持全外连接。</p></li><li><p>内连接：只显示符合条件的数据</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/C0A6AC82B167BDBAAE5E7BB1589B5B64.png" alt="图片说明"></p></li><li><p>交叉连接：使用笛卡尔积的一种连接。</p><p>笛卡尔积，<a href="">百度</a>百科的解释：两个集合<em>X</em>和<em>Y</em>的笛卡尔积表示为<em>X</em> × <em>Y</em>，第一个对象是<em>X</em>的成员而第二个对象是<em>Y</em>的所有可能有序对的其中一个成员 。例如：A={a,b}，B={0,1,2}，A × B = {(a,0)，(a,1)，(a,2)，(b,0)，(b,1)，(b,2)}</p></li></ul><p>举例如下：有两张表分为L表和R表。</p><p>L表</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>a1</td><td>b1</td></tr><tr><td>a2</td><td>b2</td></tr><tr><td>a3</td><td>b3</td></tr></tbody></table><p>R表</p><table><thead><tr><th>B</th><th>C</th></tr></thead><tbody><tr><td>b1</td><td>c1</td></tr><tr><td>b2</td><td>c2</td></tr><tr><td>b4</td><td>c3</td></tr></tbody></table><ul><li><p>左外连接 ：<code>select L.</code><em><code>,R.</code></em><code>from L left join R on L.b=R.b</code></p><table><thead><tr><th>A</th><th>B</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>b1</td><td>c1</td></tr><tr><td>a2</td><td>b2</td><td>b2</td><td>c2</td></tr><tr><td>a3</td><td>b3</td><td>null</td><td>null</td></tr></tbody></table></li><li><p>右外连接：<code>select L.</code><em><code>,R.</code></em><code>from L right join R on L.b=R.b</code></p><table><thead><tr><th>B</th><th>C</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>b1</td><td>c1</td><td>a1</td><td>b1</td></tr><tr><td>b2</td><td>c2</td><td>a2</td><td>b2</td></tr><tr><td>b4</td><td>c3</td><td>null</td><td>null</td></tr></tbody></table></li><li><p>内连接：<code>select L.</code><em><code>,R.</code></em><code>from L inner join R on L.b=R.b</code></p><table><thead><tr><th>A</th><th>B</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>b1</td><td>c1</td></tr><tr><td>a2</td><td>b2</td><td>b2</td><td>c2</td></tr></tbody></table></li><li><p>交叉连接：<code>select L.</code><em><code>,R.</code></em><code>from L,R</code></p><table><thead><tr><th>A</th><th>B</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>b1</td><td>c1</td></tr><tr><td>a1</td><td>b1</td><td>b2</td><td>c2</td></tr><tr><td>a1</td><td>b1</td><td>b4</td><td>c3</td></tr><tr><td>a2</td><td>b2</td><td>b1</td><td>c1</td></tr><tr><td>a2</td><td>b2</td><td>b2</td><td>c2</td></tr><tr><td>a2</td><td>b2</td><td>b4</td><td>c3</td></tr><tr><td>a3</td><td>b3</td><td>b1</td><td>c1</td></tr><tr><td>a3</td><td>b3</td><td>b2</td><td>c2</td></tr><tr><td>a3</td><td>b3</td><td>b4</td><td>c3</td></tr></tbody></table></li></ul><h4 id="mysql中in和exists的区别？-＊＊"><a href="#mysql中in和exists的区别？-＊＊" class="headerlink" title="mysql中in和exists的区别？　＊＊"></a>mysql中in和exists的区别？　＊＊</h4><p>in和exists一般用于子查询。</p><ul><li>使用exists时会先进行外表查询，将查询到的每行数据带入到内表查询中看是否满足条件；使用in一般会先进行内表查询获取结果集，然后对外表查询匹配结果集，返回数据。 </li><li>in在内表查询或者外表查询过程中都会用到索引。 </li><li>exists仅在内表查询时会用到索引 </li><li>一般来说，当子查询的结果集比较大，外表较小使用exist效率更高；当子查询寻得结果集较小，外表较大时，使用in效率更高。 </li><li>对于not in和not exists，not exists效率比not in的效率高，与子查询的结果集无关，因为not in对于内外表都进行了全表扫描，没有使用到索引。not exists的子查询中可以用到表上的索引。 </li></ul><h4 id="varchar和char的区别？-＊＊＊"><a href="#varchar和char的区别？-＊＊＊" class="headerlink" title="varchar和char的区别？　＊＊＊"></a>varchar和char的区别？　＊＊＊</h4><ul><li>varchar表示变长，char表示长度固定。当所插入的字符超过他们的长度时，在严格模式下，会拒绝插入并提示错误信息，在一般模式下，会截取后插入。如char(5)，无论插入的字符长度是多少，长度都是5，插入字符长度小于5，则用空格补充。对于varchar(5)，如果插入的字符长度小于5，则存储的字符长度就是插入字符的长度，不会填充。 </li><li>存储容量不同，对于char来说，最多能存放的字符个数为255。对于varchar，最多能存放的字符个数是65532。 </li><li>存储速度不同，char长度固定，存储速度会比varchar快一些，但在空间上会占用额外的空间，属于一种空间换时间的策略。而varchar空间利用率会高些，但存储速度慢，属于一种时间换空间的策略。 </li></ul><h4 id="MySQL中int-10-和char-10-和varchar-10-的区别？-＊＊＊"><a href="#MySQL中int-10-和char-10-和varchar-10-的区别？-＊＊＊" class="headerlink" title="MySQL中int(10)和char(10)和varchar(10)的区别？　＊＊＊"></a>MySQL中int(10)和char(10)和varchar(10)的区别？　＊＊＊</h4><p>int(10)中的10表示的是显示数据的长度，而char(10)和varchar(10)表示的是存储数据的大小。</p><h4 id="drop、delete和truncate的区别？-＊＊"><a href="#drop、delete和truncate的区别？-＊＊" class="headerlink" title="drop、delete和truncate的区别？　＊＊"></a>drop、delete和truncate的区别？　＊＊</h4><table><thead><tr><th>drop</th><th>delete</th><th>truncate</th><th></th></tr></thead><tbody><tr><td>速度</td><td>快</td><td>逐行删除，慢</td><td>较快</td></tr><tr><td>类型</td><td>DDL</td><td>DML</td><td>DDL</td></tr><tr><td>回滚</td><td>不可回滚</td><td>可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>删除整个表，数据行、索引都会被删除</td><td>表结构还在，删除表的一部分或全部数据</td><td>表结构还在，删除表的全部数据</td></tr></tbody></table><p>一般来讲，删除整个表，使用drop，删除表的部分数据使用delete，保留表结构删除表的全部数据使用truncate。</p><h4 id="UNION和UNION-ALL的区别？-＊＊"><a href="#UNION和UNION-ALL的区别？-＊＊" class="headerlink" title="UNION和UNION ALL的区别？　＊＊"></a>UNION和UNION ALL的区别？　＊＊</h4><p>union和union all的作用都是将两个结果集合并到一起。</p><ul><li>union会对结果去重并<a href="">排序</a>，union all直接直接返回合并后的结果，不去重也不进行<a href="">排序</a>。 </li><li>union all的性能比union性能好。 </li></ul><h4 id="什么是临时表，什么时候会使用到临时表，什么时候删除临时表？-＊"><a href="#什么是临时表，什么时候会使用到临时表，什么时候删除临时表？-＊" class="headerlink" title="什么是临时表，什么时候会使用到临时表，什么时候删除临时表？　＊"></a>什么是临时表，什么时候会使用到临时表，什么时候删除临时表？　＊</h4><p>MySQL在执行SQL语句的时候会临时创建一些存储中间结果集的表，这种表被称为临时表，临时表只对当前连接可见，在连接关闭后，临时表会被删除并释放空间。</p><p>临时表主要分为内存临时表和磁盘临时表两种。内存临时表使用的是MEMORY存储引擎，磁盘临时表使用的是MyISAM存储引擎。</p><p>一般在以下几种情况中会使用到临时表：</p><ul><li>FROM中的子查询 </li><li>DISTINCT查询并加上ORDER BY </li><li>ORDER BY和GROUP BY的子句不一样时会产生临时表 </li><li>使用UNION查询会产生临时表 </li></ul><h4 id="大表数据查询如何进行优化？-＊＊＊"><a href="#大表数据查询如何进行优化？-＊＊＊" class="headerlink" title="大表数据查询如何进行优化？　＊＊＊"></a>大表数据查询如何进行优化？　＊＊＊</h4><ul><li>索引优化 </li><li>SQL语句优化 </li><li>水平拆分 </li><li>垂直拆分 </li><li>建立中间表 </li><li>使用缓存技术 </li><li>固定长度的表访问起来更快 </li><li>越小的列访问越快 </li></ul><h4 id="了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？-＊＊＊"><a href="#了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？-＊＊＊" class="headerlink" title="了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？　＊＊＊"></a>了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？　＊＊＊</h4><p>慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志。</p><p>相关参数：</p><ul><li>slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。 </li><li>slow_query_log_file：MySQL数据库慢查询日志存储路径。 </li><li>long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。 </li><li>log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。 </li><li>log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE”表示将日志存入数据库。 </li></ul><p>如何对慢查询进行优化？</p><ul><li>分析语句的执行计划，查看SQL语句的索引是否命中 </li><li>优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。 </li><li>优化LIMIT分页。 </li></ul><h4 id="为什么要设置主键？-＊＊"><a href="#为什么要设置主键？-＊＊" class="headerlink" title="为什么要设置主键？　＊＊"></a>为什么要设置主键？　＊＊</h4><p>主键是唯一区分表中每一行的唯一标识，如果没有主键，更新或者删除表中特定的行会很困难，因为不能唯一准确地标识某一行。</p><h4 id="主键一般用自增ID还是UUID？-＊＊"><a href="#主键一般用自增ID还是UUID？-＊＊" class="headerlink" title="主键一般用自增ID还是UUID？　＊＊"></a>主键一般用自增ID还是UUID？　＊＊</h4><p>使用自增ID的好处：</p><ul><li>字段长度较uuid会小很多。 </li><li>数据库自动编号，按顺序存放，利于检索 </li><li>无需担心主键重复问题 </li></ul><p>使用自增ID的缺点：</p><ul><li>因为是自增，在某些业务场景下，容易被其他人查到业务量。 </li><li>发生数据迁移时，或者表合并时会非常麻烦 </li><li>在高并发的场景下，竞争自增锁会降低数据库的吞吐能力 </li></ul><p>UUID：通用唯一标识码，UUID是基于当前时间、计数器和硬件标识等数据计算生成的。</p><p>使用UUID的优点：</p><ul><li>唯一标识，不会考虑重复问题，在数据拆分、合并时也能达到全局的唯一性。 </li><li>可以在应用层生成，提高数据库的吞吐能力。 </li><li>无需担心业务量泄露的问题。 </li></ul><p>使用UUID的缺点：</p><ul><li>因为UUID是随机生成的，所以会发生随机IO，影响插入速度，并且会造成硬盘的使用率较低。 </li><li>UUID占用空间较大，建立的索引越多，造成的影响越大。 </li><li>UUID之间比较大小较自增ID慢不少，影响查询速度。 </li></ul><p>最后说下结论，一般情况MySQL推荐使用自增ID。因为在MySQL的InnoDB存储引擎中，主键索引是一种聚簇索引，主键索引的B+树的叶子节点按照顺序存储了主键值及数据，如果主键索引是自增ID，只需要按顺序往后排列即可，如果是UUID，ID是随机生成的，在数据插入时会造成大量的数据移动，产生大量的内存碎片，造成插入性能的下降。</p><h4 id="字段为什么要设置成not-null-＊＊"><a href="#字段为什么要设置成not-null-＊＊" class="headerlink" title="字段为什么要设置成not null?　＊＊"></a>字段为什么要设置成not null?　＊＊</h4><p>首先说一点，NULL和空值是不一样的，空值是不占用空间的，而NULL是占用空间的，所以字段设为NOT NULL后仍然可以插入空值。</p><p>字段设置成not null主要有以下几点原因：</p><ul><li><p>NULL值会影响一些函数的统计，如count，遇到NULL值，这条记录不会统计在内。</p></li><li><p>B树不存储NULL，所以索引用不到NULL，会造成第一点中说的统计不到的问题。</p></li><li><p>NOT IN子查询在有NULL值的情况下返回的结果都是空值。</p><p>例如user表如下</p><table><thead><tr><th>id</th><th>username</th></tr></thead><tbody><tr><td>0</td><td>zhangsan</td></tr><tr><td>1</td><td>lisi</td></tr><tr><td>2</td><td>null</td></tr></tbody></table><p><code>select * from</code>user<code>where username NOT IN (select username from</code>user<code>where id != 0)</code>，这条查询语句应该查到zhangsan这条数据，但是结果显示为null。</p></li><li><p>MySQL在进行比较的时候，NULL会参与字段的比较，因为NULL是一种比较特殊的数据类型，数据库在处理时需要进行特数处理，增加了数据库处理记录的复杂性。</p></li></ul><h4 id="如何优化查询过程中的数据访问？-＊＊＊"><a href="#如何优化查询过程中的数据访问？-＊＊＊" class="headerlink" title="如何优化查询过程中的数据访问？　＊＊＊"></a>如何优化查询过程中的数据访问？　＊＊＊</h4><p>从减少数据访问方面考虑：</p><ul><li>正确使用索引，尽量做到索引覆盖 </li><li>优化SQL执行计划 </li></ul><p>从返回更少的数据方面考虑：</p><ul><li>数据分页处理 </li><li>只返回需要的字段 </li></ul><p>从减少服务器CPU开销方面考虑：</p><ul><li>合理使用<a href="">排序</a></li><li>减少比较的操作 </li><li>复杂运算在客户端处理 </li></ul><p>从增加资源方面考虑：</p><ul><li>客户端多进程并行访问 </li><li>数据库并行处理 </li></ul><h4 id="如何优化长难的查询语句？-＊＊"><a href="#如何优化长难的查询语句？-＊＊" class="headerlink" title="如何优化长难的查询语句？　＊＊"></a>如何优化长难的查询语句？　＊＊</h4><ul><li>将一个大的查询分解为多个小的查询 </li><li>分解关联查询，使缓存的效率更高 </li></ul><h4 id="如何优化LIMIT分页？-＊＊"><a href="#如何优化LIMIT分页？-＊＊" class="headerlink" title="如何优化LIMIT分页？　＊＊"></a>如何优化LIMIT分页？　＊＊</h4><ul><li>在LIMIT偏移量较大的时候，查询效率会变低，可以记录每次取出的最大ID，下次查询时可以利用ID进行查询</li><li>建立复合索引</li></ul><h4 id="如何优化UNION查询-＊＊"><a href="#如何优化UNION查询-＊＊" class="headerlink" title="如何优化UNION查询　＊＊"></a>如何优化UNION查询　＊＊</h4><p>如果不需要对结果集进行去重或者<a href="">排序</a>建议使用UNION ALL，会好一些。</p><h4 id="如何优化WHERE子句-＊＊＊"><a href="#如何优化WHERE子句-＊＊＊" class="headerlink" title="如何优化WHERE子句　＊＊＊"></a>如何优化WHERE子句　＊＊＊</h4><ul><li>不要在where子句中使用!=和&lt;&gt;进行不等于判断，这样会导致放弃索引进行全表扫描。 </li><li>不要在where子句中使用null或空值判断，尽量设置字段为not null。 </li><li>尽量使用union all代替or </li><li>在where和order by涉及的列建立索引 </li><li>尽量减少使用in或者not in，会进行全表扫描 </li><li>在where子句中使用参数会导致全表扫描 </li><li>避免在where子句中对字段及进行表达式或者函数操作会导致存储引擎放弃索引进而全表扫描 </li></ul><h4 id="SQL语句执行的很慢原因是什么？-＊＊＊"><a href="#SQL语句执行的很慢原因是什么？-＊＊＊" class="headerlink" title="SQL语句执行的很慢原因是什么？　＊＊＊"></a>SQL语句执行的很慢原因是什么？　＊＊＊</h4><ul><li>如果SQL语句只是偶尔执行很慢，可能是执行的时候遇到了锁，也可能是redo log日志写满了，要将redo log中的数据同步到磁盘中去。 </li><li>如果SQL语句一直都很慢，可能是字段上没有索引或者字段有索引但是没用上索引。 </li></ul><h4 id="SQL语句的执行顺序-＊"><a href="#SQL语句的执行顺序-＊" class="headerlink" title="SQL语句的执行顺序?　＊"></a>SQL语句的执行顺序?　＊</h4><p><a href="#">复制代码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT&#96; &#96;DISTINCT&#96;   &#96;select_list &#96;&#96;FROM&#96;   &#96;left_table &#96;&#96;LEFT&#96; &#96;JOIN&#96;   &#96;right_table &#96;&#96;ON&#96; &#96;join_condition &#96;&#96;WHERE&#96;   &#96;where_condition &#96;&#96;GROUP&#96; &#96;BY&#96;   &#96;group_by_list &#96;&#96;HAVING&#96;   &#96;having_condition &#96;&#96;ORDER&#96; &#96;BY&#96;   &#96;order_by_condition</span><br></pre></td></tr></table></figure><p>执行顺序如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/351AE2E2E22880A46A74F2843EC675F5.png" alt="图片说明"></p><ul><li>FROM：对SQL语句执行查询时，首先对关键字两边的表以笛卡尔积的形式执行连接，并产生一个虚表V1。虚表就是视图，数据会来自多张表的执行结果。</li><li>ON：对FROM连接的结果进行ON过滤,并创建虚表V2</li><li>JOIN：将ON过滤后的左表添加进来，并创建新的虚拟表V3</li><li>WHERE：对虚拟表V3进行WHERE筛选，创建虚拟表V4</li><li>GROUP BY：对V4中的记录进行分组操作，创建虚拟表V5</li><li>HAVING：对V5进行过滤，创建虚拟表V6</li><li>SELECT：将V6中的结果按照SELECT进行筛选，创建虚拟表V7</li><li>DISTINCT：对V7表中的结果进行去重操作，创建虚拟表V8，如果使用了GROUP BY子句则无需使用DISTINCT，因为分组的时候是将列中唯一的值分成一组，并且每组只返回一行记录，所以所有的记录都h是不同的。</li><li>ORDER BY：对V8表中的结果进行<a href="">排序</a>。</li></ul><h3 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h3><h4 id="大表如何优化？-＊＊＊"><a href="#大表如何优化？-＊＊＊" class="headerlink" title="大表如何优化？　＊＊＊"></a>大表如何优化？　＊＊＊</h4><ul><li>限定数据的范围：避免不带任何限制数据范围条件的查询语句。 </li><li>读写分离：主库负责写，从库负责读。 </li><li>垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。 </li><li>水平分表：在同一个数据库内，把一个表的数据按照一定规则拆分到多个表中。 </li><li>对单表进行优化：对表中的字段、索引、查询SQL进行优化。 </li><li>添加缓存 </li></ul><h4 id="什么是垂直分表、垂直分库、水平分表、水平分库？-＊＊＊"><a href="#什么是垂直分表、垂直分库、水平分表、水平分库？-＊＊＊" class="headerlink" title="什么是垂直分表、垂直分库、水平分表、水平分库？　＊＊＊"></a>什么是垂直分表、垂直分库、水平分表、水平分库？　＊＊＊</h4><p>垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。一般会将常用的字段放到一个表中，将不常用的字段放到另一个表中。</p><p>垂直分表的优势：</p><ul><li>避免IO竞争减少锁表的概率。因为大的字段效率更低，第一数据量大，需要的读取时间长。第二，大字段占用的空间更大，单页内存储的行数变少，会使得IO操作增多。</li><li>可以更好地提升热门数据的查询效率。</li></ul><p>垂直分库：按照业务对表进行分类，部署到不同的数据库上面，不同的数据库可以放到不同的服务器上面。</p><p>垂直分库的优势：</p><ul><li>降低业务中的耦合，方便对不同的业务进行分级管理。 </li><li>可以提升IO、数据库连接数、解决单机硬件资源的瓶颈问题。 </li></ul><p>垂直拆分（分库、分表）的缺点：</p><ul><li>主键出现冗余，需要管理冗余列 </li><li>事务的处理变得复杂 </li><li>仍然存在单表数据量过大的问题 </li></ul><p>水平分表：在同一个数据库内，把同一个表的数据按照一定规则拆分到多个表中。</p><p>水平分表的优势：</p><ul><li>解决了单表数据量过大的问题 </li><li>避免IO竞争并减少锁表的概率 </li></ul><p>水平分库：把同一个表的数据按照一定规则拆分到不同的数据库中，不同的数据库可以放到不同的服务器上。</p><p>水平分库的优势：</p><ul><li>解决了单库大数据量的瓶颈问题 </li><li>IO冲突减少，锁的竞争减少，某个数据库出现问题不影响其他数据库（可用性），提高了系统的稳定性和可用性 </li></ul><p>水平拆分（分表、分库）的缺点：</p><ul><li>分片事务一致性难以解决 </li><li>跨节点JOIN性能差，逻辑会变得复杂 </li><li>数据扩展难度大，不易维护 </li></ul><p>在系统设计时应根据业务耦合来确定垂直分库和垂直分表的方案，在数据访问压力不是特别大时应考虑缓存、读写分离等方法，若数据量很大，或持续增长可考虑水平分库分表，水平拆分所涉及的逻辑比较复杂，常见的方案有客户端架构和恶代理架构。</p><h4 id="分库分表后，ID键如何处理？-＊＊＊"><a href="#分库分表后，ID键如何处理？-＊＊＊" class="headerlink" title="分库分表后，ID键如何处理？　＊＊＊"></a>分库分表后，ID键如何处理？　＊＊＊</h4><p>分库分表后不能每个表的ID都是从1开始，所以需要一个全局ID，设置全局ID主要有以下几种方法：</p><ul><li><p>UUID：优点：本地生成ID，不需要远程调用；全局唯一不重复。缺点：占用空间大，不适合作为索引。</p></li><li><p>数据库自增ID：在分库分表表后使用数据库自增ID，需要一个专门用于生成主键的库，每次服务接收到请求，先向这个库中插入一条没有意义的数据，获取一个数据库自增的ID，利用这个ID去分库分表中写数据。优点：简单易实现。缺点：在高并发下存在瓶颈。系统结构如下图（图片来源于网络）</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/6586A5077D34DE1267461D166FE412F9.png" alt="图片说明"></p></li><li><p>Redis生成ID：优点：不依赖数据库，性能比较好。缺点：引入新的组件会使得系统复杂度增加</p></li><li><p>Twitter的snowflake<a href="">算法</a>：是一个64位的long型的ID，其中有1bit是不用的，41bit作为毫秒数，10bit作为工作机器ID，12bit作为序列号。</p><p>1bit：第一个bit默认为0，因为二进制中第一个bit为1的话为负数，但是ID不能为负数.</p><p>41bit：表示的是时间戳，单位是毫秒。</p><p>10bit：记录工作机器ID，其中5个bit表示机房ID，5个bit表示机器ID。</p><p>12bit：用来记录同一毫秒内产生的不同ID。</p></li><li><p><a href="">美团</a>的Leaf分布式ID生成系统，<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">美团点评分布式ID生成系统</a></p></li></ul><h4 id="MySQL的复制原理及流程？如何实现主从复制？-＊＊＊"><a href="#MySQL的复制原理及流程？如何实现主从复制？-＊＊＊" class="headerlink" title="MySQL的复制原理及流程？如何实现主从复制？　＊＊＊"></a>MySQL的复制原理及流程？如何实现主从复制？　＊＊＊</h4><p>MySQL复制：为保证主服务器和从服务器的数据一致性，在向主服务器插入数据后，从服务器会自动将主服务器中修改的数据同步过来。</p><p>主从复制的原理：</p><p>主从复制主要有三个线程：binlog线程，I/O线程，SQL线程。</p><ul><li>binlog线程：负责将主服务器上的数据更改写入到二进制日志（Binary log）中。 </li><li>I/O线程：负责从主服务器上读取二进制日志（Binary log），并写入从服务器的中继日志（Relay log）中。 </li><li>SQL线程：负责读取中继日志，解析出主服务器中已经执行的数据更改并在从服务器中重放 </li></ul><p>复制过程如下（图片来源于网络）：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/E8FDAF1ABF59E596BD35B262F933C4D1.jpeg" alt="图片说明"></p><ol><li>Master在每个事务更新数据完成之前，将操作记录写入到binlog中。 </li><li>Slave从库连接Master主库，并且Master有多少个Slave就会创建多少个binlog dump线程。当Master节点的binlog发生变化时，binlog dump会通知所有的Slave，并将相应的binlog发送给Slave。 </li><li>I/O线程接收到binlog内容后，将其写入到中继日志（Relay log）中。 </li><li>SQL线程读取中继日志，并在从服务器中重放。 </li></ol><p>这里补充一个通俗易懂的图。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/464F14CF483B16A8E405700C72FC1A44.png" alt="图片说明"></p><p>主从复制的作用：</p><ul><li>高可用和故障转移 </li><li>负载均衡 </li><li>数据备份 </li><li>升级测试 </li></ul><h4 id="了解读写分离吗？-＊＊＊"><a href="#了解读写分离吗？-＊＊＊" class="headerlink" title="了解读写分离吗？　＊＊＊"></a>了解读写分离吗？　＊＊＊</h4><p>读写分离主要依赖于主从复制，主从复制为读写分离服务。</p><p>读写分离的优势：</p><ul><li>主服务器负责写，从服务器负责读，缓解了锁的竞争 </li><li>从服务器可以使用MyISAM，提升查询性能及节约系统开销 </li><li>增加冗余，提高可用性</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作者：捏捏小肥脸&lt;br&gt;链接：&lt;a href=&quot;https://www.nowcoder.com/discuss/735199?channel=-1&amp;amp;source_id=profile_follow_post_nctrack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/discuss/735199?channel=-1&amp;amp;source_id=profile_follow_post_nctrack&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>日记_0242</title>
    <link href="https://xwjahahahaha.github.io/2021/11/07/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0242/"/>
    <id>https://xwjahahahaha.github.io/2021/11/07/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0242/</id>
    <published>2021-11-07T05:09:51.000Z</published>
    <updated>2021-11-07T14:02:44.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经<ul><li><input checked="" disabled="" type="checkbox"> go携程与调度模型</li></ul></li><li><input disabled="" type="checkbox"> 下午：刷leetcode</li><li><input checked="" disabled="" type="checkbox"> 晚上：做项目<ul><li><input checked="" disabled="" type="checkbox"> 第二章基本结束</li></ul></li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>12-runtime-1-goroutine原理</title>
    <link href="https://xwjahahahaha.github.io/2021/11/06/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/12-runtime-1-goroutine%E5%8E%9F%E7%90%86/"/>
    <id>https://xwjahahahaha.github.io/2021/11/06/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/12-runtime-1-goroutine%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-06T06:37:41.000Z</published>
    <updated>2021-11-09T05:33:40.511Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/69554144#:~:text=用户态就是提供应,，内存，I%2FO%E3%80%82" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69554144#:~:text=用户态就是提供应,，内存，I%2FO%E3%80%82</a></li><li><a href="https://zhuanlan.zhihu.com/p/342119843" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/342119843</a></li><li>极客时间《go进阶训练营》</li></ul></blockquote><p>[TOC]</p><a id="more"></a><h1 id="一、goroutine原理"><a href="#一、goroutine原理" class="headerlink" title="一、goroutine原理"></a>一、goroutine原理</h1><h2 id="1-1-Goroutine"><a href="#1-1-Goroutine" class="headerlink" title="1.1 Goroutine"></a>1.1 Goroutine</h2><h3 id="1-用户态与内核态"><a href="#1-用户态与内核态" class="headerlink" title="1. 用户态与内核态"></a>1. 用户态与内核态</h3><p>linux的系统架构如下图：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/4J34Ry.png" alt="4J34Ry" style="zoom:50%;" /><p>用户态或者内核态可以理解为用户应用程序空间与内核空间。</p><p>内核态就是内核，是一套在硬件之上应用程序之下的一套软件程序，管理系统的cpu调度、内存资源等重要服务。</p><p>用户态就是提供应用程序运行的空间，为了使一些特定的应用程序访问到内核管理的资源（CPU、内存等）要通过系统调用调用内核提供的一些通用的访问接口。</p><p>库函数就是为了屏蔽这些复杂的系统调用，为程序员提供的更为方便的函数上层封装接口，例如：open(), write(), read()等等。</p><p><strong>goroutine运行在用户态</strong></p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/acomlz.png" alt="acomlz" style="zoom: 40%;" /><h3 id="2-goroutine定义"><a href="#2-goroutine定义" class="headerlink" title="2. goroutine定义"></a>2. goroutine定义</h3><p>“Goroutine 是一个与其他 goroutines 并行运行在同一地址空间的 Go 函数或方法。一个运行的程序由一个或更多个 goroutine 组成。它与线程、协程、进程等不同。它是一个 goroutine” —— Rob Pike</p><p>Goroutines 在同一个用户地址空间里并行独立执行 functions，channels 则用于 goroutines 间的<strong>通信</strong>和<strong>同步</strong>访问控制。</p><h3 id="3-goroutine与thread的区别"><a href="#3-goroutine与thread的区别" class="headerlink" title="3. goroutine与thread的区别"></a>3. goroutine与thread的区别</h3> <img src="http://xwjpics.gumptlu.work/qinniu_uPic/p1YMfn.png" alt="p1YMfn" style="zoom: 50%;" /><ul><li><p>内存占用</p><p>创建一个 goroutine 的栈内存消耗为 <strong>2 KB</strong>(Linux AMD64 Go v1.4后)，运行过程中，<strong>如果栈空间不够用，会自动进行扩容</strong>。<br>创建一个 thread 为了尽量避免极端情况下操作系统线程栈的溢出，默认会为其分配一个较大的栈内存( 1 - 8 MB 栈内存，线程标准 POSIX Thread)，而且还需要一个被称为 “guard page” 的区域用于和其他 thread 的栈空间进行隔离。而栈内存空间一旦创建和初始化完成之后其大小就不能再有变化，这决定了在某些特殊场景下系统线程栈还是有溢出的风险。</p></li><li><p>创建/销毁</p><p>线程创建和销毀都会有巨大的消耗，是<strong>内核级的交互(trap)</strong>。<br>POSIX 线程(定义了创建和操纵线程的一套 API)通常是在已有的进程模型中增加的逻辑扩展，所以线程控制和进程控制很相似。而进入内核调度所消耗的性能代价比较高，开销较大。<strong>goroutine 是用户态线程</strong>，是由 goruntime 管理，创建和销毁的消耗非常小。</p></li><li><p>调度切换</p><p>抛开陷入内核，线程切换会消耗 1000-1500 纳秒(上下文保存成本高，较多寄存器，公平性，复杂时间计算统计)，一个纳秒平均可以执行 12-18 条指令。所以由于线程切换，执行指令的条数会减少 12000-18000。goroutine 的切换约为 200 ns(用户态、3个寄存器)，相当于 2400-3600 条指令。因此，goroutines 切换成本比 threads 要小得多。</p></li><li><p>复杂性<br>线程的创建和退出复杂，多个thread间通讯复杂(share memory)。不能大量创建线程(参考早期的 httpd)，成本高，使用网络多路复用，存在大量callback(参考twemproxy、nginx 的代码)。对于应用服务线程门槛高，例如需要做第三方库隔离，需要考虑引入线程池等。</p></li></ul><h3 id="4-M-N模型"><a href="#4-M-N模型" class="headerlink" title="4. M:N模型"></a>4. M:N模型</h3><img src="http://xwjpics.gumptlu.work/qinniu_uPic/aW228R.png" alt="aW228R" style="zoom:50%;" /><p>Go 创建 M 个线程(CPU 执行调度的单元，内核的 task_struct)，之后创建的 N 个 goroutine 都会依附在这 M 个线程上执行，即 M:N 模型。它们能够同时运行，与线程类似，但相比之下非常轻量。因此，程序运行时，Goroutines 的个数应该是远大于线程的个数的（phread 是内核线程？）。</p><p><strong>同一个时刻，一个线程只能跑一个 goroutine。</strong>当 goroutine 发生阻塞 (chan 阻塞、mutex、syscall 等等) 时，Go 会把当前的 goroutine 调度走，让其他 goroutine 来继续执行，而不是让线程阻塞休眠，尽可能多的分发任务出去，让 CPU 忙。</p><h2 id="1-2-GMP调度模型"><a href="#1-2-GMP调度模型" class="headerlink" title="1.2 GMP调度模型"></a>1.2 GMP调度模型</h2><h3 id="1-GMP概念"><a href="#1-GMP概念" class="headerlink" title="1. GMP概念"></a>1. GMP概念</h3><p><strong>G：</strong> goroutine 的缩写，每次 go func() 都代表一个 G，无限制。使用 struct runtime.g，包含了当前 goroutine 的状态、堆栈、上下文。</p><p><strong>M：</strong>工作线程(OS thread)也被称为 Machine，使用 struct runtime.m，所有 M 是有线程栈的（独自的栈）。如果不对该线程栈提供内存的话，系统会给该线程栈提供内存(不同操作系统提供的线程栈大小不同)。<strong>当指定了线程栈，则 M.stack→G.stack（将线程的栈指向goroutine的栈），M 的 PC 寄存器指向 G 提供的函数，然后去执行，执行完毕后又会回到线程栈。</strong></p><p>其中找寻可用的goroutine栈的代码就是g0，找寻代码运行在线程自己的栈上</p><p><strong>P：</strong>？</p><h3 id="2-GM调度器"><a href="#2-GM调度器" class="headerlink" title="2. GM调度器"></a>2. GM调度器</h3><p>早期的调度模型，Go 1.2前的调度器实现，限制了 Go 并发程序的伸缩性，尤其是对那些有高吞吐或并行计算需求的服务程序。</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211106161429689.png" style="zoom:50%;" /><blockquote><p><font color='#39b54a'>把所有的G都放到一个全局队列中，这个队列的访问需要锁机制，每个线程M从其中获得一个G然后执行。锁的机制让进程访问的过程中还是有阻塞等待的情况</font></p></blockquote><p>每个 goroutine 对应于 runtime 中的一个抽象结构：G，而 thread 作为“物理 CPU”的存在而被抽象为一个结构：M(machine)。</p><p>当 goroutine 调用了一个阻塞的系统调用，运行这个 goroutine 的线程就会被阻塞，这时至少应该再创建一个线程来运行别的没有阻塞的 goroutine。线程这里可以创建不止一个，可以按需不断地创建，而活跃的线程（处于非阻塞状态的线程）的最大个数存储在变量 GOMAXPROCS中。</p><p>问题分析：</p><ul><li><p><strong>单一全局互斥锁(Sched.Lock)和集中状态存储</strong></p><pre><code>导致所有 goroutine 相关操作，比如：创建、结束、重新调度等都要上锁。</code></pre></li><li><p><strong>Goroutine 亲缘性问题</strong><br> 刚创建的 G 放到了全局队列，而不是本地 M 执行，被其他M抢占，亲缘性不好。</p></li><li><p><strong>Per-M 持有内存缓存 (M.mcache)</strong></p><pre><code>每个 M 持有 mcache 和 stack alloc，然而只有在 M 运行 Go 代码时才需要使用的内存(每个 mcache 可以高达2mb)，当 M 在处于 syscall 时并不需要。运行 Go 代码和阻塞在 syscall 的 M 的比例高达1:100，造成了很大的浪费。同时内存亲缘性也较差。G 当前在 M运 行后对 M 的内存进行了预热，因为现在 G 调度到同一个 M 的概率不高，数据局部性不好。</code></pre></li><li><p><strong>严重的线程阻塞/解锁</strong></p><pre><code>在系统调用的情况下，工作线程经常被阻塞和取消阻塞，这增加了很多开销。比如 M 找不到G，此时 M 就会进入频繁阻塞/唤醒来进行检查的逻辑，以便及时发现新的 G 来执行。在GM模型中，当M没有任务后会休眠，一旦有新的G再唤醒，这样的不断的休眠唤醒效率很低（后面就添加了M自旋）</code></pre><blockquote><p>by Dmitry Vyukov “Scalable Go Scheduler Design Doc”</p></blockquote></li></ul><h3 id="3-GMP概念"><a href="#3-GMP概念" class="headerlink" title="3. GMP概念"></a>3. GMP概念</h3><p>P： “Processor”是一个抽象的概念，并不是真正的物理 CPU。</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/llOn2F-20211106165131708.png" style="zoom:50%;" /><p>Dmitry Vyukov的方案是引入一个结构 P，它代表了 M 所需的<strong>上下文环境</strong>，也是处理用户级代码逻辑的<strong>处理器</strong>。它负责衔接 M 和 G 的调度上下文，将等待执行的 G 与 M 对接。当 P 有任务时需要创建或者唤醒一个 M 来执行它队列里的任务。所以 <strong>P/M 需要进行绑定，构成一个执行单元</strong>。<strong>P 决定了并行任务的数量，可通过 runtime.GOMAXPROCS 来设定</strong>。在 <u>Go1.5 之后GOMAXPROCS 被默认设置可用的核数</u>，而之前则默认为1。</p><blockquote><p><font color='#39b54a'>P可以理解为一个本地队列，作为本地缓存，防止频繁的访问全局队列</font></p></blockquote><blockquote><p>docker中的一个坑：创建的docker会自动设置为宿主机的核数，导致多个docker创建后过多的使用cpu</p><p>解决方法：</p><p>Tips: <a href="https://github.com/uber-go/automaxprocs" target="_blank" rel="noopener">https://github.com/uber-go/automaxprocs</a><br>Automatically set GOMAXPROCS to match Linux container CPU quota.</p></blockquote><p>mcache 等从 M 移到了 P，而 G 队列也被分成两类，保留全局 G 队列，同时每个 P 中都会有一个本地的 G 队列。</p><p>引入了 local queue，因为 P 的存在，runtime 并不需要做一个集中式的 goroutine 调度，每一个 M 都会在 P’s local queue、global queue 或者<strong>其他 P 队列中找 G 执行</strong>，减少全局锁对性能的影响。<strong>这也是 GMP Work-stealing 调度算法的核心</strong>。</p><blockquote><p><font color='#e54d42'>注意，虽然P与M一一绑定，但是M仍然可能会去其他P的队列中寻找G，所以P的本地队列也面临着并发访问的问题</font></p></blockquote><p>注意 P 的本地 G 队列还是可能面临一个并发访问的场景，为了避免加锁，这里 P 的本地队列是一个 LockFree的队列，窃取 G 时使用 CAS 原子操作来完成。关于LockFree 和 CAS 的知识参见 Lock-Free。</p><h2 id="1-3-Goroutine-Lifecycle生命周期"><a href="#1-3-Goroutine-Lifecycle生命周期" class="headerlink" title="1.3 Goroutine Lifecycle生命周期"></a>1.3 Goroutine Lifecycle生命周期</h2><h3 id="1-go程序启动"><a href="#1-go程序启动" class="headerlink" title="1. go程序启动"></a>1. go程序启动</h3><p><strong>runtime.GOMAXPROCS 指定了P的数量，M的数量可能大于等于P，可以把P的数量理解为并行数</strong></p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/B3phMQ.png" alt="B3phMQ" style="zoom: 23%;" /><p>启动的步骤如下：</p><ol start="0"><li><p>整个程序始于一段汇编，而在随后的<code>runtime·rt0_go</code>（也是汇编程序）中，会执行很多初始化工作。</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/MLBbwa.png" alt="MLBbwa" style="zoom:50%;" /></li><li><p>绑定 M0 和 g0，M0就是程序的主线程，程序启动必然会拥有一个主线程(运行主函数<code>main()</code>)，这个就是 M0。g0 负责调度，即 shedule() 函数。</p></li><li><p>创建P0：首先会创建<strong>逻辑 CPU （不是物理CPU核数）核数个 P ，存储在 sched 的 空闲链表(pidle)。</strong>然后绑定P0与M0</p></li><li><p>新建任务G（就是main）到 P0 本地队列，M0 的 g0 会创建一个指向<code>runtime.main()</code>的 G ，并放到 P0 的本地队列。</p></li><li><p><code>runtime.main()</code>: 启动 sysmon 线程M1；启动 GC 协程；执行 init，即代码中的各种 init 函数；执行 <code>main.main</code> 函数。</p></li></ol><p>每一个goroutine的创建即<code>go func(){...}()</code>的代码都是由一个特殊的goroutine创建的，那就是<strong>g0</strong></p><p>关于g0、sysmon都会在后面介绍</p><h3 id="2-g0-特殊的goroutine"><a href="#2-g0-特殊的goroutine" class="headerlink" title="2. g0 - 特殊的goroutine"></a>2. g0 - 特殊的goroutine</h3><p><em>（本节基于Go 1.13）</em></p><p>Go必须在每个正在运行的线程上调度和管理goroutine。该角色被委派给名为<strong><code>g0</code>的特殊goroutine，这是为每个系统线程创建的第一个goroutine：</strong></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/QZSRZr.png" alt="QZSRZr"></p><p>然后，它将安排就绪的<u>goroutine在系统线程上</u>运行。</p><p>为了更好地了解在<code>g0</code>上的调度方式，让我们回顾一下通道的使用情况。这是当goroutine阻塞在通道上发送时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">[...]</span><br><span class="line">ch &lt;- v</span><br></pre></td></tr></table></figure><p>在通道上阻塞时，当前goroutine将被停放，即处于等待模式，并且不会在任何goroutine队列中被推送：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/YvpWjn.png" alt="YvpWjn" style="zoom:50%;" /><p>(G7阻塞进入等待模式)</p><p>然后，<code>g0</code><strong>替换</strong>goroutine并进行第一轮调度：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/ROY4zI.png" alt="ROY4zI" style="zoom:50%;" /><p>在调度期间，<strong>本地队列拥有优先级(但不是一定就在本地队列中调度，优先级详细见Scheduler)</strong>，并且goroutine 2 (G2) 现在将运行：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/Xp71cd.png" alt="Xp71cd" style="zoom:50%;" /><p>一旦接收器将读取通道，则goroutine＃7 (G7) 将被解除阻塞：</p><p><code>v := &lt;-ch</code></p><p>接收到消息的goroutine将切换到<code>g0</code>并通过将其放置在本地队列中来解锁停放的goroutine（后面会知道这是<code>runnext</code>字段的作用）：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/2LQPiy.png" alt="2LQPiy" style="zoom:50%;" /><p>特殊的goroutine(g0)除了管理调度，它还有更多的职责。</p><p>与一般goroutine相反，<strong><code>g0</code>拥有固定的较大的栈</strong>。这样，Go可以在需要更大栈并且在不希望栈增长的情况下执行操作。在<code>g0</code>的职责中，我们可以列出：</p><ul><li><p><strong>Goroutine创建</strong>。当调用<code>go func(){ ... }()</code>或<code>go myFunction()</code>时，Go会将函数创建委托给<code>g0</code>，然后再将其<u>放置在本地队列中</u>。<u><strong>新创建的goroutine优先运行，并放置在本地队列的顶部。</strong></u></p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/G7WkRM.png" alt="G7WkRM" style="zoom:50%;" /></li><li><p><strong>Defer方法分配。</strong></p></li><li><p><strong>GC操作</strong>，例如stw，扫描goroutine的栈以及一些标清操作。</p></li><li><p><strong>栈增长</strong>。在需要时，Go会增加goroutine的大小。该操作由<code>g0</code>在prolog方法中完成。</p></li></ul><p>这个特殊的goroutine <code>g0</code>涉及许多其他操作（大量分配，cgo等），使我们的程序可以更高效地管理操作，并且需要更大的栈，以保持我们的程序在低内存下更加高效。</p><h3 id="3-OS-thread线程的创建"><a href="#3-OS-thread线程的创建" class="headerlink" title="3. OS thread线程的创建"></a>3. OS thread线程的创建</h3><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211107142659520.png" alt="image-20211107142659520" style="zoom: 33%;" /><p>准备运行的新 goroutine 时，如果没有新的P存在，那么将唤醒新的 P 以更好地分发工作（在P的空闲链表中选一个，图中是P3）。<u>这个 P 将创建一个与之关联的 M 绑定到一个OS thread。</u></p><p>go func() 中 触发 <strong>Wakeup 唤醒机制：</strong></p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/Ss9Uzw.png" alt="Ss9Uzw" style="zoom:43%;" /><p><strong>有空闲的 Processor 而没有在 <code>spinning</code>状态Machine （该状态中M不断循环找寻可以执行的G, 会在后面详述） 时候, 需要去唤醒一个空闲(睡眠)的 M</strong> （M也有一个空闲链表，如果spinning一段时间后还没有找到G，那么这个M就会放入到M的空闲链表中），<strong>如果M空闲链表中也没有那么就会新建一个</strong>，新建的M其实是P0的M创建的（已存在的线程M创建的），<strong>新建的M会创建g0并执行g0</strong>，因为没有G在本地队列，所以g0会从全局队列中寻找G执行</p><p>程序启动后，Go 已经将主线程和 M 绑定(<code>rt0_go</code>)。<br>当 goroutine 创建完后，它是放在当前 P 的 local queue 还是 global queue ？</p><p><code>runtime.runqput</code>这个函数会尝试把 <code>new g</code> 放到本地队列上，<u><strong>如果本地队列满了</strong>，它会将本地队列的<strong>前半部分</strong>和 <code>new g</code>  迁移到全局队列中</u>。剩下的事情就等待 M 自己去拿任务了。</p><h2 id="1-4-Work-stealing调度算法"><a href="#1-4-Work-stealing调度算法" class="headerlink" title="1.4 Work-stealing调度算法"></a>1.4 Work-stealing调度算法</h2><h3 id="1-调度G到线程M上"><a href="#1-调度G到线程M上" class="headerlink" title="1. 调度G到线程M上"></a>1. 调度G到线程M上</h3><p> Go 基于两种断点将 G 调度到线程上：</p><ul><li>当 G 阻塞时：系统调用、互斥锁或 chan。阻塞的 G 进入睡眠模式/进入队列，并允许Go 安排和运行等待其他的 G。</li><li>在函数调用期间，如果 G 必须扩展其堆栈。这个断点允许 Go 调度另一个 G 并避免运行 G 占用CPU。</li></ul><p>在这两种情况下，<strong>运行调度程序的 g0 将当前G 替换为另一个 G，即 ready to run。然后，<u>选择的 G 替换 g0 并在线程上运行</u></strong></p><h3 id="2-G的切换过程"><a href="#2-G的切换过程" class="headerlink" title="2. G的切换过程"></a>2. G的切换过程</h3><p>在 Go 中，G 的切换相当轻便，其中需要保存的状态仅仅涉及以下两个：</p><ul><li><strong>Goroutine 在停止运行前执行的指令</strong>，程序当前要运行的指令是记录在程序计数器（PC）中的， G 稍后将在同一指令处恢复运行；</li><li><strong>G 的堆栈</strong>，以便在再次运行时还原局部变量；在切换之前，堆栈将被保存，以便在 G 再次运行时进行恢复：</li></ul><img src="http://xwjpics.gumptlu.work/qinniu_uPic/9iLmh8.png" alt="9iLmh8" style="zoom:50%;" /><p><strong>从 G 到 g0 或从 g0 到 G 的切换是相当迅速的，它们只包含少量固定的指令。</strong>相反，对于调度阶段，调度程序需要检查许多资源以便确定下一个要运行的 G。</p><blockquote><p><font color='#39b54a'>切换很快，寻找新的G则需要花费一些时间</font></p></blockquote><ul><li><p>当前 G 阻塞在 chan 上并切换到 g0：</p><ol><li>PC 和堆栈指针一起保存在内部结构中；</li><li>将 g0 设置为正在运行的 goroutine；</li><li>g0 的堆栈替换当前堆栈；</li></ol></li><li><p>g0 寻找新的 Goroutine 来运行</p></li><li><p>g0 使用所选的新 Goroutine 进行切换： </p><ol><li>PC 和堆栈指针是从其内部结构中获取的；</li><li>程序跳转到对应的 PC 地址；</li></ol></li></ul><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211107191350700.png" alt="image-20211107191350700" style="zoom:50%;" /><h3 id="3-Goroutine-Recycle-回收"><a href="#3-Goroutine-Recycle-回收" class="headerlink" title="3. Goroutine Recycle 回收"></a>3. Goroutine Recycle 回收</h3><p>G 很容易创建，栈很小以及快速的上下文切换。基于这些原因，开发人员非常喜欢并使用它们。</p><p>然而，<strong>一个产生许多 <code>shortlive</code>的 G 的程序将花费相当长的时间来<u>创建和销毁</u>它们。</strong></p><p>每个 P 维护一个<code>freelist G</code>(<strong>就是本地队列<code>local queue</code></strong>)，保持这个列表是本地的，这样做的好处是不使用任何锁来 push/get 一个空闲的 G。当 G 退出当前工作时，它将被 push 到这个空闲列表中。</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/igXjJM.png" alt="igXjJM" style="zoom: 33%;" /><p>为了<strong>更好地分发空闲的 G ，调度器也有自己的列表。</strong>它实际上有两个列表：<strong>一个包含已分配栈的 G，另一个包含释放过堆栈的 G（无栈）。</strong></p><p>锁保护<code>central list</code>(中心列表)，因为任何 M 都可以访问它。</p><p><strong>本地队列满的解决方法：</strong>当本地列表长度超过64时，调度程序持有的列表从 P 获取 G。然后<u><em>一半的</em> G 将移动到中心列表</u>。需求回收 G 是一种节省分配成本的好方法。</p><p>但是，由于堆栈是动态增长的，现有的G 最终可能会有一个大栈。<u>因此，当堆栈增长（即超过2K）时，Go 不会保留这些栈。</u>（<font color='#39b54a'>拓展过栈空间的go都不会保留</font>）</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/flSm54.png" alt="flSm54" style="zoom:50%;" /><h3 id="4-Schedule优先级与Work-stealing"><a href="#4-Schedule优先级与Work-stealing" class="headerlink" title="4. Schedule优先级与Work-stealing"></a>4. Schedule优先级与Work-stealing</h3><p>M 绑定的 P 没有可执行的 goroutine 时，它会去<strong>按照优先级</strong>去抢占任务：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/hKLIS0.png" alt="hKLIS0" style="zoom: 33%;" /><p>优先级策略（<code>runtime.schedule</code>）顺序如下：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/BzHxuL.png" alt="BzHxuL" style="zoom:33%;" /><ul><li>1/61的概率直接去全局队列中寻找新的G</li><li>如果没有找到，检查本地队列有没有G</li><li>如果还没有找到：<ul><li>尝试向其他P的本地队列中偷取G</li><li>还没找到，检查全局队列获取G</li><li>还没找到，找寻一些网络处理的G</li></ul></li></ul><blockquote><p><font color='#e54d42'>核心思路：避免饥饿，首先防止全局队列饥饿，然后是本地队列等等</font></p></blockquote><p>窃取的选择思路如下：</p><p>为了保证公平性，<strong>从随机位置上的 P 开始</strong>，而且遍历的顺序也<strong>随机化</strong>了(选择一个小于 GOMAXPROCS，且和它互为质数的步长)，<strong>保证遍历的顺序也随机化了。</strong></p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/htZgAK.png" alt="htZgAK" style="zoom:40%;" /><h3 id="5-Spining-thread"><a href="#5-Spining-thread" class="headerlink" title="5. Spining thread"></a>5. Spining thread</h3><p><strong>线程自旋</strong>是相对于线程阻塞而言的，表象就是<strong>循环执行一个指定逻辑</strong>(就是上面提到的<strong>调度逻辑</strong>，目的是不停地寻找 G)。这样做的问题显而易见，如果 G 迟迟不来，CPU 会白白浪费在这无意义的计算上。但好处也很明显，降低了 M 的上下文切换成本，提高了性能。</p><ul><li>M 带 P 的找 G 运行 （M已将与一个P绑定了）</li><li>M 不带 P 的找 P 挂载 （此时的M处于“游离”状态，从idle空闲链表中寻找）</li><li>G 创建又没 spining M 唤醒一个 M （如果有一个新的G创建，会检查让至少有一个M在spining）</li></ul><p>Go 的设计者倾向于高性能的并发表现，选择了后者。当然前面也提到过，<u>为了避免过多浪费 CPU 资源，自旋的线程数不会超过 GOMAXPROCS (Busy P)</u>，<u>这是因为一个 P 在同一个时刻只能绑定一个 M，P 的数量不会超过 GOMAXPROCS，自然被绑定的 M 的数量也不会超过</u>。对于未被绑定的“游离态”的 M，会进入休眠阻塞态。</p><h3 id="6-Syscall系统调用"><a href="#6-Syscall系统调用" class="headerlink" title="6. Syscall系统调用"></a>6. Syscall系统调用</h3><p><strong>Go 有自己封装的 syscall</strong>，也就是进入和退出 syscall 的时候执行 <code>entersyscall/exitsyscall</code>， 也<u>只有被封装了系统调用才有可能触发重新调度</u>，<u>它将改变 P 的状态为 syscall。</u></p><p><strong>系统监视器 (system monitor)，称为 sysmon</strong>，<strong>会定时扫描。在执行系统调用时, <u>如果某个 P 的 G 执行超过一个 sysmon tick，脱离 M</u>。</strong>(小优化)</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/Dwneyp.png" alt="Dwneyp" style="zoom: 33%;" /><p>P3 和 M 脱离后 目前在 idle list 中等待被绑定。而 syscall 结束后 M 按照如下规则执行直到满足其中一个条件：</p><ul><li><p>尝试获取同一个 P(P3)，恢复执行 G (为了同源性更好)</p></li><li><p>尝试获取 <code>idle list</code>中的空闲 P</p></li><li><p>把 G 放回 global queue，M 放回到M的idle list</p></li></ul><img src="http://xwjpics.gumptlu.work/qinniu_uPic/H56QU9.png" alt="H56QU9" style="zoom: 33%;" /><blockquote><p><strong>当使用了 Syscall，Go 无法限制 Blocked OS threads （系统调用Syscall会将线程阻塞Blocked，变为Blocked mode）的数量： 因为只可以通过runtime.GOMAXPROCS限制P的数量，但是Blocked OS threads的数量是无法限制的</strong><br>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package’s GOMAXPROCS function queries and changes the limit.</p><p>Tips: <strong>使用 syscall 写程序要认真考虑 pthread exhaust 问题。</strong></p></blockquote><h3 id="7-Sysmon"><a href="#7-Sysmon" class="headerlink" title="7. Sysmon"></a>7. Sysmon</h3><p>Sysmon（system monitor）是一个系统级别的goroutine，挂在一个M上执行，<strong>不需要P，始终执行</strong>，会不断的检测P在M上执行的G的时间，如果过长就会主动将其断开</p><p>sysmon 也叫监控线程，它无需 P 也可以运行，他是一个死循环，每20us~10ms循环一次，循环完一次就 sleep 一会，为什么会是一个变动的周期呢，主要是避免空转，如果每次循环都没什么需要做的事，那么 sleep 的时间就会加大。</p><p>Sysmon的主要作用：</p><ul><li>释放闲置超过5分钟的 span 物理内存；</li><li>如果超过2分钟没有垃圾回收，强制执行；</li><li><u><em>将长时间未处理的 netpoll 添加到全局队列；</em></u></li><li><em>向长时间运行的 G 任务发出抢占调度；</em> （信号抢占）</li><li><em>收回因 syscall 长时间阻塞的 P</em>；</li></ul><p>go是<strong><em>协作式抢占</em></strong>，也就是<u>需要依靠携程阻塞主动释放自己与P的连接，无法直接强制的阻断一个携程</u>。当 P 在 M 上执行时间超过10ms，sysmon 调用 <code>preemptone</code>将 G 标记为<code>stackPreempt</code>。因此需要在某个地方触发检测逻辑，Go 当前是在检查栈是否溢出的地方判定(morestack())，M 会保存当前 G 的上下文，重新进入调度逻辑。</p><blockquote><p><font color='#39b54a'>如果goroutine执行的是一个死循环，那么可能会一直占用这个线程P与M，如果死循环中有哦一些其他函数调用或者需要扩展内存空间，那么会被检测出来（<code>stackPreempt</code>），断开链接。如果是一个单纯的死循环那么可能就会一直占有(缺点)</font></p></blockquote><blockquote><p>Tips：<br>死循环：issues/11462<br>信号抢占：<strong>go1.14基于信号的抢占式调度实现原理</strong></p></blockquote><p>go1.14基于信号的抢占式调度实现原理:</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/072nly.png" alt="072nly" style="zoom: 50%;" /><p>异步抢占，注册<code>sigurg</code>信号，通过sysmon 检测，对 M 对应的线程发送信号，触发注册的 handler，它往当前 G 的 PC 中插入一条指令(调用某个方法)，在处理完 handler，G 恢复后，自己把自己推到了 global queue 中。</p><blockquote><p>Tips: 发生程序 hang 死情况时，通常使用什么工具诊断？</p><ul><li><code>go tool pprof</code></li><li><code>perf top</code></li></ul></blockquote><h3 id="8-Network-poller"><a href="#8-Network-poller" class="headerlink" title="8. Network poller"></a>8. Network poller</h3><p><strong>Go 所有的 I/O 都是阻塞的。然后通过 goroutine + channel 来处理并发。</strong>因此所有的 IO 逻辑都是直来直去的，你不再需要回调，不再需要 future，要的仅仅是 step by step。这对于代码的可读性是很有帮助的。</p><p><strong>G 发起网络 I/O 操作也不会导致 M 被阻塞(仅阻塞G)，从而不会导致大量 M 被创建出来。<u>将异步 I/O 转换为阻塞 I/O 的部分称为net poller。</u></strong></p><p>打开或接受连接都被设置为非阻塞模式。如果你试图对其进行 I/O 操作，并且文件描述符数据还没有准备好，G 会进入 gopark 函数，将当前正在执行的 G 状态保存起来，然后切换到新的堆栈上执行新的 G。</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/BaBWHX.png" alt="BaBWHX" style="zoom: 33%;" /><p>network poller中G被调度回来执行的触发点：</p><ul><li>sysmon  （调度到全局队列）</li><li>runtime.schedule()  (调用到P的本地队列)</li><li>GC: start the worl：从 ready 的网络事件中恢复 G。</li></ul><p><strong>gopark</strong>：G 置为 waiting 状态，等待显示<strong>goready</strong>唤醒，在poller中用得较多，还有锁、chan等。</p><h3 id="9-Scheduler-Affinity-亲缘性调度"><a href="#9-Scheduler-Affinity-亲缘性调度" class="headerlink" title="9.  Scheduler Affinity 亲缘性调度"></a>9.  Scheduler Affinity 亲缘性调度</h3><p>亲缘性调度的一些限制：</p><ul><li>Work-stealing <pre><code>当 P 的 local queue 任务不够，同时 global queue、network poller 也会空，这时从其他 P 窃取任务运行，然后任务就运行到了其他线程。*&lt;u&gt;那么，一些内存的一些亲缘性问题可能会因此放大&lt;/u&gt;*</code></pre></li><li>系统调用<pre><code>当 syscall 产生，Go 把当前线程置为 blocking mode，让一个新的线程接管了这个 P (过一个 sysmon tick 才会交给其他 M，大多数syscall都是很快的)。</code></pre></li></ul><p><strong>communicate-and-wait问题：</strong></p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211107162042595.png" alt="image-20211107162042595" style="zoom:33%;" /><p>目前M只执行到了G5，但是在使用channel通信的另一方释放了G9，G9可以执行，另一方通信的携程希望M能够快速的反应过来执行G9，但是M需要执行G5，G9可能需要被别的M窃取才可以执行，这就造成了通信上的时间等待问题。</p><p>针对 communicate-and-wait 模式，进行了亲缘性调度的优化。<br>当前 local queue，使用了 FIFO 实现，unlock 的 G 无法尽快执行，如果队列中前面存在占用线程的其他 G。<br><strong>Go 1.5 在 P 中引入了<code>runnext</code> 特殊的一个字段，可以高优先级执行 unblock G （插队）。加速channel通信机制的时间效率。</strong></p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/t9uU29.png" alt="t9uU29" style="zoom:33%;" />]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/69554144#:~:text=用户态就是提供应,，内存，I%2FO%E3%80%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/69554144#:~:text=用户态就是提供应,，内存，I%2FO%E3%80%82&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/342119843&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/342119843&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;极客时间《go进阶训练营》&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0241</title>
    <link href="https://xwjahahahaha.github.io/2021/11/06/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0241/"/>
    <id>https://xwjahahahaha.github.io/2021/11/06/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0241/</id>
    <published>2021-11-06T01:00:36.000Z</published>
    <updated>2021-11-07T05:09:46.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经</li><li><input disabled="" type="checkbox"> 下午：刷leetcode</li><li><input disabled="" type="checkbox"> 晚上：做项目</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0240</title>
    <link href="https://xwjahahahaha.github.io/2021/11/05/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0240/"/>
    <id>https://xwjahahahaha.github.io/2021/11/05/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0240/</id>
    <published>2021-11-05T00:55:23.000Z</published>
    <updated>2021-11-06T01:00:31.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经</li><li><input checked="" disabled="" type="checkbox"> 下午：刷leetcode<ul><li><input checked="" disabled="" type="checkbox"> 排序两个有序链表</li><li><input checked="" disabled="" type="checkbox"> 二叉树的层序便利</li><li><input checked="" disabled="" type="checkbox"> 买股票的最佳时机</li><li><input checked="" disabled="" type="checkbox"> 相交链表</li><li><input checked="" disabled="" type="checkbox"> 合并两个有序数组</li></ul></li><li><input disabled="" type="checkbox"> 晚上：做项目</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0239</title>
    <link href="https://xwjahahahaha.github.io/2021/11/04/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0239/"/>
    <id>https://xwjahahahaha.github.io/2021/11/04/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0239/</id>
    <published>2021-11-04T01:46:44.000Z</published>
    <updated>2021-11-05T00:55:18.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经</li><li><input checked="" disabled="" type="checkbox"> 下午：刷leetcode<ul><li><input checked="" disabled="" type="checkbox"> 环形链表</li><li><input checked="" disabled="" type="checkbox"> 数组中第k个最大元素</li><li><input checked="" disabled="" type="checkbox"> 三数之和</li></ul></li><li><input checked="" disabled="" type="checkbox"> 晚上：做项目</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0238</title>
    <link href="https://xwjahahahaha.github.io/2021/11/03/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0238/"/>
    <id>https://xwjahahahaha.github.io/2021/11/03/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0238/</id>
    <published>2021-11-03T00:36:44.000Z</published>
    <updated>2021-11-04T01:46:37.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经</li><li><input disabled="" type="checkbox"> 下午：刷leetcode</li><li><input disabled="" type="checkbox"> 晚上：做项目</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0237</title>
    <link href="https://xwjahahahaha.github.io/2021/11/02/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0237/"/>
    <id>https://xwjahahahaha.github.io/2021/11/02/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0237/</id>
    <published>2021-11-02T04:39:10.000Z</published>
    <updated>2021-11-03T00:37:04.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> docker第二章结束</li><li><input checked="" disabled="" type="checkbox"> 算法：<ul><li><input checked="" disabled="" type="checkbox"> 排序算法完结</li><li><input disabled="" type="checkbox"> 数组中第k个最大元素</li></ul></li><li><input disabled="" type="checkbox"> go面经</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0236</title>
    <link href="https://xwjahahahaha.github.io/2021/11/01/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0236/"/>
    <id>https://xwjahahahaha.github.io/2021/11/01/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0236/</id>
    <published>2021-11-01T01:08:58.000Z</published>
    <updated>2021-11-01T15:05:33.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经</li><li><input disabled="" type="checkbox"> 下午：刷leetcode 4道老题+2新题<ul><li><input checked="" disabled="" type="checkbox"> 二分法查找</li><li><input checked="" disabled="" type="checkbox"> 搜索插入位置</li><li><input disabled="" type="checkbox"> 数组中最大的第k个元素</li></ul></li><li><input checked="" disabled="" type="checkbox"> 晚上：做项目<ul><li><input checked="" disabled="" type="checkbox"> Cgroups</li></ul></li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>二分法边界问题</title>
    <link href="https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86%E6%B3%95%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86%E6%B3%95%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-31T14:07:28.000Z</published>
    <updated>2021-11-01T05:39:16.670Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习自：<a href="https://blog.csdn.net/Lin_RD/article/details/105186081" target="_blank" rel="noopener">https://blog.csdn.net/Lin_RD/article/details/105186081</a></p></blockquote><h1 id="一、二分法流程"><a href="#一、二分法流程" class="headerlink" title="一、二分法流程"></a>一、二分法流程</h1><p>二分法的一般流程如下：</p><ol><li>确定左右边界：[left, right)</li><li>确定终止条件</li><li>获得中点</li><li>比较，缩减一半区间</li></ol><a id="more"></a><h1 id="二、确定左右边界"><a href="#二、确定左右边界" class="headerlink" title="二、确定左右边界"></a>二、确定左右边界</h1><p>对于一个有序序列最小索引是0，最大索引是$n-1$</p><p>可以使用两种方法表示其区间：</p><ul><li>左闭右开： $[0, n)$</li><li>左闭右闭：$[0, n-1]$</li></ul><p>一般情况符合使用习惯的话都会使用左闭右开的方式</p><h1 id="三、确定终止条件"><a href="#三、确定终止条件" class="headerlink" title="三、确定终止条件"></a>三、确定终止条件</h1><p>需要明确的是，我们需要遍历整个数组，因此终止条件必须要确保数组的所有元素被包含</p><p>如果使用$[0, n)$此时右值不可取，因此终止条件是: <code>while left &lt; right</code></p><p>如果使用$[0, n-1]$此时右值可取，因此终止条件是:<code>while left &lt;= right</code></p><p>例子：假设数组只有一个元素，n=1，左闭右开$[0, 1)$则当设置$left&lt;right$则$0&lt;1$满足可以进入考察全部元素</p><p>如果是左闭右闭$[0,0]$那么只有设置$left&lt;=right$即有等号才能进入循环，判断所有元素</p><p><strong><font color='#e54d42'>取右值用&lt;=    不取右值用&lt;  </font></strong></p><h1 id="四、获取中点"><a href="#四、获取中点" class="headerlink" title="四、获取中点"></a>四、获取中点</h1><p>最主要的是防止溢出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">mid := (left+right)&gt;&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="五、收缩区间"><a href="#五、收缩区间" class="headerlink" title="五、收缩区间"></a>五、收缩区间</h1><p>避免死循环，所以需要保证每次进入while可行区间必须缩小即要么left变大或者right变小</p><p>升序序列下，当<code>nums[mid]&lt;target</code>时，应该将<code>left</code>右移，省略左半部分</p><p>此时有两种情况：</p><ol><li><code>left=mid</code></li><li><code>left=mid+1</code></li></ol><p>选择哪一种考察的原则是：<strong>对于位置<code>mid</code>的值是否是可能的<code>target</code></strong></p><p>这里很明显不是，所以我们采用第二种（因为两种情况都是左闭，所以<code>left</code>都可以取到）</p><p>当<code>nums[mid]&gt;target</code>时，<code>right</code>左移，省略右半部分</p><p>此时也有两种情况：</p><ol><li><code>right=mid</code></li><li><code>right=mid-1</code></li></ol><p>相同的对应上面的原则，<code>mid</code>的值也一定不是可能的<code>target</code>，要舍去</p><ul><li><p>左闭右开[0, n)： 因为<code>right</code>取不到，所以对应第一种可以直接舍去<code>mid</code>位置，满足；第二种则会多舍去一个<code>mid-1</code>位置，让<code>mid-1</code>位置无法考察到，所以应该选择<code>right=mid</code> （隐式收缩）</p></li><li><p>左闭右闭[0, n]：<code>right</code>可以取到，所以要舍去的话只能选择第二种方式即<code>right=mid-1</code> （显式收缩）</p></li></ul><blockquote><p><font color='#39b54a'>right是否能取到，是对应while条件，如是是left &lt; right，那么当left==right时是无法进入while循环中的，所以无法取到；对于left&lt;=right条件，当left等于right时可以取到right </font></p></blockquote><p>总结如下(都假设mid值不是要找的值)：</p><table><thead><tr><th align="center">while条件</th><th align="center">收缩左半部</th><th align="center">收缩右半部</th></tr></thead><tbody><tr><td align="center">Left &lt; Right</td><td align="center">Left=mid+1</td><td align="center">Right=mid</td></tr><tr><td align="center">Left &lt;= Right</td><td align="center">Left=mid+1</td><td align="center">Right=mid-1</td></tr></tbody></table><h1 id="六、退出循环的位置"><a href="#六、退出循环的位置" class="headerlink" title="六、退出循环的位置"></a>六、退出循环的位置</h1><p>while退出后，left和right分别指向哪？</p><h2 id="1-while-left-lt-right"><a href="#1-while-left-lt-right" class="headerlink" title="1. while left &lt; right"></a>1. while left &lt; right</h2><p>首先明确的是，这个条件下退出时<code>left == right</code></p><p>因为此条件下每次<code>right=mid</code>而判断收缩右半部的条件是:<code>nums[mid]&gt;target</code>所以可以明确的是<code>nums[right]&gt;target</code>，即退出循环后<code>right</code>指针指向的值一定是大于<code>target</code>的</p><p>再者，推出循环时<code>left==right</code>，所以退出循环后<code>left</code>、<code>right</code>指向的值都是大于目标值的</p><p>实际上，<strong><code>left</code>、<code>right</code>都指向第一个大于<code>target</code>的值</strong></p><blockquote><ul><li><p>假设left-1存在：</p><ul><li>如果执行过赋值left = mid + 1， 那么nums[mid] &lt; target。所以nums[left-1] &lt; target。nums[left-1] &lt; target &lt; nums[left]，显然nums[left]是nums中大于target的最小值。</li><li>如果left = mid + 1没有执行过， 那么说明left == 0，没有移动过，这就相当于left-1不存在。</li></ul></li><li><p>如果left-1不存在， left-1不存在说明left == 0， 因为0是第一个索引，所以nums[left]还是第一个大于target的数(target小于nums[0])</p></li></ul></blockquote><h2 id="2-while-left-lt-right"><a href="#2-while-left-lt-right" class="headerlink" title="2. while left &lt;= right"></a>2. while left &lt;= right</h2><p>退出时，<code>left==right+1</code></p><p>如果执行过赋值<code>right = mid - 1</code>，<code>nums[mid] &gt; target</code>， 换句话说<code>nums[right+1] == nums[mid] &gt; target</code>。<code>left = right + 1</code>所以<code>nums[left] &gt; target</code>。</p><p>如果没执行过<code>right = mid-1</code>， 那么<code>right == n-1</code>, <code>left == right+1 == n</code>。也就是说不存在大于<code>target</code>的数字(<code>nums[n-1]&lt;target</code>)。</p><p>如果执行过赋值<code>left = mid + 1</code>，<code>nums[mid] &lt; target</code>所以<code>nums[mid+1]=nums[left]&gt;target</code></p><p>如果没执行过<code>left = mid + 1</code>， 那么<code>left == 0</code>，是第一个索引，所以<code>left</code>仍然是第一个大于<code>target</code>的数字。</p><p><strong><font color='#e54d42'>综上所述：不论哪种情况，结束二分时left都是指向第一个大于target的数，或者不存在大于target的数，那么left指向序列的末尾n， 需要注意的是，nums[left-1]并不一定就是目标值，因为目标值不一定存在于序列中</font></strong></p><h1 id="七、训练"><a href="#七、训练" class="headerlink" title="七、训练"></a>七、训练</h1><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></p><p>两种情况如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右开</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            l = mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            r = mid </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// l的位置是第一个大于target的值，但是l-1不一定就是目标值</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; <span class="built_in">len</span>(nums) &amp;&amp; l &gt; <span class="number">0</span> &amp;&amp; nums[l<span class="number">-1</span>] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> l<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            l = mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            r = mid<span class="number">-1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l &gt; <span class="number">0</span> &amp;&amp; l &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[l<span class="number">-1</span>] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> l<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r, n := <span class="number">0</span>, <span class="built_in">len</span>(nums), <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        mid := (l+r) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            l = mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            r = mid</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在于数组的三种情况</span></span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> l == n &#123; <span class="keyword">return</span> n &#125;</span><br><span class="line">    <span class="comment">// if nums[l-1] != target &#123; return l &#125;</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习自：&lt;a href=&quot;https://blog.csdn.net/Lin_RD/article/details/105186081&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/Lin_RD/article/details/105186081&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、二分法流程&quot;&gt;&lt;a href=&quot;#一、二分法流程&quot; class=&quot;headerlink&quot; title=&quot;一、二分法流程&quot;&gt;&lt;/a&gt;一、二分法流程&lt;/h1&gt;&lt;p&gt;二分法的一般流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定左右边界：[left, right)&lt;/li&gt;
&lt;li&gt;确定终止条件&lt;/li&gt;
&lt;li&gt;获得中点&lt;/li&gt;
&lt;li&gt;比较，缩减一半区间&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-31T07:15:55.000Z</published>
    <updated>2021-11-09T07:56:56.997Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习自：</p><ul><li><p><a href="https://blog.csdn.net/zxzxzx0119/article/details/79826380" target="_blank" rel="noopener">https://blog.csdn.net/zxzxzx0119/article/details/79826380</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/42586566" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42586566</a></p></li></ul></blockquote><p>对常见的排序算法进行三方面总结：</p><ol><li>基本思路与实现</li><li>稳定性</li><li>复杂度分析</li></ol><a id="more"></a> <p>[TOC]</p><h1 id="一、总览"><a href="#一、总览" class="headerlink" title="一、总览"></a>一、总览</h1><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/20200525161742.png" alt=""></p><p>什么是排序算法的<strong>稳定性</strong>？</p><p>简单来说如果原本数组中的两个相等的数的次序为相对一前一后，排序结束后仍然为相对一前一后，那么就可以说这个排序算法是稳定的。即保证排序前后两个相等的数的相对顺序不会改变</p><p>所以在具体的排序算法中可以进行特定的处理改变稳定性</p><p>举例：对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成<code>arr[i] &gt;= arr[i + 1]</code>，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。</p><h1 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h1><h2 id="1-基本思路"><a href="#1-基本思路" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>每次沉底一个最大的数，将大的数一直向后交换，大的沉底，小的自动上浮</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="comment">// i：当前需要冒泡的数组长度</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="built_in">len</span>(nums)<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="comment">// j：冒泡的位置</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;i; j++ &#123;</span><br><span class="line"><span class="comment">// 如果前一个数大就和后一个交换，不断沉底</span></span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li>最好$O(N)$: 唯一的情况是数组已经有序</li><li>平均$O(N^2)$</li><li>最差$O(N^2)$</li></ul><p><strong>优化思路一</strong>: 设立flag，如果当前长度没有发生任何交换，则说明已经有序，直接结束</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">   flag := <span class="literal">true</span></span><br><span class="line">   <span class="comment">// i：当前需要冒泡的数组长度</span></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="built_in">len</span>(nums)<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">      <span class="comment">// j：冒泡的位置</span></span><br><span class="line">      <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;i; j++ &#123;</span><br><span class="line">         <span class="comment">// 如果前一个数大就和后一个交换，不断沉底</span></span><br><span class="line">         <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">            nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">            <span class="comment">// 一旦发生了交换，就改变标记</span></span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 一旦发现没有交换就直接结束</span></span><br><span class="line">      <span class="keyword">if</span> flag &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：平均优化到$O(N)$</p><p><strong>优化思路二</strong>：记录上次最后一次交换的位置，最后一次交换位置后面的位置都是有序的，所以只需要到达这个位置即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">flag := <span class="literal">true</span></span><br><span class="line"><span class="comment">// i：当前需要冒泡的数组长度</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="built_in">len</span>(nums)<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="comment">// 记录上一次结束位置，初始化时为i</span></span><br><span class="line">end := i</span><br><span class="line"><span class="comment">// j：冒泡的位置</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;i; j++ &#123;</span><br><span class="line"><span class="comment">// 如果前一个数大就和后一个交换，不断沉底</span></span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line"><span class="comment">// 一旦发生了交换，就改变标记</span></span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 记录最后一次交换位置</span></span><br><span class="line">end = j+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 替换i</span></span><br><span class="line">i = end</span><br><span class="line"><span class="comment">// 一旦发现没有交换就直接结束</span></span><br><span class="line"><span class="keyword">if</span> flag &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性"><a href="#2-稳定性" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>因为当两个数相等时不交换，所以稳定</p><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(N)$: 唯一的情况是数组已经有序</li><li>平均$O(N^2)$，优化后可到达$O(N)$</li><li>最差$O(N^2)$</li></ul><p>空间复杂度$O(1)$</p><h1 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h1><h2 id="1-基本思路-1"><a href="#1-基本思路-1" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>每次找到最大的，然后与最后一个数交换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 一共需要n-1次</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">maxIndex := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(nums)-i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[maxIndex] &#123;</span><br><span class="line">maxIndex = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和最后一个交换</span></span><br><span class="line">nums[maxIndex], nums[<span class="built_in">len</span>(nums)-i<span class="number">-1</span>] = nums[<span class="built_in">len</span>(nums)-i<span class="number">-1</span>], nums[maxIndex]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性-1"><a href="#2-稳定性-1" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的</p><p>一般排序算法描述的都是数组，所以可以说是<strong>不稳定的</strong></p><h2 id="3-复杂度分析-1"><a href="#3-复杂度分析-1" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(N^2)$</li><li>平均$O(N^2)$，优化后可到达$O(N)$</li><li>最差$O(N^2)$</li></ul><p>空间复杂度$O(1)$</p><h1 id="四、插入排序"><a href="#四、插入排序" class="headerlink" title="四、插入排序"></a>四、插入排序</h1><h2 id="1-基本思路-2"><a href="#1-基本思路-2" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>从前往后维护一个有序窗口，每次考察窗口的下一个元素，如果比窗口的最右侧/最大元素小，则从右往左遍历窗口直到合适顺序的地方插入。初始化认为数组的第一个位置有序。 （像是一种向前的冒泡排序）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// i: 这个有序窗口的最右边位置的下一个考察的位置, 起始位置0默认有序</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="comment">// 从窗口的下一个判定位置，一直向左遍历</span></span><br><span class="line"><span class="keyword">for</span> j:=i; j&gt;<span class="number">0</span>; j-- &#123;</span><br><span class="line"><span class="comment">// 如果当前位置j比窗口位置j-1小，则一直向右侧交换</span></span><br><span class="line"><span class="keyword">if</span> nums[j] &lt; nums[j<span class="number">-1</span>] &#123;</span><br><span class="line">nums[j], nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>], nums[j]</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果已经大于，那么就已将该元素加入到了有序窗口</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化思路：二分法查找插入排序的位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// i: 有序窗口的下一个考察的位置(target), 起始位置0默认有序</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="comment">// 二分法找出当前窗口中合适顺序的位置，插入</span></span><br><span class="line">l, r, target := <span class="number">0</span>, i<span class="number">-1</span>, nums[i]</span><br><span class="line"><span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">mid := (l+r) &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">l = mid+<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 即使找到了相同的值，也舍去，目的是找到合适插入的位置(刚好大于target的位置)</span></span><br><span class="line">r = mid<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// l就是刚好大于target的位置</span></span><br><span class="line"><span class="comment">// 从i开始移位，赋值</span></span><br><span class="line"><span class="keyword">for</span> j:=i; j&gt;=l+<span class="number">1</span>; j-- &#123;</span><br><span class="line">nums[j] = nums[j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">nums[l]= target</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性-2"><a href="#2-稳定性-2" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>如果遇到相同的值比较，不会进行交换，所以是稳定的</p><h2 id="3-复杂度分析-2"><a href="#3-复杂度分析-2" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。</p><p>时间复杂度:</p><ul><li>最好$O(N)$</li><li>平均$O(N^2)$</li><li>最差$O(N^2)$</li></ul><p>空间复杂度$O(1)$</p><h1 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a>五、希尔排序</h1><h2 id="1-基本思路-3"><a href="#1-基本思路-3" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>希尔排序使更高效的插入排序，它的思想在于：</p><ul><li>把数组分成几块，每一块进行一个插入排序；</li><li>而分块的依据在于增量的选择分好块之后，从gap开始到n，每一组和它前面的元素（自己组内的）进行插入排序；</li></ul><p>每次和组内的元素比较完之后，最后的元素基本就是有序的了，希尔排序相对于插入排序的优势在于插入排序每次只能将数据移动一位，在数组较大且基本无序的情况下性能会迅速恶化。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=,size_16,color_FFFFFF,t_70-20211101141829191.png" alt="希尔排序"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// gap每次减小为原来的一半</span></span><br><span class="line"><span class="keyword">for</span> gap:=<span class="built_in">len</span>(nums)/<span class="number">2</span>; gap&gt;<span class="number">0</span>; gap/=<span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// i为每个分组的起始位置</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;gap; i++ &#123;</span><br><span class="line"><span class="comment">// 下面对每个分组进行插入排序</span></span><br><span class="line"><span class="keyword">for</span> j:=i+gap; j&lt;<span class="built_in">len</span>(nums); j+=gap &#123;</span><br><span class="line"><span class="keyword">for</span> k:=j; k&gt;i; k-=gap &#123;</span><br><span class="line"><span class="keyword">if</span> nums[k-gap] &gt; nums[k] &#123;</span><br><span class="line">nums[k-gap], nums[k] = nums[k], nums[k-gap]</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性-3"><a href="#2-稳定性-3" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p><strong>不稳定</strong>。插入排序是一种稳定的排序算法，但是希尔排序不是，因为在多次插入的过程中，相同元素完全有可能在不同的插入轮次中移动破坏稳定性</p><h2 id="3-复杂度分析-3"><a href="#3-复杂度分析-3" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(N^{1.3})$</li><li>平均$O(NlogN)$~$ O(N^2)$</li><li>最差$O(N^2)$</li></ul><p>空间复杂度$O(1)$</p><p>希尔排序时间复杂度的大小还是要取决于步长的合适度</p><p>在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。</p><h1 id="六、快速排序"><a href="#六、快速排序" class="headerlink" title="六、快速排序"></a>六、快速排序</h1><h2 id="1-基本思路-4"><a href="#1-基本思路-4" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><ol><li>从数列中挑出一个元素，称为”基准/轴值”（pivot），</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为<strong>分区（partition）操作</strong>。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/nNT0Di.jpg" alt="快速排序"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> quickProcess <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">gitMid := <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">pivot := nums[l]</span><br><span class="line"><span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line"><span class="keyword">for</span> l &lt; r &amp;&amp; nums[r] &gt;= pivot &#123; r-- &#125;</span><br><span class="line">nums[l] = nums[r]</span><br><span class="line"><span class="keyword">for</span> l &lt; r &amp;&amp; nums[l] &lt;= pivot &#123; l++ &#125;</span><br><span class="line">nums[r] = nums[l]</span><br><span class="line">&#125;</span><br><span class="line">nums[l] = pivot</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line">quickProcess = <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">mid := gitMid(l, r)</span><br><span class="line"><span class="comment">// 左半部</span></span><br><span class="line">quickProcess(l, mid<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 右半部</span></span><br><span class="line">quickProcess(mid+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">quickProcess(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点： 如果每次选择的pivot都是极端数值（最大或者最小），导致后面划分的数组极度不平衡，复杂度灰降低到$O(N^2)$</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/mB1jD1.jpg" alt="快速排序弊端"></p><p>改进策略： 随机快排/快速选择（就是选择pivot时不选择最左边的而是随机选择）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())        <span class="comment">// 随机种子</span></span><br><span class="line"><span class="keyword">var</span> quickProcess <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">gitMid := <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 选取最左边为pivot</span></span><br><span class="line">pivot := nums[l]</span><br><span class="line"><span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line"><span class="keyword">for</span> l &lt; r &amp;&amp; nums[r] &gt;= pivot &#123; r-- &#125;</span><br><span class="line">nums[l] = nums[r]</span><br><span class="line"><span class="keyword">for</span> l &lt; r &amp;&amp; nums[l] &lt;= pivot &#123; l++ &#125;</span><br><span class="line">nums[r] = nums[l]</span><br><span class="line">&#125;</span><br><span class="line">nums[l] = pivot</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line">quickProcess = <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line"><span class="comment">// 改为随机选择</span></span><br><span class="line">randIdx := rand.Int() % (r-l+<span class="number">1</span>) + l</span><br><span class="line"><span class="comment">// 与最左边的数交换</span></span><br><span class="line">nums[randIdx], nums[l] = nums[l], nums[randIdx]</span><br><span class="line">mid := gitMid(l, r)</span><br><span class="line"><span class="comment">// 左半部</span></span><br><span class="line">quickProcess(l, mid<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 右半部</span></span><br><span class="line">quickProcess(mid+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">quickProcess(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性-4"><a href="#2-稳定性-4" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>不稳定，因为我们无法保证相等的数据按顺序被扫描到和按顺序存放。</p><h2 id="3-复杂度分析-4"><a href="#3-复杂度分析-4" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(NlogN)$</li><li>平均$O(NlogN)$</li><li>最差$O(N^2)$</li></ul><p>空间复杂度$O(logN)$~$O(N)$, $O(N)$是最坏情况，每次都选取到了最大/最小值，每次只能划分出一个数，调用栈的大小就是$O(N)$;如果每次运气都很好，选择的pivot都刚刚好平分数组，那么调用栈的时间复杂度就是$O(logN)$</p><p>时间复杂度$O(NlogN)$: 最优情况下， 对于每个pivot都需要折半的递归调用，折半递归到最底层一个数的时间复杂度就是$O(logN)$（共有$O(logN)$层，有这么多次操作）。在每一层中，需要遍历$N$个元素调换顺序，所以总的时间复杂度最优为$O(NlogN)$</p><h1 id="七、归并排序"><a href="#七、归并排序" class="headerlink" title="七、归并排序"></a>七、归并排序</h1><h2 id="1-基本思路-5"><a href="#1-基本思路-5" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>归并排序也是分治法一个很好的应用，先递归到最底层，然后从下往上每次两个序列进行归并合起来，是一个由上往下分开，再由下往上合并的过程，而对于每一次合并操作，对于每一次<code>merge</code>的操作过程如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/70.png" alt="归并排序"></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/3BCnUD.png" alt="归并排序"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">mergeProcess(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeProcess</span><span class="params">(nums []<span class="keyword">int</span>, l, r <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line"><span class="comment">// 分为两部分</span></span><br><span class="line">mid := l + (r-l) &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 左右分离</span></span><br><span class="line">mergeProcess(nums, l, mid)</span><br><span class="line">mergeProcess(nums, mid+<span class="number">1</span>, r)</span><br><span class="line"><span class="comment">// 此时已经分割开，有序, 进行合并</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt; nums[mid+<span class="number">1</span>] &#123;<span class="comment">// 优化：如果两个部分前后已经有序就不需要合并了</span></span><br><span class="line">merge(nums, l, mid, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums []<span class="keyword">int</span>, l, mid, r <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="comment">// 两个部分的起始位置</span></span><br><span class="line">p1, p2 := l, mid+<span class="number">1</span></span><br><span class="line"><span class="comment">// 创建中间辅助数组</span></span><br><span class="line">help := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> p1&lt;=mid &amp;&amp; p2&lt;=r &#123;</span><br><span class="line"><span class="keyword">if</span> nums[p1] &lt;= nums[p2] &#123;</span><br><span class="line">help = <span class="built_in">append</span>(help, nums[p1])</span><br><span class="line">p1 ++</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">help = <span class="built_in">append</span>(help, nums[p2])</span><br><span class="line">p2 ++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理两边剩余部分</span></span><br><span class="line"><span class="keyword">for</span> p1 &lt;= mid &#123;</span><br><span class="line">help = <span class="built_in">append</span>(help, nums[p1])</span><br><span class="line">p1++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> p2 &lt;= r &#123;</span><br><span class="line">help = <span class="built_in">append</span>(help, nums[p2])</span><br><span class="line">p2++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值到原数组</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> help &#123;</span><br><span class="line">nums[l+i] = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意几点:</p><ul><li><strong>注意上面的代码中<code>if(arr[mid] &gt; arr[mid+1])</code>防止一开始数组很有序的情况；</strong></li><li><strong>注意在外排比较的时候，为了保证稳定性，左右相等的时候，先拷贝左边的；</strong></li></ul><h2 id="2-稳定性-5"><a href="#2-稳定性-5" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>归并排序是稳定的</p><h2 id="3-复杂度分析-5"><a href="#3-复杂度分析-5" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(NlogN)$</li><li>平均$O(NlogN)$</li><li>最差$O(NlogN)$</li></ul><p>因为不断的二分区域，所以分到长度为1即只有一个数时的时间复杂度为$O(logN)$(因为共有$O(logN)$层，分了这么多次)，再看每一层中都需要进行merge操作，看上面的过程图就可以发现每层不管分成几组几个，总的都是$N$个，所以每一层merge操作的时间复杂度就是$O(N)$, 总体就是$O(NlogN)$</p><p>空间复杂度$O(N)$, 来源于其中的辅助数组</p><p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度$O(n)$使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。</p><h1 id="八、堆排序"><a href="#八、堆排序" class="headerlink" title="八、堆排序"></a>八、堆排序</h1><h2 id="1-基本思路-6"><a href="#1-基本思路-6" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>可用数组表示的完全二叉树。</p><ol><li><p>已知父节点数组索引i</p><p>父节点是i, 则左子节点为2i，右子节点为2i+1</p><blockquote><p>通常数据的0索引位置创建但不使用，根节点从index1开始，否则上述规律无意义</p></blockquote></li><li><p>已知子节点数组索引为i</p><p>则其父节点索引为i/2，其当前层为i/2 (除2也可以用效率更高的位运算)</p></li></ol><ul><li><p>大顶堆：父节点的值比其<strong>所有</strong>子节点都大</p></li><li><p>小顶堆：父节点的值比其<strong>所有</strong>子节点都小</p></li></ul><blockquote><p><font color='#e54d42'>这里的“值”可以代表为任意属性优先值，进而得到<strong>优先队列（也就是堆）：特殊的队列，取出元素的顺序按照元素的优先权而不是先后顺序</strong></font></p></blockquote><p>堆的根节点一定是最大/小值，但是节点的顺序未知</p><p>堆的原始操作，时间复杂度都为<code>nlogk</code>，<code>k</code>为按优先级分类的规模（例如按数组中元素出现次数划分，共有k个规模）</p><ul><li><strong>上浮</strong> shift up: 向堆尾新加入一个元素，堆规模 +1，依次向上与父节点比较，如小于父节点就交换。</li><li><strong>下沉</strong> shift down: 从堆顶取出一个元素（堆规模 -1，用于堆排序）或者更新堆中一个元素（本题），依次向下与子节点比较，如大于子节点就交换。</li></ul><p>堆排序的过程是一个反复调整堆的过程：</p><ul><li>利用数组建立一个小顶堆；</li><li>调用<code>siftDown</code>，把堆（无序区）的尺寸缩小<code>1</code>，取出栈顶元素，并从新的堆顶元素开始进行堆调整；</li><li>重复步骤，直到堆的大小为<code>1</code>；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myMinHeap []<span class="keyword">int</span><span class="comment">// 小顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *myMinHeap)</span> <span class="title">shiftUp</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, v)</span><br><span class="line"><span class="comment">// 调换位置</span></span><br><span class="line">i := <span class="built_in">len</span>(*h)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">1</span> &amp;&amp; (*h)[i] &lt; (*h)[i/<span class="number">2</span>] &#123;</span><br><span class="line"><span class="comment">// 小于父节点，调换位置</span></span><br><span class="line">(*h)[i], (*h)[i/<span class="number">2</span>] = (*h)[i/<span class="number">2</span>], (*h)[i]</span><br><span class="line">i /= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *myMinHeap)</span> <span class="title">shiftDown</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(*h)</span><br><span class="line">v := (*h)[<span class="number">1</span>]</span><br><span class="line">(*h)[<span class="number">1</span>] = (*h)[n<span class="number">-1</span>]</span><br><span class="line">*h = (*h)[:n<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// 调整</span></span><br><span class="line">minPoint, i := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 找出父、左右孩子中最小的节点</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span>*i &lt; n<span class="number">-1</span> &amp;&amp; (*h)[i] &gt; (*h)[<span class="number">2</span>*i] &#123;</span><br><span class="line">minPoint = <span class="number">2</span>*i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span>*i+<span class="number">1</span> &lt; n<span class="number">-1</span> &amp;&amp; (*h)[minPoint] &gt; (*h)[<span class="number">2</span>*i+<span class="number">1</span>] &#123;</span><br><span class="line">minPoint = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> minPoint == i &#123;</span><br><span class="line"><span class="comment">// 如果已经满足，则不需要调整了，因为底下本来就是有序的</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将父节点与最小的交换</span></span><br><span class="line">(*h)[i], (*h)[minPoint] = (*h)[minPoint], (*h)[i]</span><br><span class="line">i = minPoint</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建小顶堆</span></span><br><span class="line">minHeap := myMinHeap([]<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">minHeap.shiftUp(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每次删除掉一个</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">nums[i] = minHeap.shiftDown()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性-6"><a href="#2-稳定性-6" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>不稳定</p><h2 id="3-复杂度分析-6"><a href="#3-复杂度分析-6" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(NlogN)$</li><li>平均$O(NlogN)$</li><li>最差$O(NlogN)$</li></ul><p>完美二叉树时间复杂度$O(logN)$, 每次删除一个共$N$个最坏情况下操作$O(NlogN)$次</p><p>空间复杂度$O(1)$</p><p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zxzxzx0119/article/details/79826380&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/zxzxzx0119/article/details/79826380&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/42586566&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/42586566&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;对常见的排序算法进行三方面总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本思路与实现&lt;/li&gt;
&lt;li&gt;稳定性&lt;/li&gt;
&lt;li&gt;复杂度分析&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go语言面经总结</title>
    <link href="https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E9%9D%A2%E8%AF%95/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E9%9D%A2%E8%AF%95/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-31T06:02:43.000Z</published>
    <updated>2021-11-09T05:33:18.566Z</updated>
    
    <content type="html"><![CDATA[<p>整理最近看面经的重要点</p><a id="more"></a><p>面试要点：</p><ul><li>由点到面，把一个点知道的内容展开描述；如果可以的话可以多与其他语言对比</li></ul><h1 id="一、基础语法细节"><a href="#一、基础语法细节" class="headerlink" title="一、基础语法细节"></a>一、基础语法细节</h1><h2 id="1-make与new的区别是什么"><a href="#1-make与new的区别是什么" class="headerlink" title="1. make与new的区别是什么"></a>1. make与new的区别是什么</h2><ul><li><p>new：只接受一个参数即类型（自定义类型也可以），主要用于一些值类型的创建（int、string、struct, slice也可以），返回指向该类型的<strong>指针</strong>，并赋值为该类型的零值</p></li><li><p>make：只用于一些内置的数据结构(chan、map、slice)的内存创建，切片返回的是其对应的<strong>结构体</strong>，而map、channel返回的都是其<strong>指针</strong></p></li></ul><h2 id="2-Slice"><a href="#2-Slice" class="headerlink" title="2. Slice"></a>2. Slice</h2><h3 id="1-底层原理"><a href="#1-底层原理" class="headerlink" title="1.底层原理"></a>1.底层原理</h3><p>相比于数据是动态的，Slice本身是一个数据结构，分为data、len、cap三个字段，data指向底层数组的一个起始位置，len表示切片元素的个数，cap是底层数组的全部大小。初始化的时候省略cap时会讲cap设置与len一样，当向切片添加元素的时候如果元素个数超出了cap，那么底层会重新分配一个数组（2倍）并将原来的值复制过来。</p><h2 id="2-函数传slice注意事项"><a href="#2-函数传slice注意事项" class="headerlink" title="2.函数传slice注意事项"></a>2.函数传slice注意事项</h2><p>slice作为函数传参数可能在函数中添加元素导致底层数组的扩大，所以函数中修改无效</p><p>两种解决方法：</p><ol><li>参数中传递切片的指针</li><li>函数中return返回，调用的时候用原切片接收</li></ol><h2 id="3-类型可比较问题"><a href="#3-类型可比较问题" class="headerlink" title="3. 类型可比较问题"></a>3. 类型可比较问题</h2><p><strong>可用直接用==比较：</strong></p><p>对于go语言中的基本类型都可以比较，例如int、string、bool等。</p><p>可以比较的必须是<em>同类型</em>：</p><p>如果数组的元素类型是基本类型，那么两个数组之间也可以比较。</p><p>同理，如果结构体的元素基本类型，那么这个结构体的实例之间也可以直接比较</p><p>指针可以比较，但是比较的是指针保存的地址，而不是指向的值</p><p><strong>不可以用==比较</strong></p><p><em>不同类型</em>一定不能比较</p><p>对于slice切片、map、函数变量都是不能够直接比较的, 需要比较的话需要使用for循环比较元素</p><p>可比较的性质主要体现在map的key与switch上，都必须选择可以比较的，如果实在想用不可比较的类型，那么可以将不可比较的类型进行一个转换。</p><h2 id="4-go怎么从源码编译到二进制文件"><a href="#4-go怎么从源码编译到二进制文件" class="headerlink" title="4. go怎么从源码编译到二进制文件"></a>4. go怎么从源码编译到二进制文件</h2><h3 id="1-总体过程"><a href="#1-总体过程" class="headerlink" title="1. 总体过程"></a>1. 总体过程</h3><p>go语言编译的总体过程：（可以通过<code>go build -n xxx.go</code>查看整个过程）</p><p><strong>创建临时目录 =&gt; 查找依赖信息 =&gt; 编译 =&gt; 连接 =&gt; 生成可执行文件 =&gt; 复制到当前项目目录下</strong></p><p>go语言执行run的过程：</p><p><strong>创建临时目录 =&gt; 查找依赖信息 =&gt; 编译 =&gt; 连接 =&gt; 生成可执行文件 =&gt; 执行</strong></p><h3 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2. 编译过程"></a>2. 编译过程</h3><p>四个阶段：</p><ol><li><p><strong>词法和语法分析</strong></p><p>用词法解释器将源文件中的字符串转换成为Token，然后将这些Token再通过语法分析器分析语法生成抽象语法树AST，一个go文件就对应一个AST</p></li><li><p><strong>类型检查</strong></p><p>对于每个抽象语法树进行类型检查，保证没有类型错误。并且还会对一些函数进行拓展，比如make就会拓展成<code>runtime.makeslice</code></p></li><li><p><strong>中间代码的生成</strong></p><p>经过语法分析和类型检查之后就不会有语法错误和类型错误了，这时候编译器就会将项目中的抽象语法树的所有函数放入编译队列中，每个goroutine将从中获取需要的函数将抽象语法树转化为中间代码。</p><p>这个过程中还会使用<em>静态单赋值SSA</em>进行代码的一个优化，例如取出无用变量、片段等</p></li><li><p><strong>机器码的生成</strong></p><p>go源代码中有对应各个cpu指令架构的包，使用这些包生成不同的架构的机器码</p><p>在编译的过程中也可以通过<code>GOARCH</code> <code>GOOS</code>进行交叉编译</p></li></ol><h2 id="5-string转-byte内存拷贝"><a href="#5-string转-byte内存拷贝" class="headerlink" title="5. string转[]byte内存拷贝"></a>5. string转[]byte内存拷贝</h2><p>会发生类型拷贝。因为go语言中string类型是不可变的，而[]byte类型是可变的，所以string转换[]byte是需要内存拷贝的。（强类型转换都会发生底层数据的内存拷贝）</p><p>优化处理：</p><p>在底层转换两者，把<code>StringHeader</code>的地址转换为<code>SliceHeader</code>。可以使用go语言中的unsafe包完成这个操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*StringHeader 是字符串在go的底层结构。*/</span></span><br><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line"> Data <span class="keyword">uintptr</span></span><br><span class="line"> Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*SliceHeader 是切片在go的底层结构。*/</span></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line"> Data <span class="keyword">uintptr</span></span><br><span class="line"> Len  <span class="keyword">int</span></span><br><span class="line"> Cap  <span class="keyword">int</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"xxxwwwjjj"</span></span><br><span class="line"><span class="comment">// 拿到s的地址</span></span><br><span class="line">sAddr := unsafe.Pointer(&amp;s)</span><br><span class="line"><span class="comment">// 把字符串s转换为底层StringHeader</span></span><br><span class="line">stringHeader := (*reflect.StringHeader)(sAddr)</span><br><span class="line"><span class="keyword">var</span> sBytes []<span class="keyword">byte</span></span><br><span class="line"><span class="comment">// 拿到sBytes的指针</span></span><br><span class="line">sBytesAddr := unsafe.Pointer(&amp;sBytes)</span><br><span class="line"><span class="comment">// 把字节数组转换为底层SliceHeader</span></span><br><span class="line">sBytesHeader := (*reflect.SliceHeader)(sBytesAddr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值操作</span></span><br><span class="line">sBytesHeader.Data = stringHeader.Data</span><br><span class="line">sBytesHeader.Len = stringHeader.Len</span><br><span class="line">sBytesHeader.Cap = stringHeader.Len</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"s = %s, sBytes = %s\n"</span>, s, sBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这样不会发生字符串的底层拷贝，但是这样使用需要慎重，因为字节数组不能再改动！</p><h2 id="6-静态类型语言与动态类型语言"><a href="#6-静态类型语言与动态类型语言" class="headerlink" title="6. 静态类型语言与动态类型语言"></a>6. 静态类型语言与动态类型语言</h2><ul><li>静态语言的变量在编译时就要确定其类型，变量要申明其类型，也叫强类型语言(java、c/c++、go)，动态类型语言则在运行时确定类型，不用申明变量类型，也叫弱类型语言（python，js）</li><li>静态语言编译时会进行类型匹配检查，所以不能变量的类型要确定，转换要在代码中体现。动态语言的变量在执行期间是可以改变的，与生俱来多态性质</li><li>静态语言规则要求高，代码安全性好，但是编写会复杂一点。动态语言的代码更加简洁，可以把精力放在业务上，但是排错可能会比较麻烦</li></ul><h2 id="7-go语言的特点"><a href="#7-go语言的特点" class="headerlink" title="7. go语言的特点"></a>7. go语言的特点</h2><ul><li>语言层面支持并发，而不是程序设计上支持并发。（一个<code>go</code>即可开启协程不用关系细节，而其他例如<code>java</code>还需要进程池等代码操作）</li><li></li></ul><h1 id="二、进阶语法特点"><a href="#二、进阶语法特点" class="headerlink" title="二、进阶语法特点"></a>二、进阶语法特点</h1><h2 id="1-goroutine协程"><a href="#1-goroutine协程" class="headerlink" title="1. goroutine协程"></a>1. goroutine协程</h2><h3 id="1-1-进程的基本工作状态"><a href="#1-1-进程的基本工作状态" class="headerlink" title="1.1 进程的基本工作状态"></a>1.1 进程的基本工作状态</h3><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211106141557437.png" alt="image-20211106141557437" style="zoom: 33%;" /><h3 id="1-2-进程、线程、协程三者对比"><a href="#1-2-进程、线程、协程三者对比" class="headerlink" title="1.2 进程、线程、协程三者对比"></a>1.2 进程、线程、协程三者对比</h3><table><thead><tr><th align="center"></th><th>角色</th><th>优点</th><th>缺点</th><th>资源共享</th></tr></thead><tbody><tr><td align="center">进程</td><td>系统资源调度的基本单位</td><td>稳定，独占资源</td><td>切换时资源消耗大</td><td>共享堆、栈</td></tr><tr><td align="center">线程</td><td>操作系统执行的基本单元，争抢CPU时间轮片</td><td>比进程轻量（1-8MB）</td><td>切换开销较小，有时会因为共享资源阻塞等待</td><td>共享堆，不共享栈（标准进程）</td></tr><tr><td align="center">协程</td><td>轻量级别的线程</td><td>比线程更加轻量（2kb），通过<strong>调度模型</strong>避免线程等待阻塞，更加高效。是<strong>用户态</strong>而不是内核态，由goruntime调度（进程、线程都是内核调度）在进程中开启</td><td>不与操作系统硬件相关，无法实现标准线程的多并发能力，性能还是受限于系统物理CPU核心数</td><td>共享堆，不共享栈</td></tr></tbody></table><h3 id="1-3-协程轻量、高效的原因-协程与进程对比"><a href="#1-3-协程轻量、高效的原因-协程与进程对比" class="headerlink" title="1.3 协程轻量、高效的原因 / 协程与进程对比"></a>1.3 协程轻量、高效的原因 / 协程与进程对比</h3><ol><li><p>内存占用</p><p>协程内存占用2KB，如果不够会<strong>动态增加</strong>，而进程为了防止栈溢出一般占用一个较大的内存（1—8MB）</p></li><li><p>用户态与内核态</p><p>协程是用户态的，由goruntime管理，可以说是模拟出来的，创建与销毁不会涉及内核资源的处理（内核级别的交互），而进程则是需要进入内核进行创建与销毁。内核态的进程之间的切换因为保存上下文、公平竞争等原因所以切换的消耗很大、速度很慢（1000-1500ns）。协程之间调度算法切换的时间会小很多（200ns）</p></li><li><p>复杂性</p><p>进程之间通讯复杂，成本高不能创建多个进程。如果使用少量进程的非阻塞执行那么代码编写上也变得复杂</p><p>携程之间通过channel通信，channel自带安全资源同步与共享，代码编写上的逻辑也更加的简单</p></li></ol><h2 id="2-携程调度模型GMP"><a href="#2-携程调度模型GMP" class="headerlink" title="2. 携程调度模型GMP"></a>2. 携程调度模型GMP</h2><h3 id="2-1-M-N模型"><a href="#2-1-M-N模型" class="headerlink" title="2.1 M:N模型"></a>2.1 M:N模型</h3><p>在内核态中创建了N个进程，在用户态中有M个携程，并且M&gt;&gt;N，这M个携程共享内核中的N个进程</p><p>对于同一个时刻下，内核中的一个线程只执行一个携程，如果携程遇到了I/O或者其他阻塞（锁、网络），那么就会使用另一个携程挂在这个进程上，让这个进程继续执行</p><h3 id="2-2-谈谈go进程调度模型"><a href="#2-2-谈谈go进程调度模型" class="headerlink" title="2.2 谈谈go进程调度模型"></a>2.2 谈谈go进程调度模型</h3><h4 id="GM模型"><a href="#GM模型" class="headerlink" title="GM模型"></a>GM模型</h4><p>go语言调度模型最早是go 1.2前采用的是GM模型，G是携程，M就是工作线程</p><p><strong>实现逻辑/流程：</strong>把所有的G都放到一个全局队列中，这个队列的访问需要锁机制，每个线程M从其中获得一个G然后执行。一旦G阻塞（IO、channel等待或Syscall）就会进入parked状态返回到全局队列中，在随后重新被争夺执行。</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211106161429689.png" style="zoom: 33%;" /><p><strong>缺点：</strong>1. 全局的互斥大锁限制了执行效率，每个线程都可能会阻塞于这个全局队列。所有 goroutine 相关操作，比如：创建、结束、重新调度等都要上锁。2. 亲缘性问题，新创建的G就放在全局而不是本地运行，可能会被其他M执行，亲缘性不好。3. Mcache缓存浪费。M需要为执行的G创建mcache缓存（2MB），而这个缓存在M执行syscall系统调用的时候是不需要的，造成了浪费。4.在GM模型中，当M没有任务后会休眠，一旦有新的G再唤醒，这样的不断的休眠唤醒效率很低（后面就添加了M自旋）</p><h4 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h4><p>随后就出现了新的GMP调度机制：P是一个上下文环境，它为每个在其上的M创建了一个本地队列，P与M之间是一一绑定的，数量可使用runtime.GOMAXPROCS 来设定。</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/llOn2F-20211106165131708.png" style="zoom: 33%;" /><p><strong>改进：</strong>1. 为每个M维护一个本地队列，类似于本地缓冲区，这样就避免频繁的访问全局队列。2.将mcache等一些资源浪费放到了P中，防止了资源浪费。 3. work-stealing调度算法。可以从别的M的本地队列中偷取G执行。</p><h3 id="2-3-goroutine的生命周期"><a href="#2-3-goroutine的生命周期" class="headerlink" title="2.3 goroutine的生命周期"></a>2.3 goroutine的生命周期</h3><ol start="0"><li><p>整个程序始于一段汇编，而在随后的<code>runtime·rt0_go</code>（也是汇编程序）中，会执行很多初始化工作。</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/MLBbwa.png" alt="MLBbwa" style="zoom:50%;" /></li><li><p>绑定 M0 和 g0，M0就是程序的主线程，程序启动必然会拥有一个主线程(运行主函数<code>main()</code>)，这个就是 M0。g0 负责调度，即 shedule() 函数。</p></li><li><p>创建P0：首先会创建<strong>逻辑 CPU （不是物理CPU核数）核数个 P ，存储在 sched 的 空闲链表(pidle)。</strong>然后绑定P0与M0</p></li><li><p>新建任务G（就是main）到 P0 本地队列，M0 的 g0 会创建一个指向<code>runtime.main()</code>的 G ，并放到 P0 的本地队列。</p></li><li><p><code>runtime.main()</code>: 启动 sysmon 线程M1；启动 GC 协程；执行 init，即代码中的各种 init 函数；执行 <code>main.main</code> 函数。</p></li></ol><h3 id="2-4-g0的作用"><a href="#2-4-g0的作用" class="headerlink" title="2.4 g0的作用"></a>2.4 g0的作用</h3><p>g0是每个系统线程创建的第一个携程就是g0，是一个特殊的goroutine，它与一般的goroutine不同有一个较大的固定的栈</p><ol><li><p><strong>Goroutine创建</strong>。当调用<code>go func(){ ... }()</code>或<code>go myFunction()</code>时，Go会将函数创建委托给<code>g0</code>，然后再将其<u>放置在本地队列中</u>。<u><strong>新创建的goroutine优先运行，并放置在本地队列的顶部。</strong></u></p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/G7WkRM.png" alt="G7WkRM" style="zoom:50%;" /></li><li><p><strong>找寻调度新的goroutine，负责G之间的切换</strong></p></li><li><p><strong>Defer方法分配。</strong></p></li><li><p><strong>GC操作</strong>，例如stw，扫描goroutine的栈以及一些标清操作。</p></li><li><p><strong>栈增长</strong>。在需要时，Go会增加goroutine的大小。该操作由<code>g0</code>在prolog方法中完成。</p></li></ol><h3 id="2-5-G的切换过程"><a href="#2-5-G的切换过程" class="headerlink" title="2.5 G的切换过程"></a>2.5 G的切换过程</h3><p>G切换原因：</p><ul><li>G 阻塞时：系统调用、互斥锁或 chan。阻塞的 G 进入睡眠模式/进入队列，并允许Go 安排和运行等待其他的 G。</li><li>在函数调用期间，如果 G 必须扩展其堆栈。这个断点允许 Go 调度另一个 G 并避免运行 G 占用CPU。</li></ul><p>在这些情况下，当前G变为Parked，当前G会切换到g0，运行调度程序的g0会替换当前G在M上执行，寻找下一个<em>优先级</em>的G然后切换到该G运行</p><p>在 Go 中，G 的切换相当轻便，其中需要保存的状态仅仅涉及以下两个：</p><ul><li><strong>Goroutine 在停止运行前执行的指令</strong>，程序当前要运行的指令是记录在程序计数器（PC）中的， G 稍后将在同一指令处恢复运行；</li><li><strong>G 的堆栈</strong>，以便在再次运行时还原局部变量；在切换之前，堆栈将被保存，以便在 G 再次运行时进行恢复</li></ul><p><strong>从 G 到 g0 或从 g0 到 G 的切换是相当迅速的，它们只包含少量固定的指令。</strong>相反，对于调度阶段，调度程序需要检查许多资源以便确定下一个要运行的 G。</p><h3 id="2-6-Schedule优先级"><a href="#2-6-Schedule优先级" class="headerlink" title="2.6 Schedule优先级"></a>2.6 Schedule优先级</h3><p>M 绑定的 P 没有可执行的 goroutine 时，它会去<strong>按照优先级</strong>去抢占任务<code>runtime.schedule</code>：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/BzHxuL-20211109102510047.png" alt="BzHxuL" style="zoom:33%;" /><ul><li>1/61的概率直接去全局队列中寻找新的G</li><li>如果没有找到，检查本地队列有没有G</li><li>如果还没有找到：<ul><li>尝试向其他P的本地队列中偷取G（work-stealing）</li><li>还没找到，检查全局队列获取G</li><li>还没找到，找寻一些网络处理的G</li></ul></li></ul><blockquote><p><font color='#e54d42'>核心思路：避免饥饿，首先防止全局队列饥饿，然后是本地队列等等</font></p></blockquote><h3 id="2-7-work-stealing"><a href="#2-7-work-stealing" class="headerlink" title="2.7 work-stealing"></a>2.7 work-stealing</h3><p>为了保证公平性，<strong>从随机位置上的 P 开始</strong>，而且遍历的顺序也<strong>随机化</strong>了(选择一个小于 GOMAXPROCS，且和它互为质数的步长)，<strong>保证遍历的顺序也随机化了。</strong></p><h3 id="2-8-M线程的自旋"><a href="#2-8-M线程的自旋" class="headerlink" title="2.8 M线程的自旋"></a>2.8 M线程的自旋</h3><p>自旋简单来说就是当M没有挂载G时，会一直不断的寻找新的G（采用上面的优先级调度算法）。虽然会消耗少量的CPU资源，但是降低了 M 的上下文切换成本，提高了性能。</p><p>如果当前有空闲的P但是没有自旋的M，那么P会在M的空闲列表中唤醒一个M，如果空闲列表中也没有，那么就会新创建一个M然后自旋寻找新的G执行（保证至少有个M在自旋）</p><h3 id="2-9-syscall系统调用与sysmon系统监视"><a href="#2-9-syscall系统调用与sysmon系统监视" class="headerlink" title="2.9 syscall系统调用与sysmon系统监视"></a>2.9 syscall系统调用与sysmon系统监视</h3><p>go有自己封装的系统调用，使用封装的系统调用让P才会触发新的调度（因为系统调用会阻塞），触发系统调用会让M处于syscall状态。</p><p>sysmon是一个系统级别的goroutine，不需要挂载P，运行期间始终执行。通过一个循环去监控各个M执行的G，如果时间过长（阻塞），那么就会主动发送信号将M与P断开（信号式抢占）。sysmon的循环周期会不断缩减，为了避免空转，如果一段时间未发现长时间的调用，那么就会睡眠一段时间然后在循环。</p><p>Sysmon的主要作用：</p><ul><li>释放闲置超过5分钟的 span 物理内存；</li><li>如果超过2分钟没有垃圾回收，强制执行；</li><li><u><em>将长时间未处理的 netpoll 添加到全局队列；</em></u></li><li><em>向长时间运行的 G 任务发出抢占调度；</em> （信号抢占）</li><li><em>收回因 syscall 长时间阻塞的 P</em>；</li></ul><h3 id="2-10-communicate-and-wait问题"><a href="#2-10-communicate-and-wait问题" class="headerlink" title="2.10 communicate-and-wait问题"></a>2.10 communicate-and-wait问题</h3><p>使用channel机制的时候，本方G阻塞在channel的一端，等待读取；当另一端写入channel后，本方G就应该立马执行。但是因为goroutine的调度模型，P维护了一个本地队列顺序，阻塞的G活跃后不会直接立即挂载执行，所以就会产生延迟（要依靠别的P偷取）</p><p>解决方式就是Go 1.5 在 P 中引入了<code>runnext</code> 特殊的一个字段，可以高优先级执行 unblock G （插队）。加速channel通信机制的时间效率。</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/t9uU29.png" alt="t9uU29" style="zoom: 25%;" /><h2 id="3-谈谈GC机制"><a href="#3-谈谈GC机制" class="headerlink" title="3. 谈谈GC机制"></a>3. 谈谈GC机制</h2><h2 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4. 内存管理"></a>4. 内存管理</h2><h2 id="5-Channel"><a href="#5-Channel" class="headerlink" title="5. Channel"></a>5. Channel</h2><h2 id="6-标准包"><a href="#6-标准包" class="headerlink" title="6. 标准包"></a>6. 标准包</h2><h3 id="1-content"><a href="#1-content" class="headerlink" title="1. content"></a>1. content</h3><h2 id="7-内存逃逸"><a href="#7-内存逃逸" class="headerlink" title="7. 内存逃逸"></a>7. 内存逃逸</h2><h2 id="8-go的新版本功能"><a href="#8-go的新版本功能" class="headerlink" title="8. go的新版本功能"></a>8. go的新版本功能</h2><h1 id="三、工程类、实践类"><a href="#三、工程类、实践类" class="headerlink" title="三、工程类、实践类"></a>三、工程类、实践类</h1><h2 id="1-生产者消费者模型"><a href="#1-生产者消费者模型" class="headerlink" title="1. 生产者消费者模型"></a>1. 生产者消费者模型</h2><h2 id="2-实现一个进程安全的Set"><a href="#2-实现一个进程安全的Set" class="headerlink" title="2. 实现一个进程安全的Set"></a>2. 实现一个进程安全的Set</h2><h2 id="3-协程访问共享资源与循环变量捕获问题"><a href="#3-协程访问共享资源与循环变量捕获问题" class="headerlink" title="3. 协程访问共享资源与循环变量捕获问题"></a>3. 协程访问共享资源与循环变量捕获问题</h2><p>以下程序有什么问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">total := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        total += i</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"total:%d sum %d"</span>, total, sum)</span><br></pre></td></tr></table></figure><p>问题：</p><ol><li>协程访问共享资源要通信协调、主进程要等到所有子进程</li><li>延迟函数执行需要捕获循环变量</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">total, sum := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">j := i<span class="comment">// 捕获循环变量</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">total += j</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">"total:%d sum %d\n"</span>, total, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-实现一个简单的客户端-服务器模型"><a href="#4-实现一个简单的客户端-服务器模型" class="headerlink" title="4. 实现一个简单的客户端/服务器模型"></a>4. 实现一个简单的客户端/服务器模型</h2><h2 id="5-实现一个tcp连接传输数据"><a href="#5-实现一个tcp连接传输数据" class="headerlink" title="5. 实现一个tcp连接传输数据"></a>5. 实现一个tcp连接传输数据</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理最近看面经的重要点&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0235</title>
    <link href="https://xwjahahahaha.github.io/2021/10/31/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0235/"/>
    <id>https://xwjahahahaha.github.io/2021/10/31/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0235/</id>
    <published>2021-10-31T01:10:15.000Z</published>
    <updated>2021-11-01T01:08:50.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经</li><li><input disabled="" type="checkbox"> 下午：刷leetcode <ul><li><input checked="" disabled="" type="checkbox"> 排序算法全部完结（部分）</li><li><input disabled="" type="checkbox"> 一题旧题：</li></ul></li><li><input disabled="" type="checkbox"> 晚上：<ul><li><input disabled="" type="checkbox"> 面经</li><li><input disabled="" type="checkbox"> docker项目</li></ul></li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
</feed>
