<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识与头发不可兼得</title>
  
  <subtitle>文杰的博客</subtitle>
  <link href="https://xwjahahahaha.github.io/atom.xml" rel="self"/>
  
  <link href="https://xwjahahahaha.github.io/"/>
  <updated>2021-07-23T09:40:45.044Z</updated>
  <id>https://xwjahahahaha.github.io/</id>
  
  <author>
    <name>DDDemons hide</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日记_0204</title>
    <link href="https://xwjahahahaha.github.io/2021/07/23/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0204/"/>
    <id>https://xwjahahahaha.github.io/2021/07/23/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0204/</id>
    <published>2021-07-23T01:17:56.000Z</published>
    <updated>2021-07-23T09:40:45.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input checked="" disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 密码学P2 PRG安全性证明</li><li><input checked="" disabled="" type="checkbox"> tendermint-2</li><li><input disabled="" type="checkbox"> 论文结束</li><li><input disabled="" type="checkbox"> go</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Tendermint-2-共识算法:Tendermint-BFT详解</title>
    <link href="https://xwjahahahaha.github.io/2021/07/22/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E8%AF%BB/Tendermint/Tendermint-2-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-Tendermint-BFT%E8%AF%A6%E8%A7%A3/"/>
    <id>https://xwjahahahaha.github.io/2021/07/22/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E8%AF%BB/Tendermint/Tendermint-2-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-Tendermint-BFT%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-07-22T08:22:38.000Z</published>
    <updated>2021-07-23T05:43:59.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Tendermint项目目录：</p><ul><li><a href="https://blog.csdn.net/weixin_43988498/article/details/118060169" target="_blank" rel="noopener">Tendermint-1-基础概念</a></li></ul></blockquote><blockquote><p>上一篇已经简单的介绍了Tendermint的基础概念，包括优势与特点、应用与生态等。下面将会详细的介绍Tendermint的共识算法，你将会学习到一下几个方面：</p><ul><li>Tendermint-PBFT详解（high-level view -&gt; detail）</li><li>TBFT与传统PBFT的比较分析</li></ul></blockquote><h1 id="一、Tendermint-BFT详解"><a href="#一、Tendermint-BFT详解" class="headerlink" title="一、Tendermint-BFT详解"></a>一、Tendermint-BFT详解</h1><h2 id="1-1-共识环境分析"><a href="#1-1-共识环境分析" class="headerlink" title="1.1 共识环境分析"></a>1.1 共识环境分析</h2><ul><li><p>角色：Validator（预先配置的网络中的一般验证者账户们）、Proposer（选举出的出块人）</p></li><li><p>阶段：Propose阶段、Prevote阶段、Precommit阶段</p></li><li><p>投票种类：prevote、precommit、commit</p></li></ul><blockquote><p><font color='#39b54a'>这些名词下面会一一介绍到</font></p></blockquote><a id="more"></a><h2 id="1-2-Round-based协议"><a href="#1-2-Round-based协议" class="headerlink" title="1.2 Round-based协议"></a>1.2 Round-based协议</h2><h3 id="1-2-1-共识的开始"><a href="#1-2-1-共识的开始" class="headerlink" title="1.2.1 共识的开始"></a>1.2.1 共识的开始</h3><p>整个Tendermint区块链网络需要通过Round-based协议来决定下一个区块，在区块链中共识的直接目的就是<strong>确定下一个区块内容、链接下一个区块</strong></p><p>共识的决定需要所有角色进行投票，vote的基本结构如图（来自于PPIO）：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/gtpHpr.png" alt="gtpHpr"></p><p>通过这些字段指定以下内容：</p><ol><li>当前投票的目标区块 &lt;= Height、Hash</li><li>当前投票的轮次 &lt;= round</li><li>当前投票的发起者 &lt;= 签名</li></ol><h3 id="1-2-2-总体流程"><a href="#1-2-2-总体流程" class="headerlink" title="1.2.2 总体流程"></a>1.2.2 总体流程</h3><p>Round-based协议的流程总的来说有五个步骤不断<strong>循环</strong>执行：</p><p><font color='#e54d42'>状态机流程:  NewHeight =&gt; Propose =&gt; Prevote =&gt; Precommit =&gt; Commit </font></p><ul><li>NewHeight、Commit都是特殊的流程，后面会详述</li><li>中间Propose、Prevote、Precommit称之为一个Round</li><li>一个Round不一定就一定会产生一个区块，因为其中会有共识失败的可能，一旦失败就会重新开始轮次</li></ul><p>以下就是整个流程图(图片来自PPIO):</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/CYYuL5.png" alt="CYYuL5"> </p><ol><li><p>进入新的高度阶段，等待时间后，进入Propose阶段</p></li><li><p>Propose阶段，选举Proposer, 然后Proposer提交一个Proposal, 进入Prevote阶段</p></li><li><p>Prevote阶段Validators对收到的Proposal进行prevote投票, 当达到2/3的prevote投票后进入Precommit阶段</p></li><li><p>Precommit阶段进行precommit投票，当达到2/3的投票后进入Commit阶段；未达到重新进入Propose阶段即Step 2</p></li><li><p>Commit阶段准备好新的高度以及广播了新的状态给节点，进入Step 1</p></li></ol><p>以上是整个过程，下面对于每个过程进行一一详细的介绍</p><h3 id="1-2-3-Proposal"><a href="#1-2-3-Proposal" class="headerlink" title="1.2.3 Proposal"></a>1.2.3 Proposal</h3><p>选举Proposer，也就是常见共识算法中的Leader，从Validators中选举，最初的Validator的注册通过编写配置文件genesis.json在区块链创世区块中配置（后期也可通过命令行添加）</p><ul><li>Validator: 所有参与共识验证的注册节点</li><li>Proposer: 每轮从Validators中选举出的出块节点</li></ul><p>选择的规则：Round-robin</p><p>规则其实很简单：</p><ul><li>初始化配置Validators后，全网的节点都会将所有的Validator数据备份到本地</li><li>一个区块高度一般对应一次选举即可结束，但有时单节点障碍或网络异常等原因会造成一个高度需要多个轮次</li><li>全网从已构建好的<strong>Validator循环排序数组</strong>的0位置开始指定Validator为Proposer，本次高度确定后，新的高度后依次向后指定（选择位置1的Validator为Proposer）, 达到最后时从0重新开始</li><li>当出现Proposer无法连接或异常时会跳过该节点继续向下指定，算法得以自动不断执行</li></ul><blockquote><p><font color='#e54d42'>这里也就解释了“<strong>非阻塞轮询机制</strong>核心是为了避免选中的Proposer中断连接,从而共识阻塞”的意思</font></p></blockquote><p><em>那么，Validator循环排序数组是怎样挑选Validator的呢？</em></p><p>根据Validator的votingPower来决定顺序，其votingPower越大被选中的概率也就越大。</p><p>每个Validator的<strong>初始化的</strong>votingPower由其质押的资金stake1:1恒定 （PoS机制需要质押资金，质押资金也是在配置文件中配置）</p><p><em>怎样防止votingPower很大的Validator选举垄断？</em></p><p>votingPower更新算法:</p><p>初始化后每轮votingPower都会更新：</p><ul><li><p>本轮未被选中的Validator本轮后其votingPower增加其初始化的stake，即$votingPower= votingPower+stake$​​</p></li><li><p>本轮被选中的Validator本轮后其votingPower减少为Validator循环数组中其他Validator的stake之和，即<br>$$<br>votingPower = votingPower - \sum_{i}^Nstake_i \ , \ i \neq thisValidator<br>$$</p></li></ul><p>举例：初始化stake配置：A:1, B:2, C:3</p><p>(图片引自知乎：吴寿鹤) 深色表示Proposer</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20210723102822577.png" alt="image-20210723102822577"></p><p>这张图片理解无障碍则已了解选举过程</p><p>总结：</p><ol><li>可以结合初始化配置将Pos设计成为DPoS</li><li>Round-robin策略的问题在于下一个Proposer可以被预测到容易引发对于特点单点主机的DDos攻击，所以还需要隐藏Validator节点的Ip地址</li></ol><hr><p>在选举出Proposer之后该Proposer提交一个Proposal，<strong>全网广播</strong>，其数据结构如下:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20210723103522580.png" alt="proposal"></p><blockquote><p><font color='#e54d42'>Proposal最为重要的字段就是Block，其核心目的就是将自己打包的区块广播更新区块链状态</font></p></blockquote><h3 id="1-2-4-Prevote"><a href="#1-2-4-Prevote" class="headerlink" title="1.2.4 Prevote"></a>1.2.4 Prevote</h3><p>Validator 不断监听是否有新的Proposal区块…….</p><p>在每个Validator进行Prevote阶段的投票之前，需要先判断自己是否锁定在上一轮的Proposal区块上：</p><ul><li><p>是则继续签名广播上一轮锁定的Proposal区块并广播prevote投票</p></li><li><p>否则签名广播当前轮Proposal区块并广播prevote投票</p></li><li><p>某些原因导致Validator没有锁定/收到任一Proposal区块，那么就签名广播一个<strong>空</strong>的prevote投票</p></li></ul><blockquote><p><font color='#39b54a'>通过不同轮次将统一网络中的Validator区分开避免多次prevote投票，prevote投票与Proposal区块一一对应</font></p></blockquote><h3 id="1-2-5-Precommit"><a href="#1-2-5-Precommit" class="headerlink" title="1.2.5 Precommit"></a>1.2.5 Precommit</h3><p>对于每一个Validator不断接收网络中的Prevote投票…….</p><p>在Precommit开始阶段，Validator会收集prevote投票:</p><ul><li><p>如果达到了总数的2/3个prevote投票，则为这个区块签名广播precommit投票，并且当前<strong>Validator锁定在此Proposal区块上，同时释放之前锁定的区块</strong> , <strong>一个Validator只能锁定在一个区块中</strong></p></li><li><p>如果其收到了超过2/3的空nil区块prevote投票, 那么释放之前锁定的所有区块</p></li><li><p>如果没有收集超过任何2/3的prevote投票，那么其不会锁定在任何区块</p></li></ul><p>处于锁定状态的 Validator 会为锁定的区块收集 prevote 投票，并把这些投票打成包放入 <strong>proof-of-lock</strong> 中，proof-of-lock 会在之后的propose阶段用到。</p><blockquote><p>对于每个Validator需要维护一个<strong>PoLC（Proof of Lock Change）</strong>的投票集结构:</p><p>PoLC表示在一个高度h和轮次r构成的元祖$(h, r)$下, 对于一个区块b（可能为空nil）prevote投票数超过2/3的集合</p></blockquote><h3 id="1-2-6-Commit"><a href="#1-2-6-Commit" class="headerlink" title="1.2.6 Commit"></a>1.2.6 Commit</h3><p>对于每一个Validator不断接收网络中的precommit投票…….</p><p>在 precommit 阶段后期，如果 Validator 收集到超过2/3的 precommit 投票，那么 Validator 进入到 <strong>Commit 阶段。</strong></p><p>否则进入下一轮的 <strong>Proposal 阶段</strong>。</p><p><strong>Commit 阶段分为两个并行的步骤：</strong></p><ol><li>Validator 收到了被全网 commit 的区块，Validator 会为这个区块广播一个commit 投票。</li><li>Validator 需要为被全网络precommit的区块，收集到超过 ⅔ commit投票。</li></ol><p>一旦两个条件全部满足了，节点会将 commitTime 设置到当前时间上，并且会<strong>进入NewHeight 阶段, 开启新的一轮</strong></p><p>在整个共识过程的任何阶段，一旦节点收到超过⅔ commit 投票，那么它会立刻进入到commit 阶段。</p><h1 id="二、共识讨论"><a href="#二、共识讨论" class="headerlink" title="二、共识讨论"></a>二、共识讨论</h1><h2 id="2-1-为什么Tendermint-BFT可以不分叉"><a href="#2-1-为什么Tendermint-BFT可以不分叉" class="headerlink" title="2.1 为什么Tendermint-BFT可以不分叉"></a>2.1 为什么Tendermint-BFT可以不分叉</h2><h3 id="分叉的诞生"><a href="#分叉的诞生" class="headerlink" title="分叉的诞生"></a>分叉的诞生</h3><p>更详细的阶段流程图：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20210723114007223.png" alt="image-20210723114007223"></p><ol><li>在propose阶段，proposer节点广播出了新块$Block_x$ </li><li>A在超时时间内没有收到这个新块，向外广播pre-vote nil，B,C,D都收到了，向外广播pre-vote投给$Block_x$ </li><li>现在四个节点进入了pre-commit阶段，<strong>A处于红色内圈，B,C,D处于蓝色外圈</strong></li><li>假设A由于自身网络不好，又没有在规定时间内收到超过2/3个对$Block_x$ 的投票，于是只能发出 pre-commit nil投票消息投给空块</li><li>D收到了B和C的pre-vote消息，加上自己的，就超过了2/3了，于是D在<strong>本地区块链</strong>里commit了$Block_x$​ </li><li>B和C网络出现问题，收不到D在pre-commit消息，这是B和C只能看到2票投给了$Block_x$ ，一票投给了空块，全部不足2/3，于是B和C都只能 commit空块，高度不变，进人R+1轮，A也只能看到2票投给了$Block_x$，一票投给了空块，也只能commit空块，高度不变，进人R+1轮</li><li>在R+1轮，由于新换了一个proposer, 提议了新的区块blockY，A,B,C 三个个可能会在达成共识，提交$Block_y$，<font color='#e54d42'>于是对于节点D来说在同样的高度，就有$Block_x$和$Block_y$两个块，产生了分叉。</font></li></ol><p>Tendermint加上了<font color='#e54d42'><strong>锁的机制</strong></font>，具体就是，在第7步，即使proposer出了新块$Block_y$​，A,B,C只能被锁定在第6步他们的pre-commit块上:</p><ul><li>A在第6步投给了空块，那么在第R+1轮，只能继续投给空块</li><li>B、C在第6步投给了$Block_x$，那么在新一轮，永远只能投给$Block_x$</li></ul><p><strong>这样在R+1轮，就会有1票投给空块，两票投给$Block_x$，最终达成共识$Block_x$，A,B,C三人都会commit $Block_x$，与D一致，没有产生冲突。</strong> </p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>首先PBFT的要求是全网有小于1/3的拜占庭节点，这是共识的基本前提条件，也是讨论分叉的前提条件。</p><p>当一个区块B在第R轮被Commit，那么就表明有大于2/3的节点在R轮投了precommit投票，进而就表明至少有<strong>大于1/3</strong>的节点锁定在R’&gt;R轮</p><blockquote><p><font color='#39b54a'>拜占庭共识的环境就是假设节点都不一定是诚实的，所以投precommit的2/3中的节点并不一定都是诚实的，所以可能会有大于1/3的节点锁定的更高轮次</font></p></blockquote><p>对于<strong>不同轮次的同一高度的区块确定</strong>来说也就不会出现两个2/3的prevote投票（因为有1/3在R’轮锁定）, 所以就不会分叉</p><blockquote><p><font color='#e54d42'>对于同一个高度，想要确定此高度的最终区块，可能会产生多个轮次的投票</font></p></blockquote><p><strong>总结：其不可分叉来自于其BFT共识的锁定以及PoLC共同完成</strong></p><h2 id="2-2-Tendermint-BFT与PBFT的比较"><a href="#2-2-Tendermint-BFT与PBFT的比较" class="headerlink" title="2.2 Tendermint-BFT与PBFT的比较"></a>2.2 Tendermint-BFT与PBFT的比较</h2><p><strong><em>相同点：</em></strong></p><ul><li>都属于BFT类型的算法，最多容忍不超过1/3的恶意节点</li><li>都是三阶段提交，Tendermint的propose-&gt;pre-vote-&gt;pre-commit三个阶段，跟PBFT的三个阶段，pre-prepare, prepare, commit 三阶段是一一对应的</li><li>都在超时的时候，换掉proposer/primary （都是leader）</li></ul><p><strong><em>不同点：</em></strong></p><p>不够Tendermint相对于PBFT有两处简化。 </p><ul><li><p>Tendermint没有PBFT那种View Change阶段</p><p>Tendermint很巧妙的<strong>把超时的情况跟普通情况融合成了统一的形式</strong>，都是 propose-&gt;pre-vote-&gt;pre-commit 三阶段，只是<font color='#e54d42'>超时的时候新块是一个特殊的空块</font>。<strong>切换proposer是通过提交commit空块</strong>来触发的，而PBFT是有一个单独的view change过程来触发primary轮换。 </p></li><li><p>Tendermint的所有信息都存储在区块链</p><p>因为PBFT是1999年提出来的，那时候还没有blockchain这个东西(blockchain是2009年比特币出现之后才有的)，因此PBFT的所有节点虽有有一致的数据，但<strong>数据是分散存放</strong>的。PBFT的每个节点的数据包括: </p><blockquote><p>The state of each replica includes the state of the service, a message log containing messages the replica has accepted, and an integer denoting the replica’s current view. </p><p>每个副本的状态包括服务状态、包含副本已接受消息的消息日志和一个表示副本当前视图的整数。</p></blockquote><p>Blockchain就是一个分布式数据库，好比在MySQL这类DBMS数据库没出现之前，人们都是把数据写入文件然后存在硬盘上，发明出各种奇怪的文件格式和组织方式。有了MySQL后，管理数据就方便多了。同理，Tendermint 把数据全部存入blockchain, PBFT没有blockchain这样一个分布式数据库，所有全节点需要自己在硬盘上管理数据，比如为了压缩消息日志，丢弃老的消息，节省硬盘空间，引入了checkpoint的概念，光是<strong>数据管理这一块就多了很多繁琐的步骤。</strong> </p></li></ul><p>总结：</p><p><font color='#e54d42'>Tendermint和PBFT关系类似于Raft和Paxos的关系，Tendermint是PBFT的简化版，是针对blockchain这个场景下的简化版PBFT 。</font></p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p><strong>==区块链技术元素提取：==</strong></p><p>==改进传统PBFT方法：==</p><ul><li>==Pos+BFT选举共识与主链共识的解耦合搭配==</li><li>==对区块施加锁机制以及PoFL，将节点绑定在一个区块的共识中防止分叉==</li><li>==提交nil块的投票可以省略view change流程==</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Tendermint项目目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43988498/article/details/118060169&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tendermint-1-基础概念&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;上一篇已经简单的介绍了Tendermint的基础概念，包括优势与特点、应用与生态等。下面将会详细的介绍Tendermint的共识算法，你将会学习到一下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tendermint-PBFT详解（high-level view -&amp;gt; detail）&lt;/li&gt;
&lt;li&gt;TBFT与传统PBFT的比较分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、Tendermint-BFT详解&quot;&gt;&lt;a href=&quot;#一、Tendermint-BFT详解&quot; class=&quot;headerlink&quot; title=&quot;一、Tendermint-BFT详解&quot;&gt;&lt;/a&gt;一、Tendermint-BFT详解&lt;/h1&gt;&lt;h2 id=&quot;1-1-共识环境分析&quot;&gt;&lt;a href=&quot;#1-1-共识环境分析&quot; class=&quot;headerlink&quot; title=&quot;1.1 共识环境分析&quot;&gt;&lt;/a&gt;1.1 共识环境分析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;角色：Validator（预先配置的网络中的一般验证者账户们）、Proposer（选举出的出块人）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;阶段：Propose阶段、Prevote阶段、Precommit阶段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;投票种类：prevote、precommit、commit&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#39b54a&#39;&gt;这些名词下面会一一介绍到&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="knowledge" scheme="https://xwjahahahaha.github.io/categories/knowledge/"/>
    
    
    <category term="tendermint" scheme="https://xwjahahahaha.github.io/tags/tendermint/"/>
    
  </entry>
  
  <entry>
    <title>DAS:Web3世界的去中心化身份认证系统</title>
    <link href="https://xwjahahahaha.github.io/2021/07/22/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E8%AF%BB/DID%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E8%BA%AB%E4%BB%BD/DAS:Web3%E4%B8%96%E7%95%8C%E7%9A%84%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F/"/>
    <id>https://xwjahahahaha.github.io/2021/07/22/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E8%AF%BB/DID%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E8%BA%AB%E4%BB%BD/DAS:Web3%E4%B8%96%E7%95%8C%E7%9A%84%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-07-22T02:59:33.000Z</published>
    <updated>2021-07-22T05:49:56.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置信息"><a href="#前置信息" class="headerlink" title="前置信息"></a>前置信息</h1><h2 id="Nervos-CKB"><a href="#Nervos-CKB" class="headerlink" title="Nervos CKB"></a>Nervos CKB</h2><h1 id="一、基本信息"><a href="#一、基本信息" class="headerlink" title="一、基本信息"></a>一、基本信息</h1><ul><li><p>官网：<a href="https://da.systems" target="_blank" rel="noopener">https://da.systems</a></p></li><li><p>上线时间：2021-7-22 20:00</p></li><li><p>开发团队：<a href="https://github.com/af913337456" target="_blank" rel="noopener">LinGuanHong</a></p><blockquote><p>目前仅在代码地址中找到该贡献者，其为《区块链以太坊DApp开发实战》书籍的作者</p></blockquote></li><li><p>开源代码地址：<a href="https://github.com/DeAccountSystems" target="_blank" rel="noopener">https://github.com/DeAccountSystems</a></p></li><li><p>依托链：Nervos CKB公链 (PoW)</p></li></ul><a id="more"></a><h1 id="二、特点介绍"><a href="#二、特点介绍" class="headerlink" title="二、特点介绍"></a>二、特点介绍</h1><h1 id="三、技术创新"><a href="#三、技术创新" class="headerlink" title="三、技术创新"></a>三、技术创新</h1><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前置信息&quot;&gt;&lt;a href=&quot;#前置信息&quot; class=&quot;headerlink&quot; title=&quot;前置信息&quot;&gt;&lt;/a&gt;前置信息&lt;/h1&gt;&lt;h2 id=&quot;Nervos-CKB&quot;&gt;&lt;a href=&quot;#Nervos-CKB&quot; class=&quot;headerlink&quot; title=&quot;Nervos CKB&quot;&gt;&lt;/a&gt;Nervos CKB&lt;/h2&gt;&lt;h1 id=&quot;一、基本信息&quot;&gt;&lt;a href=&quot;#一、基本信息&quot; class=&quot;headerlink&quot; title=&quot;一、基本信息&quot;&gt;&lt;/a&gt;一、基本信息&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;官网：&lt;a href=&quot;https://da.systems&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://da.systems&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上线时间：2021-7-22 20:00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开发团队：&lt;a href=&quot;https://github.com/af913337456&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LinGuanHong&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前仅在代码地址中找到该贡献者，其为《区块链以太坊DApp开发实战》书籍的作者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开源代码地址：&lt;a href=&quot;https://github.com/DeAccountSystems&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/DeAccountSystems&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;依托链：Nervos CKB公链 (PoW)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="knowledge" scheme="https://xwjahahahaha.github.io/categories/knowledge/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer18.删除链表的节点</title>
    <link href="https://xwjahahahaha.github.io/2021/07/22/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://xwjahahahaha.github.io/2021/07/22/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2021-07-22T02:42:09.000Z</published>
    <updated>2021-07-22T02:55:29.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 18. 删除链表的节点</a></p><p>难度简单</p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><a id="more"></a><p><strong>注意：</strong>此题对比原题有改动</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>本题是入门题，相信一般的解法不会难到大家</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接的思路</span></span><br><span class="line"><span class="comment">// 时间复杂度O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(head *ListNode, val <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head.Val == val &#123;</span><br><span class="line">        <span class="keyword">return</span> head.Next    <span class="comment">// 即使只有一个头节点，刚好返回nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    p := head</span><br><span class="line">    <span class="keyword">for</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p.Next != <span class="literal">nil</span> &amp;&amp; p.Next.Val == val &#123;</span><br><span class="line">            <span class="keyword">if</span> p.Next.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.Next = <span class="literal">nil</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p.Next = p.Next.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是需要学习的是还有一种给参方式：参数给的不是要删除的Val而是对应链表中节点的指针（也就是不用我们去遍历找了）</p><p>那在这种情况下怎样删除该节点呢？</p><p>主要的问题在于：<strong>单向链表中无法从当前节点获取上一个节点</strong></p><p>具体的思路可以这样解决：(来自剑指offer书)</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/G1dn8u.png" alt="G1dn8u"></p><p>例如给出了i节点的指针，那么可以将j节点的值复制到i，然后将i原本的指针指向j的后继节点，最后删除j节点i即可</p><p>此方法相当于从头开始遍历找i的前节点时间复杂度仅为O(1)</p><p>需要注意的是，如果给出的i是最后一个末尾节点，那么还是需要从头开始遍历（因为没有后续节点了），所以时间复杂度为O(n)</p><p>所以此方法的平均时间复杂度为: [(n-1)*1 + 1*n] / n= O(1) </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 18. 删除链表的节点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度简单&lt;/p&gt;
&lt;p&gt;给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。&lt;/p&gt;
&lt;p&gt;返回删除后的链表的头节点。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0203</title>
    <link href="https://xwjahahahaha.github.io/2021/07/22/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0203/"/>
    <id>https://xwjahahahaha.github.io/2021/07/22/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0203/</id>
    <published>2021-07-22T01:52:30.000Z</published>
    <updated>2021-07-23T01:17:51.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input checked="" disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input checked="" disabled="" type="checkbox"> 密码学</li><li><input disabled="" type="checkbox"> 论文</li><li><input checked="" disabled="" type="checkbox"> tendermint项目解读2</li><li><input disabled="" type="checkbox"> 一小时阅读</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0202</title>
    <link href="https://xwjahahahaha.github.io/2021/07/21/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0202/"/>
    <id>https://xwjahahahaha.github.io/2021/07/21/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0202/</id>
    <published>2021-07-21T01:39:01.000Z</published>
    <updated>2021-07-22T01:52:24.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input checked="" disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input checked="" disabled="" type="checkbox"> 密码学</li><li><input checked="" disabled="" type="checkbox"> 论文</li><li><input disabled="" type="checkbox"> tendermint项目解读2</li><li><input disabled="" type="checkbox"> 一小时阅读</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Decentralized_Privacy_Using_Blockchain-Enabled_Federated_Learning_in_Fog_Computing》精读</title>
    <link href="https://xwjahahahaha.github.io/2021/07/20/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E8%AE%BA%E6%96%87/FL%20And%20BlockChain/%E3%80%8ADecentralized-Privacy-Using-Blockchain-Enabled-Federated-Learning-in-Fog-Computing%E3%80%8B%E7%B2%BE%E8%AF%BB/"/>
    <id>https://xwjahahahaha.github.io/2021/07/20/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E8%AE%BA%E6%96%87/FL%20And%20BlockChain/%E3%80%8ADecentralized-Privacy-Using-Blockchain-Enabled-Federated-Learning-in-Fog-Computing%E3%80%8B%E7%B2%BE%E8%AF%BB/</id>
    <published>2021-07-20T07:40:34.000Z</published>
    <updated>2021-07-23T09:35:33.227Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>论文地址：<a href="https://ieeexplore.ieee.org/document/9019859" target="_blank" rel="noopener">https://ieeexplore.ieee.org/document/9019859</a></p></blockquote><h1 id="一、基本信息、前置知识"><a href="#一、基本信息、前置知识" class="headerlink" title="一、基本信息、前置知识"></a>一、基本信息、前置知识</h1><h2 id="1-1-基本信息"><a href="#1-1-基本信息" class="headerlink" title="1.1 基本信息"></a>1.1 基本信息</h2><p>《Decentralized Privacy Using Blockchain-Enabled Federated Learning in Fog Computing》</p><p>作者：<a href="https://ieeexplore.ieee.org/author/37086113748" target="_blank" rel="noopener">Youyang Qu</a>; <a href="https://ieeexplore.ieee.org/author/37400376100" target="_blank" rel="noopener">Longxiang Gao</a>; <a href="https://ieeexplore.ieee.org/author/37085345130" target="_blank" rel="noopener">Tom H. Luan</a>; <a href="https://ieeexplore.ieee.org/author/37286573200" target="_blank" rel="noopener">Yong Xiang</a>; <a href="https://ieeexplore.ieee.org/author/37405530700" target="_blank" rel="noopener">Shui Yu</a>; <a href="https://ieeexplore.ieee.org/author/37088420381" target="_blank" rel="noopener">Bai Li</a>; <a href="https://ieeexplore.ieee.org/author/37088420573" target="_blank" rel="noopener">Gavin Zheng</a></p><p>出版刊物：<a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6488907" target="_blank" rel="noopener">IEEE Internet of Things Journal</a> ( Volume: 7, <a href="https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=9115800" target="_blank" rel="noopener">Issue: 6</a>)</p><p>年份：June 2020</p><p>期刊影响因子/分区：2021年9.47/<strong>Q1</strong></p><a id="more"></a><h2 id="1-2-前置知识"><a href="#1-2-前置知识" class="headerlink" title="1.2 前置知识"></a>1.2 前置知识</h2><h3 id="雾计算"><a href="#雾计算" class="headerlink" title="雾计算"></a>雾计算</h3><blockquote><p>百度百科：</p><p>雾计算（Fog Computing），在该模式中数据、（数据）处理和<a href="https://baike.baidu.com/item/应用程序集/3491931" target="_blank" rel="noopener">应用程序集</a>中在<strong>网络边缘的设备</strong>中，而不是几乎全部保存在云中，是<a href="https://baike.baidu.com/item/云计算/9969353" target="_blank" rel="noopener">云计算</a>（Cloud Computing）的延伸概念，由<a href="https://baike.baidu.com/item/思科/454822" target="_blank" rel="noopener">思科</a>（Cisco）提出的。这个因“云”而“雾”的命名源自“雾是更贴近地面的云”这一名句。</p><p>雾计算和云计算一样，十分形象。云在天空飘浮，高高在上，遥不可及，刻意抽象；而雾却现实可及，贴近地面，就在你我身边。雾计算并非由性能强大的服务器组成，而是由<strong>性能较弱、更为分散的各类功能计算机组成</strong>，渗入工厂、汽车、电器、街灯及人们物质生活中的各类用品。</p></blockquote><p>雾计算不是具体的一种算法，而是偏向一种新型的应用概念</p><h1 id="二、解决的问题"><a href="#二、解决的问题" class="headerlink" title="二、解决的问题"></a>二、解决的问题</h1><ol><li><p>分布式隐私：融合区块链和联邦学习框架解决雾计算的单点隐私问题, 通过区块链解决隐私保护 </p><blockquote><p><font color='#39b54a'>去中心化实现的隐私保护</font></p></blockquote></li><li><p>投毒攻击证明：区块链系统提供non-tempering特点实现投毒攻击的评估</p></li><li><p>高效率：一方面联邦学习只交换梯度参数，第二方面区块链只存储指针，数据通过<strong>链下的分布式Hash表存储</strong></p></li></ol><h1 id="三、创新的方法"><a href="#三、创新的方法" class="headerlink" title="三、创新的方法"></a>三、创新的方法</h1><h2 id="3-1-FL-Block体系框架"><a href="#3-1-FL-Block体系框架" class="headerlink" title="3.1 FL-Block体系框架"></a>3.1 FL-Block体系框架</h2><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/P6vXDd.png" alt="P6vXDd"></p><ul><li><p>在FL-Block的框架中，区块的区块体中保存所有本地设备的模型更新, 对于每个设备来说包括：</p><ul><li>在每个epoch的$(w_i^{(l)}, { \nabla f_k(w^{(l)}) }_{s_k \in S_i})$​</li><li>本地计算时间 <img src="http://xwjpics.gumptlu.work/qinniu_uPic/2NSrSL.png" alt="2NSrSL"></li></ul><blockquote><p><font color='#39b54a'>后面的式子可以简单理解: (此次参数， 此次参数的变化量)</font></p></blockquote></li><li><p>每个区块的大小被定义为$h + \delta_m N_V $</p><ul><li>$h$代表区块头大小</li><li>$\delta_m$​代表模型更新大小</li></ul></li><li><p><strong>每一个矿工Miner拥有一个与其相关联的设备或者其他Miner的充满了本地模型更新数据的候选区块(未上链区块)</strong>,写入区块数据的过程直到达到区块的最大数据量或者达到等待时间$T_{wait}$​</p></li><li><p>区块的生成速度$\lambda$（在区块头）可以被POW的难度控制,即POW的难度越大/区块目标值越小,区块生成速率$\lambda$越小</p></li></ul><blockquote><p><font color='#e54d42'>这部分区块链设计与《Blockchained_On-Device_Federated_Learning》论文一模一样…….emmm, 估计后面的时间效率分析也是一摸一样了….抄袭过于明显了.</font></p></blockquote><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;论文地址：&lt;a href=&quot;https://ieeexplore.ieee.org/document/9019859&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ieeexplore.ieee.org/document/9019859&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、基本信息、前置知识&quot;&gt;&lt;a href=&quot;#一、基本信息、前置知识&quot; class=&quot;headerlink&quot; title=&quot;一、基本信息、前置知识&quot;&gt;&lt;/a&gt;一、基本信息、前置知识&lt;/h1&gt;&lt;h2 id=&quot;1-1-基本信息&quot;&gt;&lt;a href=&quot;#1-1-基本信息&quot; class=&quot;headerlink&quot; title=&quot;1.1 基本信息&quot;&gt;&lt;/a&gt;1.1 基本信息&lt;/h2&gt;&lt;p&gt;《Decentralized Privacy Using Blockchain-Enabled Federated Learning in Fog Computing》&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://ieeexplore.ieee.org/author/37086113748&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Youyang Qu&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37400376100&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Longxiang Gao&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37085345130&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tom H. Luan&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37286573200&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yong Xiang&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37405530700&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Shui Yu&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37088420381&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bai Li&lt;/a&gt;; &lt;a href=&quot;https://ieeexplore.ieee.org/author/37088420573&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gavin Zheng&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出版刊物：&lt;a href=&quot;https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6488907&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IEEE Internet of Things Journal&lt;/a&gt; ( Volume: 7, &lt;a href=&quot;https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=9115800&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Issue: 6&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;年份：June 2020&lt;/p&gt;
&lt;p&gt;期刊影响因子/分区：2021年9.47/&lt;strong&gt;Q1&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="knowledge" scheme="https://xwjahahahaha.github.io/categories/knowledge/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer17.打印从1到最大的n位数</title>
    <link href="https://xwjahahahaha.github.io/2021/07/20/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <id>https://xwjahahahaha.github.io/2021/07/20/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</id>
    <published>2021-07-20T03:47:16.000Z</published>
    <updated>2021-07-21T02:08:18.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 17. 打印从1到最大的n位数</a></p><p>难度简单</p><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure> <a id="more"></a><p>说明：</p><ul><li>用返回一个整数列表来代替打印</li><li>n 为正整数</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>本题乍一看非常简单，但是核心考察的是<strong>大数溢出问题</strong></p><p>不论是int64还是其他语言，变量都有上限，在输入n很大的情况下就会导致溢出，所以大数溢出问题的解决：</p><ul><li><font color='#e54d42'>字符数组表示数字，由低到高</font></li></ul><p>在编写代码时还需要注意两个细节：</p><ol><li><p>例如n=3， 从1～999怎样判断该字符数组到达999？</p><p>使用循环逐位判断’9’复杂度为O(n)，不是很好的办法。当其再加一就会导致进位，判断其进位是否到达最高位的上一位即可（即判断再加1是否到1000），这样时间复杂度为O(1)</p></li><li><p>初始化字符数组都为’0’，如果数字没有n位，那么前面会有多个无意义的0，对于输出来说不合适，所以在字符数组大数转为对应的数字时需要清除掉前面的0 （虽然Go的Atoi自动会清除）</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直观的思路</span></span><br><span class="line"><span class="comment">// 但是没有考虑大数溢出问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建结果数组</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=<span class="keyword">int</span>(math.Pow10(n)<span class="number">-1</span>); i++ &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 </span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法二：字符串模拟构造大数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    numString := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n+<span class="number">1</span>)    <span class="comment">// 多设置一位是为了判断循环是否结束</span></span><br><span class="line">    <span class="comment">// 全部位初始化为0，即使达不到n位，前面也为0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(numString); i++ &#123;</span><br><span class="line">        numString[i] = <span class="keyword">byte</span>(<span class="string">'0'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> !Increment(&amp;numString) &#123;</span><br><span class="line">        <span class="comment">// 将输出存储</span></span><br><span class="line">        <span class="comment">// 排除前面的0, 找到第一个1</span></span><br><span class="line">        vaildIndex := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(numString); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> numString[i] != <span class="string">'0'</span> &#123;</span><br><span class="line">                vaildIndex = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num, _ := strconv.Atoi(<span class="keyword">string</span>(numString[vaildIndex:]))</span><br><span class="line">        res = <span class="built_in">append</span>(res, num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串数字 +1 函数</span></span><br><span class="line"><span class="comment">// 注意为了改变原字节数组，所以传递指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Increment</span><span class="params">(numString *[]<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> carry <span class="keyword">byte</span>          <span class="comment">// 进位</span></span><br><span class="line">    carry = <span class="number">0</span>  </span><br><span class="line">    n := <span class="built_in">len</span>(*numString)<span class="number">-1</span>     </span><br><span class="line">    <span class="keyword">for</span> i:=n; i&gt;=<span class="number">0</span>; i-- &#123;       <span class="comment">// 此循环为了进位</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 到达最高位即可让外层循环退出，最高位(数组中下标为1)的上一位(数组中下标为0)为1，产生进位，所以结束</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取当前位置数</span></span><br><span class="line">        num := (*numString)[i] - <span class="string">'0'</span> </span><br><span class="line">        <span class="comment">// +1 只在末位(数组中下标为n)</span></span><br><span class="line">        <span class="keyword">if</span> i == n &#123;</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加上进位</span></span><br><span class="line">        num += carry</span><br><span class="line">        <span class="comment">// 计算新的进位</span></span><br><span class="line">        <span class="keyword">if</span> num &gt;= <span class="number">10</span> &#123;</span><br><span class="line">            carry = <span class="number">1</span></span><br><span class="line">            num -= <span class="number">10</span></span><br><span class="line">            (*numString)[i] = <span class="string">'0'</span> + num     <span class="comment">// 将当前位写上，进位还有继续循环计算 </span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 变回字符串</span></span><br><span class="line">            (*numString)[i] = <span class="string">'0'</span> + num     <span class="comment">// 将当前位写上，已无进位，结束循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一次+1 计算完毕，无溢出返回falsefalse，让外层循环继续写入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于使用字符串表示大数，本题的大数每一位都是’0’～’9’字符的排列，所以可以看作全排列来减少代码量</p><p>全排列使用递归会更加的好写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大数字符串的递归全排列</span></span><br><span class="line"><span class="comment">// 每一位都是字符0～1的全排列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    numString := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">    <span class="comment">// 递归函数</span></span><br><span class="line">    <span class="keyword">var</span> recursive <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span> </span><br><span class="line">    recursive = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> index == n &#123;</span><br><span class="line">            <span class="comment">// 记录当前值（除去开头无效0）</span></span><br><span class="line">            vaildStart := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> numString[i] != <span class="string">'0'</span> &#123;</span><br><span class="line">                    vaildStart = i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num, _ := strconv.Atoi(<span class="keyword">string</span>(numString[vaildStart:]))</span><br><span class="line">            res = <span class="built_in">append</span>(res, num)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=<span class="number">9</span>; i++ &#123;</span><br><span class="line">            <span class="comment">// 存储当前下标位置字符</span></span><br><span class="line">            numString[index] = <span class="string">'0'</span> + <span class="keyword">byte</span>(i)</span><br><span class="line">            <span class="comment">// 向下一位递归</span></span><br><span class="line">            recursive(index+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    recursive(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">1</span>:]  <span class="comment">// 此处去除掉最开始的0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='#39b54a'>本题直接用数字遍历到n位在时间上肯定会比字符串大数来的快，但是安全性上是有所缺陷的并且对于项目来说可能是致命的，具体场景要具体适用</font></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 17. 打印从1到最大的n位数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度简单&lt;/p&gt;
&lt;p&gt;输入数字 &lt;code&gt;n&lt;/code&gt;，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: n &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2,3,4,5,6,7,8,9]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0201</title>
    <link href="https://xwjahahahaha.github.io/2021/07/20/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0201/"/>
    <id>https://xwjahahahaha.github.io/2021/07/20/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0201/</id>
    <published>2021-07-20T01:08:42.000Z</published>
    <updated>2021-07-21T01:38:55.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input checked="" disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input disabled="" type="checkbox"> 零知识证明</li><li><input checked="" disabled="" type="checkbox"> 论文</li><li><input disabled="" type="checkbox"> tendermint项目解读2</li><li><input disabled="" type="checkbox"> 一小时阅读</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>零知识证明</title>
    <link href="https://xwjahahahaha.github.io/2021/07/19/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"/>
    <id>https://xwjahahahaha.github.io/2021/07/19/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</id>
    <published>2021-07-19T08:40:51.000Z</published>
    <updated>2021-07-20T06:45:35.897Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.bilibili.com/video/BV18y4y1v7Ai" target="_blank" rel="noopener">https://www.bilibili.com/video/BV18y4y1v7Ai</a></p><p><a href="https://cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography/" target="_blank" rel="noopener">https://cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography/</a></p><p><a href="https://cloud.tencent.com/developer/article/1779901" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1779901</a></p><p><a href="https://www.cnblogs.com/Lands-ljk/p/11718235.html" target="_blank" rel="noopener">https://www.cnblogs.com/Lands-ljk/p/11718235.html</a></p></blockquote><blockquote><p>本文资料多来自2019年ALON ROSEN教授的“第九届BIU密码学冬令营-Zero Knowledge专题”, 该课程从<strong>复杂性理论</strong>切入，较难理解</p></blockquote><h1 id="一、Zero-Knowledge基础"><a href="#一、Zero-Knowledge基础" class="headerlink" title="一、Zero-Knowledge基础"></a>一、Zero-Knowledge基础</h1><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/7INqR5.png" alt="7INqR5"></p><a id="more"></a><p>零知识证明：证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV18y4y1v7Ai&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/BV18y4y1v7Ai&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1779901&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cloud.tencent.com/developer/article/1779901&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Lands-ljk/p/11718235.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/Lands-ljk/p/11718235.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;本文资料多来自2019年ALON ROSEN教授的“第九届BIU密码学冬令营-Zero Knowledge专题”, 该课程从&lt;strong&gt;复杂性理论&lt;/strong&gt;切入，较难理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、Zero-Knowledge基础&quot;&gt;&lt;a href=&quot;#一、Zero-Knowledge基础&quot; class=&quot;headerlink&quot; title=&quot;一、Zero-Knowledge基础&quot;&gt;&lt;/a&gt;一、Zero-Knowledge基础&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/7INqR5.png&quot; alt=&quot;7INqR5&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/categories/technical/golang/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer16.数值的整数次方</title>
    <link href="https://xwjahahahaha.github.io/2021/07/19/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>https://xwjahahahaha.github.io/2021/07/19/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</id>
    <published>2021-07-19T03:05:02.000Z</published>
    <updated>2021-07-19T03:17:45.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a></p><p>难度中等</p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>-104 &lt;= xn &lt;= 104</code></li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>此题细节非常多，考察的不仅仅是简单的求整数次方，要着重考虑<strong>边界情况与优化</strong></p><p>细节注意点：</p><ol><li>输入的指数n是否可能为负数，负数要怎样处理？</li><li>输入的底数x是否可能为0，n为负数，那么就会导致分母为0的情况，所以对于x为0统一的处理方式是返回0（$0^0$在数学上没有意义）</li><li>浮点数的等值判断是否可以直接用等号？显然是不合适的</li><li>求数值的整数次方时间上是否可以优化？</li><li>除2以及求余函数是否可以优化？</li></ol><p>求整数倍的优化算法是：<br>$$<br>a^n = \begin{cases}a^{n/2} * a^{n/2} &amp; n为偶数 \ a^{(n-1)/2} * a^{(n-1)/2} * a &amp; n为奇数 \end{cases}<br>$$<br>详情可见下方代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MIN = <span class="number">0.00000000000001</span>        <span class="comment">// 比较的精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个浮点数是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsEqual</span><span class="params">(f1, f2 <span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f1 &gt; f2 &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Dim(f1, f2) &lt; MIN</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Dim(f2, f1) &lt; MIN</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值整数次方计算函数</span></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">uint</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右移代替除二</span></span><br><span class="line">    res := MyPow(x, n&gt;&gt;<span class="number">1</span>)</span><br><span class="line">    res = res * res</span><br><span class="line">    <span class="comment">// 判断奇偶，奇数再乘本身一次</span></span><br><span class="line">    <span class="comment">// 位与运算代替求余</span></span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">0x1</span> == <span class="number">1</span> &#123;</span><br><span class="line">        res *= x</span><br><span class="line">    &#125;             </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> IsEqual(x, <span class="number">0.0</span>) &#123;       <span class="comment">// 如果底数为0，则无意义直接返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;                <span class="comment">// 如果底数不为0，但指数为负数，那么处理底数与指数</span></span><br><span class="line">        x = <span class="number">1.0</span> / x</span><br><span class="line">        n *= <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求整数倍的优化算法</span></span><br><span class="line">    <span class="keyword">return</span> MyPow(x, <span class="keyword">uint</span>(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 16. 数值的整数次方&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;实现 &lt;a href=&quot;https://www.cplusplus.com/reference/valarray/pow/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pow(&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;)&lt;/a&gt; ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0200</title>
    <link href="https://xwjahahahaha.github.io/2021/07/19/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0200/"/>
    <id>https://xwjahahahaha.github.io/2021/07/19/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0200/</id>
    <published>2021-07-19T01:10:48.000Z</published>
    <updated>2021-07-20T01:08:34.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input disabled="" type="checkbox"> 零知识证明</li><li><input checked="" disabled="" type="checkbox"> BlockFLA论文</li><li><input disabled="" type="checkbox"> tendermint项目解读2</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LibP2P包的学习</title>
    <link href="https://xwjahahahaha.github.io/2021/07/17/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E5%8C%85%E5%AD%A6%E4%B9%A0/libp2p%E5%8C%85%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://xwjahahahaha.github.io/2021/07/17/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E5%8C%85%E5%AD%A6%E4%B9%A0/libp2p%E5%8C%85%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-17T10:32:16.000Z</published>
    <updated>2021-07-19T13:30:50.466Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习资料来源：</p><p><a href="https://zhuanlan.zhihu.com/p/49062384" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49062384</a></p><p><a href="https://colobu.com/2018/03/26/distributed-hash-table/" target="_blank" rel="noopener">https://colobu.com/2018/03/26/distributed-hash-table/</a></p><p>libp2p官方文档</p></blockquote><p>本篇文章涵盖内容：</p><ul><li>分布式Hash表、Kademlia算法</li><li>Libp2p的基本、核心概念</li><li>Libp2p的一个简单使用流程（手动编写ping协议实现）</li><li>基本的主机配置</li></ul><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>万事万物都要从其概念学起…</p><h2 id="1-1-前置概念"><a href="#1-1-前置概念" class="headerlink" title="1.1 前置概念"></a>1.1 前置概念</h2><h3 id="分布式Hash表"><a href="#分布式Hash表" class="headerlink" title="分布式Hash表"></a>分布式Hash表</h3><hr><p><em>查表式与计算式</em></p><p>关于分布式多节点情景下数据如何布局，主要有两种思路：<strong>查表式和计算式</strong>。</p><p>所谓查表式，即通过维护<strong>全局统一的映射表</strong>，需要访问数据时，先查询该表定位数据所在节点。<br>计算式无需维护该映射表，需要访问数据时，通过<strong>一定规则</strong>计算出数据所在位置。</p><p>查表式和计算式各有优劣：</p><p>查表式需要一个中心服务器维护全局的映射表信息，这可能成为系统的瓶颈；<br>而计算式的主要问题在于存储节点的变更可能带来大量的数据迁移，增加系统复杂度。</p><p><font color='#e54d42'>分布式Hash就是一种典型的<strong>计算式</strong>数据布局算法</font></p><hr><p><em>官方概念：</em></p><blockquote><p><strong>分布式哈希表（distributed hash table，缩写DHT）</strong>是分布式计算系统中的一类，用来将一个键（key）的集合分散到所有在分布式系统中的节点。这里的节点类似哈希表中的存储位置。分布式哈希表通常是为了拥有大量节点的系统，而且系统的节点常常会加入或离开。</p><p>其主要的动机是为了开发<strong>点对点</strong>系统。</p></blockquote><hr><p><em>算法过程：</em></p><p>DHT算法大致可以描述为以下两个子算法：</p><ul><li>建立节点的位置算法</li><li>确定查询节点位置算法</li><li>确定存储对象的位置算法 =&gt; 提供服务</li></ul><p>下面以Dynamo使用的结构举例：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/ZTQGjf.png" alt="ZTQGjf"></p><blockquote><p><strong>注意：这里的Ring结构只是举个例子，并不是所有的DHT都使用此结构</strong></p></blockquote><p>所有的分布式节点都遵循这样的一套规则进行数据的存储与查询，整体向外提供高容灾性的服务。</p><hr><p><em>特性：</em></p><p>分布式Hash表本质上强调以下特性：</p><ul><li><strong>离散性</strong>：构成系统的节点并没有任何中央式的协调机制</li><li><strong>伸缩性</strong>：即使有成千上万个节点，系统仍然应该十分有效率</li><li><strong>容错性</strong>：即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度</li></ul><p>对于分布式Hash表有一个基本的了解即可，这里不再继续展开。。。</p><hr><h3 id="Kademlia算法"><a href="#Kademlia算法" class="headerlink" title="Kademlia算法"></a>Kademlia算法</h3><p><em>维基官方定义如下：</em></p><blockquote><p><font color='#e54d42'><strong>Kademlia</strong>（简称kad）是一种通过 DHT 的协议算法</font>，它是由Petar和David在2002年为P2P网络而设计的。Kademlia规定了网络的结构，也规定了通过节点查询进行信息交换的方式。<br>Kademlia网络节点之间使用<strong>UDP</strong>进行通讯。参与通讯的所有节点形成一张虚拟网（或者叫做覆盖网）。这些节点通过一组数字（或称为节点ID）来进行身份标识。节点ID不仅可以用来做身份标识，还可以用来进行值定位（值通常是文件的散列或者关键词）。</p><p>当我们在网络中搜索某些值（即通常搜索存储文件散列或关键词的节点）的时候，Kademlia算法需要知道与这些值相关的键，然后逐步在网络中开始搜索。每一步都会找到一些节点，这些节点的ID与键更为接近，如果有节点直接返回搜索的值或者再也无法找到与键更为接近的节点ID的时候搜索便会停止。</p></blockquote><hr><p><em>节点距离计算规则：</em></p><p>距离是指节点之间的<strong>跳数</strong></p><p>精妙的与<strong>异或算法</strong>结合：</p><ul><li><code>(A ⊕ B) == (B ⊕ A)</code>: XOR 符合“交换律”，具备对称性。A和B的距离从哪一个节点计算都是相同的。</li><li><code>(A ⊕ A) == 0</code>: 反身性，自己和自己的距离为零。</li><li><code>(A ⊕ B) &gt; 0</code>: 两个不同的 key 之间的距离必大于零。</li><li><code>(A ⊕ B) + (B ⊕ C) &gt;= (A ⊕ C)</code>: 三角不等式, A经过B到C的距离总是大于A直接到C的距离。</li></ul><hr><p><em>映射规则 / 节点位置计算方法：</em></p><p>Kad使用160位的Hash算法，完整的Key有160二进制位，所以最多可以容纳$2^{160}$个节点</p><p>Kad将所有的Key都映射到一个二叉树，每一个<strong>Key都是二叉树的叶子</strong></p><blockquote><p><font color='#e54d42'><strong>一个Key对应于一个节点</strong>，当然也可能会有虚拟节点</font></p><p><font color='#e54d42'><strong>注意:</strong>上方距离DHT的时候使用的是Ring结构，这里Kad算法使用的二叉树而不是Ring</font></p></blockquote><p>将Key看作160位的二进制，二叉树的第n层就对应了第n位，可以按照左0右1的规则如下分割下去：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/k2P4PD.png" alt="k2P4PD"></p><p>分割完之后<strong>叶子节点到根节点的路径</strong>就对应于一个完整的Key，代表着该系统分布式的一个节点</p><hr><p><em>拆子树与K桶：</em></p><ul><li><p>拆子树</p><ul><li><p>每个节点按照<strong>自己的角度</strong>去拆分子树，从根节点开始看，如果其右子树不包含自己那么就将其左子树拆分出来，依此类推往下拆分直到只有自己</p></li><li><p>因为Kad的Key一共是160位，其二叉树就是160层，那么对于一个节点来说最多拆分出来的子树有160个（每层拆一个）（当然实际情况节点数远小于$2^{160}$个，节点拆分子树的个数也不会是160个）</p></li><li><p>对于一个节点的n个拆分子树，如果都知道里面的一个节点，那么就可以利用这n个节点进行<strong>递归路由</strong>从而找到整个二叉树的所有节点(也即到达每一个节点)</p></li></ul></li><li><p>K桶<code>（K-bucket）</code></p><ul><li>仅知道子树中的一个节点不够健壮(考虑到意外宕机等), 多个才安全</li><li>K就是指知道K个节点来保证健壮性(考虑实际情况K只是一个<strong>上限</strong>)，其K为一个系统级别的常量</li><li>K桶的概念其实就是<strong>路由表</strong>，节点需要知道n个子树就需要维护n个路由表/K桶，每个路由表/桶的上限大小是K</li><li>选择K个节点：选择<strong>长时间在线</strong>的节点，如果当前K桶满了就将新的节点放入<strong>缓存</strong>，待有节点断连就将新节点更换之</li></ul></li></ul><hr><p><em>Kad协议消息类型：</em></p><p>共四种：</p><ul><li><strong>PING</strong>消息: 用来测试节点<u>是否仍然在线</u>。</li><li><strong>STORE</strong>消息: 在某个节点中<u>存储</u>一个键值对。</li><li><strong>FIND_NODE</strong>消息: 消息请求的接收者将返回自己桶中<u>离请求键值最<strong>近</strong></u>的K个节点。</li><li><strong>FIND_VALUE</strong>消息: 与FIND_NODE一样，不过当请求的接收者存有请求者所请求的键的时候，它将返回相应键的值。</li></ul><p>每一个RPC消息中都包含一个发起者加入的<strong>随机值</strong>，这一点确保响应消息在收到的时候能够与前面发送的请求消息<strong>匹配</strong></p><hr><p><em>定位最近节点:</em></p><p>查询可以异步也可同步</p><ol><li>查询发起者节点从自己的K桶中筛选出离目标Id最近的一些节点，并发起异步查询请求</li><li>被查询节点收到请求后，从自己的K桶中找出自己知道的与查询ID最近的若干个节点返回给发起者</li><li>发起者收到后更新自己的结果列表，再次筛选出离目标最近的若干未请求过的节点重复步骤一</li><li>直到找不到最近的未请求过的节点为止</li><li>查询过程中未响应的节点会被立即排除；查询者需要最终获得的K个节点都是活动的</li></ol><hr><p><em>定位资源：</em></p><p>定位资源时，如果一个节点存有相应的资源的值的时候，它就返回该资源，搜索便结束了，除了该点以外，<strong>定位资源与定位离键最近的节点的过程相似。</strong></p><p>考虑到节点未必都在线的情况，<strong>资源的值被存在多个节点上（节点中的K个）</strong>，并且，为了提供冗余，还有可能在更多的节点上储存值。储存值的节点将定期搜索网络中与储存值所对应的键接近的K个节点并且把值复制到这些节点上，这些节点可作为那些下线的节点的补充。另外还有缓存技术。</p><hr><p><em>加入网络：</em></p><ol><li>新节点A必须知道某个引导节点B，并把它加入到自己相应的K-桶中</li><li>生成一个随机的节点ID,直到离开网络，该节点会一直使用该ID号</li><li>向B（A目前知道的唯一节点）发起一个查询请求（FIND_NODE），请求的ID是自己（就是查询自己）</li><li>B收到该请求之后，会先把A的ID加入自己的相应的 K-桶中。并且根据 FIND_NODE 请求的约定，B会找到K个最接近 A 的节点，并返回给 A</li><li>A收到这K个节点的ID之后，把他们加入自己的 K-桶</li><li>然后A会继续向刚刚拿到的这批节点(还未发送过请求的节点)发送查询请求（协议类型 FIND_NODE），如此往复，直至A建立了足够详细的路由表。</li><li>这种<font color='#e54d42'>“<strong>自我定位</strong>”</font>将使得Kad的其他节点（收到请求的节点）能够使用A的ID填充他们的K-桶，同时也能够使用那些查询过程的中间节点来填充A的K-桶。这已过程既让A获得了详细的路由表，也让其它节点知道了A节点的加入</li></ol><h2 id="1-2-LibP2P基本概念"><a href="#1-2-LibP2P基本概念" class="headerlink" title="1.2 LibP2P基本概念"></a>1.2 LibP2P基本概念</h2><p>Libp2p是Protocol Labs旗下的五个明星项目之一，五个项目彼此独立而又相互联系，旨在建立一个更安全、高效、开放的网络。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/QBObqG.png" alt="QBObqG"></p><p>Libp2p是一个<strong><font color='#e54d42'>模块化</font>的网络栈</strong>，通过将各种传输协议和P2P协议结合在一起，开发人员能够构建大型、健壮的P2P网络。</p><a id="more"></a><p><strong>Libp2p是IPFS的网络层,主要负责发现节点、连接节点、发现数据、传输数据</strong></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/H2RaTm.png" alt="H2RaTm"></p><blockquote><p>Libp2p官方网站: <a href="https://libp2p.io" target="_blank" rel="noopener">https://libp2p.io</a></p><p>github(go版本): <a href="https://github.com/libp2p/go-libp2p" target="_blank" rel="noopener">https://github.com/libp2p/go-libp2p</a></p></blockquote><p><font color='#e54d42'><strong>LibP2P实现了基于Kademlia-base的分布式Hash表</strong></font></p><h1 id="二、LibP2P核心概念"><a href="#二、LibP2P核心概念" class="headerlink" title="二、LibP2P核心概念"></a>二、LibP2P核心概念</h1><p>此章介绍LibP2P中的一些核心概念，此部分大多来自官网翻译，知道大意即可</p><h2 id="2-1-Transport-传输"><a href="#2-1-Transport-传输" class="headerlink" title="2.1 Transport 传输"></a>2.1 Transport 传输</h2><p>网络中不同电脑之间的数据传播很可能使用的就是TCP/IP协议, 当然要求快速但不可靠的服务可能会用到UDP</p><p>虽然TCP和UDP(连同IP)是目前最常用的协议，但它们绝不是唯一的选择。</p><p>备选方案存在于较低的级别(例如发送原始以太网数据包或蓝牙帧)和较高的级别(例如QUIC，它是在UDP之上分层的)。</p><p>在libp2p中，我们将这些围绕传输移动比特的基本协议称为基础协议，libp2p的核心需求之一是<strong>与传输无关</strong>。这意味着<strong>使用什么传输协议取决于开发人员</strong>，事实上<strong>一个应用程序可以同时支持许多不同的传输</strong>。</p><p>传输具有两个核心的操作实现：<strong>监听</strong>和<strong>拨号</strong></p><p>libp2p 实现中的<strong>每个传输都将共享相同的编程接口。</strong></p><p>监听和拨号都需要知道如何联系他们，libp2p 使用一种称为“<code>multiaddr</code>多地址”的约定或对许多不同的寻址方案进行编码。</p><p>例子：<code>/ip4/7.7.7.7/tcp/6543</code> 其表示<code>7.7.7.7</code>属于IPv4协议, 6543属于tcp</p><p>包含<code>PeerId</code>的例子：<code>/ip4/1.2.3.4/tcp/4321/p2p/QmcEPrat8ShnCph8WjkREzt5CPXF2RwhYxYBALDcLC1iV6</code></p><p>其添加了公钥的Hash唯一标识远程对等方</p><p><font color='#39b54a'>当<strong>对等路由</strong>启动后，只需要使用PeerId即可拨打给对等方，而无需事先知道他们的传输地址</font></p><h2 id="2-2-NAT穿透"><a href="#2-2-NAT穿透" class="headerlink" title="2.2 NAT穿透"></a>2.2 NAT穿透</h2><p>NAT(网络地址转换)简单来说就是一个局域网内的主机共享一个对外的公网IP，当需要数据传出时将公共IP替换成内部IP，当数据从另一端返回时，路由器将转换回内部IP</p><p>NAT的转出一般是透明的，转入则需要一些配置，指定到一些特定的端口中, 通常是通过将一个或多个 TCP 或 UDP 端口从公共 IP 映射到内部端口。</p><p><strong>自动路由器配置</strong>：许多路由器支持端口转发的自动配置协议，最常见的是 <a href="https://en.wikipedia.org/wiki/Universal_Plug_and_Play" target="_blank" rel="noopener">UPnP</a> 或者 <a href="https://en.wikipedia.org/wiki/NAT_Port_Mapping_Protocol" target="_blank" rel="noopener">nat-pmp。</a>如果你的路由器支持这些协议之一，那么libp2p将会自动配置端口映射，无需其他操作。</p><p>当使用 IP 支持的传输时，libp2p 将尝试通过<strong>使用相同的端口进行拨号和侦听</strong>，使用名为的套接字选项 <a href="https://lwn.net/Articles/542629/" target="_blank" rel="noopener"><code>SO_REUSEPORT</code></a>.</p><p>libp2p 的核心协议之一是<a href="https://github.com/libp2p/specs/pull/97" target="_blank" rel="noopener">identify protocol (识别协议)</a>，这允许一个对等点向另一个点询问一些识别信息。当发送他们的<a href="https://docs.libp2p.io/concepts/peer-id/" target="_blank" rel="noopener">公钥</a> 和一些其他有用的信息，被识别的对等方包括它为提出问题的对等方观察到的地址集。</p><p>虽然 <a href="https://github.com/libp2p/specs/pull/97" target="_blank" rel="noopener">识别协议</a> 上面描述的让对等点相互通知他们观察到的网络地址，并非所有网络都允许在用于拨出的同一端口上进行传入连接。</p><p>其他对等点可以帮助我们观察我们的情况，这一次是通过尝试通过我们观察到的地址拨打我们的电话。如果这成功了，我们就可以<strong>依靠其他节点也可以拨打我们的电话</strong>，然后我们就可以开始宣传我们的收听地址了。</p><p>一个名为 AutoNAT 的 libp2p 协议允许对等方从提供 AutoNAT 服务的对等方请求回拨。</p><p>在某些情况下，对等方将无法以可公开访问的方式遍历其 NAT。</p><p>libp2p 提供了一个 <a href="https://docs.libp2p.io/concepts/circuit-relay/" target="_blank" rel="noopener">电路中继协议</a> 这允许<strong>对等点通过有用的中间对等点进行间接通信。</strong></p><h2 id="2-3-电路继电器-中继节点"><a href="#2-3-电路继电器-中继节点" class="headerlink" title="2.3 电路继电器(中继节点)"></a>2.3 电路继电器(中继节点)</h2><p>电路继电器是一种 <a href="https://docs.libp2p.io/concepts/transport/" target="_blank" rel="noopener">传输协议</a> 通过第三方“中继”对等体在两个对等体之间路由流量。</p><p>中继连接是<strong>端到端加密</strong>的，这意味着充当中继的对等方无法读取或篡改流经连接的任何流量。</p><p>中继协议的一个重要方面是它不是“透明的”。换句话说，源和目的地都知道正在中继流量。这很有用，因为目的地可以看到用于打开连接的中继地址，并且可以潜在地使用它来构造返回源的路径。它也不是匿名的——所有参与者都使用他们的对等 ID 进行识别，包括中继节点。</p><p>假设我有一个 peer 的 peer id <code>QmAlice</code>。我想把我的地址给我的朋友<code>QmBob</code>，但我(Alice)在一个不允许任何人直接给我拨号的 NAT 后面。</p><p><code>p2p-circuit</code>我可以构造的最基本的地址如下所示：</p><p><code>/p2p-circuit/p2p/QmAlice</code></p><p>上面的地址很有趣，因为<strong>它不包含任何 <a href="https://docs.libp2p.io/concepts/transport/" target="_blank" rel="noopener">运输</a>我们要联系的对等点 ( <code>QmAlice</code>) 或将传送流量的中继对等点的地址</strong>。如果没有这些信息，对等方拨打我的唯一机会就是<strong>发现中继并希望他们与我建立联系</strong>。</p><p>更好的地址应该是<code>/p2p/QmRelay/p2p-circuit/p2p/QmAlice</code>. 这包括<strong>特定中继对等体</strong>的身份<code>QmRelay</code>。如果对等方已经知道如何打开与 连接<code>QmRelay</code>，他们将能够联系到我们。</p><blockquote><p><font color='#39b54a'>指定特定的中继</font></p></blockquote><p><strong>更好的是在地址中包含中继对等方的传输地址</strong>。假设我已经使用 peer id 建立了到特定中继的连接<code>QmRelay</code>。他们通过识别协议告诉我，他们正在侦听<code>7.7.7.7</code>IPv4 地址<code>55555</code>端口上的TCP 连接。我可以构建一个地址，描述通过该传输的特定中继到达我的路径：</p><p><code>/ip4/7.7.7.7/tcp/55555/p2p/QmRelay/p2p-circuit/p2p/QmAlice</code></p><p>在<code>/p2p-circuit/</code><strong>之前的所有内容都是中继对等体的地址</strong>，其中包括传输地址和它们的peer id <code>QmRelay</code>。在<code>/p2p-circuit/</code>之后的是我在线路另一端的peer的peer ID，即<code>QmAlice</code>.</p><p>通过将完整的中继路径提供给我的朋友<code>QmBob</code>，他们能够快速建立中继连接，而无需“四处询问”具有到<code>QmAlice</code>.</p><p>Autorelay 是一项功能（目前在 go-libp2p 中实现），peer 可以启用它以尝试使用 libp2p 发现中继 peer <a href="https://docs.libp2p.io/concepts/content-routing/" target="_blank" rel="noopener">内容路由</a> 界面。</p><p>启用自动中继后，对等方将尝试发现一个或多个公共中继并打开中继连接。如果成功，对等方将使用 libp2p 的<a href="https://docs.libp2p.io/concepts/peer-routing/" target="_blank" rel="noopener">对等路由</a> 系统。</p><blockquote><p><font color='#39b54a'>中继节点其实简单来说就是<strong>代理</strong>的作用</font></p></blockquote><h2 id="2-4-协议"><a href="#2-4-协议" class="headerlink" title="2.4 协议"></a>2.4 协议</h2><p>当您编写网络应用程序时，到处都有协议，而 libp2p 中的协议尤其丰富。</p><p>本文所关注的协议类型是使用 libp2p 本身构建的协议，使用核心 libp2p 抽象，如 <a href="https://docs.libp2p.io/concepts/transport" target="_blank" rel="noopener">运输</a>, <a href="https://docs.libp2p.io/concepts/peer-id/" target="_blank" rel="noopener">对等身份</a>, <a href="https://docs.libp2p.io/concepts/addressing/" target="_blank" rel="noopener">寻址</a>， 等等。</p><p>在本文中，我们将这种使用 libp2p<strong>构建的协议</strong>称为<strong>libp2p 协议</strong>，但您也可能将它们称为“线路协议”或“应用程序协议”。</p><p>libp2p 协议具有以下关键特性：</p><h3 id="协议ID"><a href="#协议ID" class="headerlink" title="协议ID"></a>协议ID</h3><p>按照惯例，协议 ID 具有类似路径的结构，版本号作为最终组成部分：</p><p><code>/my-app/amazing-protocol/1.0.1</code></p><h3 id="核心libp2p协议"><a href="#核心libp2p协议" class="headerlink" title="核心libp2p协议"></a>核心libp2p协议</h3><p>除了您在开发 libp2p 应用程序时编写的协议之外，libp2p 本身还定义了几个用于核心功能的基础协议。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/mYLLgf.png" alt="mYLLgf"></p><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec</th><th align="left"></th><th align="left"></th><th align="left">implementations</th></tr></thead><tbody><tr><td align="left"><code>/ipfs/ping/1.0.0</code></td><td align="left">N/A</td><td align="left"><a href="https://github.com/libp2p/go-libp2p/tree/master/p2p/protocol/ping" target="_blank" rel="noopener">go</a></td><td align="left"><a href="https://github.com/libp2p/js-libp2p-ping" target="_blank" rel="noopener">js</a></td><td align="left"><a href="https://github.com/libp2p/rust-libp2p/blob/master/protocols/ping/src/lib.rs" target="_blank" rel="noopener">rust</a></td></tr></tbody></table><p>ping 协议是一个简单的活动检查，点可以用来快速查看另一个点是否在线。</p><h4 id="Identify"><a href="#Identify" class="headerlink" title="Identify"></a>Identify</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec</th><th align="left"></th><th align="left"></th><th align="left">implementations</th></tr></thead><tbody><tr><td align="left"><code>/ipfs/id/1.0.0</code></td><td align="left"><a href="https://github.com/libp2p/specs/pull/97/files" target="_blank" rel="noopener">identify spec</a></td><td align="left"><a href="https://github.com/libp2p/go-libp2p/tree/master/p2p/protocol/identify" target="_blank" rel="noopener">go</a></td><td align="left"><a href="https://github.com/libp2p/js-libp2p-identify" target="_blank" rel="noopener">js</a></td><td align="left"><a href="https://github.com/libp2p/rust-libp2p/tree/master/protocols/identify/src" target="_blank" rel="noopener">rust</a></td></tr></tbody></table><p>该<code>identify</code>协议允许对等方交换有关彼此的信息，尤其是他们的<strong>公钥和已知网络地址</strong>。</p><h4 id="identify-push"><a href="#identify-push" class="headerlink" title="identify/push"></a>identify/push</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec &amp; implementations</th></tr></thead><tbody><tr><td align="left"><code>/ipfs/id/push/1.0.0</code></td><td align="left">same as <a href="https://docs.libp2p.io/concepts/protocols/#identify" target="_blank" rel="noopener">identify above</a></td></tr></tbody></table><p>与<code>identify</code>稍有变化，<code>identify/push</code>协议发送相同的<code>Identify</code>消息，但它是主动发送的，而不是响应请求。</p><h4 id="secio"><a href="#secio" class="headerlink" title="secio"></a>secio</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec</th><th align="left"></th><th align="left"></th><th align="left">implementations</th></tr></thead><tbody><tr><td align="left"><code>/secio/1.0.0</code></td><td align="left"><a href="https://github.com/libp2p/specs/pull/106" target="_blank" rel="noopener">secio spec</a></td><td align="left"><a href="https://github.com/libp2p/go-libp2p-secio" target="_blank" rel="noopener">go</a></td><td align="left"><a href="https://github.com/libp2p/js-libp2p-secio" target="_blank" rel="noopener">js</a></td><td align="left"><a href="https://github.com/libp2p/rust-libp2p/tree/master/protocols/secio" target="_blank" rel="noopener">rust</a></td></tr></tbody></table><p><code>secio</code>（安全输入/输出的缩写）是一种类似于 TLS 1.2 的加密通信协议，但没有证书颁发机构的要求。因为每个 libp2p peer 都有一个PeerID这是从他们的公钥派生的，通过<strong>使用他们的公钥来验证签名的消息</strong>，<strong>可以在不需要证书颁发机构的情况下验证对等方的身份。</strong></p><blockquote><p>虽然 secio 是目前 libp2p 使用的默认加密协议，但将 TLS 1.3 集成到 libp2p 的工作正在进行中，预计一旦完成，它将成为默认加密协议。</p></blockquote><h4 id="kad-dht"><a href="#kad-dht" class="headerlink" title="kad-dht"></a>kad-dht</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec</th><th align="left"></th><th align="left"></th><th align="left">implementations</th></tr></thead><tbody><tr><td align="left"><code>/ipfs/kad/1.0.0</code></td><td align="left"><a href="https://github.com/libp2p/specs/pull/108" target="_blank" rel="noopener">kad-dht spec</a></td><td align="left"><a href="https://github.com/libp2p/go-libp2p-kad-dht" target="_blank" rel="noopener">go</a></td><td align="left"><a href="https://github.com/libp2p/js-libp2p-kad-dht" target="_blank" rel="noopener">js</a></td><td align="left"><a href="https://github.com/libp2p/rust-libp2p/tree/master/protocols/kad" target="_blank" rel="noopener">rust</a></td></tr></tbody></table><p><code>kad-dht</code> 是一个 <a href="https://en.wikipedia.org/wiki/Distributed_hash_table" target="_blank" rel="noopener">分布式哈希表DHT</a> 基于 <a href="https://en.wikipedia.org/wiki/Kademlia" target="_blank" rel="noopener">Kademlia</a> 路由算法，<strong>有一些修改</strong>。</p><p>libp2p 使用 DHT 作为其基础 <a href="https://docs.libp2p.io/concepts/peer-routing/" target="_blank" rel="noopener">对等路由</a> 和 <a href="https://docs.libp2p.io/concepts/content-routing/" target="_blank" rel="noopener">内容路由</a> 功能。</p><h4 id="Circuit-Relay"><a href="#Circuit-Relay" class="headerlink" title="Circuit Relay"></a>Circuit Relay</h4><table><thead><tr><th align="left"><strong>Protocol id</strong></th><th align="left">spec</th><th align="left"></th><th align="left">implementations</th></tr></thead><tbody><tr><td align="left"><code>/libp2p/circuit/relay/0.1.0</code></td><td align="left"><a href="https://github.com/libp2p/specs/tree/master/relay" target="_blank" rel="noopener">circuit relay spec</a></td><td align="left"><a href="https://github.com/libp2p/go-libp2p-circuit" target="_blank" rel="noopener">go</a></td><td align="left"><a href="https://github.com/libp2p/js-libp2p-circuit" target="_blank" rel="noopener">js</a></td></tr></tbody></table><p>如中所述 <a href="https://docs.libp2p.io/concepts/circuit-relay/" target="_blank" rel="noopener">电路继电器篇</a>，libp2p 提供了一个协议，<strong>当两个对等点无法直接相互连接时，通过中继对等点传输流量。</strong></p><h2 id="2-5-PeerID"><a href="#2-5-PeerID" class="headerlink" title="2.5 PeerID"></a>2.5 PeerID</h2><p>对等身份（通常写作<code>PeerId</code>）是对整个对等网络中特定对等的唯一引用。</p><p>除了充当每个对等点的唯一标识符外，PeerId 还是<strong>对等点与其公共加密密钥之间的可验证链接</strong>。</p><p>每个 libp2p peer 控制一个私钥，它对所有其他 peer 保密。每个私钥都有一个对应的公钥，与其他对等方共享。</p><p>公钥和私钥（或“密钥对”）一起允许对等方建立 <a href="https://docs.libp2p.io/concepts/secure-comms/" target="_blank" rel="noopener">安全通讯</a> 通道相互。</p><p>从概念上讲，PeerId 是一个 <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener">加密散列</a>对等方的公钥。当对等方建立安全通道时，散列可用于验证用于保护通道的公钥是否与用于识别对等方的公钥相同。</p><p>PeerIds 使用 <a href="https://docs.libp2p.io/reference/glossary/#multihash" target="_blank" rel="noopener">多重散列</a> 格式，<strong>它向散列本身添加一个小标头，用于标识用于生成它的散列算法</strong>。</p><p>PeerId被编码成Base-58然后表示为字符串（这与比特币类似）:    <code>QmYyQSo1c1Ym7orWxLYvCrM2EmxFTANf8wXmmE7DWjhx5N</code></p><blockquote><p><font color='#e54d42'>PeerID生成的过程：创建私钥 =&gt; 导出公钥 =&gt; hash函数 =&gt; Base58编码</font></p></blockquote><h2 id="2-6-内容路由"><a href="#2-6-内容路由" class="headerlink" title="2.6 内容路由"></a>2.6 内容路由</h2><p>针对查找的<strong>内容</strong>进行路由</p><h2 id="2-7-节点路由"><a href="#2-7-节点路由" class="headerlink" title="2.7 节点路由"></a>2.7 节点路由</h2><p>针对<strong>节点</strong>发现进行路由</p><h2 id="2-8-发布与订阅"><a href="#2-8-发布与订阅" class="headerlink" title="2.8 发布与订阅"></a>2.8 发布与订阅</h2><p>节点可以发布topic，在网络中不断传递，当有一些人订阅之后就会收到消息 （类似mqtt）</p><h2 id="2-9-数据流的多路复用"><a href="#2-9-数据流的多路复用" class="headerlink" title="2.9 数据流的多路复用"></a>2.9 数据流的多路复用</h2><p>A节点与B节点之间建立流通道，不断的传输数据流，但是A、B之间的应用可能是多个，那么在此数据流通道Libp2p就实现了数据流的多路复用</p><p>使用<strong>协议号</strong>来标识不同应用的流</p><h1 id="三、快速开始-Go"><a href="#三、快速开始-Go" class="headerlink" title="三、快速开始(Go)"></a>三、快速开始(Go)</h1><h2 id="2-1-前置要求"><a href="#2-1-前置要求" class="headerlink" title="2.1 前置要求"></a>2.1 前置要求</h2><ul><li><p>go语言最低要求：&gt;= 1.11</p></li><li><p>使用Go module模式编写代码</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建空文件夹，名字自定</span></span><br><span class="line">mkdir libp2p &amp;&amp; cd libp2p</span><br><span class="line">go mod init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载包环境</span></span><br><span class="line">go get -u github.com/libp2p/go-libp2p</span><br></pre></td></tr></table></figure><h2 id="2-2-开启libp2p节点"><a href="#2-2-开启libp2p节点" class="headerlink" title="2.2 开启libp2p节点"></a>2.2 开启libp2p节点</h2><p>编写main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个背景上下文环境</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一个默认配置的libp2p节点</span></span><br><span class="line">node, err := libp2p.New(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出节点监听地址</span></span><br><span class="line">fmt.Println(<span class="string">"Listen Address: "</span>, node.Addrs())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止节点</span></span><br><span class="line"><span class="keyword">if</span> err := node.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">go run main.go                       </span><br><span class="line">Listen Address:  [/ip4/192.168.3.30/tcp/58048 /ip4/127.0.0.1/tcp/58048 /ip6/::1/tcp/58049]</span><br></pre></td></tr></table></figure><h2 id="2-3-配置节点"><a href="#2-3-配置节点" class="headerlink" title="2.3 配置节点"></a>2.3 配置节点</h2><p>新建节点时，添加配置，例如：第二个参数设置监听</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node, err := libp2p.New(ctx, libp2p.ListenAddrStrings(<span class="string">"/ip4/127.0.0.1/tcp/2000"</span>))</span><br></pre></td></tr></table></figure><p>重新运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">Listen Address:  [/ip4/127.0.0.1/tcp/2000]</span><br></pre></td></tr></table></figure><h2 id="2-4-等待信号"><a href="#2-4-等待信号" class="headerlink" title="2.4 等待信号"></a>2.4 等待信号</h2><p>给节点设置等待OS的信号再停止</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待SIGINT或SIGTERM信号</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 当收到ctrl + c时将信号写入通道</span></span><br><span class="line">signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">&lt;- ch<span class="comment">// 等待阻塞</span></span><br><span class="line">fmt.Println(<span class="string">"Received signal, shutting down..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止节点</span></span><br><span class="line"><span class="keyword">if</span> err := node.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">Listen Address:  [/ip4/127.0.0.1/tcp/2000]</span><br><span class="line">^CReceived signal, shutting down...</span><br></pre></td></tr></table></figure><h2 id="2-5-运行ping协议"><a href="#2-5-运行ping协议" class="headerlink" title="2.5 运行ping协议"></a>2.5 运行ping协议</h2><p>下面开始通信, 以go-libp2p启动的节点将默认运行自己的ping协议，但让我们禁用它并手动设置它，通过<strong>注册流处理程序</strong>来演示运行协议的过程。</p><blockquote><p><font color='#39b54a'><strong>将原本的ping协议取消，下面手动演示手动编写一个ping协议</strong></font></p></blockquote><h3 id="2-5-1-设置Steam-handler"><a href="#2-5-1-设置Steam-handler" class="headerlink" title="2.5.1 设置Steam handler"></a>2.5.1 设置Steam handler</h3><p>从<code>libp2p.New</code>返回的对象实现了Host接口，我们将使用<code>SetStreamHandler</code>方法为我们的ping协议设置一个处理程序。</p><p>配置禁止自带的Ping协议，并设置tcp监听的端口为随机（为了在单机上模拟开启多个节点时端口不冲突）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启一个默认配置的libp2p节点</span></span><br><span class="line">node, err := libp2p.New(ctx,</span><br><span class="line">libp2p.ListenAddrStrings(<span class="string">"/ip4/127.0.0.1/tcp/0"</span>),<span class="comment">// 0表示随机</span></span><br><span class="line">libp2p.Ping(<span class="literal">false</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置我们自己的ping协议</span></span><br><span class="line">pingService := &amp;ping.PingService&#123;Host: node&#125;</span><br><span class="line">node.SetStreamHandler(ping.ID, pingService.PingHandler)</span><br></pre></td></tr></table></figure><h3 id="2-5-2-连接peer节点"><a href="#2-5-2-连接peer节点" class="headerlink" title="2.5.2 连接peer节点"></a>2.5.2 连接peer节点</h3><p>运行Ping协议，首先要连接上其他节点</p><p>首先替换节点打印日志的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 更改节点打印内容</span></span><br><span class="line"><span class="comment">// 构建打印Info</span></span><br><span class="line">peerInfo := peer.AddrInfo&#123;</span><br><span class="line">  ID: node.ID(),</span><br><span class="line">  Addrs: node.Addrs(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增加日志输出</span></span><br><span class="line">addrs, err := peer.AddrInfoToP2pAddrs(&amp;peerInfo)</span><br><span class="line">fmt.Println(<span class="string">"libp2p node address: "</span>, addrs[<span class="number">0</span>])</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">libp2p node address:  /ip4/127.0.0.1/tcp/63726/p2p/Qma3pW4kM46cELahGAQrN23mM4zBbrjyq2GEQnNfLAThze</span><br></pre></td></tr></table></figure><p>然后，设置命令行操作(发送ping和监听)，其中使用<code>github.com/multiformats/go-multiaddr</code>包来解析收到的multiaddr格式地址</p><p>安装依赖包：<code>go get -u github.com/multiformats/go-multiaddr</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p-core/peer"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p/p2p/protocol/ping"</span></span><br><span class="line">multiaddr <span class="string">"github.com/multiformats/go-multiaddr"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/signal"</span></span><br><span class="line"><span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个背景上下文环境</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一个默认配置的libp2p节点</span></span><br><span class="line">node, err := libp2p.New(ctx,</span><br><span class="line">libp2p.ListenAddrStrings(<span class="string">"/ip4/127.0.0.1/tcp/0"</span>),</span><br><span class="line">libp2p.Ping(<span class="literal">false</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置我们自己的ping协议</span></span><br><span class="line">pingService := &amp;ping.PingService&#123;Host: node&#125;</span><br><span class="line">node.SetStreamHandler(ping.ID, pingService.PingHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改节点打印内容</span></span><br><span class="line"><span class="comment">// 构建打印Info</span></span><br><span class="line">peerInfo := peer.AddrInfo&#123;</span><br><span class="line">ID: node.ID(),</span><br><span class="line">Addrs: node.Addrs(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增加日志输出</span></span><br><span class="line">addrs, err := peer.AddrInfoToP2pAddrs(&amp;peerInfo)</span><br><span class="line">fmt.Println(<span class="string">"libp2p node address: "</span>, addrs[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果命令行中包含需要连接的节点就连接，并发送5个ping消息，否则监听OS中断消息</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// 解析参数</span></span><br><span class="line">addr, err := multiaddr.NewMultiaddr(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把multiaddr格式转换为AddrInfo格式</span></span><br><span class="line">peer, err := peer.AddrInfoFromP2pAddr(addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 连接节点</span></span><br><span class="line"><span class="keyword">if</span> err := node.Connect(ctx, *peer); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"sending 5 ping messages to"</span>, addr)</span><br><span class="line"><span class="comment">// 发起Ping服务，将结果写入channel</span></span><br><span class="line">ch := pingService.Ping(ctx, peer.ID)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line">res := &lt;-ch</span><br><span class="line">fmt.Println(<span class="string">"got ping response!"</span>, <span class="string">"RTT:"</span>, res.RTT)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 等待SIGINT或SIGTERM信号</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 当收到ctrl + c时将信号写入通道</span></span><br><span class="line">signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">&lt;- ch<span class="comment">// 等待阻塞</span></span><br><span class="line">fmt.Println(<span class="string">"Received signal, shutting down..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止节点</span></span><br><span class="line"><span class="keyword">if</span> err := node.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-运行"><a href="#2-5-3-运行" class="headerlink" title="2.5.3 运行"></a>2.5.3 运行</h3><p>第一个节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build ./ </span><br><span class="line">./libp2p</span><br><span class="line">libp2p node address:  /ip4/127.0.0.1/tcp/49904/p2p/Qmaeyg7CEBpe7TE6eCGsmomBLHotU6GergoX2kz3cCmbGr</span><br></pre></td></tr></table></figure><p>第二个节点(新开一个命令行窗口):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./libp2p /ip4/127.0.0.1/tcp/49904/p2p/Qmaeyg7CEBpe7TE6eCGsmomBLHotU6GergoX2kz3cCmbGr</span><br><span class="line">sending 5 ping messages to /ip4/127.0.0.1/tcp/49904/p2p/Qmaeyg7CEBpe7TE6eCGsmomBLHotU6GergoX2kz3cCmbGr</span><br><span class="line">got ping response! RTT: 120µs</span><br><span class="line">got ping response! RTT: 120.875µs</span><br><span class="line">got ping response! RTT: 120.167µs</span><br><span class="line">got ping response! RTT: 62.125µs</span><br><span class="line">got ping response! RTT: 135.792µs</span><br></pre></td></tr></table></figure><p>更多的演示案例：<a href="https://github.com/libp2p/go-libp2p/tree/master/examples" target="_blank" rel="noopener">https://github.com/libp2p/go-libp2p/tree/master/examples</a></p><blockquote><p><font color='#39b54a'>这里虽然说是我们手动实现了Ping协议，但是其实应该明白的是服务的创建和处理函数都是调用原来写好的，所以真正完全的实现一个协议还需要学习后续的案例， 后续也会持续的更新。。。</font></p></blockquote><h1 id="四、主机配置"><a href="#四、主机配置" class="headerlink" title="四、主机配置"></a>四、主机配置</h1><p>主机配置即当前节点的一般配置，如果不使用默认的配置则一般会用到以下的配置：</p><p>所有配置见；<a href="https://godoc.org/github.com/libp2p/go-libp2p" target="_blank" rel="noopener">see the different options in the docs</a>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p"</span></span><br><span class="line">connmgr <span class="string">"github.com/libp2p/go-libp2p-connmgr"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p-core/crypto"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p-core/host"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p-core/peer"</span></span><br><span class="line"><span class="string">"github.com/libp2p/go-libp2p-core/routing"</span></span><br><span class="line">dht <span class="string">"github.com/libp2p/go-libp2p-kad-dht"</span></span><br><span class="line">libp2pquic <span class="string">"github.com/libp2p/go-libp2p-quic-transport"</span></span><br><span class="line">secio <span class="string">"github.com/libp2p/go-libp2p-secio"</span></span><br><span class="line">libp2ptls <span class="string">"github.com/libp2p/go-libp2p-tls"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 上下文管理libp2p节点的生命周期。</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">// 延迟停止node</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个自己配置的节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置自己的公私钥对</span></span><br><span class="line">priv, _, err := crypto.GenerateKeyPair(</span><br><span class="line">crypto.Ed25519,</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> idht *dht.IpfsDHT</span><br><span class="line"></span><br><span class="line">node, err := libp2p.New(ctx,</span><br><span class="line"><span class="comment">// 使用自己生成的私钥</span></span><br><span class="line">libp2p.Identity(priv),</span><br><span class="line"><span class="comment">// 设置Multiple格式监听地址</span></span><br><span class="line">libp2p.ListenAddrStrings(</span><br><span class="line"><span class="string">"/ip4/0.0.0.0/tcp/9000"</span>,<span class="comment">// tcp连接</span></span><br><span class="line"><span class="string">"/ip4/0.0.0.0/udp/9000/quic"</span>,<span class="comment">// 用于QUIC传输的UDP端点</span></span><br><span class="line">),</span><br><span class="line"><span class="comment">// 支持TLS连接</span></span><br><span class="line">libp2p.Security(libp2ptls.ID, libp2ptls.New),</span><br><span class="line"><span class="comment">// 支持secio连接</span></span><br><span class="line">libp2p.Security(secio.ID, secio.New),</span><br><span class="line"><span class="comment">// 支持QUIC（该功能还在实验中）</span></span><br><span class="line">libp2p.Transport(libp2pquic.NewTransport),</span><br><span class="line"><span class="comment">// 支持其他默认传输协议（tcp）</span></span><br><span class="line">libp2p.DefaultTransports,</span><br><span class="line"><span class="comment">// 防止peer节点连接过多的其他对等节点，设置连接管理器</span></span><br><span class="line">libp2p.ConnectionManager(connmgr.NewConnManager(</span><br><span class="line"><span class="number">100</span>, <span class="comment">// 下限</span></span><br><span class="line"><span class="number">400</span>,<span class="comment">// 上限</span></span><br><span class="line">time.Minute,<span class="comment">// 连接新连接之前的设置的宽限期</span></span><br><span class="line">)),</span><br><span class="line"><span class="comment">// 尝试为NAT主机使用uPNP打开端口（自动路由）</span></span><br><span class="line">libp2p.NATPortMap(),</span><br><span class="line"><span class="comment">// 为该节点使用DHT去找到其他节点</span></span><br><span class="line">libp2p.Routing(<span class="function"><span class="keyword">func</span><span class="params">(h host.Host)</span> <span class="params">(routing.PeerRouting, error)</span></span> &#123;</span><br><span class="line">idht, err = dht.New(ctx, h)</span><br><span class="line"><span class="keyword">return</span> idht, err</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 开启中继防止节点处于NAT网络下</span></span><br><span class="line">libp2p.EnableRelay(),</span><br><span class="line"><span class="comment">// 节点可以帮助其他在NAT下的节点中继，开启自己的AutoNAT中继服务端 (这个服务本身带有限制，不会产生很大的开销)</span></span><br><span class="line">libp2p.EnableNATService(),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接网络中的引导节点或者其他节点</span></span><br><span class="line"><span class="comment">// 连接公共引导节点</span></span><br><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> dht.DefaultBootstrapPeers&#123;</span><br><span class="line">fmt.Println(<span class="string">"defaultBootstrapPeer : "</span>, addr)</span><br><span class="line"><span class="comment">// 格式转换为AddrInfo</span></span><br><span class="line">p1, _ := peer.AddrInfoFromP2pAddr(addr)</span><br><span class="line"><span class="comment">// 连接(忽略连接不上的引导节点)</span></span><br><span class="line">node.Connect(ctx, *p1)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"My Host ID is %s\n"</span>, node.ID())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49062384&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/49062384&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://colobu.com/2018/03/26/distributed-hash-table/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://colobu.com/2018/03/26/distributed-hash-table/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;libp2p官方文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章涵盖内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分布式Hash表、Kademlia算法&lt;/li&gt;
&lt;li&gt;Libp2p的基本、核心概念&lt;/li&gt;
&lt;li&gt;Libp2p的一个简单使用流程（手动编写ping协议实现）&lt;/li&gt;
&lt;li&gt;基本的主机配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h1&gt;&lt;p&gt;万事万物都要从其概念学起…&lt;/p&gt;
&lt;h2 id=&quot;1-1-前置概念&quot;&gt;&lt;a href=&quot;#1-1-前置概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 前置概念&quot;&gt;&lt;/a&gt;1.1 前置概念&lt;/h2&gt;&lt;h3 id=&quot;分布式Hash表&quot;&gt;&lt;a href=&quot;#分布式Hash表&quot; class=&quot;headerlink&quot; title=&quot;分布式Hash表&quot;&gt;&lt;/a&gt;分布式Hash表&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;em&gt;查表式与计算式&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;关于分布式多节点情景下数据如何布局，主要有两种思路：&lt;strong&gt;查表式和计算式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所谓查表式，即通过维护&lt;strong&gt;全局统一的映射表&lt;/strong&gt;，需要访问数据时，先查询该表定位数据所在节点。&lt;br&gt;计算式无需维护该映射表，需要访问数据时，通过&lt;strong&gt;一定规则&lt;/strong&gt;计算出数据所在位置。&lt;/p&gt;
&lt;p&gt;查表式和计算式各有优劣：&lt;/p&gt;
&lt;p&gt;查表式需要一个中心服务器维护全局的映射表信息，这可能成为系统的瓶颈；&lt;br&gt;而计算式的主要问题在于存储节点的变更可能带来大量的数据迁移，增加系统复杂度。&lt;/p&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;分布式Hash就是一种典型的&lt;strong&gt;计算式&lt;/strong&gt;数据布局算法&lt;/font&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;官方概念：&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;分布式哈希表（distributed hash table，缩写DHT）&lt;/strong&gt;是分布式计算系统中的一类，用来将一个键（key）的集合分散到所有在分布式系统中的节点。这里的节点类似哈希表中的存储位置。分布式哈希表通常是为了拥有大量节点的系统，而且系统的节点常常会加入或离开。&lt;/p&gt;
&lt;p&gt;其主要的动机是为了开发&lt;strong&gt;点对点&lt;/strong&gt;系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;算法过程：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;DHT算法大致可以描述为以下两个子算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立节点的位置算法&lt;/li&gt;
&lt;li&gt;确定查询节点位置算法&lt;/li&gt;
&lt;li&gt;确定存储对象的位置算法 =&amp;gt; 提供服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面以Dynamo使用的结构举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/ZTQGjf.png&quot; alt=&quot;ZTQGjf&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：这里的Ring结构只是举个例子，并不是所有的DHT都使用此结构&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有的分布式节点都遵循这样的一套规则进行数据的存储与查询，整体向外提供高容灾性的服务。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;特性：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;分布式Hash表本质上强调以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;离散性&lt;/strong&gt;：构成系统的节点并没有任何中央式的协调机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;伸缩性&lt;/strong&gt;：即使有成千上万个节点，系统仍然应该十分有效率&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容错性&lt;/strong&gt;：即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于分布式Hash表有一个基本的了解即可，这里不再继续展开。。。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Kademlia算法&quot;&gt;&lt;a href=&quot;#Kademlia算法&quot; class=&quot;headerlink&quot; title=&quot;Kademlia算法&quot;&gt;&lt;/a&gt;Kademlia算法&lt;/h3&gt;&lt;p&gt;&lt;em&gt;维基官方定义如下：&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;&lt;strong&gt;Kademlia&lt;/strong&gt;（简称kad）是一种通过 DHT 的协议算法&lt;/font&gt;，它是由Petar和David在2002年为P2P网络而设计的。Kademlia规定了网络的结构，也规定了通过节点查询进行信息交换的方式。&lt;br&gt;Kademlia网络节点之间使用&lt;strong&gt;UDP&lt;/strong&gt;进行通讯。参与通讯的所有节点形成一张虚拟网（或者叫做覆盖网）。这些节点通过一组数字（或称为节点ID）来进行身份标识。节点ID不仅可以用来做身份标识，还可以用来进行值定位（值通常是文件的散列或者关键词）。&lt;/p&gt;
&lt;p&gt;当我们在网络中搜索某些值（即通常搜索存储文件散列或关键词的节点）的时候，Kademlia算法需要知道与这些值相关的键，然后逐步在网络中开始搜索。每一步都会找到一些节点，这些节点的ID与键更为接近，如果有节点直接返回搜索的值或者再也无法找到与键更为接近的节点ID的时候搜索便会停止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;节点距离计算规则：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;距离是指节点之间的&lt;strong&gt;跳数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;精妙的与&lt;strong&gt;异或算法&lt;/strong&gt;结合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ B) == (B ⊕ A)&lt;/code&gt;: XOR 符合“交换律”，具备对称性。A和B的距离从哪一个节点计算都是相同的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ A) == 0&lt;/code&gt;: 反身性，自己和自己的距离为零。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ B) &amp;gt; 0&lt;/code&gt;: 两个不同的 key 之间的距离必大于零。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A ⊕ B) + (B ⊕ C) &amp;gt;= (A ⊕ C)&lt;/code&gt;: 三角不等式, A经过B到C的距离总是大于A直接到C的距离。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;映射规则 / 节点位置计算方法：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Kad使用160位的Hash算法，完整的Key有160二进制位，所以最多可以容纳$2^{160}$个节点&lt;/p&gt;
&lt;p&gt;Kad将所有的Key都映射到一个二叉树，每一个&lt;strong&gt;Key都是二叉树的叶子&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;&lt;strong&gt;一个Key对应于一个节点&lt;/strong&gt;，当然也可能会有虚拟节点&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;&lt;strong&gt;注意:&lt;/strong&gt;上方距离DHT的时候使用的是Ring结构，这里Kad算法使用的二叉树而不是Ring&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将Key看作160位的二进制，二叉树的第n层就对应了第n位，可以按照左0右1的规则如下分割下去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/k2P4PD.png&quot; alt=&quot;k2P4PD&quot;&gt;&lt;/p&gt;
&lt;p&gt;分割完之后&lt;strong&gt;叶子节点到根节点的路径&lt;/strong&gt;就对应于一个完整的Key，代表着该系统分布式的一个节点&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;拆子树与K桶：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;拆子树&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每个节点按照&lt;strong&gt;自己的角度&lt;/strong&gt;去拆分子树，从根节点开始看，如果其右子树不包含自己那么就将其左子树拆分出来，依此类推往下拆分直到只有自己&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为Kad的Key一共是160位，其二叉树就是160层，那么对于一个节点来说最多拆分出来的子树有160个（每层拆一个）（当然实际情况节点数远小于$2^{160}$个，节点拆分子树的个数也不会是160个）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于一个节点的n个拆分子树，如果都知道里面的一个节点，那么就可以利用这n个节点进行&lt;strong&gt;递归路由&lt;/strong&gt;从而找到整个二叉树的所有节点(也即到达每一个节点)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;K桶&lt;code&gt;（K-bucket）&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅知道子树中的一个节点不够健壮(考虑到意外宕机等), 多个才安全&lt;/li&gt;
&lt;li&gt;K就是指知道K个节点来保证健壮性(考虑实际情况K只是一个&lt;strong&gt;上限&lt;/strong&gt;)，其K为一个系统级别的常量&lt;/li&gt;
&lt;li&gt;K桶的概念其实就是&lt;strong&gt;路由表&lt;/strong&gt;，节点需要知道n个子树就需要维护n个路由表/K桶，每个路由表/桶的上限大小是K&lt;/li&gt;
&lt;li&gt;选择K个节点：选择&lt;strong&gt;长时间在线&lt;/strong&gt;的节点，如果当前K桶满了就将新的节点放入&lt;strong&gt;缓存&lt;/strong&gt;，待有节点断连就将新节点更换之&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;Kad协议消息类型：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;共四种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PING&lt;/strong&gt;消息: 用来测试节点&lt;u&gt;是否仍然在线&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STORE&lt;/strong&gt;消息: 在某个节点中&lt;u&gt;存储&lt;/u&gt;一个键值对。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIND_NODE&lt;/strong&gt;消息: 消息请求的接收者将返回自己桶中&lt;u&gt;离请求键值最&lt;strong&gt;近&lt;/strong&gt;&lt;/u&gt;的K个节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIND_VALUE&lt;/strong&gt;消息: 与FIND_NODE一样，不过当请求的接收者存有请求者所请求的键的时候，它将返回相应键的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一个RPC消息中都包含一个发起者加入的&lt;strong&gt;随机值&lt;/strong&gt;，这一点确保响应消息在收到的时候能够与前面发送的请求消息&lt;strong&gt;匹配&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;定位最近节点:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;查询可以异步也可同步&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查询发起者节点从自己的K桶中筛选出离目标Id最近的一些节点，并发起异步查询请求&lt;/li&gt;
&lt;li&gt;被查询节点收到请求后，从自己的K桶中找出自己知道的与查询ID最近的若干个节点返回给发起者&lt;/li&gt;
&lt;li&gt;发起者收到后更新自己的结果列表，再次筛选出离目标最近的若干未请求过的节点重复步骤一&lt;/li&gt;
&lt;li&gt;直到找不到最近的未请求过的节点为止&lt;/li&gt;
&lt;li&gt;查询过程中未响应的节点会被立即排除；查询者需要最终获得的K个节点都是活动的&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;定位资源：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;定位资源时，如果一个节点存有相应的资源的值的时候，它就返回该资源，搜索便结束了，除了该点以外，&lt;strong&gt;定位资源与定位离键最近的节点的过程相似。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑到节点未必都在线的情况，&lt;strong&gt;资源的值被存在多个节点上（节点中的K个）&lt;/strong&gt;，并且，为了提供冗余，还有可能在更多的节点上储存值。储存值的节点将定期搜索网络中与储存值所对应的键接近的K个节点并且把值复制到这些节点上，这些节点可作为那些下线的节点的补充。另外还有缓存技术。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;加入网络：&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新节点A必须知道某个引导节点B，并把它加入到自己相应的K-桶中&lt;/li&gt;
&lt;li&gt;生成一个随机的节点ID,直到离开网络，该节点会一直使用该ID号&lt;/li&gt;
&lt;li&gt;向B（A目前知道的唯一节点）发起一个查询请求（FIND_NODE），请求的ID是自己（就是查询自己）&lt;/li&gt;
&lt;li&gt;B收到该请求之后，会先把A的ID加入自己的相应的 K-桶中。并且根据 FIND_NODE 请求的约定，B会找到K个最接近 A 的节点，并返回给 A&lt;/li&gt;
&lt;li&gt;A收到这K个节点的ID之后，把他们加入自己的 K-桶&lt;/li&gt;
&lt;li&gt;然后A会继续向刚刚拿到的这批节点(还未发送过请求的节点)发送查询请求（协议类型 FIND_NODE），如此往复，直至A建立了足够详细的路由表。&lt;/li&gt;
&lt;li&gt;这种&lt;font color=&#39;#e54d42&#39;&gt;“&lt;strong&gt;自我定位&lt;/strong&gt;”&lt;/font&gt;将使得Kad的其他节点（收到请求的节点）能够使用A的ID填充他们的K-桶，同时也能够使用那些查询过程的中间节点来填充A的K-桶。这已过程既让A获得了详细的路由表，也让其它节点知道了A节点的加入&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-2-LibP2P基本概念&quot;&gt;&lt;a href=&quot;#1-2-LibP2P基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.2 LibP2P基本概念&quot;&gt;&lt;/a&gt;1.2 LibP2P基本概念&lt;/h2&gt;&lt;p&gt;Libp2p是Protocol Labs旗下的五个明星项目之一，五个项目彼此独立而又相互联系，旨在建立一个更安全、高效、开放的网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/QBObqG.png&quot; alt=&quot;QBObqG&quot;&gt;&lt;/p&gt;
&lt;p&gt;Libp2p是一个&lt;strong&gt;&lt;font color=&#39;#e54d42&#39;&gt;模块化&lt;/font&gt;的网络栈&lt;/strong&gt;，通过将各种传输协议和P2P协议结合在一起，开发人员能够构建大型、健壮的P2P网络。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/categories/technical/golang/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0199</title>
    <link href="https://xwjahahahaha.github.io/2021/07/17/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0199/"/>
    <id>https://xwjahahahaha.github.io/2021/07/17/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0199/</id>
    <published>2021-07-17T09:59:12.000Z</published>
    <updated>2021-07-19T01:10:32.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> go p2p -1- 基本概念和使用</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>同态加密</title>
    <link href="https://xwjahahahaha.github.io/2021/07/16/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    <id>https://xwjahahahaha.github.io/2021/07/16/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/</id>
    <published>2021-07-16T03:01:23.000Z</published>
    <updated>2021-07-16T07:48:18.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习资料来源：</p><p>知乎VenusBlockChain: <a href="https://zhuanlan.zhihu.com/p/110210315" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110210315</a></p><p>知乎刘巍然：<a href="https://www.zhihu.com/question/27645858/answer/37598506" target="_blank" rel="noopener">https://www.zhihu.com/question/27645858/answer/37598506</a></p><p><a href="https://blog.csdn.net/Gouph/article/details/106179325" target="_blank" rel="noopener">https://blog.csdn.net/Gouph/article/details/106179325</a></p></blockquote><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-1-同态加密"><a href="#1-1-同态加密" class="headerlink" title="1.1 同态加密"></a>1.1 同态加密</h2><p><strong><em>什么是同态加密？</em></strong></p><p>提出第一个构造出全同态加密（Fully Homomorphic Encryption）[Gen09]的Craig Gentry给出的直观定义最好：</p><blockquote><p>A way to delegate processing of your data, without giving away access to it.</p><p>一种委托数据处理的方法，但是让你不丧失对数据的所有权</p></blockquote><p><font color='#e54d42'>同态加密对于数据安全来说，不像一般的加密方案只关注<strong>数据存储安全</strong>，攻击者无法从密文中获得任何信息, 对加密数据的任何改动操作都会造成解密的错误。而同态加密关注于<strong>数据的处理安全</strong>，其提供了一种对加密数据处理的功能，且处理过程中无法得知原始内容，同时数据经过操作后还能够解密得到处理好的结果。</font></p><p>同态加密（Homomorphic Encryption）允许对密文处理后仍然是加密的结果。即对密文直接进行处理，跟对明文进行处理后再对处理结果加密，得到的结果相同。从抽象代数的角度讲，保持了同态性。</p><p>同态加密是<strong>基于数学难题</strong>的计算复杂性理论的密码学技术，它的概念可以简单的解释为：对经过同态加密的数据进行密文运算处理得到一个输出，这一输出解密结果与用同一方法处理未加密的原始数据得到的输出结果是一样的。</p><a id="more"></a><p>可以定一个运算符$\Delta$ , 对应的加密算法E和解密算法D, 同态加密满足: $E(x\Delta y) = E(x) \Delta E(y)$</p><p><strong><em>一个例子：</em></strong></p><p>(刘老师的例子非常贴切)</p><p>Alice想让工人加工自己的金子但是不信任工人，害怕其在操作过程中偷取自己的金子，那么就相出了以下的办法：</p><ul><li>Alice将金子锁在一个密闭的盒子里面，这个盒子安装了一个手套。</li><li>工人可以带着这个手套，对盒子内部的金子进行处理。但是盒子是锁着的，所以工人不仅拿不到金块，连处理过程中掉下的任何金子都拿不到。</li><li>加工完成后。Alice拿回这个盒子，把锁打开，就得到了金子。</li></ul><p>这个盒子的样子大概是这样的：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/GiDNiP.png" alt="GiDNiP"></p><p>这里面的对应关系是：</p><ul><li>Alice：数据持有方</li><li>工人： 不可信的服务提供第三方</li></ul><ul><li>盒子：加密算法</li><li>盒子上的锁：用户密钥</li><li>将金块放在盒子里面并且用锁锁上：将数据用同态加密方案进行加密</li><li>加工：应用同态特性，在无法取得数据的条件下直接对加密结果进行处理</li><li>开锁：对结果进行解密，直接得到处理后的结果</li></ul><h2 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h2><p>同态性来自代数领域，一般包括四种类型：加法同态、乘法同态、减法同态和除法同态。</p><p>同时满足加法同态和乘法同态，则意味着是代数同态，称为<strong>全同态</strong>(Full Homomorphic)</p><p>同时满足四种同态性，则称为<strong>算数同态</strong>。</p><p><font color='#e54d42'>对于计算机来说，实现了全同态就可以实现所有操作的同态性</font></p><p>只实现部分特定操作的同态性称为<strong>特定同态</strong>, 对于特定同态特性的算法，如RSA，Elgamal，Paillier、Pedersen Commitment等等。</p><p>目前业界使用的较多的还是特定同态/部分同态，而斯坦福大学的博士生Craig Gentry基于<strong>理想格</strong>提出一个全同态加密方案。Fully Homomorphic Encryption Using Ideal Lattices. In the 41st ACM Symposium on Theory of Computing (STOC), 2009.</p><p>所谓的格（Lattice）就是整系数基的线性组合构成的点，也就是一个空间中的一些离散有规律的点。离散的点之间的距离产生了一些困难问题，例如：最短向量问题(SVP)。</p><p>如果是一个二维平面，那么寻找在格上寻找最短向量问题是简单的，但是当维数变大的时候，例如200多维，寻找格上的最短向量问题就变的异常困难，称之为格上标准困难问题，是一个指数级的困难问题。 </p><p>Gentry首次设计出一个真正的全同态加密体制，即可以在不解密的条件下对加密数据进行任何可以在明文上进行的运算，使得对加密信息仍能进行深入和无限的分析，而不会影响其保密性。</p><blockquote><p>IBM公布的开源代码：FHE ：<a href="https://github.com/IBM/fhe-toolkit-linux" target="_blank" rel="noopener">https://github.com/IBM/fhe-toolkit-linux</a></p></blockquote><h2 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1.3 应用"></a>1.3 应用</h2><p><strong><em>云计算</em></strong></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/rb1HwZ.png" alt="rb1HwZ"></p><p>Alice通过Cloud，以Homomorphic Encryption（以下简称HE）处理数据的整个处理过程大致是这样的：</p><ol><li>Alice对数据进行加密。并把加密后的数据发送给Cloud；</li><li>Alice向Cloud提交数据的处理方法，这里用函数f来表示；</li><li>Cloud在函数f下对数据进行处理，并且将处理后的结果发送给Alice；</li><li>Alice对数据进行解密，得到结果。</li></ol><p>可想而之，在未来如果实现了真正可以实用的全同态技术(加强环节中的f()的操作空间)，那么一款完全不会泄漏个人数据隐私的云计算服务的市场竞争有多大！</p><blockquote><p>对于Function f()是否也可以进行加密呢，这样云服务器连操作都不会知晓</p></blockquote><p><strong><em>区块链</em></strong></p><p>使用同态加密技术，运行在区块链上的<strong>智能合约可以处理密文</strong>，<strong>而无法获知真实数据</strong>，极大地提高了隐私安全性。</p><p>这样的优点是，用户将交易数据提交到区块链网络之前，可使用相应的加密算法对交易数据进行加密，数据以密文的形式存在，即使被攻击者获取，也不会泄露用户的任何隐私信息，同时密文运算结果与明文运算结果一致。</p><p>数据的操作还可以与区块链的<strong>智能合约</strong>相关联</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/TZ7T29.png" alt="TZ7T29"></p><p>华为区块链提供同态加密库，对用户的交易数据用其公钥进行加密保护，交易的时候都是密文运算，最终账本中加密保存，即使节点被攻破，获取到账本记录也无法解密。</p><p>趣链Hyperchain通过同态加密（采用Paillier同态加密算法）的加密思想实现区块中交易金额和账户余额的加密。其白皮书声称经过同态加密的交易验证时间约为10微秒，可以满足Hyperchain每秒上万笔交易的需求。</p><p>BCOS也采用了Paillier同态加密算法，并开源出了加法同态解说使用说明[1]，以及Paillier同态加密算法JAVA版实现[2]。当然还有其他产品，此处不再一一列举。</p><h1 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h1><p>同态加密也有很多的实现算法</p><h2 id="2-1-Paillier"><a href="#2-1-Paillier" class="headerlink" title="2.1 Paillier"></a>2.1 Paillier</h2><p>类别:  <font color='#fbbd08'><strong>加法</strong>同态加密算法</font></p><p>困难：分解两个大质数</p><p>Paillier加密算法[3]是1999年Paillier发明的基于复合剩余类的困难问题的加法同态加密算法</p><h3 id="算法生成过程："><a href="#算法生成过程：" class="headerlink" title="算法生成过程："></a>算法生成过程：</h3><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/dQbHXB.png" alt="dQbHXB"></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul><li>明文m, 0&lt;=m&lt;=n</li><li>随机数r, 0&lt;r&lt;n, 且gcd(r, n) =1</li><li>加密结果: $c = g^m * r ^n mod n^2$</li></ul><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><ul><li>解密结果：$m = L(c^\lambda)modn^2 * \mu  mod n$</li></ul><h3 id="同态性的证明"><a href="#同态性的证明" class="headerlink" title="同态性的证明"></a>同态性的证明</h3><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/0idXJv.png" alt="0idXJv"></p><h2 id="2-2-ElGamal"><a href="#2-2-ElGamal" class="headerlink" title="2.2 ElGamal"></a>2.2 ElGamal</h2><p>类别：<font color='#fbbd08'><strong>乘法</strong>同态加密算法</font></p><p>困难：离散对数问题</p><p>ELGamal密码是除了RSA之外最有代表性的公开密钥密码之一，是一种公认安全的公钥密码。</p><h3 id="离散对数问题"><a href="#离散对数问题" class="headerlink" title="离散对数问题"></a>离散对数问题</h3><p>设p为素数，若存在一个正整数α，使得 $a,a^2,a^3,…,a^{p-1}$ 关于模p互不同余，则称α为模p的一个<strong>原根</strong>。于是有如下运算：</p><p>a的幂乘运算： $y = a^xmod p , 1 \leqslant x \leqslant{p-1}$</p><p>a的对数运算： $x = log_a^y, \ 1 \leqslant y \leqslant {p-1}$</p><p>只要p足够大，求解离散对数问题时相当复杂的。离散对数问题具有较好的单向性。</p><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><ul><li>随机地选择一个大素数p，且要求p-1有大素数因子，将p公开。</li><li>选择一个模p的原根α，并将α公开。</li><li>随机地选择一个整数d（1＜d＜p-1）作为私钥，并对d保密。</li><li>计算公钥$y=a^d(modp)$ ，并将y公开。</li></ul><h3 id="加密-1"><a href="#加密-1" class="headerlink" title="加密"></a>加密</h3><ul><li><p>对于待加密明文M，随机地选取一个整数k（1＜k＜p-1）。</p></li><li><p>计算$U= a^kmodp 、C_1=a^kmodp 、C_2=U*Mmodp$</p></li><li><p>取(C1,C2)作为密文。</p></li></ul><h4 id="解密-1"><a href="#解密-1" class="headerlink" title="解密"></a>解密</h4><p>计算$V = C_1^dmodp$</p><p>解密结果: $M = C_2V^{-1}modp$</p><h3 id="同态性的证明-1"><a href="#同态性的证明-1" class="headerlink" title="同态性的证明"></a>同态性的证明</h3><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/OmOuqx.png" alt="OmOuqx"></p><h1 id="三、golang代码实现"><a href="#三、golang代码实现" class="headerlink" title="三、golang代码实现"></a>三、golang代码实现</h1><h2 id="3-1-Paillier"><a href="#3-1-Paillier" class="headerlink" title="3.1 Paillier"></a>3.1 Paillier</h2><p>代码库：<a href="https://github.com/Roasbeef/go-go-gadget-paillier" target="_blank" rel="noopener">https://github.com/Roasbeef/go-go-gadget-paillier</a></p><p>采用Go语言实现的加法同态加密算法Paillier </p><p>其主要可以实现以下操作：</p><ul><li><p>可以将加密的整数加在一起 </p></li><li><p>加密的整数可以与未加密的整数相<strong>乘</strong> </p></li><li><p>加密的整数和未加密的整数可以加在一起</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>go get github.com/roasbeef/go-go-gadget-paillier</code></p><h3 id="测试Demo"><a href="#测试Demo" class="headerlink" title="测试Demo"></a>测试Demo</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_homomorphicCrypto</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个128位的私钥</span></span><br><span class="line">privKey, _ := paillier.GenerateKey(rand.Reader, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公钥加密明文：数字15</span></span><br><span class="line">m15 := <span class="built_in">new</span>(big.Int).SetInt64(<span class="number">15</span>)</span><br><span class="line">c15, _ := paillier.Encrypt(&amp;privKey.PublicKey, m15.Bytes())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私钥解密密文：15</span></span><br><span class="line">d, _ := paillier.Decrypt(privKey, c15)</span><br><span class="line">plainText := <span class="built_in">new</span>(big.Int).SetBytes(d)</span><br><span class="line">fmt.Println(<span class="string">"Decryption Result of 15: "</span>, plainText.String()) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 公钥加密数字20</span></span><br><span class="line">m20 := <span class="built_in">new</span>(big.Int).SetInt64(<span class="number">20</span>)</span><br><span class="line">c20, _ := paillier.Encrypt(&amp;privKey.PublicKey, m20.Bytes())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将15的密文与20的密文相加（注意都是同一公钥）</span></span><br><span class="line">plusM16M20 := paillier.AddCipher(&amp;privKey.PublicKey, c15, c20)</span><br><span class="line"><span class="comment">// 使用私钥解密和的明文结果</span></span><br><span class="line">decryptedAddition, _ := paillier.Decrypt(privKey, plusM16M20)</span><br><span class="line">fmt.Println(<span class="string">"Result of 15+20 after decryption: "</span>,</span><br><span class="line"><span class="built_in">new</span>(big.Int).SetBytes(decryptedAddition).String()) <span class="comment">// 35!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将15密文与10明文常数相加</span></span><br><span class="line">plusE15and10 := paillier.Add(&amp;privKey.PublicKey, c15, <span class="built_in">new</span>(big.Int).SetInt64(<span class="number">10</span>).Bytes())</span><br><span class="line">decryptedAddition, _ = paillier.Decrypt(privKey, plusE15and10)</span><br><span class="line">fmt.Println(<span class="string">"Result of 15+10 after decryption: "</span>,</span><br><span class="line"><span class="built_in">new</span>(big.Int).SetBytes(decryptedAddition).String()) <span class="comment">// 25!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将15密文与10明文常数相乘</span></span><br><span class="line">mulE15and10 := paillier.Mul(&amp;privKey.PublicKey, c15, <span class="built_in">new</span>(big.Int).SetInt64(<span class="number">10</span>).Bytes())</span><br><span class="line">decryptedMul, _ := paillier.Decrypt(privKey, mulE15and10)</span><br><span class="line">fmt.Println(<span class="string">"Result of 15*10 after decryption: "</span>,</span><br><span class="line"><span class="built_in">new</span>(big.Int).SetBytes(decryptedMul).String()) <span class="comment">// 150!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 结果显示</span></span><br><span class="line">=== RUN   Test_homomorphicCrypto</span><br><span class="line">Decryption Result of 15:  15</span><br><span class="line">Result of 15+20 after decryption:  35</span><br><span class="line">Result of 15+10 after decryption:  25</span><br><span class="line">Result of 15*10 after decryption:  150</span><br><span class="line">--- PASS: Test_homomorphicCrypto (0.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>值得注意的是该包的作者说其用于课程教学，实际的生产环境则不太适合</p><h1 id="四、当下挑战"><a href="#四、当下挑战" class="headerlink" title="四、当下挑战"></a>四、当下挑战</h1><p>同态加密最大的问题是效率</p><p>效率。效率一词包含两个方面，一个是<strong>加密数据的处理速度</strong>，一个是这个<strong>加密方案的数据存储量</strong>。</p><ul><li><p>工人戴着手套加工金子，肯定没有直接加工来得快嘛~ 也就是说，隔着手套处理，精准度会变差（<strong>现有构造会有误差传递问题</strong>），加工的时间也会变得更长（<strong>密文的操作花费更长的时间</strong>），工人需要隔着操作，因此也需要更专业（<strong>会正确调用算法</strong>）。</p></li><li><p>金子放在盒子里面，为了操作，总得做一个稍微大一点的盒子吧，要不然手操作不开啊（<strong>存储空间问题</strong>）。里面也要放各种工具吧，什么电钻啦，锉刀啦，也需要空间吧？</p></li></ul><p>2011年，Gentry和Halevi在IBM尝试实现了两个HE方案：Smart-Vercauteren的SWHE方案[SV10]以及Gentry的FHE方案[Gen09]，并公布了效率。结果如何呢？我们给出Gentry公布的数据（原始数据可以在<a href="https://link.zhihu.com/?target=http%3A//crypto.biu.ac.il/winterschool2012/">2nd Bar-Ilan Winter School on Cryptography</a>找到）Smart-Vercauteren的SWHE方案效率如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/IsCUut.png" alt="IsCUut"></p><p>看着好像还行，不过这Dimension有点夸张啊…也就是说公钥很长…那么，Gentry的FHE方案如何呢？效率如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/69jQG9.png" alt="69jQG9"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;p&gt;知乎VenusBlockChain: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/110210315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/110210315&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;知乎刘巍然：&lt;a href=&quot;https://www.zhihu.com/question/27645858/answer/37598506&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/27645858/answer/37598506&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Gouph/article/details/106179325&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/Gouph/article/details/106179325&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-同态加密&quot;&gt;&lt;a href=&quot;#1-1-同态加密&quot; class=&quot;headerlink&quot; title=&quot;1.1 同态加密&quot;&gt;&lt;/a&gt;1.1 同态加密&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;什么是同态加密？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提出第一个构造出全同态加密（Fully Homomorphic Encryption）[Gen09]的Craig Gentry给出的直观定义最好：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A way to delegate processing of your data, without giving away access to it.&lt;/p&gt;
&lt;p&gt;一种委托数据处理的方法，但是让你不丧失对数据的所有权&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;同态加密对于数据安全来说，不像一般的加密方案只关注&lt;strong&gt;数据存储安全&lt;/strong&gt;，攻击者无法从密文中获得任何信息, 对加密数据的任何改动操作都会造成解密的错误。而同态加密关注于&lt;strong&gt;数据的处理安全&lt;/strong&gt;，其提供了一种对加密数据处理的功能，且处理过程中无法得知原始内容，同时数据经过操作后还能够解密得到处理好的结果。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;同态加密（Homomorphic Encryption）允许对密文处理后仍然是加密的结果。即对密文直接进行处理，跟对明文进行处理后再对处理结果加密，得到的结果相同。从抽象代数的角度讲，保持了同态性。&lt;/p&gt;
&lt;p&gt;同态加密是&lt;strong&gt;基于数学难题&lt;/strong&gt;的计算复杂性理论的密码学技术，它的概念可以简单的解释为：对经过同态加密的数据进行密文运算处理得到一个输出，这一输出解密结果与用同一方法处理未加密的原始数据得到的输出结果是一样的。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/categories/technical/golang/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer15.二进制中1的个数</title>
    <link href="https://xwjahahahaha.github.io/2021/07/16/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://xwjahahahaha.github.io/2021/07/16/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2021-07-16T02:16:29.000Z</published>
    <updated>2021-07-16T02:19:57.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 15. 二进制中1的个数</a></p><p>难度简单</p><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">汉明重量</a>).）。</p><a id="more"></a><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用 <a href="https://baike.baidu.com/item/二进制补码/5295284" target="_blank" rel="noopener">二进制补码</a> 记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 11 (控制台输入 00000000000000000000000000001011)</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 128 (控制台输入 00000000000000000000000010000000)</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n &#x3D; -3）</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>本题依托一种算法：  <a href="https://myblog.gumptlu.work/2020/07/03/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/" target="_blank" rel="noopener">布赖恩·克尼根算法</a>， 位运算中需要掌握的一种算法</p><p>作用： 将一个数的二进制从右往左看最后一个1变为0</p><p>原理：将一个数-1，在二进制上的表现就是最后一位1变为0，此位后面的所有0变为1，此位前面的二进制位数字不动</p><p>使用： x &amp; (x-1)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">0</span>  &#123;</span><br><span class="line">        <span class="comment">// x &amp; (x-1) 可以去除掉最后一位1</span></span><br><span class="line">        num &amp;= (num<span class="number">-1</span>)</span><br><span class="line">        count ++ </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 15. 二进制中1的个数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度简单&lt;/p&gt;
&lt;p&gt;编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 &lt;a href=&quot;http://en.wikipedia.org/wiki/Hamming_weight&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汉明重量&lt;/a&gt;).）。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0198</title>
    <link href="https://xwjahahahaha.github.io/2021/07/16/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0198/"/>
    <id>https://xwjahahahaha.github.io/2021/07/16/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0198/</id>
    <published>2021-07-16T01:13:02.000Z</published>
    <updated>2021-07-16T08:40:31.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input checked="" disabled="" type="checkbox"> 隐私计算-同态加密</li><li><input disabled="" type="checkbox"> BlockFLA论文</li><li><input disabled="" type="checkbox"> tendermint项目解读2</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>隐私计算</title>
    <link href="https://xwjahahahaha.github.io/2021/07/15/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    <id>https://xwjahahahaha.github.io/2021/07/15/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/</id>
    <published>2021-07-15T06:04:05.000Z</published>
    <updated>2021-07-16T03:05:44.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习材料：</p><p><a href="https://zhuanlan.zhihu.com/p/138630291" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/138630291</a></p><p><a href="https://zhuanlan.zhihu.com/p/110210315" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110210315</a></p></blockquote><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><ul><li><p>区块链本身的公开性与隐私保护的冲突：</p><ul><li>区块链的隐私保护与传统隐私保护不同：上链数据需要多节点的验证共识, 链上的数据是公开透明的</li></ul></li><li><p>区块链隐私保护策略：</p><ol><li>链上链下分割, 分别设计隐私数据的保护策略</li><li>访问控制</li></ol></li><li><p>隐私保护策略的实现需要密码学技术的支持：</p><ol><li><p>同态加密：加密后的数据计算与原数据的直接计算同态</p></li><li><p>零知识证明：不泄漏数据本身的任何信息的情况下实现某些信息的证明</p></li><li><p>安全多方计算: 在隐私保护的情况下多方之间协同计算 (<em>一般基于<strong>混淆电路</strong>和<strong>不经意传输</strong>等技术实现</em>)</p></li><li><p>TEE(如SGX): 信任硬件设备:</p><p>在信任特定硬件设备（如 Intel 芯片的 SGX 功能）难以攻破的前提下选择在受硬件保护的 Enclave 环境中解密外部输入数据、执行智能合约代码、加密输出数据，此过程中<strong>明文信息只出现在 Enclave 中</strong>但不能被外部看到。</p><blockquote><p><font color='#39b54a'>加解密在硬件中，让明文只在硬件中暴露</font></p></blockquote></li></ol></li></ul><a id="more"></a><ul><li><p>区块链隐私主要分为身份隐私和交易隐私</p><ul><li>身份隐私：区块链地址与真实地址的映射关系隐私</li><li>交易隐私： 区块链上公开的信息，例如比特币的输入输出地址、金额暴露的支付关系</li></ul></li><li><p>交易数据的加密可以实现隐私保护，但是密文又会给验证交易带来困难</p><blockquote><p>如果比特币的金额都是加密的，那么核对账户余额以及扣款等就会相对变得更加复杂</p></blockquote><p>同态加密可以解决这个问题</p></li></ul><p>文章针对 ACCOUNT 模型，设计一种交易金额的同态加密计算和基于 FO 承诺的零知识证明方案。</p><blockquote><p>详细的加密工具的基本详解与使用，见下方链接：</p><ol><li>同态加密：</li><li>零知识证明：</li><li>安全多方计算：</li><li>查分隐私：</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习材料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/138630291&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/138630291&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/110210315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/110210315&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;区块链本身的公开性与隐私保护的冲突：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区块链的隐私保护与传统隐私保护不同：上链数据需要多节点的验证共识, 链上的数据是公开透明的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;区块链隐私保护策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;链上链下分割, 分别设计隐私数据的保护策略&lt;/li&gt;
&lt;li&gt;访问控制&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隐私保护策略的实现需要密码学技术的支持：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;同态加密：加密后的数据计算与原数据的直接计算同态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;零知识证明：不泄漏数据本身的任何信息的情况下实现某些信息的证明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安全多方计算: 在隐私保护的情况下多方之间协同计算 (&lt;em&gt;一般基于&lt;strong&gt;混淆电路&lt;/strong&gt;和&lt;strong&gt;不经意传输&lt;/strong&gt;等技术实现&lt;/em&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TEE(如SGX): 信任硬件设备:&lt;/p&gt;
&lt;p&gt;在信任特定硬件设备（如 Intel 芯片的 SGX 功能）难以攻破的前提下选择在受硬件保护的 Enclave 环境中解密外部输入数据、执行智能合约代码、加密输出数据，此过程中&lt;strong&gt;明文信息只出现在 Enclave 中&lt;/strong&gt;但不能被外部看到。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#39b54a&#39;&gt;加解密在硬件中，让明文只在硬件中暴露&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="solidity" scheme="https://xwjahahahaha.github.io/categories/technical/solidity/"/>
    
    
    <category term="solidity" scheme="https://xwjahahahaha.github.io/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer14-II.剪绳子II</title>
    <link href="https://xwjahahahaha.github.io/2021/07/14/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer14-II-%E5%89%AA%E7%BB%B3%E5%AD%90II/"/>
    <id>https://xwjahahahaha.github.io/2021/07/14/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87Offer14-II-%E5%89%AA%E7%BB%B3%E5%AD%90II/</id>
    <published>2021-07-14T06:18:34.000Z</published>
    <updated>2021-07-14T06:29:07.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 14- II. 剪绳子 II</a></p><p>难度中等125</p><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><font color='#e54d42'>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</font></p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 1000</code></li></ul><p>注意：本题与主站 343 题相同：<a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-break/</a></p><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>循环求余法除去溢出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此题不在适合动态规划，要用贪心算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cuttingRope</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    mod := <span class="number">1000000007</span></span><br><span class="line">    timesOf3 := n/<span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> n- (<span class="number">3</span> * timesOf3) == <span class="number">1</span> &#123;</span><br><span class="line">        timesOf3 -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timesOf2 := (n - <span class="number">3</span> * timesOf3) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求指数的时候，进行循环求模处理</span></span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=timesOf3; i++ &#123;</span><br><span class="line">        res = (res * <span class="number">3</span>) % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=timesOf2; i++ &#123;</span><br><span class="line">        res = (res * <span class="number">2</span>) % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % mod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 14- II. 剪绳子 II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等125&lt;/p&gt;
&lt;p&gt;给你一根长度为 &lt;code&gt;n&lt;/code&gt; 的绳子，请把绳子剪成整数长度的 &lt;code&gt;m&lt;/code&gt; 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 &lt;code&gt;k[0],k[1]...k[m - 1]&lt;/code&gt; 。请问 &lt;code&gt;k[0]*k[1]*...*k[m - 1]&lt;/code&gt; 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。&lt;/p&gt;
&lt;p&gt;&lt;font color=&#39;#e54d42&#39;&gt;答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0197</title>
    <link href="https://xwjahahahaha.github.io/2021/07/14/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0197/"/>
    <id>https://xwjahahahaha.github.io/2021/07/14/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-07/%E6%97%A5%E8%AE%B0-0197/</id>
    <published>2021-07-14T03:21:17.000Z</published>
    <updated>2021-07-16T01:09:25.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> BlockFLA:Accountable_Federated_Learning_via_Hybrid_Blockchain_Architecture</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input disabled="" type="checkbox"> Go网络编程Base</li><li><input disabled="" type="checkbox"> Go网络编程(base、Echo、Gin)</li><li><input disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)</li><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> Go设计模式 </li><li><input disabled="" type="checkbox"> docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><ul><li>Go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 英语</li><li><input checked="" disabled="" type="checkbox"> leetcode一题 剑指offer</li><li><input checked="" disabled="" type="checkbox"> 华为比赛</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
</feed>
