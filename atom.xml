<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识与头发不可兼得</title>
  
  <subtitle>文杰的博客</subtitle>
  <link href="https://xwjahahahaha.github.io/atom.xml" rel="self"/>
  
  <link href="https://xwjahahahaha.github.io/"/>
  <updated>2021-04-03T01:29:28.454Z</updated>
  <id>https://xwjahahahaha.github.io/</id>
  
  <author>
    <name>DDDemons hide</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日记_0149</title>
    <link href="https://xwjahahahaha.github.io/2021/04/03/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0149/"/>
    <id>https://xwjahahahaha.github.io/2021/04/03/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0149/</id>
    <published>2021-04-03T05:28:55.000Z</published>
    <updated>2021-04-03T01:29:28.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发</th><th>项目</th><th><font color='red'>科研</font></th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>区块链公链项目</td><td>论文一周两篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td></td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td></td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li>学弟的cosmos隐私保护项目</li><li>第一篇论文</li><li>科技部编程比赛</li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> <p>3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></p></li><li><input checked="" disabled="" type="checkbox"> <p>3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</p></li><li><input disabled="" type="checkbox"> <p>3-20~3-31 Go公链实现项目</p></li><li><input disabled="" type="checkbox"> <p>确定研究主方向,第一篇论文初稿与老师讨论</p></li></ul><p>四月 主要准备算法与Go后端框架的学习</p><p>四五月中要好好准备六级, 这次要过.</p><p>五月~七月 算法、面试准备</p><p><strong>走go开发, 有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> <p>英语</p></li><li><input disabled="" type="checkbox"> <p>leetcode</p></li><li><input disabled="" type="checkbox"> </li><li><input disabled="" type="checkbox"> </li><li><input disabled="" type="checkbox"> </li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发&lt;/th&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;&lt;font color=&#39;red&#39;&gt;科研&lt;/font&gt;&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;区块链公链项目&lt;/td&gt;
&lt;td&gt;论文一周两篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>103-二叉树的锯齿形层次遍历</title>
    <link href="https://xwjahahahaha.github.io/2021/04/03/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>https://xwjahahahaha.github.io/2021/04/03/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</id>
    <published>2021-04-03T05:06:42.000Z</published>
    <updated>2021-04-03T05:10:06.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层序遍历</a></h4><p>难度中等</p><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><a id="more"></a><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回锯齿形层序遍历如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>两种方法: 递归(深度优先)、迭代(广度优先) 不翻转奇数层数组,而是在插入时判断层数奇数层倒叙插入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span> <span class="params">(res [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建递归函数</span></span><br><span class="line">    <span class="keyword">var</span> recursive <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode, <span class="keyword">int</span>)</span></span></span><br><span class="line">    recursive = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, level <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前层次与结果集大小相等,那么就为新的层创建空间</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) == level &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断层数奇偶,决定插入结果集顺序,奇数反序,偶数正序</span></span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">0</span> || level % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            res[level] = <span class="built_in">append</span>(res[level], node.Val)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 反序添加</span></span><br><span class="line">            res[level] = <span class="built_in">append</span>(res[level], <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> i:=<span class="built_in">len</span>(res[level])<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">                res[level][i] = res[level][i<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            res[level][<span class="number">0</span>] = node.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归子节点</span></span><br><span class="line">        <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            recursive(node.Left, level+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            recursive(node.Right, level+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    recursive(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span> <span class="params">(resList [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    res := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    division := &amp;TreeNode&#123;&#125;</span><br><span class="line">    <span class="comment">// 加入根节点与分隔符节点</span></span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root, division)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 弹出节点</span></span><br><span class="line">        node := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="comment">// 判断是否为分隔符节点</span></span><br><span class="line">        <span class="keyword">if</span> node == division &#123;</span><br><span class="line">            resList = <span class="built_in">append</span>(resList, res)</span><br><span class="line">            res = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, division)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 层还未结束,继续添加</span></span><br><span class="line">            <span class="comment">// 根据当前层数奇偶,判断添加到结果集的顺序.奇数为逆序,偶数为顺序</span></span><br><span class="line">            level := <span class="built_in">len</span>(resList)</span><br><span class="line">            <span class="keyword">if</span> level == <span class="number">0</span> || level % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反序添加</span></span><br><span class="line">                res = <span class="built_in">append</span>(res, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> i:=<span class="built_in">len</span>(res)<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">                    res[i] = res[i<span class="number">-1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                res[<span class="number">0</span>] = node.Val</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加子节点到队列</span></span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;103-二叉树的锯齿形层序遍历&quot;&gt;&lt;a href=&quot;#103-二叉树的锯齿形层序遍历&quot; class=&quot;headerlink&quot; title=&quot;103. 二叉树的锯齿形层序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;103. 二叉树的锯齿形层序遍历&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>145-二叉树的后序遍历</title>
    <link href="https://xwjahahahaha.github.io/2021/04/01/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://xwjahahahaha.github.io/2021/04/01/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-04-01T02:10:31.000Z</published>
    <updated>2021-04-01T02:11:18.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></h4><p>难度中等555</p><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> recursive <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">    recursive = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 边界情况</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        recursive(node.Left)</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        recursive(node.Right)</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    recursive(root)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    <span class="comment">// 已访问的右子节点需要标记,防止死循环</span></span><br><span class="line">    <span class="keyword">var</span> visited *TreeNode       <span class="comment">// 表示已访问</span></span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 左走,入栈</span></span><br><span class="line">        <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走完,出栈,到达中间根节点</span></span><br><span class="line">        root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">// 判断此根节点右子节点</span></span><br><span class="line">        <span class="comment">// 1. 为空或已访问则结束此根节点</span></span><br><span class="line">        <span class="keyword">if</span> root.Right == <span class="literal">nil</span> || root.Right == visited &#123;</span><br><span class="line">            <span class="comment">// 加入结果集</span></span><br><span class="line">            res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">            visited = root</span><br><span class="line">            root = <span class="literal">nil</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 2. 不为空或者未访问责重新入栈访问右节点</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, root)     <span class="comment">// root重新入栈</span></span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;145-二叉树的后序遍历&quot;&gt;&lt;a href=&quot;#145-二叉树的后序遍历&quot; class=&quot;headerlink&quot; title=&quot;145. 二叉树的后序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-postorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;145. 二叉树的后序遍历&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等555&lt;/p&gt;
&lt;p&gt;给定一个二叉树，返回它的 &lt;em&gt;后序&lt;/em&gt; 遍历。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0148</title>
    <link href="https://xwjahahahaha.github.io/2021/04/01/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0148/"/>
    <id>https://xwjahahahaha.github.io/2021/04/01/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0148/</id>
    <published>2021-04-01T00:42:50.000Z</published>
    <updated>2021-04-02T05:29:01.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发</th><th>项目</th><th><font color='red'>科研</font></th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>区块链公链项目</td><td>论文一周两篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>金窝窝项目需求准备cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td>本科毕业设计</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td>科技部编程比赛</td><td></td><td></td></tr><tr><td>⑤</td><td></td><td></td><td>微信小程序前端uni-app</td><td></td><td></td></tr><tr><td>⑥</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li>学弟的cosmos隐私保护项目</li><li>第一篇论文</li><li>科技部编程比赛</li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> <p>3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></p></li><li><input checked="" disabled="" type="checkbox"> <p>3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</p></li><li><input disabled="" type="checkbox"> <p>3-20~3-31 Go公链实现项目</p></li><li><input disabled="" type="checkbox"> <p>确定研究主方向,第一篇论文初稿与老师讨论</p></li></ul><p>四月 主要准备算法与Go后端框架的学习</p><p>四五月中要好好准备六级, 这次要过.</p><p>五月~七月 算法、面试准备</p><p><strong>走go开发, 有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语70词</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> 机器学习 =&gt; p24</li><li><input checked="" disabled="" type="checkbox"> 论文 </li><li><input checked="" disabled="" type="checkbox"> go advance =&gt; p89</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发&lt;/th&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;&lt;font color=&#39;red&#39;&gt;科研&lt;/font&gt;&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;区块链公链项目&lt;/td&gt;
&lt;td&gt;论文一周两篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;金窝窝项目需求准备cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;本科毕业设计&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;科技部编程比赛&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑤&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;微信小程序前端uni-app&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑥&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>144-二叉树的前序遍历</title>
    <link href="https://xwjahahahaha.github.io/2021/03/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://xwjahahahaha.github.io/2021/03/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-03-31T03:02:25.000Z</published>
    <updated>2021-03-31T03:03:40.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></h4><p>难度中等</p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p> <a id="more"></a><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> recursive <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    <span class="comment">// 函数定义</span></span><br><span class="line">    recursive = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        recursive(root.Left)</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        recursive(root.Right)  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    recursive(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="comment">// 中</span></span><br><span class="line">           stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">           res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">           <span class="comment">// 左</span></span><br><span class="line">           root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 弹出</span></span><br><span class="line">        root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        root = root.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;144-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#144-二叉树的前序遍历&quot; class=&quot;headerlink&quot; title=&quot;144. 二叉树的前序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-preorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;144. 二叉树的前序遍历&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回它节点值的 &lt;strong&gt;前序&lt;/strong&gt; 遍历。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>94-二叉树的中序遍历</title>
    <link href="https://xwjahahahaha.github.io/2021/03/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://xwjahahahaha.github.io/2021/03/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-03-31T02:31:39.000Z</published>
    <updated>2021-03-31T03:03:47.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h4><p>难度中等</p><a id="more"></a><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>递归与迭代</p><p>时间复杂度O(N)</p><p>空间复杂度O(N) (最坏当链表为一条直线时,栈的深度就是N)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    GetPath(&amp;path, root)</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPath</span><span class="params">(path *[]<span class="keyword">int</span>, root *TreeNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    GetPath(path, root.Left)</span><br><span class="line">    *path = <span class="built_in">append</span>(*path, root.Val)</span><br><span class="line">    GetPath(path, root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="comment">// 维护一个栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   stack := []*TreeNode&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="comment">// 一直遍历左边</span></span><br><span class="line">       <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="comment">// 入栈</span></span><br><span class="line">           stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">           root = root.Left</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 处理中间</span></span><br><span class="line">       root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">       stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">       res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">       <span class="comment">// 右边</span></span><br><span class="line">       root = root.Right</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;94-二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#94-二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;94. 二叉树的中序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-inorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;94. 二叉树的中序遍历&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0147</title>
    <link href="https://xwjahahahaha.github.io/2021/03/31/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0147/"/>
    <id>https://xwjahahahaha.github.io/2021/03/31/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0147/</id>
    <published>2021-03-31T00:42:59.000Z</published>
    <updated>2021-04-01T00:41:56.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发</th><th>项目</th><th><font color='red'>科研</font></th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>区块链公链项目</td><td>论文一周两篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>金窝窝项目需求准备cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td>本科毕业设计</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td>科技部编程比赛</td><td></td><td></td></tr><tr><td>⑤</td><td></td><td></td><td>微信小程序前端uni-app</td><td></td><td></td></tr><tr><td>⑥</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li>学弟的cosmos隐私保护项目</li><li>第一篇论文</li><li>科技部编程比赛</li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> <p>3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></p></li><li><input checked="" disabled="" type="checkbox"> <p>3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</p></li><li><input disabled="" type="checkbox"> <p>3-20~3-31 Go公链实现项目</p></li><li><input disabled="" type="checkbox"> <p>确定研究主方向,第一篇论文初稿与老师讨论</p></li></ul><p>四月 主要准备算法与Go后端框架的学习</p><p>四五月中要好好准备六级, 这次要过.</p><p>五月~七月 算法、面试准备</p><p><strong>走go开发, 有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> <p>英语70词</p></li><li><input checked="" disabled="" type="checkbox"> <p>leetcode二叉树的遍历两题</p></li><li><input checked="" disabled="" type="checkbox"> <p>go Advance =&gt; p69</p></li><li><input checked="" disabled="" type="checkbox"> <p>吴恩达机器学习 =&gt; P18</p></li><li><input checked="" disabled="" type="checkbox"> <p>论文</p></li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发&lt;/th&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;&lt;font color=&#39;red&#39;&gt;科研&lt;/font&gt;&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;区块链公链项目&lt;/td&gt;
&lt;td&gt;论文一周两篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;金窝窝项目需求准备cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;本科毕业设计&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;科技部编程比赛&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑤&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;微信小程序前端uni-app&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑥&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>160-相交链表</title>
    <link href="https://xwjahahahaha.github.io/2021/03/30/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>https://xwjahahahaha.github.io/2021/03/30/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2021-03-30T03:26:45.000Z</published>
    <updated>2021-03-30T04:24:30.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></h4><p>难度简单</p><p>编写一个程序，找到两个单链表相交的起始节点。</p><a id="more"></a><p>如下面的两个链表<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力法 </span></span><br><span class="line"><span class="comment">// 对于每一个A链表的节点,遍历B链表是否有与之相同的节点</span></span><br><span class="line"><span class="comment">// 时间复杂度O(MN), 空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    tailA, tailB := headA, headB</span><br><span class="line">    <span class="keyword">for</span> tailA != <span class="literal">nil</span> &#123;</span><br><span class="line">        tailB = headB</span><br><span class="line">        <span class="keyword">for</span> tailB != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> tailA == tailB &#123;</span><br><span class="line">                <span class="keyword">return</span> tailA</span><br><span class="line">            &#125;</span><br><span class="line">            tailB = tailB.Next</span><br><span class="line">        &#125;</span><br><span class="line">        tailA = tailA.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二 Hash表计数法</span></span><br><span class="line"><span class="comment">// 时间复杂度O(M+N), 空间复杂度O(M)/O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    tailA, tailB := headA, headB</span><br><span class="line">    countMap := <span class="built_in">make</span>(<span class="keyword">map</span>[*ListNode]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 记录A链表的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> tailA != <span class="literal">nil</span> &#123;</span><br><span class="line">        countMap[tailA] = <span class="number">1</span></span><br><span class="line">        tailA = tailA.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历B链表</span></span><br><span class="line">    <span class="keyword">for</span> tailB != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := countMap[tailB];ok &#123;</span><br><span class="line">            <span class="keyword">return</span> tailB</span><br><span class="line">        &#125;</span><br><span class="line">        tailB = tailB.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三: 双指针</span></span><br><span class="line"><span class="comment">// len(A) + len(common) + len(B) = len(B) + len(common) + len(A)</span></span><br><span class="line"><span class="comment">// 时间复杂度O(M+N), 空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    tailA, tailB := headA, headB</span><br><span class="line">    <span class="comment">// 当两者相同时, 结束循环返回</span></span><br><span class="line">    <span class="comment">// 即使是不相交的情况, 双方最终也会到达nil(双方互换了链)从而相等,返回的也就是nil代表不相交</span></span><br><span class="line">    <span class="keyword">for</span> tailA != tailB  &#123;</span><br><span class="line">        <span class="keyword">if</span> tailA == <span class="literal">nil</span> &#123;</span><br><span class="line">            tailA = headB</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tailA = tailA.Next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tailB == <span class="literal">nil</span> &#123;</span><br><span class="line">            tailB = headA</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tailB = tailB.Next      </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tailA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;160-相交链表&quot;&gt;&lt;a href=&quot;#160-相交链表&quot; class=&quot;headerlink&quot; title=&quot;160. 相交链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;160. 相交链表&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度简单&lt;/p&gt;
&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0146</title>
    <link href="https://xwjahahahaha.github.io/2021/03/30/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0146/"/>
    <id>https://xwjahahahaha.github.io/2021/03/30/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0146/</id>
    <published>2021-03-30T00:51:54.000Z</published>
    <updated>2021-03-31T00:42:46.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发</th><th>项目</th><th><font color='red'>科研</font></th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>区块链公链项目</td><td>论文一周两篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>金窝窝项目需求准备cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td>本科毕业设计</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td>科技部编程比赛</td><td></td><td></td></tr><tr><td>⑤</td><td></td><td></td><td>微信小程序前端uni-app</td><td></td><td></td></tr><tr><td>⑥</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li>学弟的cosmos隐私保护项目</li><li>第一篇论文</li><li>科技部编程比赛</li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> <p>3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></p></li><li><input checked="" disabled="" type="checkbox"> <p>3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</p></li><li><input disabled="" type="checkbox"> <p>3-20~3-31 Go公链实现项目</p></li><li><input disabled="" type="checkbox"> <p>确定研究主方向,第一篇论文初稿与老师讨论</p></li></ul><p>四月 主要准备算法与Go后端框架的学习</p><p>四五月中要好好准备六级, 这次要过.</p><p>五月~七月 算法、面试准备</p><p><strong>走go开发, 有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语70词 + 语法课 =&gt; 08</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> golang Advance =&gt; P62</li><li><input checked="" disabled="" type="checkbox"> simple_bitcoin =&gt; p21</li><li><input checked="" disabled="" type="checkbox"> 论文</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发&lt;/th&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;&lt;font color=&#39;red&#39;&gt;科研&lt;/font&gt;&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;区块链公链项目&lt;/td&gt;
&lt;td&gt;论文一周两篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;金窝窝项目需求准备cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;本科毕业设计&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;科技部编程比赛&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑤&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;微信小程序前端uni-app&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑥&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Blockchained_On-Device_Federated_Learning》</title>
    <link href="https://xwjahahahaha.github.io/2021/03/28/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E8%AE%BA%E6%96%87/%E3%80%8ABlockchained-On-Device-Federated-Learning%E3%80%8B/"/>
    <id>https://xwjahahahaha.github.io/2021/03/28/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E8%AE%BA%E6%96%87/%E3%80%8ABlockchained-On-Device-Federated-Learning%E3%80%8B/</id>
    <published>2021-03-28T07:36:50.000Z</published>
    <updated>2021-04-01T08:12:24.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>《区块链设备上的联邦学习》</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/k52km4.png" alt="k52km4"></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>我们结合区块链技术,这篇文章提出了一个区块链联邦学习(blockchain federated learning, BlockFL)架构，其中交换和验证了本地学习模型的更新。</p><p>这使得设备上的机器学习无需任何集中的训练数据或通过使用区块链中的共识机制进行协调。</p><p>此外，我们分析了BlockFL的端到端延迟模型，并通过考虑通信、计算和共识延迟来刻画最优的块生成率。</p><a id="more"></a><h1 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h1><p>未来的无线系统可以保证随时随地的低延迟和高可靠性</p><p>为此，设备上的机器学习是一个引人注目的解决方案，其中每个设备存储一个高质量的机器学习模型，从而能够做出决策, 即使它失去了连通性。</p><p>训练这样一个设备上的机器学习模型需要比每个设备的本地样本更多的数据样本，并且有必要与其他设备交换样本</p><p>在这篇文章中，我们解决了通过与其他设备联合来训练每个设备的本地模型的问题</p><p>一个关键的挑战是每个设备都拥有本地数据样本。因此，交换的过程应该保证来自于其他设备原始数据的私有与隐私.</p><p>为此，正如谷歌的联邦学习(FL),被称为<code>vanilla FL</code>,每个设备交换它自己本地的模型更新</p><p>也就是,学习模型的权值和梯度参数，不能从中得到原始数据</p><p>如图1-a所示，<code>vanilla FL</code>的交换是通过中央服务器的帮助而实现的，中央服务器聚合并获取所有本地模型更新的总体平均值,产生<code>global model</code>的更新。然后，每个设备下载全局模型(<code>global model</code>)的更新，并计算它的下一个本地更新，直到全局模型训练完成[5]。由于这些交换，<code>vanilla FL</code>的训练完成延迟可能是几十分钟或更多，正如谷歌的键盘应用程序( Google’s keyboard application)[7]所演示的那样.</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/2ORl0c.png" alt="2ORl0c"></p><hr><p><font color='green'>下面开始分析谷歌Vanilla的缺点: 两个方面: <strong>1.中心服务器的中心化 2. 缺乏奖励措施</strong></font></p><p>Vanilla FL操作的局限性是双重的。</p><p>首先,它依赖于一个<strong>单一的中央服务器</strong>，这在服务器故障时是脆弱的。那么当global model发生不准确的更新时会导致所有的local model发生错误的更新</p><p>其次,他对于本地设备没有给予奖励,拥有更多数据样本的设备对全局训练的贡献更大。如果不提供补偿，这样的设备就不太愿意与拥有少量数据样本的其他设备联合.</p><hr><p><font color='green'> 引入本项目的架构: BlockFL</font></p><p>为了解决这些紧迫的问题, 通过利用区块链技术作为中央服务器的替代,我们提出了一个Blockchained FL (BlockFL)架构</p><p>区块链网络允许交换设备的本地模型更新，同时验证和提供相应的奖励。</p><p>BlockFL克服了单点故障问题，并将其联合范围扩展到公共网络中不值得信任的设备，这得益于本地训练结果的验证过程</p><p>此外，通过提供与训练样本大小成比例的奖励，BlockFL促进了更多设备与更多训练样本的联合。</p><hr><p>如图1-b所示，BlockFL的逻辑结构由设备和矿工组成</p><p>矿工在物理上可以是随机选择的设备，也可以是独立的节点，如边缘网络(network edges)(即蜂窝网络中的基站).它们在采矿过程中相对不受能源限制。</p><p>BlockFL的操作总结如下:</p><p>每个设备计算并上传本地模型更新到区块链网络中的相关miner;</p><p>矿工交换并验证所有本地模型更新，然后运行工作证明(PoW) [8];一旦一个矿工完成PoW，它会生成一个块，其中记录了已验证的本地模型更新;</p><p>最后，生成的存储聚合本地模型更新的块被添加到区块链，也被称为分布式账本，并被设备下载。每个设备从新的块计算全局模型更新。</p><hr><p>请注意，BlockFL的全局模型更新是在每个设备本地计算的。矿机或设备的故障不会影响其他设备的全局模型更新。</p><p>为了这些好处，与普通的FL相比，blockfl需要考虑由区块链网络引起的额外延迟。</p><p>为了解决这个问题，通过考虑通信、计算和PoW延迟，建立了Block FL的端到端延迟模型.</p><p><font color='red'>通过调整块生成率，也就是PoW难度，从而使延迟最小化。    </font></p><hr><h1 id="2-Architecture-And-Operation-架构和操作"><a href="#2-Architecture-And-Operation-架构和操作" class="headerlink" title="2.Architecture And Operation 架构和操作"></a>2.Architecture And Operation 架构和操作</h1><h2 id="FL-operation-in-BlockFL"><a href="#FL-operation-in-BlockFL" class="headerlink" title="FL operation in BlockFL:"></a>FL operation in BlockFL:</h2><p>FL的相关操作: FL在一套设备下操作:$D = {1,2,…,N_D}$其中$|D| = N_D$<font color='green'>(一共有$N_D个设备$)    </font> .第i个设备$D_i$拥有的数据样例表示为$S_i$其中$|S_i| = N_i$,并且只训练其本地的模型.设备$D_i$本地模型的更新将会上传到与其相关联的Miner:$M_j$ (这是从一组Miner中统一随机选择出来的, 即$M= {1,2,…,N_M}$ )</p><p>我们的分布式模型训练主要以平行的方式关注于解决<strong>回归问题</strong>,考虑到整套设备的数据样本: $S = \bigcup^{N_D}_{i=1}S_i$ <font color='green'>(所有数据样本的并集) </font>其中$|S|= N_S$</p><p>第k个数据样本$ s_k \in S$ 即 $s_k = {x_k,y_k}$是一个d维的列向量$x_k \in \mathbb{R}^d$ 和一个标量值$y_k \in \mathbb{R}$</p><p><font color='green'> ($\mathbb{R}^d$表示的是一个d维的向量)   </font></p><p>训练的目标是使一个全局权重向量$w \in \mathbb{R}^d$ <font color='green'> (权重其实就是参数向量)   </font>的损失函数$f(w)$最小.取损失函数$f(w)$作为均方误差:</p><p>$f(w) = \frac{1}{N_S} \sum^{N_D}<em>{i=1}\sum</em>{s_k\in S_i}f_k(w)$ 其中 $f_k(w) = (x_k^Tw-y_k)^2/2$</p><p>深度神经网络下的其他损失函数也可以像[10]中那样被整合。</p><hr><p>为了解决这些问题,按照<code>vanilla FL</code>在[4]的设置,设备$D_i$通过[4]中的随机方差约化梯度算法训练本地模型.采用分布式近似牛顿法对所有设备的局部模型更新进行聚合.对于每次训练, 设备$D_i$的本地模型都以$N_i$的次数迭代(Ni是Di样本的总数)</p><p>对于第$l$次训练的第t次本地迭代,本地权重$w_i^{(t,l)} \in \mathbb{R}^d$为:<br>$$<br>w_i^{(t,l)}=w_i^{(t-1, l)}- \frac{\beta}{N_i}([\nabla f_k(w_i^{(t-1, l)})-\nabla f_k(w^{(l)})]+\nabla f(w^{(l)}))<br>$$<br>其中的$\nabla$符号:</p><blockquote><p>劈形算符，倒三角算符，是一个符号，形为∇。就是对倒三角后面的量做如下操作：<strong>表示对函数在各个正交方向上求导数以后再分别乘上各个方向上的单位向量。</strong></p><p>劈形算符在数学中用于指代梯度算符。它也用于指代微分几何中的联络（可以视为更广意义上的梯度算符）。它由哈密尔顿引入。</p></blockquote><p>其中$\beta ( &gt;0)$ 是一个步长, $w^{(l)}$表示在第$l$次训练中的全局权重<font color='green'> (每次训练的均方误差)   </font>, 其中:<br>$$<br>\nabla f(w^{(l)}) = \frac{1}{N_S}\sum^{N_D}<em>{i=1}\sum</em>{s_k\in S_i}\nabla f_k(w^{(l)})<br>$$<br>让$w_i^{(l)}$代表在第$l$次训练中最后一次本地迭代的本地权重,表示为$w_i^{(l)}=w^{(N_i, l)}$ <font color='green'> (样本总数为Ni,最后一次就是t=Ni)</font> 则有:<br>$$<br>w^{(l)} = w^{(l-1)}+ \sum^{N_D}_{i=1}\frac{N_i}{N_S}(w_i^{(l)}-w^{(l-1)})<br>$$<br>$N_S$为合并各个设备所有样本的总数</p><p>在<code>vanilla FL</code>[4][5]中,设备$D_i$上传自己的本地模型更新$(w_i^{(l)}, {\nabla f_k(w^{(l)})}_{s_k\in S_i})$给中央服务器,其中模型的更新的大小$\delta_m$相等的给各个设备.全局模型更新$(w^{(l)}, \nabla f(w^{(l)}))$由服务器进行计算. <strong>在BlockFL中，服务器实体被区块链网络取代</strong>，详细描述如下.</p><hr><h2 id="Blockchain-operation-in-BlockFL"><a href="#Blockchain-operation-in-BlockFL" class="headerlink" title="Blockchain operation in BlockFL:"></a>Blockchain operation in BlockFL:</h2><p>在BlockFL中，通过$M$中的miner实现区块生成和它们的验证，miner的功能在于在一个分布式账本(即区块链)与本地模型之间<strong>信任的</strong>交换本地模型的更新,</p><p>分类帐中的每个块被分为它的主体body部分和头head部分[8]</p><p>在BlockFL中,<strong>区块体</strong>中存储着设备D的本地模型更新数据,即设备$D_i$在第$l$次训练更新的数据: $(w_i^{(l)}, {\nabla f_k(w^{(l)})<em>{s_k \in S_i}})$以及它的本地计算时间$T</em>{local,i}^{(l)}$(这将会在后续讨论)</p><p>区块头部包含了指向前一个块的指针、块生成率λ和PoW的输出值的信息.</p><p>每一个区块的大小设置为$h + \delta_m N_D$  其中的$h $和$ \delta_m$分别是区块头和模型更新的大小</p><p><strong>每一个矿工Miner拥有一个与其相关联的设备或者其他Miner的充满了本地模型更新数据的候选区块(未上链区块)</strong>,写入区块数据的过程直到达到区块的最大数据量或者达到等待时间$T_{wait}$</p><hr><p>然后，根据PoW[8]，miner通过改变其输入即nonce随机生成一个哈希值,直到生成的hash值变得小于目标值(难度)</p><p>一旦miner $M_1$成功地找到了哈希值，它的候选块就可以成为区块链中一个新的区块，如图2所示。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/6Lbv5h.png" alt="6Lbv5h"></p><p>区块的生成速度$\lambda$可以被POW的难度控制,即POW的难度越大/区块目标值越小,区块生成速率$\lambda$越小</p><p>由于其简单、健壮性，PoW应用于无线系统，如[11]、[12]。BlockFL还可以使用其他共识算法，如权益证明(PoS)或拜占庭容错(BFT)，这可能需要更复杂的操作和初步工作来在矿工之间达成共识。</p><hr><p>生成的块将传播给所有其他矿工。为此，正如[8]中所做的，所有收到生成区块的矿工都被迫停止他们的Pow工作，并将生成的区块添加到本地区块链中.</p><p>如图2所示,如果另一个矿工$M_2$在第一个生成的块的传播延迟内成功生成了块，那么一些矿工可能会错误地将第二个生成的块添加到他们本地的账本中，称为分叉。在BlockFL中，分叉使得一些设备将一个不正确的全局模型更新应用到它们的下一个局部模型更新。分叉频率随着区块生成速率λ和块传播延迟的增加而增加，其缓解会带来额外的延迟，具体在第三节中进行阐述.</p><hr><p>区块链网络还为设备的数据样本和矿工的验证过程提供奖励，分为数据奖励data reward和挖掘奖励mining reward.</p><p>设备$D_i$的<strong>数据奖励</strong>来自于与其相关联的Miner(或者说由其提供),奖励的数量与提供数据样例的大小$N_i$成比例</p><p>当miner $M_j$生成一个区块时，它的<strong>采矿奖励</strong>由区块链网络获得，就像在传统的区块链结构中那样.</p><p>挖掘奖励的数量与其所有关联设备的总数据样本大小成正比，即$\sum_{i=1}^{N_{M_j}}N_i$ 其中的$N_{M_j}$代表矿工$M_j$相关联的设备数量.</p><p>值得注意的是，BlockFL可以通过奖励机制进一步改进，<strong>不仅可以考虑数据样本的大小，而且可以考虑数据样本的质量，这些都影响了FL</strong></p><p>不可信的<u>设备</u>可能会通过任意的本地模型更新来扩充它们的可提供的样本大小.矿工在存储这些样本之前会验证这些本地更新, 其通过比较样本大小$N_i$与其相关联的计算时间$T_{local,i}^{(l)}$ <font color='green'> (样本数量与其对应的计算时间是相关的,所以两者不匹配就会错误)   </font>这在实际中可以由英特尔的软件保护扩展(Intel’s  software  guard  extensions)来保证，允许应用程序在受保护环境中运行，这是区块链技术[13]所使用的</p><p>允许应用程序在受保护环境中运行，这是区块链技术[13]所使用的</p><h2 id="One-epoch-BlockFL-operation"><a href="#One-epoch-BlockFL-operation" class="headerlink" title="One-epoch BlockFL operation:"></a>One-epoch BlockFL operation:</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h1&gt;&lt;p&gt;《区块链设备上的联邦学习》&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/k52km4.png&quot; alt=&quot;k52km4&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;我们结合区块链技术,这篇文章提出了一个区块链联邦学习(blockchain federated learning, BlockFL)架构，其中交换和验证了本地学习模型的更新。&lt;/p&gt;
&lt;p&gt;这使得设备上的机器学习无需任何集中的训练数据或通过使用区块链中的共识机制进行协调。&lt;/p&gt;
&lt;p&gt;此外，我们分析了BlockFL的端到端延迟模型，并通过考虑通信、计算和共识延迟来刻画最优的块生成率。&lt;/p&gt;</summary>
    
    
    
    <category term="knowledge" scheme="https://xwjahahahaha.github.io/categories/knowledge/"/>
    
    <category term="block_chain" scheme="https://xwjahahahaha.github.io/categories/knowledge/block-chain/"/>
    
    
    <category term="block_chain" scheme="https://xwjahahahaha.github.io/tags/block-chain/"/>
    
    <category term="federated_learing" scheme="https://xwjahahahaha.github.io/tags/federated-learing/"/>
    
  </entry>
  
  <entry>
    <title>328-奇偶链表</title>
    <link href="https://xwjahahahaha.github.io/2021/03/27/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>https://xwjahahahaha.github.io/2021/03/27/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</id>
    <published>2021-03-27T02:58:30.000Z</published>
    <updated>2021-03-27T03:00:23.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">328. 奇偶链表</a></h4><p>难度中等</p><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p><strong>分离合并</strong>的思想(但是不使用额外的空间)</p><p>时间复杂度O(N)</p><p>空间复杂度O(1)</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/osTp4e.jpg" alt="osTp4e"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 分离合并</span></span><br><span class="line"> <span class="comment">// 将偶链表分离出来,在添加到奇链表之后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oddEvenList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将链表分离为奇偶两个链表</span></span><br><span class="line">    <span class="comment">// 创建奇偶指针</span></span><br><span class="line">    odd, even := head, head.Next</span><br><span class="line">    <span class="comment">// 记录奇链表的头</span></span><br><span class="line">    evenHead := even</span><br><span class="line">    <span class="comment">// 一直读取,直到奇指针先结束</span></span><br><span class="line">    <span class="comment">// even.Next != nil 为了防止nil.Next的空指针出现</span></span><br><span class="line">    <span class="keyword">for</span> even != <span class="literal">nil</span> &amp;&amp; even.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 先奇节点开始</span></span><br><span class="line">        odd.Next = even.Next</span><br><span class="line">        odd = odd.Next</span><br><span class="line">        <span class="comment">// 偶节点</span></span><br><span class="line">        even.Next = odd.Next</span><br><span class="line">        even = even.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拼接</span></span><br><span class="line">    odd.Next = evenHead</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;328-奇偶链表&quot;&gt;&lt;a href=&quot;#328-奇偶链表&quot; class=&quot;headerlink&quot; title=&quot;328. 奇偶链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/odd-even-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;328. 奇偶链表&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。&lt;/p&gt;
&lt;p&gt;请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0145</title>
    <link href="https://xwjahahahaha.github.io/2021/03/27/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0145/"/>
    <id>https://xwjahahahaha.github.io/2021/03/27/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0145/</id>
    <published>2021-03-27T01:50:35.000Z</published>
    <updated>2021-03-28T00:51:39.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发</th><th>项目</th><th><font color='red'>科研</font></th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>区块链公链项目</td><td>论文一周两篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>金窝窝项目需求准备cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td>本科毕业设计</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td>科技部编程比赛</td><td></td><td></td></tr><tr><td>⑤</td><td></td><td></td><td>微信小程序前端uni-app</td><td></td><td></td></tr><tr><td>⑥</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li>学弟的cosmos隐私保护项目</li><li>第一篇论文</li><li>科技部编程比赛</li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> <p>3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></p></li><li><input checked="" disabled="" type="checkbox"> <p>3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</p></li><li><input disabled="" type="checkbox"> <p>3-20~3-31 Go公链实现项目</p></li><li><input disabled="" type="checkbox"> <p>确定研究主方向,第一篇论文初稿与老师讨论</p></li></ul><p>四月 主要准备算法与Go后端框架的学习</p><p>四五月中要好好准备六级, 这次要过.</p><p>五月~七月 算法、面试准备</p><p><strong>走go开发, 有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语70词</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> 《Federated Machine Learning: Concept and Applications》论文学习结束</li><li><input checked="" disabled="" type="checkbox"> 机器学习 =&gt;  P11</li><li><input checked="" disabled="" type="checkbox"> go Advance =&gt; P59</li><li><input checked="" disabled="" type="checkbox"> simple bitcoin =&gt; p11</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2><ul><li>做事先过脑</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发&lt;/th&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;&lt;font color=&#39;red&#39;&gt;科研&lt;/font&gt;&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;区块链公链项目&lt;/td&gt;
&lt;td&gt;论文一周两篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;金窝窝项目需求准备cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;本科毕业设计&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;科技部编程比赛&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑤&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;微信小程序前端uni-app&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑥&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2-两数相加</title>
    <link href="https://xwjahahahaha.github.io/2021/03/25/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>https://xwjahahahaha.github.io/2021/03/25/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2021-03-25T05:41:44.000Z</published>
    <updated>2021-03-25T05:44:57.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></h4><p>难度中等</p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><a id="more"></a> <p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>时间复杂度O(max(m, n))</p><p>空间复杂度O(max(m,n))</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础运算的规律: 两个数按位相加</span></span><br><span class="line"><span class="comment">// 当前位的计算: (n1 + n2 + carry) % 10</span></span><br><span class="line"><span class="comment">// 进位的计算: (n1 + n2 + carry) / 10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   carry := <span class="number">0</span></span><br><span class="line">   <span class="keyword">var</span> tail, head  *ListNode</span><br><span class="line">   <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 取值, 如果已经取完那么默认就是0</span></span><br><span class="line">        n1, n2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">           n1 = l1.Val</span><br><span class="line">           l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">           n2 = l2.Val</span><br><span class="line">           l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        digit := (n1 + n2 + carry) % <span class="number">10</span></span><br><span class="line">        carry = (n1 +  n2 + carry) / <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 第一处创建</span></span><br><span class="line">            tail = &amp;ListNode&#123;Val : digit&#125;</span><br><span class="line">            head = tail</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 随后</span></span><br><span class="line">            tail.Next = &amp;ListNode&#123;Val : digit&#125;</span><br><span class="line">            tail = tail.Next</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 检查是否需要再进位. 这一步是关键</span></span><br><span class="line">   <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tail.Next = &amp;ListNode&#123;Val : carry&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;2-两数相加&quot;&gt;&lt;a href=&quot;#2-两数相加&quot; class=&quot;headerlink&quot; title=&quot;2. 两数相加&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2. 两数相加&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给你两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表，表示两个非负的整数。它们每位数字都是按照 &lt;strong&gt;逆序&lt;/strong&gt; 的方式存储的，并且每个节点只能存储 &lt;strong&gt;一位&lt;/strong&gt; 数字。&lt;/p&gt;
&lt;p&gt;请你将两个数相加，并以相同形式返回一个表示和的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>日记_0144</title>
    <link href="https://xwjahahahaha.github.io/2021/03/25/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0144/"/>
    <id>https://xwjahahahaha.github.io/2021/03/25/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0144/</id>
    <published>2021-03-25T00:27:36.000Z</published>
    <updated>2021-03-27T01:50:22.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发</th><th>项目</th><th><font color='red'>科研</font></th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>区块链公链项目</td><td>论文一周两篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>金窝窝项目需求准备cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td>本科毕业设计</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td>科技部编程比赛</td><td></td><td></td></tr><tr><td>⑤</td><td></td><td></td><td>微信小程序前端uni-app</td><td></td><td></td></tr><tr><td>⑥</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li>学弟的cosmos隐私保护项目</li><li>第一篇论文</li><li>科技部编程比赛</li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> <p>3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></p></li><li><input checked="" disabled="" type="checkbox"> <p>3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</p></li><li><input disabled="" type="checkbox"> <p>3-20~3-31 Go公链实现项目</p></li><li><input disabled="" type="checkbox"> <p>确定研究主方向,第一篇论文初稿与老师讨论</p></li></ul><p>四月 主要准备算法与Go后端框架的学习</p><p>四五月中要好好准备六级, 这次要过.</p><p>五月~七月 算法、面试准备</p><p><strong>走go开发, 有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语70词 + 语法课P7完结</li><li><input checked="" disabled="" type="checkbox"> 一篇六级阅读</li><li><input checked="" disabled="" type="checkbox"> leetcode</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2><ul><li>突发不幸,自力更生</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发&lt;/th&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;&lt;font color=&#39;red&#39;&gt;科研&lt;/font&gt;&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;区块链公链项目&lt;/td&gt;
&lt;td&gt;论文一周两篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;金窝窝项目需求准备cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;本科毕业设计&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;科技部编程比赛&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑤&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;微信小程序前端uni-app&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑥&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mac使用typora快捷多颜色文字和公式设置</title>
    <link href="https://xwjahahahaha.github.io/2021/03/24/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%B0%8F%E6%8A%80%E5%B7%A7/mac%E4%BD%BF%E7%94%A8typroa%E5%BF%AB%E6%8D%B7%E5%A4%9A%E9%A2%9C%E8%89%B2%E6%96%87%E5%AD%97%E5%92%8C%E5%85%AC%E5%BC%8F%E8%AE%BE%E7%BD%AE/"/>
    <id>https://xwjahahahaha.github.io/2021/03/24/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%B0%8F%E6%8A%80%E5%B7%A7/mac%E4%BD%BF%E7%94%A8typroa%E5%BF%AB%E6%8D%B7%E5%A4%9A%E9%A2%9C%E8%89%B2%E6%96%87%E5%AD%97%E5%92%8C%E5%85%AC%E5%BC%8F%E8%AE%BE%E7%BD%AE/</id>
    <published>2021-03-24T06:36:46.000Z</published>
    <updated>2021-03-24T07:22:40.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac使用typora快捷多颜色文字-公式设置"><a href="#mac使用typora快捷多颜色文字-公式设置" class="headerlink" title="mac使用typora快捷多颜色文字/公式设置"></a>mac使用typora快捷多颜色文字/公式设置</h1><h2 id="需要的工具"><a href="#需要的工具" class="headerlink" title="需要的工具:"></a>需要的工具:</h2><ul><li>typora</li><li>Alfred</li></ul><p>typora搜索官网下载,Alfred可以<a href="https://xclient.info/s/alfred.html#versions" target="_blank" rel="noopener">点此</a>下载</p><a id="more"></a><h2 id="设置过程"><a href="#设置过程" class="headerlink" title="设置过程:"></a>设置过程:</h2><ol><li><p>在typora上设置好内联公式设置:(不使用多颜色公式的可以跳过)</p><p>打开偏好设置:勾选即可</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/ACLZvi.png" alt="ACLZvi"></p></li><li><p>打开Alfred偏好设置 :</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/uz9Qof.png" alt="uz9Qof"></p></li><li><p>点击左侧下面的加号,新建一个文字拓展分组:</p><p>  <img src="http://xwjpics.gumptlu.work/qinniu_uPic/c9eOVY.png" alt="c9eOVY"></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/i85r1e.png" alt="i85r1e"></p></li><li><p>点击右侧加号,在typora分组下新建一个文字拓展</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/waghXp.png" alt="waghXp"></p></li><li><p>黄颜色公式拓展示例:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/cdwTTW.png" alt="cdwTTW"></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/THBN1k.png" alt="THBN1k"></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/mURWhi.png" alt="mURWhi"></p></li><li><p>拓展内容</p><p>所有的公式颜色:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">\textcolor&#123;GreenYellow&#125;&#123;GreenYellow&#125; $$\textcolor&#123;Yellow&#125;&#123;Yellow&#125;$$\textcolor&#123;Goldenrod&#125;&#123;Goldenrod&#125; $$\textcolor&#123;Dandelion&#125;&#123;Dandelion&#125;$$\textcolor&#123;Apricot&#125;&#123;Apricot&#125; $$\textcolor&#123;Peach&#125;&#123;Peach&#125;$$\textcolor&#123;Melon&#125;&#123;Melon&#125; $$\textcolor&#123;YellowOrange&#125;&#123;YellowOrange&#125;$$\textcolor&#123;Orange&#125;&#123;Orange&#125; $$\textcolor&#123;BurntOrange&#125;&#123;BurntOrange&#125;$$\textcolor&#123;Bittersweet&#125;&#123;Bittersweet&#125;$$\textcolor&#123;RedOrange&#125;&#123;RedOrange&#125; $$\textcolor&#123;Mahogany&#125;&#123;Mahogany&#125;$$\textcolor&#123;Maroon&#125;&#123;Maroon&#125; $$\textcolor&#123;BrickRed&#125;&#123;BrickRed&#125;$$\textcolor&#123;Red&#125;&#123;Red&#125; $$\textcolor&#123;OrangeRed&#125;&#123;OrangeRed&#125;$$\textcolor&#123;RubineRed&#125;&#123;RubineRed&#125;$$\textcolor&#123;WildStrawberry&#125;&#123;WildStrawberry&#125;$$\textcolor&#123;Salmon&#125;&#123;Salmon&#125;$$\textcolor&#123;CarnationPink&#125;&#123;CarnationPink&#125;$$\textcolor&#123;Magenta&#125;&#123;Magenta&#125; $$\textcolor&#123;VioletRed&#125;&#123;VioletRed&#125;$$\textcolor&#123;Rhodamine&#125;&#123;Rhodamine&#125; $$\textcolor&#123;Mulberry&#125;&#123;Mulberry&#125;$$\textcolor&#123;RedViolet&#125;&#123;RedViolet&#125; $$\textcolor&#123;Fuchsia&#125;&#123;Fuchsia&#125;$$\textcolor&#123;Lavender&#125;&#123;Lavender&#125; $$\textcolor&#123;Thistle&#125;&#123;Thistle&#125;$$\textcolor&#123;Orchid&#125;&#123;Orchid&#125; $$\textcolor&#123;DarkOrchid&#125;&#123;DarkOrchid&#125;$$\textcolor&#123;Purple&#125;&#123;Purple&#125; $$\textcolor&#123;Plum&#125;&#123;Plum&#125;$$\textcolor&#123;Violet&#125;&#123;Violet&#125; $$\textcolor&#123;RoyalPurple&#125;&#123;RoyalPurple&#125;$$\textcolor&#123;BlueViolet&#125;&#123;BlueViolet&#125;$$\textcolor&#123;Periwinkle&#125;&#123;Periwinkle&#125;$$\textcolor&#123;CadetBlue&#125;&#123;CadetBlue&#125;$$\textcolor&#123;CornflowerBlue&#125;&#123;CornflowerBlue&#125;$$\textcolor&#123;MidnightBlue&#125;&#123;MidnightBlue&#125;$$\textcolor&#123;NavyBlue&#125;&#123;NavyBlue&#125; $$\textcolor&#123;RoyalBlue&#125;&#123;RoyalBlue&#125;$$\textcolor&#123;Blue&#125;&#123;Blue&#125; $$\textcolor&#123;Cerulean&#125;&#123;Cerulean&#125;$$\textcolor&#123;Cyan&#125;&#123;Cyan&#125; $$\textcolor&#123;ProcessBlue&#125;&#123;ProcessBlue&#125;$$\textcolor&#123;SkyBlue&#125;&#123;SkyBlue&#125; $$\textcolor&#123;Turquoise&#125;&#123;Turquoise&#125;$$\textcolor&#123;TealBlue&#125;&#123;TealBlue&#125; $$\textcolor&#123;Aquamarine&#125;&#123;Aquamarine&#125;$$\textcolor&#123;BlueGreen&#125;&#123;BlueGreen&#125; $$\textcolor&#123;Emerald&#125;&#123;Emerald&#125;$$\textcolor&#123;JungleGreen&#125;&#123;JungleGreen&#125;$$\textcolor&#123;SeaGreen&#125;&#123;SeaGreen&#125; $$\textcolor&#123;Green&#125;&#123;Green&#125;$$\textcolor&#123;ForestGreen&#125;&#123;ForestGreen&#125;$$\textcolor&#123;PineGreen&#125;&#123;PineGreen&#125; $$\textcolor&#123;LimeGreen&#125;&#123;LimeGreen&#125;$$\textcolor&#123;YellowGreen&#125;&#123;YellowGreen&#125;$$\textcolor&#123;SpringGreen&#125;&#123;SpringGreen&#125;$$\textcolor&#123;OliveGreen&#125;&#123;OliveGreen&#125;$$\textcolor&#123;RawSienna&#125;&#123;RawSienna&#125; $$\textcolor&#123;Sepia&#125;&#123;Sepia&#125;$$\textcolor&#123;Brown&#125;&#123;Brown&#125; $$\textcolor&#123;Tan&#125;&#123;Tan&#125;$$\textcolor&#123;Gray&#125;&#123;Gray&#125; $$\textcolor&#123;Black&#125;&#123;Black&#125;$</span></span><br></pre></td></tr></table></figure><p><strong>文字的拓展</strong></p><p><font color='red'>color属性值:   </font></p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>颜色名</em></td><td align="left">通过颜色名指定文本颜色（例如：“red”）</td></tr><tr><td align="left"><em>十六进制颜色值</em></td><td align="left">通过十六进制颜色值指定文本颜色（例如：“#ff0000”）</td></tr><tr><td align="left"><em>RGB颜色值</em></td><td align="left">通过RGB颜色值指定文本颜色（例如：“rgb(255,0,0)”）</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">'yellow'</span>&gt;</span>    <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/EXV8M6.png" alt="EXV8M6"></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mac使用typora快捷多颜色文字-公式设置&quot;&gt;&lt;a href=&quot;#mac使用typora快捷多颜色文字-公式设置&quot; class=&quot;headerlink&quot; title=&quot;mac使用typora快捷多颜色文字/公式设置&quot;&gt;&lt;/a&gt;mac使用typora快捷多颜色文字/公式设置&lt;/h1&gt;&lt;h2 id=&quot;需要的工具&quot;&gt;&lt;a href=&quot;#需要的工具&quot; class=&quot;headerlink&quot; title=&quot;需要的工具:&quot;&gt;&lt;/a&gt;需要的工具:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;typora&lt;/li&gt;
&lt;li&gt;Alfred&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;typora搜索官网下载,Alfred可以&lt;a href=&quot;https://xclient.info/s/alfred.html#versions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点此&lt;/a&gt;下载&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>334-递增的三元子序列</title>
    <link href="https://xwjahahahaha.github.io/2021/03/24/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/334-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://xwjahahahaha.github.io/2021/03/24/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/334-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2021-03-24T06:11:42.000Z</published>
    <updated>2021-03-24T06:13:12.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">334. 递增的三元子序列</a></h4><p>难度中等</p><p>给你一个整数数组 <code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p><p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足 <code>i &lt; j &lt; k</code> ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：任何 i &lt; j &lt; k 的三元组都满足题意</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,4,3,2,1]</span><br><span class="line">输出：false</span><br><span class="line">解释：不存在满足题意的三元组</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,1,5,0,4,6]</span><br><span class="line">输出：true</span><br><span class="line">解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] &#x3D;&#x3D; 0 &lt; nums[4] &#x3D;&#x3D; 4 &lt; nums[5] &#x3D;&#x3D; 6</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>题解:</p><p><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/solution/pou-xi-ben-zhi-yi-wen-bang-ni-kan-qing-t-3ye2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/increasing-triplet-subsequence/solution/pou-xi-ben-zhi-yi-wen-bang-ni-kan-qing-t-3ye2/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性复杂度O(N) 空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">const</span> INT_MAX = <span class="keyword">int</span>(^<span class="keyword">uint32</span>((<span class="number">0</span>)) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increasingTriplet</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    one, two := INT_MAX, INT_MAX</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; two &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[i] &lt;= two &amp;&amp; nums[i] &gt; one &#123;</span><br><span class="line">            two = nums[i]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            one = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;334-递增的三元子序列&quot;&gt;&lt;a href=&quot;#334-递增的三元子序列&quot; class=&quot;headerlink&quot; title=&quot;334. 递增的三元子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-triplet-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;334. 递增的三元子序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，判断这个数组中是否存在长度为 &lt;code&gt;3&lt;/code&gt; 的递增子序列。&lt;/p&gt;
&lt;p&gt;如果存在这样的三元组下标 &lt;code&gt;(i, j, k)&lt;/code&gt; 且满足 &lt;code&gt;i &amp;lt; j &amp;lt; k&lt;/code&gt; ，使得 &lt;code&gt;nums[i] &amp;lt; nums[j] &amp;lt; nums[k]&lt;/code&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>日记_0143</title>
    <link href="https://xwjahahahaha.github.io/2021/03/24/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0143/"/>
    <id>https://xwjahahahaha.github.io/2021/03/24/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0143/</id>
    <published>2021-03-24T00:01:50.000Z</published>
    <updated>2021-03-25T00:27:26.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发</th><th>项目</th><th><font color='red'>科研</font></th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>区块链公链项目</td><td>论文一周两篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>金窝窝项目需求准备cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td>本科毕业设计</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td>科技部编程比赛</td><td></td><td></td></tr><tr><td>⑤</td><td></td><td></td><td>微信小程序前端uni-app</td><td></td><td></td></tr><tr><td>⑥</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li>学弟的cosmos隐私保护项目</li><li>第一篇论文</li><li>科技部编程比赛</li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> <p>3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></p></li><li><input checked="" disabled="" type="checkbox"> <p>3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</p></li><li><input disabled="" type="checkbox"> <p>3-20~3-31 Go公链实现项目</p></li><li><input disabled="" type="checkbox"> <p>确定研究主方向,第一篇论文初稿与老师讨论</p></li></ul><p>四月 主要准备算法与Go后端框架的学习</p><p>四五月中要好好准备六级, 这次要过.</p><p>五月~七月 算法、面试准备</p><p><strong>走go开发, 有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> <p>英语</p></li><li><input checked="" disabled="" type="checkbox"> <p>leetcode一题解 + 一题</p></li><li><input checked="" disabled="" type="checkbox"> <p>机器学习复习 P8</p></li><li><input checked="" disabled="" type="checkbox"> <p>论文p11</p></li><li><input checked="" disabled="" type="checkbox"> <p>go小test</p></li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发&lt;/th&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;&lt;font color=&#39;red&#39;&gt;科研&lt;/font&gt;&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;区块链公链项目&lt;/td&gt;
&lt;td&gt;论文一周两篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;金窝窝项目需求准备cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;本科毕业设计&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;科技部编程比赛&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑤&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;微信小程序前端uni-app&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑥&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>5-最长回文子串</title>
    <link href="https://xwjahahahaha.github.io/2021/03/23/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://xwjahahahaha.github.io/2021/03/23/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2021-03-23T04:51:42.000Z</published>
    <updated>2021-03-24T00:45:43.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><p>难度中等</p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>此题目视频题解很详细,建议看视频</p><h3 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一:动态规划"></a>方法一:动态规划</h3><p>时间复杂度O(n^2^), 空间复杂度(n^2^)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    width, maxLen := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    maxI := <span class="number">0</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="comment">// dp(i, j) = dp(i+1, j-1) &amp;&amp; s[i] == s[j]</span></span><br><span class="line">    <span class="comment">// 注意: 此题的状态转移必须从短串向大串才能可以</span></span><br><span class="line">    <span class="comment">// 从二维数组来看,[i+1][j-1]必须先知道当前数组位置其下右位置的数才能填充此位置,所以需要按列遍历!</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;n; j++&#123;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=j; i++&#123;</span><br><span class="line">            <span class="keyword">if</span> i == j &#123;         <span class="comment">// 长度为1,单个字母直接赋值为true</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> i+<span class="number">1</span> == j &#123; <span class="comment">// 长度为2,两个字母,检查是否相同</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;             <span class="comment">// 长度&gt;2,状态转移</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比较长度</span></span><br><span class="line">            width = j-i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j] == <span class="number">1</span> &amp;&amp; width &gt; maxLen &#123;</span><br><span class="line">                maxI = i</span><br><span class="line">                maxLen = width</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[maxI:maxI+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-中心拓展方法"><a href="#方法二-中心拓展方法" class="headerlink" title="方法二:中心拓展方法"></a>方法二:中心拓展方法</h3><p>状态转移时,从子串不断向父串拓展,其中<strong>状态转移是连续的</strong>,<strong>一旦子串不满足就不用继续拓展父串了</strong></p><p><em>P</em>(<em>i</em>,<em>j</em>)←<em>P</em>(<em>i</em>+1,<em>j</em>−1)←<em>P</em>(<em>i</em>+2,<em>j</em>−2)←⋯←某一边界情况</p><p>我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案</p><p>而边界的情况就是<strong>单字母和双字母(相同)</strong>这两种情况,其实边界问题也就是对应着回文串的中心,这就是中心拓展方法</p><p>时间复杂度O(N^2^) 外层N,拓展最长拓展N次</p><p>空间复杂度O(1)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心拓展方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 遍历各个中心</span></span><br><span class="line">    start, maxLen := <span class="number">0</span>, <span class="number">0</span>      <span class="comment">//最大回文子串的起始位和长度</span></span><br><span class="line">    <span class="comment">// 分为两种</span></span><br><span class="line">    <span class="comment">//1.以单个字母为中心 2.以两个相同的字母为中心</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="comment">// 以单个字母为中心</span></span><br><span class="line">        left_1, right_1 := expandFunc(s, i, i)</span><br><span class="line">        <span class="comment">// 以两个字母位中心</span></span><br><span class="line">        left_2, right_2 := expandFunc(s, i, i+<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 比较两者长度的最大者</span></span><br><span class="line">        width_1 := right_1 - left_1 + <span class="number">1</span></span><br><span class="line">        width_2 := right_2 - left_2 + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> width_1 &gt; maxLen &#123;</span><br><span class="line">            maxLen = width_1</span><br><span class="line">            start = left_1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> width_2 &gt; maxLen &#123;</span><br><span class="line">            maxLen = width_2</span><br><span class="line">            start = left_2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start:start+maxLen]</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展函数</span></span><br><span class="line"><span class="comment">// 返回能拓展的最大长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandFunc</span><span class="params">(s <span class="keyword">string</span>, left, right <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果碰到边界或者两边字母不相同就退出</span></span><br><span class="line">    <span class="keyword">for</span> left &gt;=<span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &amp;&amp; s[left] == s[right] &#123;</span><br><span class="line">        left --</span><br><span class="line">        right ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left + <span class="number">1</span>, right <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;5-最长回文子串&quot;&gt;&lt;a href=&quot;#5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;5. 最长回文子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;5. 最长回文子串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0142</title>
    <link href="https://xwjahahahaha.github.io/2021/03/22/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0142/"/>
    <id>https://xwjahahahaha.github.io/2021/03/22/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-03/%E6%97%A5%E8%AE%B0-0142/</id>
    <published>2021-03-22T02:21:53.000Z</published>
    <updated>2021-03-25T01:29:20.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发</th><th>项目</th><th><font color='red'>科研</font></th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>区块链公链项目</td><td>论文一周两篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>金窝窝项目需求准备cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td>本科毕业设计</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td>科技部编程比赛</td><td></td><td></td></tr><tr><td>⑤</td><td></td><td></td><td>微信小程序前端uni-app</td><td></td><td></td></tr><tr><td>⑥</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li>学弟的cosmos隐私保护项目</li><li>第一篇论文</li><li>科技部编程比赛</li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> <p>3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></p></li><li><input checked="" disabled="" type="checkbox"> <p>3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</p></li><li><input disabled="" type="checkbox"> <p>3-20~3-31 Go公链实现项目</p></li><li><input disabled="" type="checkbox"> <p>确定研究主方向,第一篇论文初稿与老师讨论</p></li></ul><p>四月 主要准备算法与Go后端框架的学习</p><p>四五月中要好好准备六级, 这次要过.</p><p>五月~七月 算法、面试准备</p><p><strong>走go开发, 有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语70词 + 并列句 P7未完待续</li><li><input checked="" disabled="" type="checkbox"> leetcode1题一种解法</li><li><input checked="" disabled="" type="checkbox"> 论文</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发&lt;/th&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;&lt;font color=&#39;red&#39;&gt;科研&lt;/font&gt;&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;区块链公链项目&lt;/td&gt;
&lt;td&gt;论文一周两篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;金窝窝项目需求准备cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;本科毕业设计&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;科技部编程比赛&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑤&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;微信小程序前端uni-app&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑥&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>3-无重复字符的最长子串</title>
    <link href="https://xwjahahahaha.github.io/2021/03/21/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>https://xwjahahahaha.github.io/2021/03/21/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2021-03-21T03:08:13.000Z</published>
    <updated>2021-03-21T03:24:07.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h4><p>难度中等</p><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><a id="more"></a> <p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>方法: ==<strong>滑动窗口</strong>==</p><p><strong>==涉及子串考虑滑动窗口==</strong></p><p>我们不妨以示例一中的字符串  abcabcbb 为例，找出<strong>从每一个字符开始的，不包含重复字符的最长子串</strong>，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p><p>以  (a)bcabcbb 开始的最长字符串为  (abc)abcbb}(abc)abcbb；<br>以  a(b)cabcbb 开始的最长字符串为  a(bca)bcbb}a(bca)bcbb；<br>以  ab(c)abcbb 开始的最长字符串为  ab(cab)cbb}ab(cab)cbb；<br>以  abc(a)bcbb 开始的最长字符串为  abc(abc)bb}abc(abc)bb；<br>以  abca(b)cbb 开始的最长字符串为  abca(bc)bb}abca(bc)bb；<br>以  abcab(c)bb 开始的最长字符串为  abcab(cb)b}abcab(cb)b；<br>以  abcabc(b)b 开始的最长字符串为  abcabc(b)b}abcabc(b)b；<br>以  abcabcb(b) 开始的最长字符串为  abcabcb(b)}abcabcb(b)。</p><p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！</p><p><strong>==选择第k个位置作为起始的位置, 设当前情况下不重复最长连续字符子串的结束位置为rk, 那么当选择k+1作为下一个起始位置时,[k+1, rk]子串一定是不重复的!所以只需要继续向后延伸即可(移动rk)==</strong></p><p><strong>==滑动窗口:左少右多,中间满足,不断移动==</strong></p><p>步骤:</p><ul><li><p>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk；</p></li><li><p>在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举<strong>下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p></li><li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p></li></ul><p>使用数据结构判断<strong>是否有重复字符</strong> =&gt; 散列表 map</p><p>==<strong>题目看到重复/统计/次数 =&gt; 散列表 key为字母,value为次数</strong>== </p><blockquote><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>时间复杂度: O(N)</p><p>空间复杂度:O(M(所有字母集的个数))</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口 + 散列表判断重复</span></span><br><span class="line"><span class="comment">//start表示窗口起始位置</span></span><br><span class="line"><span class="comment">//over表示窗口结束位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// -1 代表字符串左侧边界(还未开始)</span></span><br><span class="line">    start, over := <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line">    <span class="comment">// width当前起始位start的极大不重复字符串长度</span></span><br><span class="line">    <span class="comment">// 全局最大长度</span></span><br><span class="line">    width, maxLen := <span class="number">0</span>, <span class="number">0</span>   </span><br><span class="line">    <span class="comment">// 判断重复</span></span><br><span class="line">    existMap := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;   </span><br><span class="line">    <span class="comment">//1. 逐个从左侧遍历字母(start)</span></span><br><span class="line">    <span class="keyword">for</span> start &lt; length &#123;</span><br><span class="line">        <span class="comment">//2. 右侧移动</span></span><br><span class="line">        <span class="comment">//3. 每次移动检查是否有重复,有则结束,无则继续</span></span><br><span class="line">        <span class="comment">// over小于边界并且新加入的字符出现次数为0</span></span><br><span class="line">        <span class="keyword">for</span> over + <span class="number">1</span> &lt; length &amp;&amp; existMap[s[over + <span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">            existMap[s[over + <span class="number">1</span>]] = <span class="number">1</span></span><br><span class="line">            over ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录当前极大长度, 比较最大长度</span></span><br><span class="line">        width = over - start + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> width &gt; maxLen &#123;</span><br><span class="line">            maxLen = width</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// start向右移动一个位置</span></span><br><span class="line">        start ++</span><br><span class="line">        <span class="comment">// start起始位置每移动一次就删除掉上个字母的存在记录</span></span><br><span class="line">        existMap[s[start<span class="number">-1</span>]] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;3-无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#3-无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;3. 无重复字符的最长子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3. 无重复字符的最长子串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
