<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识与头发不可兼得</title>
  
  <subtitle>文杰的博客</subtitle>
  <link href="https://xwjahahahaha.github.io/atom.xml" rel="self"/>
  
  <link href="https://xwjahahahaha.github.io/"/>
  <updated>2023-07-06T06:07:34.936Z</updated>
  <id>https://xwjahahahaha.github.io/</id>
  
  <author>
    <name>文杰@</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Prometheus官方文档学习纪要</title>
    <link href="https://xwjahahahaha.github.io/2023/07/06/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E4%BA%91%E5%8E%9F%E7%94%9F/Prometheus%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7/Prometheus%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9/"/>
    <id>https://xwjahahahaha.github.io/2023/07/06/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E4%BA%91%E5%8E%9F%E7%94%9F/Prometheus%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7/Prometheus%E5%9F%BA%E7%A1%80%E9%87%8D%E7%82%B9/</id>
    <published>2023-07-06T06:07:34.936Z</published>
    <updated>2023-07-06T06:07:34.936Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考自：</p><ul><li>官网文档<a href="https://prometheus.io/docs/introduction/first_steps/" target="_blank" rel="noopener">https://prometheus.io/docs/introduction/first_steps/</a></li><li><a href="https://prometheus.io/docs/guides/go-application/" target="_blank" rel="noopener">https://prometheus.io/docs/guides/go-application/</a></li><li><a href="https://blog.csdn.net/easylife206/article/details/102480764" target="_blank" rel="noopener">https://blog.csdn.net/easylife206/article/details/102480764</a></li><li><a href="https://blog.csdn.net/u014029783/article/details/80001251" target="_blank" rel="noopener">https://blog.csdn.net/u014029783/article/details/80001251</a></li></ul></blockquote><p>记录学习与使用prometheus的重点，建议先过一遍官方文档：</p><h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><p>Prometheus（Go语言开发）是由<code>SoundCloud</code>开发的开源监控告警系统和时序列数据库。从字面上理解，<strong>Prometheus由两个部分组成，一个是监控告警系统，另一个是自带的时序数据库（TSDB）</strong>。</p><a id="more"></a><p><img src="http://xwjpics.gumptlu.work/image-20220110193658682.png" alt="image-20220110193658682"></p><p>Prometheus server从各个<code>exporter</code>拉取数据，或者间接地通过网关<code>Pushgateway</code>拉取数据，它默认本地存储抓取的所有数据。采集到的数据有两个去向，一个是可视化，另一个是告警。<code>PromQL</code>和其他<code>API</code>可视化地展示收集的数据，通过<code>Alertmanager</code>提供告警能力。</p><p>对比其他监控方案：</p><ul><li><code>Ceilometer</code>：OpenStack中用来做计量计费功能的一个组件，后来又逐步发展增加了部分监控采集、告警的功能。</li><li><code>Nightingale</code>：（夜莺，简称n9e，Go语言开发）是滴滴开源的一个企业级监控解决方案。能达到企业级别的需求</li></ul><p><strong>Prometheus的优缺点：</strong></p><p>优点：</p><ul><li>简单轻量、自带时序服务器</li><li>处理能力强：指标都存储在Server本地数据库中，单个实例可以处理数百万的 Metrics</li><li>灵活的数据模型：引入了 Tag，给不同的接收端打好标识，属于多维数据模型，聚合统计更方便</li><li>强大的查询语句：<code>PromQL</code> 允许在同一个查询语句中，对多个 <code>Metrics</code>进行加法、连接等操作。</li><li>生态与社区：很好兼容k8s，社区有很多常见应用的<code>exporter</code>可以使用</li></ul><p>缺点：</p><ul><li><p>自带的时序服务器不支持<strong>降采样</strong></p><blockquote><p>即通过降低数据精度，来达到存储更长时间历史数据的目的。比如，12个5秒精度的点，通过计算均值，合并成1个1分钟精度的点。</p></blockquote></li><li><p>中心化<code>server</code>不支持拓展，容灾问题（社区目前已经有一些高可用的方案）</p></li></ul><p>启动：</p><ul><li>携带配置文件启动：<code>./prometheus --config.file prometheus.yml</code></li></ul><h1 id="二、配置文件"><a href="#二、配置文件" class="headerlink" title="二、配置文件"></a>二、配置文件</h1><h2 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1. 基本结构"></a>1. 基本结构</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">15s</span><span class="comment"># 获取目标数据的频率</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span><span class="comment"># 评估规则的频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">          <span class="comment"># - alertmanager:9093</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="comment"># - "first_rules.yml"</span></span><br><span class="line">  <span class="comment"># - "second_rules.yml"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">"prometheus"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">["localhost:9090"]</span></span><br></pre></td></tr></table></figure><ul><li><code>global</code> : 全局共享配置</li><li><code>alerting</code>：和告警相关的配置</li><li><code>rule_files</code>: Prometheus服务器加载的规则，并通过这些规则去评估（<code>evaluation_interval</code>）</li><li><code>scrape_configs</code> : 配置Prometheus需要抓取/监控的资源点（其自身也是http接口，所以自身已经加入到了评估）</li></ul><h2 id="2-其他配置"><a href="#2-其他配置" class="headerlink" title="2. 其他配置"></a>2. 其他配置</h2><h1 id="三、核心概念"><a href="#三、核心概念" class="headerlink" title="三、核心概念"></a>三、核心概念</h1><h2 id="1-数据模型Data-model"><a href="#1-数据模型Data-model" class="headerlink" title="1. 数据模型Data model"></a>1. 数据模型Data model</h2><ul><li><p>Prometheus 从根本上将所有数据存储为<strong>时间序列</strong>：属于同一指标和同一组标记维度的时间戳值流</p></li><li><p>每一个时间序列都被其<strong>指标名</strong>和<strong>标签</strong>（k/v键值对）标记</p></li><li><p><strong>指标名(metric name)</strong>：一般用于指定被测量系统的一般性特征（例如http服务器的被请求次数等）</p><ul><li>由数字、字母、<code>_</code>、<code>:</code>组成，其中<code>:</code>是留给用户规则定义的指标</li></ul></li><li><p><strong>标签(label)</strong>：所有同一个指标名的所有标签就定义了这个指标的各项数据维度，这些数据维度也用于查询时的筛选</p><ul><li>更改、添加、修改一个指标名的任意标签都会创建一个新的时间序列</li><li>由数字、字母、<code>_</code>、<code>:</code>组成，其中<code>_</code>是供内部使用的指标</li><li>空标签值得标签可以认为是不存在的标签</li></ul></li><li><p>一般的结构： <code>&lt;metric name&gt;{&lt;label name&gt;=&lt;label value&gt;, ...}</code>，例如<code>api_http_requests_total{method=&quot;POST&quot;, handler=&quot;/messages&quot;}</code></p></li></ul><h2 id="2-指标类型-Metric-types"><a href="#2-指标类型-Metric-types" class="headerlink" title="2. 指标类型 Metric types"></a>2. 指标类型 Metric types</h2><p>四类：</p><ul><li><p><code>Counter</code>: 计数器，不断累计数量单调递增，只有在重启/重置时变为0, 例如可以用一个计数器去统计当前请求的数量</p><ul><li>注意，不要使用计数器统计会递减的指标</li></ul></li><li><p><code>Gauge</code>：测量指标，表示可以任意增加或减少的一种度量，测量指标通常用于测量值，例如温度或当前内存使用情况</p></li><li><p><code>Histogram</code> : 直方图，直方图对观察结果进行采样（通常是请求持续时间或响应大小等），并将它们计入可配置的存储桶中。 它还提供所有观察值的总和。</p></li><li><p><code>Summary</code>: 概略图与直方图类似，摘要对观察结果进行采样（通常是请求持续时间和响应大小等）,虽然它还提供了观察总数和所有观察值的总和，但它计算了滑动时间窗口上的可配置分位数。</p></li></ul><p>Histogram和Summary使用的频率较少，两种都是基于采样的方式。另外有一些库对于这两个指标的使用和支持程度不同，有些仅仅实现了部分功能。</p><p>这两个类型对于某一些业务需求可能比较常见，比如查询单位时间内：总的响应时间低于300ms的占比，或者查询95%用户查询的门限值对应的响应时间是多少。 </p><p><strong>使用Histogram和Summary指标的时候同时会产生多组数据，_count代表了采样的总数，_sum则代表采样值的和。 _bucket则代表了落入此范围的数据。</strong></p><p>下面是使用historam来定义的一组指标，计算出了平均五分钟内的查询请求小于0.3s的请求占比总量的比例值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(rate(http_request_duration_seconds_bucket&#123;le="0.3"&#125;[5m])) by (job) /</span><br><span class="line">sum(rate(http_request_duration_seconds_count[5m])) by (job)</span><br></pre></td></tr></table></figure><h2 id="3-任务和实例-JOBS-AND-INSTANCES"><a href="#3-任务和实例-JOBS-AND-INSTANCES" class="headerlink" title="3. 任务和实例 JOBS AND INSTANCES"></a>3. 任务和实例 JOBS AND INSTANCES</h2><ul><li><p>在Prometheus中能够获取到指标数据的终端都称之为<strong>实例 instances</strong>，一般对应一个进程</p></li><li><p>具有相同目的的实例集合，例如为可扩展性或可靠性而复制的流程，称为<strong>作业 job</strong>。</p></li><li><p>例如，四个复制的实例总体是一个job：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job: api-server</span><br><span class="line">    instance 1: 1.2.3.4:5670</span><br><span class="line">    instance 2: 1.2.3.4:5671</span><br><span class="line">    instance 3: 5.6.7.8:5670</span><br><span class="line">    instance 4: 5.6.7.8:5671</span><br></pre></td></tr></table></figure></li><li><p>Prometheus抓取目标指标数据的时候会默认添加一些标签：</p><ul><li><code>job</code>：目标所属的作业名称</li><li><code>instance</code> : 被抓取的URL(<http>:<port>)</li></ul></li></ul><h1 id="四、编写客户端"><a href="#四、编写客户端" class="headerlink" title="四、编写客户端"></a>四、编写客户端</h1><p>目前prometheus提供的编写获取指标的客户端sdk库已经非常丰富，包含了很多语言：<a href="https://prometheus.io/docs/instrumenting/clientlibs" target="_blank" rel="noopener">10 languages already supported</a> ，虽然语言不同但是都需要遵循一套基本规则:</p><p><a href="https://prometheus.io/docs/instrumenting/writing_clientlibs/" target="_blank" rel="noopener">https://prometheus.io/docs/instrumenting/writing_clientlibs/</a></p><h1 id="五、编写自己的Export"><a href="#五、编写自己的Export" class="headerlink" title="五、编写自己的Export"></a>五、编写自己的Export</h1><p><a href="https://blog.csdn.net/easylife206/article/details/102480764" target="_blank" rel="noopener">https://blog.csdn.net/easylife206/article/details/102480764</a></p><h2 id="1-Exporter的作用"><a href="#1-Exporter的作用" class="headerlink" title="1. Exporter的作用"></a>1. Exporter的作用</h2><p>对于自己linux机器上的一些指标（大量服务、硬件、网络等），我们期望将其暴露给prometheus处理，但是其格式并不是prometheus期望的指标格式。</p><p>prometheus期望的一般指标格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HELP http_requests_total The total number of HTTP requests.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE http_requests_total counter</span></span><br><span class="line">http_requests_total&#123;method="post",code="200"&#125; 1027</span><br><span class="line">http_requests_total&#123;method="post",code="400"&#125;    3</span><br></pre></td></tr></table></figure><p>特定系统某些信息的格式:</p><ul><li>通过<code>/proc</code>目录下这样的文件系统暴露系统信息；</li></ul><ul><li>Redis 的监控信息需要通过 INFO 命令获取;</li><li>路由器等硬件的监控信息需要通过 <code>SNMP**</code> 协议获取;</li></ul><p>所以一般的流程为：</p><img src="http://xwjpics.gumptlu.work/image-20220124163016951.png" alt="image-20220124163016951" style="zoom:67%;" /><p>对于上面那些常见的情形, 社区早就写好了成熟的<code>Exporter</code>, 它们就是<code>node_exporter</code>, <code>redis_exporter</code> 和 <code>snmp_exporter</code>.</p><p><strong>整合监控：</strong>exporter可以用于将其他服务的监控接入到prometheus中，这样就可以通过prometheus进行统一的监控，其还提供了promQL这样强大的数据处理功能</p><h2 id="2-Export编写准则"><a href="#2-Export编写准则" class="headerlink" title="2. Export编写准则"></a>2. Export编写准则</h2><p><a href="https://prometheus.io/docs/instrumenting/writing_exporters/" target="_blank" rel="noopener">https://prometheus.io/docs/instrumenting/writing_exporters/</a> 详细的介绍了一些准则，总结如下：</p><ul><li><p>做到开箱即用(默认配置就可以直接开始用)</p><ul><li>高度可配置化：即可以配置只获取自己需要的指标而避免浪费性能</li></ul></li><li><p>推荐使用 <code>YAML</code>作为配置格式</p></li><li><p>指标使用下划线命名</p></li><li><p>为指标提供 <code>HELP String</code> (指标上的<code># HELP</code>注释, 事实上这点大部分 exporter 都没做好)</p></li><li><p>为 Exporter 本身的运行状态提供指标</p><ul><li>首先, 所有的 Prometheus 抓取目标都有一个 <code>up</code> 指标用来表明这个抓取目标能否被成功抓取. 因此, 假如 exporter 挂掉或无法正常工作了, 我们是可以从相应的 up 指标立刻知道并报警的.</li><li>但是up是通过指标接口返回200来粗粒度确定的，如果用一个export同时监听多个模块，其中某些模块指标无法返回这时候就需要降低粒度，每类指标都设置一个<code>up</code></li></ul></li><li><p>可以提供一个落地页</p><ul><li>什么是落地页：用过 node_exporter 的会知道, 当访问它的主页, 也就是根路径 / 时, 它会返回一个简单的页面, 这就是 exporter 的落地页(Landing Page).</li><li>落地页什么都可以放, 我认为最有价值的是放文档和帮助信息(或者放对应的链接). 而文档中最有价值的莫过于对于每个指标项的说明, 没有人理解的指标没有任何价值.</li></ul></li><li><p>Label的设置应该保证唯一性和可读性：</p><ul><li><p>唯一性：key应该是区分度很高的键，这样Value才很难重叠，避免修改Value创建新的时间序列而导致统计问题</p><blockquote><p>比方说某台 ECS 的名字变了, 那么在 Prometheus 内部就会重新记录一个时间序列, 造成额外的开销和部分 PromQL 计算的问题, 比如下面的示意图:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列A &#123;id="foo", name="旧名字"&#125; ..................</span><br><span class="line">序列B &#123;id="foo", name="新名字"&#125;                   .................</span><br></pre></td></tr></table></figure></blockquote></li><li><p>可读性： 唯一性的例外，当有些标签必须表达某些信息时不需要考虑其区分性，比如IP这样的标签，我们希望可以通过ID去查询到IP，不然只有ID没办法排查，所以要增加可读性降低唯一性.</p><p>但这样的问题有更好的解决方法：info指标(Info Metric). 单独暴露一个指标, 用 label 来记录实例的”额外信息”, 比如:</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ecs_info&#123;id="foo", name="DIO", os="linux", region="hangzhou", cpu="4", memory="16GB", ip="188.188.188.188"&#125; 1</span><br></pre></td></tr></table></figure></blockquote><p>这类指标的值习惯上永远为 1, 它们并记录实际的监控值, 仅仅记录 ecs 的一些额外信息. 而在使用的时候, 我们就可以通过 <code>PromQL</code> 的 <code>“Join”(group_left)</code>语法将这些信息加入到最后的查询结果中:</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这条 PromQL 将 aliyun_meta_rds_info 中记录的描述和状态从添加到了 aliyun_acs_rds_dashboard_MemoryUsage 中</span></span><br><span class="line">aliyun_acs_rds_dashboard_MemoryUsage </span><br><span class="line">    * on (instanceId) group_left(DBInstanceDescription,DBInstanceStatus) </span><br><span class="line">    aliyun_meta_rds_info</span><br></pre></td></tr></table></figure></blockquote><p><strong>一般的编写思路：Label记录唯一性的值 + Info指标记录详细可读性值</strong></p></li></ul></li></ul><h2 id="3-Export实例"><a href="#3-Export实例" class="headerlink" title="3. Export实例"></a>3. Export实例</h2><h3 id="1-一个简单的go-Export"><a href="#1-一个简单的go-Export" class="headerlink" title="1. 一个简单的go Export"></a>1. 一个简单的go Export</h3><p><a href="https://prometheus.io/docs/guides/go-application/" target="_blank" rel="noopener">https://prometheus.io/docs/guides/go-application/</a></p><p>prometheus提供了官方的go客户端开发包，我们可以直接使用，首先下载依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/prometheus/client_golang/prometheus</span><br><span class="line">go get github.com/prometheus/client_golang/prometheus/promauto</span><br><span class="line">go get github.com/prometheus/client_golang/prometheus/promhttp</span><br></pre></td></tr></table></figure><p>注册自定义的go指标的示例：</p><p>添加一个<code>myapp_processed_ops_total</code>计数器，用于计算迄今为止已处理的操作数。每 2 秒，计数器加一</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"github.com/prometheus/client_golang/prometheus/promhttp"</span></span><br><span class="line">        <span class="string">"github.com/prometheus/client_golang/prometheus"</span></span><br><span class="line">        <span class="string">"github.com/prometheus/client_golang/prometheus/promauto"</span></span><br><span class="line">        <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recordMetrics</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> &#123;</span><br><span class="line">                        <span class="comment">// Counter两秒递增一次</span></span><br><span class="line">                        opsProcessed.Inc()</span><br><span class="line">                        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">        <span class="comment">// 创建一个Counter类型的指标</span></span><br><span class="line">        opsProcessed = promauto.NewCounter(prometheus.CounterOpts&#123;</span><br><span class="line">                Name: <span class="string">"myapp_processed_opt_total"</span>,</span><br><span class="line">                Help: <span class="string">"The total number of processed events"</span>,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        recordMetrics()</span><br><span class="line">        http.Handle(<span class="string">"/metrics"</span>, promhttp.Handler())</span><br><span class="line">        http.ListenAndServe(<span class="string">":2112"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在另一个终端输入<code>curl http://localhost:2112/metrics</code>查看指标中查看我们自定义的指标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HELP myapp_processed_opt_total The total number of processed events</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE myapp_processed_opt_total counter</span></span><br><span class="line">myapp_processed_opt_total 21</span><br></pre></td></tr></table></figure><p>当然我们可以在本地的prometheus中配置这个数据抓取指标</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">localhost:2112</span></span><br></pre></td></tr></table></figure><h3 id="2-统计CPU温度与磁盘失败次数案例"><a href="#2-统计CPU温度与磁盘失败次数案例" class="headerlink" title="2. 统计CPU温度与磁盘失败次数案例"></a>2. 统计CPU温度与磁盘失败次数案例</h3><blockquote><p>源自：<a href="https://blog.csdn.net/u014029783/article/details/80001251" target="_blank" rel="noopener">https://blog.csdn.net/u014029783/article/details/80001251</a></p></blockquote><ul><li><p>创建指标</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// gauge类型</span></span><br><span class="line">cpuTemp = prometheus.NewGauge(prometheus.GaugeOpts&#123;</span><br><span class="line">Name: <span class="string">"cpu_temperature_celsius"</span>,</span><br><span class="line">Help: <span class="string">"Current temperature of the CPU"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// counter类型</span></span><br><span class="line">hdFailures = prometheus.NewCounterVec(</span><br><span class="line">prometheus.CounterOpts&#123;</span><br><span class="line">Name: <span class="string">"hd_errors_total"</span>,</span><br><span class="line">Help: <span class="string">"Number of hard-disk errors."</span>,</span><br><span class="line">&#125;, []<span class="keyword">string</span>&#123;<span class="string">"divice"</span>&#125;,</span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>注册指标</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 注册指标</span></span><br><span class="line"><span class="comment">// Metrics have to be registered to be exposed:</span></span><br><span class="line">prometheus.MustRegister(cpuTemp)</span><br><span class="line">prometheus.MustRegister(hdFailures)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>prometheus.MustRegister</code>是将数据直接注册到<code>Default Registry</code>，就像上面的运行的例子一样，这个<code>Default Registry</code>不需要额外的任何代码就可以将指标传递出去。注册后既可以在程序层面上去使用该指标了，这里我们使用之前定义的指标提供的API（<code>Set</code>和<code>With().Inc</code>）去改变指标的数据内容</p></li><li><p>设置指标值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 直接设置温度</span></span><br><span class="line">cpuTemp.Set(<span class="number">65.3</span>)</span><br><span class="line"><span class="comment">// 对应标签的数值+1,with返回的是一个counter实例</span></span><br><span class="line">hdFailures.With(prometheus.Labels&#123;<span class="string">"device"</span>:<span class="string">"/dev/sda"</span>&#125;).Inc()</span><br><span class="line"><span class="comment">// The Handler function provides a default handler to expose metrics</span></span><br><span class="line"><span class="comment">// via an HTTP server. "/metrics" is the usual endpoint for that.</span></span><br><span class="line">http.Handle(<span class="string">"/metrics"</span>, promhttp.Handler())</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是模拟的直接写入，实际情况应该是不断从一个系统中获取这对应的指标，这样监控才是有意义的。其中With函数是传递到之前定义的<code>label=”device”</code>上的值。</p></li></ul><h3 id="3-自定义一个采集器Collector实例"><a href="#3-自定义一个采集器Collector实例" class="headerlink" title="3.自定义一个采集器Collector实例"></a>3.自定义一个采集器Collector实例</h3><blockquote><p>源自：<a href="https://blog.csdn.net/u014029783/article/details/80001251" target="_blank" rel="noopener">https://blog.csdn.net/u014029783/article/details/80001251</a></p></blockquote><p>所有的指标类型都是实现了<code>Collector</code>采集器这个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Collector <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 用于传递所有可能的指标的定义描述符</span></span><br><span class="line">    <span class="comment">// 可以在程序运行期间添加新的描述，收集新的指标信息</span></span><br><span class="line">    <span class="comment">// 重复的描述符将被忽略。两个不同的Collector不要设置相同的描述符</span></span><br><span class="line">    Describe(<span class="keyword">chan</span>&lt;- *Desc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prometheus的注册器调用Collect执行实际的抓取参数的工作，</span></span><br><span class="line">    <span class="comment">// 并将收集的数据传递到Channel中返回</span></span><br><span class="line">    <span class="comment">// 收集的指标信息来自于Describe中传递，可以并发的执行抓取工作，但是必须要保证线程的安全。</span></span><br><span class="line">    Collect(<span class="keyword">chan</span>&lt;- Metric)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了接口的实现后，我们就可以写自己的实现了，先定义结构体，这是一个<strong>集群的指标采集器</strong>，每个集群都有自己的<code>Zone</code>,代表集群的名称。另外两个是保存的采集的指标。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ClusterManager <span class="keyword">struct</span> &#123;</span><br><span class="line">Zone <span class="keyword">string</span></span><br><span class="line">OOMCountDesc *prometheus.Desc<span class="comment">// OOM错误计数</span></span><br><span class="line">RAMUUsageDesc *prometheus.Desc<span class="comment">// RAM使用指标信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现我们的采集工作，此处为模拟：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClusterManager)</span> <span class="title">ReallyExpensiveAssessmentOfTheSystemState</span><span class="params">()</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">oomCountByHost <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, ramUsageByHost <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>,  //返回两个参数，<span class="keyword">map</span>键是集群中的主机名</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line"><span class="comment">// 模拟两个采集数据</span></span><br><span class="line">oomCountByHost = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">"foo.example.org"</span>: <span class="keyword">int</span>(rand.Int31n(<span class="number">1000</span>)),</span><br><span class="line"><span class="string">"bar.example.org"</span>: <span class="keyword">int</span>(rand.Int31n(<span class="number">1000</span>)),</span><br><span class="line">&#125;</span><br><span class="line">ramUsageByHost = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>&#123;</span><br><span class="line"><span class="string">"foo.example.org"</span>: rand.Float64() * <span class="number">100</span>,</span><br><span class="line"><span class="string">"bar.example.org"</span>: rand.Float64() * <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现自定义集群采集器的<code>Describe</code>接口方法，传递指标描述符到channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClusterManager)</span> <span class="title">Describe</span><span class="params">(ch <span class="keyword">chan</span> &lt;- *prometheus.Desc)</span></span> &#123;</span><br><span class="line">ch &lt;- c.OOMCountDesc<span class="comment">// 传入两个Describe</span></span><br><span class="line">ch &lt;- c.RAMUUsageDesc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再实现<code>Collect</code>数据采集方法：抓取数据然后转格式，最后返回到<code>chan</code>中, 并且传递的同时绑定原先的指标描述符。指标的类型（一个Counter和一个Guage）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClusterManager)</span> <span class="title">Collect</span><span class="params">(ch <span class="keyword">chan</span>&lt;- prometheus.Metric)</span></span> &#123;</span><br><span class="line">oomCountByHost, ramUsageByHost := c.ReallyExpensiveAssessmentOfTheSystemState()</span><br><span class="line"><span class="keyword">for</span> host, oomCount := <span class="keyword">range</span> oomCountByHost &#123;</span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(  <span class="comment">// MustNewConstMetric 返回一个固定值指标</span></span><br><span class="line">c.OOMCountDesc,</span><br><span class="line">prometheus.CounterValue,<span class="comment">// 表明指标的类型Counter</span></span><br><span class="line"><span class="keyword">float64</span>(oomCount),</span><br><span class="line">host,<span class="comment">// 设置主机名的host标签的值</span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> host, ramUsage := <span class="keyword">range</span> ramUsageByHost &#123;</span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(</span><br><span class="line">c.RAMUsageDesc,</span><br><span class="line">prometheus.GaugeValue,<span class="comment">// 表明指标的类型GauageValue</span></span><br><span class="line">ramUsage,</span><br><span class="line">host,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后实现创建这个自定义采集器类的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClusterManager</span><span class="params">(zone <span class="keyword">string</span>)</span> *<span class="title">ClusterManager</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ClusterManager&#123;</span><br><span class="line">Zone: zone,</span><br><span class="line">OOMCountDesc: prometheus.NewDesc(</span><br><span class="line"><span class="string">"clustermanager_oom_crashes_total"</span>,<span class="comment">// 指标的名称</span></span><br><span class="line"><span class="string">"Number of OOM crashes."</span>,<span class="comment">// Help</span></span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">"host"</span>&#125;,<span class="comment">// 变化的标签</span></span><br><span class="line">prometheus.Labels&#123;<span class="string">"zone"</span>: zone&#125;,<span class="comment">// 固定值的标签</span></span><br><span class="line">),</span><br><span class="line">RAMUsageDesc: prometheus.NewDesc(</span><br><span class="line"><span class="string">"clustermanager_ram_usage_bytes"</span>,<span class="comment">// 指标的名称</span></span><br><span class="line"><span class="string">"RAM usage as reported to the cluster manager."</span>,<span class="comment">// Help</span></span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">"host"</span>&#125;,<span class="comment">// 变化的标签</span></span><br><span class="line">prometheus.Labels&#123;<span class="string">"zone"</span>: zone&#125;,<span class="comment">// 固定值的标签</span></span><br><span class="line">),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册集群收集器类：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   managerDB := NewClusterManager(<span class="string">"db"</span>)</span><br><span class="line">   managerCA := NewClusterManager(<span class="string">"ca"</span>)</span><br><span class="line">   <span class="comment">// Since we are dealing with custom Collector implementations, it might</span></span><br><span class="line">   <span class="comment">// be a good idea to try it out with a pedantic registry.</span></span><br><span class="line">   <span class="comment">// 注册自定义的集群收集器</span></span><br><span class="line">   reg := prometheus.NewPedanticRegistry()</span><br><span class="line">   reg.MustRegister(managerDB)</span><br><span class="line">   reg.MustRegister(managerCA)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接执行上面函数，不会获取任何的参数，因为程序将自动推出，我们并未定义<code>http</code>接口去暴露数据出来，因此数据在执行的时候还需要定义一个<code>httphandler</code>来处理<code>http</code>请求。完整的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">managerDB := NewClusterManager(<span class="string">"db"</span>)</span><br><span class="line">managerCA := NewClusterManager(<span class="string">"ca"</span>)</span><br><span class="line"><span class="comment">// Since we are dealing with custom Collector implementations, it might</span></span><br><span class="line"><span class="comment">// be a good idea to try it out with a pedantic registry.</span></span><br><span class="line"><span class="comment">// 注册自定义的集群收集器</span></span><br><span class="line">reg := prometheus.NewPedanticRegistry()</span><br><span class="line">reg.MustRegister(managerDB)</span><br><span class="line">reg.MustRegister(managerCA)</span><br><span class="line"></span><br><span class="line">gatherers := prometheus.Gatherers&#123;</span><br><span class="line">prometheus.DefaultGatherer,</span><br><span class="line">reg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h := promhttp.HandlerFor(gatherers,</span><br><span class="line">promhttp.HandlerOpts&#123;</span><br><span class="line">ErrorHandling: promhttp.ContinueOnError,</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/metrics"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">h.ServeHTTP(w, r)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"Start server at :8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Errorf(<span class="string">"error occur when start server %v"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中<code>prometheus.Gatherers</code>用来定义一个采集数据的收集器集合，可以<code>merge</code>多个不同的采集数据到一个结果集合</strong>，<strong>这里我们传递了缺省的<code>DefaultGatherer</code>，所以他在输出中也会包含go运行时指标信息</strong>。同时包含reg是我们之前生成的一个注册对象，用来自定义采集数据。</p><p><code>promhttp.HandlerFor()</code>函数传递之前的<code>Gatherers</code>对象，并返回一个<code>httpHandler</code>对象，这个<code>httpHandler</code>对象可以调用其自身的<code>ServeHTTP</code>函数来接手<code>http</code>请求，并返回响应。其中<strong><code>promhttp.HandlerOpts</code>定义了采集过程中如果发生错误时，继续采集其他的数据。</strong></p><p>promhttp.HandlerFor()函数传递之前的Gatherers对象，并返回一个httpHandler对象，这个httpHandler对象可以调用其自身的ServHTTP函数来接手http请求，并返回响应。其中promhttp.HandlerOpts定义了采集过程中如果发生错误时，继续采集其他的数据。</p><p>启动后测试获取指标<code>curl localhost:8080/metrics</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HELP clustermanager_oom_crashes_total Number of OOM crashes.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE clustermanager_oom_crashes_total counter</span></span><br><span class="line">clustermanager_oom_crashes_total&#123;host="bar.example.org",zone="ca"&#125; 318</span><br><span class="line">clustermanager_oom_crashes_total&#123;host="bar.example.org",zone="db"&#125; 887</span><br><span class="line">clustermanager_oom_crashes_total&#123;host="foo.example.org",zone="ca"&#125; 81</span><br><span class="line">clustermanager_oom_crashes_total&#123;host="foo.example.org",zone="db"&#125; 81</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP clustermanager_ram_usage_bytes RAM usage as reported to the cluster manager.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE clustermanager_ram_usage_bytes gauge</span></span><br><span class="line">clustermanager_ram_usage_bytes&#123;host="bar.example.org",zone="ca"&#125; 15.651925473279125</span><br><span class="line">clustermanager_ram_usage_bytes&#123;host="bar.example.org",zone="db"&#125; 43.771418718698015</span><br><span class="line">clustermanager_ram_usage_bytes&#123;host="foo.example.org",zone="ca"&#125; 6.563701921747622</span><br><span class="line">clustermanager_ram_usage_bytes&#123;host="foo.example.org",zone="db"&#125; 66.45600532184905</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官网文档&lt;a href=&quot;https://prometheus.io/docs/introduction/first_steps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://prometheus.io/docs/introduction/first_steps/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://prometheus.io/docs/guides/go-application/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://prometheus.io/docs/guides/go-application/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/easylife206/article/details/102480764&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/easylife206/article/details/102480764&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/u014029783/article/details/80001251&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/u014029783/article/details/80001251&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录学习与使用prometheus的重点，建议先过一遍官方文档：&lt;/p&gt;
&lt;h1 id=&quot;一、基本介绍&quot;&gt;&lt;a href=&quot;#一、基本介绍&quot; class=&quot;headerlink&quot; title=&quot;一、基本介绍&quot;&gt;&lt;/a&gt;一、基本介绍&lt;/h1&gt;&lt;p&gt;Prometheus（Go语言开发）是由&lt;code&gt;SoundCloud&lt;/code&gt;开发的开源监控告警系统和时序列数据库。从字面上理解，&lt;strong&gt;Prometheus由两个部分组成，一个是监控告警系统，另一个是自带的时序数据库（TSDB）&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="Prometheus" scheme="https://xwjahahahaha.github.io/categories/technical/Prometheus/"/>
    
    
    <category term="hide" scheme="https://xwjahahahaha.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>mysql死锁故障排查案例</title>
    <link href="https://xwjahahahaha.github.io/2023/04/21/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%E6%AD%BB%E9%94%81%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%A1%88%E4%BE%8B/"/>
    <id>https://xwjahahahaha.github.io/2023/04/21/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%E6%AD%BB%E9%94%81%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%A1%88%E4%BE%8B/</id>
    <published>2023-04-21T11:23:35.000Z</published>
    <updated>2023-07-06T06:07:34.950Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><blockquote><p>参考：</p><ul><li><a href="https://www.cnblogs.com/hunternet/p/11383360.html" target="_blank" rel="noopener">https://www.cnblogs.com/hunternet/p/11383360.html</a></li></ul></blockquote><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>并发的操作了两次update操作，导致了死锁，具体的log如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">2023-04-20 18:40:42 0x7f8d889d8700</span><br><span class="line"></span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line"></span><br><span class="line">TRANSACTION 17303071376, ACTIVE 0 sec fetching rows</span><br><span class="line"></span><br><span class="line">mysql tables in use 3, locked 3</span><br><span class="line"></span><br><span class="line">LOCK WAIT 7 lock struct(s), heap size 1136, 3 row lock(s)</span><br><span class="line"></span><br><span class="line">MySQL thread id 13507501, OS thread handle 140245884405504, query id 3006870350 10.20.59.200 eit7056897361_w updating</span><br><span class="line"></span><br><span class="line">/* psm=it.saa.eita_consumer, ip=fdbd:dc02:ff:500:9cb0:e1ad:776d:349e, ip=- / UPDATE / psm=it.saa.eita_consumer, logid=c1988e1f-ec5d-4fc5-8c34-e52a018d3e10, ip=fdbd:dc02:ff:500:9cb0:e1ad:776d:349e, pid=217 */  email_group_department_employee_ref SET status=0,update_time='2023-04-20 18:40:42.808' WHERE email_group_id = 45019009923 AND employee_id = 545697 AND employee_role = 'MEMBER'</span><br><span class="line"></span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"></span><br><span class="line">RECORD LOCKS space id 890 page no 2136 n bits 952 index idx_email_group_id of table eita.email_group_department_employee_ref trx id 17303071376 lock_mode X locks rec but not gap waiting</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line"></span><br><span class="line">TRANSACTION 17303071371, ACTIVE 0 sec fetching rows, thread declared inside InnoDB 1006</span><br><span class="line"></span><br><span class="line">mysql tables in use 3, locked 3</span><br><span class="line"></span><br><span class="line">8 lock struct(s), heap size 1136, 7 row lock(s), undo log entries 1</span><br><span class="line"></span><br><span class="line">MySQL thread id 13507502, OS thread handle 140245859141376, query id 3006870341 10.20.59.152 eit7056897361_w updating</span><br><span class="line"></span><br><span class="line">/* psm=it.saa.eita_consumer, ip=fdbd:dc02:1a:204::22, ip=- / UPDATE / psm=it.saa.eita_consumer, logid=c74a7158-692c-4eea-8f70-ae9e92994004, ip=fdbd:dc02:1a:204::22, pid=236 */  email_group_department_employee_ref SET status=0,update_time='2023-04-20 18:40:42.803' WHERE email_group_id = 45019009923 AND employee_id = 327271 AND employee_role = 'MEMBER'</span><br><span class="line"></span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line"></span><br><span class="line">RECORD LOCKS space id 890 page no 2136 n bits 952 index idx_email_group_id of table eita.email_group_department_employee_ref trx id 17303071371 lock_mode X locks rec but not gap</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"></span><br><span class="line">RECORD LOCKS space id 890 page no 2516 n bits 240 index PRIMARY of table eita.email_group_department_employee_ref trx id 17303071371 lock_mode X locks rec but not gap waiting</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br><span class="line"></span><br><span class="line">------------</span><br></pre></td></tr></table></figure><p>错误如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure><p>其中：<code>email_group_id</code>和<code>employee_id</code>都构建了索引</p><h1 id="2-知识点"><a href="#2-知识点" class="headerlink" title="2. 知识点"></a>2. 知识点</h1><ol><li>mysql innodb引擎支持事务，更新时采用的是行级锁。</li><li>行级锁必须建立在索引的基础</li><li>行级锁并不是直接锁记录，而是锁索引</li><li><font color='#e54d42'><strong>如果一条SQL语句用到了主键索引，mysql会锁住主键索引，然后在其他索引上加锁；如果一条语句操作了非主键索引，mysql会先锁住非主键索引，再锁定主键索引。</strong></font></li><li>对于没有用索引的操作会采用表级锁</li></ol><h1 id="3-分析与解决方案"><a href="#3-分析与解决方案" class="headerlink" title="3. 分析与解决方案"></a>3. 分析与解决方案</h1><h2 id="1-阻塞分析"><a href="#1-阻塞分析" class="headerlink" title="1. 阻塞分析"></a>1. 阻塞分析</h2><p>首先明显可以从日志中看出是两个事务在同时执行：</p><ul><li>事务1：17303071376 </li><li>事务2：17303071371</li></ul><p>首先下面的log表示了事务1在等待<code>idx_email_group_id</code>索引的锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"></span><br><span class="line">RECORD LOCKS space id 890 page no 2136 n bits 952 index idx_email_group_id of table eita.email_group_department_employee_ref trx id 17303071376 lock_mode X locks rec but not gap waiting</span><br></pre></td></tr></table></figure><p><code>lock_mode X locks rec but not gap waiting</code> =&gt; 这个是一个X排他锁并且是记录锁而不是一个临键锁（或者说只是在等待记录而不等待间隙）</p><p>而事务2的log页表示了他持有了上面事务1等待的同一个记录的锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line"></span><br><span class="line">RECORD LOCKS space id 890 page no 2136 n bits 952 index idx_email_group_id of table eita.email_group_department_employee_ref trx id 17303071371 lock_mode X locks rec but not gap</span><br></pre></td></tr></table></figure><p>这就表明事务1在等待事务2释放<code>space id 890 page no 2136 n bits 952 index idx_email_group_id</code>的锁</p><p>同时，事务2的log：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"></span><br><span class="line">RECORD LOCKS space id 890 page no 2516 n bits 240 index PRIMARY of table eita.email_group_department_employee_ref trx id 17303071371 lock_mode X locks rec but not gap waiting</span><br></pre></td></tr></table></figure><p>表明事务2在获取到非主键锁之后，需要获取主键锁，然而一直等待<code>space id 890 page no 2516 n bits 240 index PRIMARY</code>的主键锁而导致了阻塞</p><blockquote><p>在这里不是事务1锁住了主键，因为业务场景下这两条SQL查询不会查到相同主键的行记录，所以可能是被另一个未知的事务并发操作时（用到了主键索引）获取到了事务2待更新的这个主键锁，导致其阻塞</p></blockquote><blockquote><p>space id 890 page no 2516 n bits 240 index 的具体含义：</p><p>space id 890 page no 2516是指MySQL存储引擎将表格存储在磁盘上，每个表格是一个空间（space id），每个空间中有多个页（page no），每个页面中有多个字段（n bits）</p></blockquote><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><p>建立一个联合索引，对于此案例中将<code>email_group_id</code>和<code>employee_id</code>两个属性构建一个联合索引，这样事务1和事务2在遇到相同的<code>email_group_id</code>但是<code>employee_id</code>不同的情况的时候因为构建了联合索引索引不同所以不会导致等待锁住同一个索引的情况</p><h1 id="4-拓展"><a href="#4-拓展" class="headerlink" title="4. 拓展"></a>4. 拓展</h1><p>一个案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_item`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`item_id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">TINYINT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_1`</span> (<span class="string">`user_id`</span>,<span class="string">`item_id`</span>,<span class="string">`status`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> user_item <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">1</span> <span class="keyword">where</span> user_id=? <span class="keyword">and</span> item_id=?</span><br></pre></td></tr></table></figure><p>上面操作的流程：</p><ol><li>由于用到了非主键索引，首先需要获取idx_1上的行级锁</li><li>紧接着根据主键进行更新，所以需要获取主键上的行级锁</li><li>更新完毕后，提交，并释放所有锁</li></ol><p>如果在步骤1和2之间突然插入一条语句(或者并行运行了一个事务)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> user_item .....where <span class="keyword">id</span>=? <span class="keyword">and</span> user_id=?</span><br></pre></td></tr></table></figure><p>这条语句会先锁住主键索引，然后锁住idx_1</p><p>蛋疼的情况出现了，第一条语句获取了idx_1上的锁，等待主键索引上的锁；</p><p>第二条语句获取了主键上的锁，等待idx_1上的锁，这样就出现了死锁。</p><p>解决方案：</p><ol><li><p>先获取需要更新的记录的主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> user_item <span class="keyword">where</span> user_id=? <span class="keyword">and</span> item_id=?</span><br></pre></td></tr></table></figure></li><li><p>再通过这些主键id合并两个update</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> ... <span class="keyword">where</span> <span class="keyword">id</span>=? <span class="keyword">and</span> user_id=? <span class="keyword">and</span> item_id=?</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>日记-0439</title>
    <link href="https://xwjahahahaha.github.io/2023/03/09/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2023/2023-03/%E6%97%A5%E8%AE%B0-0439/"/>
    <id>https://xwjahahahaha.github.io/2023/03/09/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2023/2023-03/%E6%97%A5%E8%AE%B0-0439/</id>
    <published>2023-03-09T01:55:13.000Z</published>
    <updated>2023-07-06T06:07:35.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><a id="more"></a><p>2023年</p><ul><li><input disabled="" type="checkbox"> 准备的下一个方向<ul><li><input disabled="" type="checkbox"> 操作系统</li><li><input disabled="" type="checkbox"> 虚拟化</li></ul></li></ul><h2 id="这段时间的待完成任务："><a href="#这段时间的待完成任务：" class="headerlink" title="这段时间的待完成任务："></a>这段时间的待完成任务：</h2><ul><li><input disabled="" type="checkbox"> <p>大论文</p><ul><li><input disabled="" type="checkbox"> 格式修改<ul><li><input disabled="" type="checkbox"> 参考文献</li><li><input disabled="" type="checkbox"> 图表格式等</li><li><input disabled="" type="checkbox"> 补充文字到三万字</li></ul></li></ul></li><li><input disabled="" type="checkbox"> <p>看书/论文</p><ul><li><input disabled="" type="checkbox"> <p>《深入理解计算机系统》CSAPP</p></li><li><input disabled="" type="checkbox"> <p>c++ </p><ul><li><input disabled="" type="checkbox"> 《C++ Primer》</li></ul></li><li><input disabled="" type="checkbox"> <p>linux内核</p><ul><li><input disabled="" type="checkbox"> 《深入理解linux内核》</li></ul></li><li><input disabled="" type="checkbox"> <p>虚拟化</p><ul><li><input disabled="" type="checkbox"> 《深度探索linux系统虚拟化》原理与实现</li></ul></li><li><input disabled="" type="checkbox"> <p>论文</p><ul><li><input disabled="" type="checkbox"> BPF<ul><li><input disabled="" type="checkbox"> <a href="https://www.usenix.org/conference/nsdi21/presentation/ghigoff" target="_blank" rel="noopener">BMC</a></li></ul></li></ul></li></ul></li><li><input disabled="" type="checkbox"> <p>项目</p><ul><li><input disabled="" type="checkbox"> myMiniDB：C++实现一个简易数据库</li><li><input disabled="" type="checkbox"> runC项目<ul><li><input disabled="" type="checkbox"> 看之前的文档和源码过一遍</li><li><input disabled="" type="checkbox"> 重构源代码、加入seccomp功能 </li><li><input disabled="" type="checkbox"> runC源码项目阅读</li><li><input disabled="" type="checkbox"> OCI 镜像格式标准文件包 bundles</li></ul></li><li><input disabled="" type="checkbox"> 修整之前实习的项目<ul><li><input disabled="" type="checkbox"> 基于eBPF的云原生profile观测系统项目</li></ul></li><li><input disabled="" type="checkbox"> 操作系统45讲-实现一个自己的OS</li></ul></li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 大论文<ul><li><input disabled="" type="checkbox"> 参考文献</li></ul></li><li><input disabled="" type="checkbox"> 《深入理解linux内核》<ul><li><input disabled="" type="checkbox"> 第三章 进程</li></ul></li><li><input disabled="" type="checkbox"> C++实现一个简易数据库<ul><li><input disabled="" type="checkbox"> 3-实现insert和select</li></ul></li><li><input disabled="" type="checkbox"> 操作系统45讲-实现一个自己的OS <ul><li><input disabled="" type="checkbox"> 09丨瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</li></ul></li><li><input disabled="" type="checkbox"> 《C++ Primer》<ul><li><input disabled="" type="checkbox"> 第八章 IO库</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>vue和js经验总结</title>
    <link href="https://xwjahahahaha.github.io/2023/03/01/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%89%8D%E7%AB%AF/vue%E5%92%8Cjs%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://xwjahahahaha.github.io/2023/03/01/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%89%8D%E7%AB%AF/vue%E5%92%8Cjs%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-01T02:52:28.000Z</published>
    <updated>2023-07-06T06:07:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h1 id="vue和js经验总结"><a href="#vue和js经验总结" class="headerlink" title="vue和js经验总结"></a>vue和js经验总结</h1><h2 id="1-slot-scope-”text-record”-参数顺序"><a href="#1-slot-scope-”text-record”-参数顺序" class="headerlink" title="1. slot-scope=”text, record” 参数顺序"></a>1. slot-scope=”text, record” 参数顺序</h2><p>使用table的<code>slot-scope=&quot;text, record&quot;</code>参数的时候，如果想要在slot的渲染中的项中使用record，必须要写text和record，只写一个<code>slot-scope=&quot;record&quot;</code>则其实默认是第一个参数即（<code>record</code>就是<code>text</code>）</p><p>同理<code>slot-scope=&quot;text, record, index&quot;</code>，一定要按顺序写且不能省略</p><h2 id="2-如何在一些默认参数的响应事件中加入自己的参数"><a href="#2-如何在一些默认参数的响应事件中加入自己的参数" class="headerlink" title="2. 如何在一些默认参数的响应事件中加入自己的参数"></a>2. 如何在一些默认参数的响应事件中加入自己的参数</h2><p>在使用Ant + Vue框架的时候，input输入框自带一个响应事件：<code>onChange</code>，其描述如下：</p><table><thead><tr><th align="left">事件名称</th><th align="left">说明</th><th align="left">回调参数</th></tr></thead><tbody><tr><td align="left">change</td><td align="left">输入框内容变化时的回调</td><td align="left">function(e)</td></tr></tbody></table><p>默认使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a-input @change&#x3D;&quot;change&quot; &#x2F;&gt;</span><br><span class="line">...</span><br><span class="line">change(e) &#123;</span><br><span class="line">console.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果想在输入框改变的同时传入一些额外的变量则需要像如下这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a-input @change&#x3D;&quot;change(record, index, $event)&quot; &#x2F;&gt;</span><br><span class="line">...</span><br><span class="line">change(record, index, e) &#123;</span><br><span class="line">console.log(record, index, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-父组件向子组件传递Number类型的值时的静态传递"><a href="#3-父组件向子组件传递Number类型的值时的静态传递" class="headerlink" title="3. 父组件向子组件传递Number类型的值时的静态传递"></a>3. 父组件向子组件传递Number类型的值时的静态传递</h2><blockquote><ul><li><a href="https://www.cnblogs.com/saoge/p/15179659.html" target="_blank" rel="noopener">https://www.cnblogs.com/saoge/p/15179659.html</a></li></ul></blockquote><p>例如父组件与子组件协商好了一个类型：（在子组件A中）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    direction: &#123;</span><br><span class="line">        type: Number</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>那么父组件如下直接写数字其实传递的是String：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;A direction&#x3D;1&gt;&lt;&#x2F;A&gt;</span><br></pre></td></tr></table></figure><p>会报错：</p><p><code>Invalid prop: type check failed for prop &quot;direction&quot;. Expected Number with value 1, got String with value &quot;1&quot;.</code></p><p>要改为动态类型的值并用v-bind绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;A :direction&#x3D;inDirection&gt;&lt;&#x2F;A&gt;</span><br><span class="line">...</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        inDirection: -1,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="4-Vue数据更新视图不更新的几种解决方案"><a href="#4-Vue数据更新视图不更新的几种解决方案" class="headerlink" title="4. Vue数据更新视图不更新的几种解决方案"></a>4. Vue数据更新视图不更新的几种解决方案</h2><blockquote><ul><li><a href="https://blog.csdn.net/bigbear00007/article/details/102594645" target="_blank" rel="noopener">https://blog.csdn.net/bigbear00007/article/details/102594645</a></li><li><a href="https://www.cnblogs.com/ypSharing/p/updataHandler.html" target="_blank" rel="noopener">https://www.cnblogs.com/ypSharing/p/updataHandler.html</a></li></ul></blockquote><h3 id="情况分类"><a href="#情况分类" class="headerlink" title="情况分类"></a>情况分类</h3><p>vue页面视图不更新的情况如下：</p><ul><li><a href="https://www.cnblogs.com/ypSharing/p/updataHandler.html#1vue-无法检测实例被创建时不存在于-data-中的-属性" target="_blank" rel="noopener">Vue 无法检测实例被创建时不存在于 data 中的 属性</a></li><li><a href="https://www.cnblogs.com/ypSharing/p/updataHandler.html#2-vue-无法检测对象属性的添加或移除" target="_blank" rel="noopener"> Vue 无法检测‘对象属性’的添加或移除</a></li><li><a href="https://www.cnblogs.com/ypSharing/p/updataHandler.html#3vue-不能检测利用数组索引直接修改一个数组项" target="_blank" rel="noopener">Vue 不能检测利用数组索引直接修改一个数组项</a></li><li><a href="https://www.cnblogs.com/ypSharing/p/updataHandler.html#4vue-不能监测直接修改数组长度的变化" target="_blank" rel="noopener">Vue 不能监测直接修改数组长度的变化</a></li><li><a href="https://www.cnblogs.com/ypSharing/p/updataHandler.html#5在异步更新执行之前操作-dom-数据不会变化" target="_blank" rel="noopener">在异步更新执行之前操作 DOM 数据不会变化</a></li><li><a href="https://www.cnblogs.com/ypSharing/p/updataHandler.html#6循环嵌套层级太深视图不更新" target="_blank" rel="noopener">循环嵌套层级太深，视图不更新？</a></li><li><a href="https://www.cnblogs.com/ypSharing/p/updataHandler.html#7路由参数变化时页面不更新数据不更新" target="_blank" rel="noopener">路由参数变化时，页面不更新（数据不更新）</a></li><li><a href="https://www.cnblogs.com/ypSharing/p/updataHandler.html#8使用keep-alive之后数据无法实时更新问题" target="_blank" rel="noopener">使用keep-alive之后数据无法实时更新问题</a></li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="1-Vue-set"><a href="#1-Vue-set" class="headerlink" title="1. Vue.set"></a>1. Vue.set</h4><p>使用 <code>Vue.set(object, key, value)</code>方法将响应属性添加到嵌套的对象上</p><p><code>Vue.set(vm.someObject, &#39;b&#39;, 2)</code>或者<code>this.$set(this.someObject,&#39;b&#39;,2)</code>(这也是全局 Vue.set 方法的别名)</p><h4 id="2-计算属性"><a href="#2-计算属性" class="headerlink" title="2. 计算属性"></a>2. 计算属性</h4><p>还可以使用计算属性解决。例如场景是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a-step v-<span class="keyword">for</span>=<span class="string">"item in steps"</span> :key=<span class="string">"item.title"</span> :title=<span class="string">"item.title"</span> /&gt;</span><br><span class="line">...</span><br><span class="line">data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          steps: [&#123; <span class="attr">title</span>: <span class="keyword">this</span>.$t(<span class="string">'sgroup.addnew.basicinfo'</span>) &#125;, &#123; <span class="attr">title</span>: <span class="keyword">this</span>.$t(<span class="string">'sgroup.addnew.relateVms'</span>) &#125;, &#123; <span class="attr">title</span>: <span class="keyword">this</span>.$t(<span class="string">'sgroup.addnew.rules'</span>) &#125;],</span><br><span class="line">      &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>vue中使用国际化，动态返回的steps数组中的对象值要根据中英文选项动态变化，但是页面无法感知title的变化</p><p>解决：</p><p>删掉data中的steps，写一个同名的计算属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    steps() &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            &#123; <span class="attr">title</span>: <span class="keyword">this</span>.$t(<span class="string">'sgroup.addnew.basicinfo'</span>) &#125;,</span><br><span class="line">            &#123; <span class="attr">title</span>: <span class="keyword">this</span>.$t(<span class="string">'sgroup.addnew.relateVms'</span>) &#125;,</span><br><span class="line">            &#123; <span class="attr">title</span>: <span class="keyword">this</span>.$t(<span class="string">'sgroup.addnew.rules'</span>) &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="5-async-await关键字执行异步的时机"><a href="#5-async-await关键字执行异步的时机" class="headerlink" title="5. async/await关键字执行异步的时机"></a>5. async/await关键字执行异步的时机</h2><ul><li><a href="https://blog.csdn.net/qq_30385099/article/details/125805192" target="_blank" rel="noopener">https://blog.csdn.net/qq_30385099/article/details/125805192</a></li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><blockquote><p>相关网站：</p><ul><li>Promise的基本概念：<a href="https://zh.javascript.info/promise-basics" target="_blank" rel="noopener">https://zh.javascript.info/promise-basics</a></li></ul></blockquote><p>首先一定需要明白的是，promise 的处理程序 <code>.then</code>、<code>.catch</code> 和 <code>.finally</code> 都是异步的。即便一个 promise 立即被 resolve，<code>.then</code>、<code>.catch</code> 和 <code>.finally</code> <strong>下面</strong> 的代码也会在这些处理程序之前被执行。</p><p>所以下面的代码会先执行（即使立即resolve）。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>输出的结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1， 2， 3</span><br></pre></td></tr></table></figure><p><strong>调用resolve()会触发异步操作，传入的then()方法的函数会被添加到任务队列并异步执行</strong>，具体内部实现的队列可以参考：<a href="https://zh.javascript.info/microtask-queue#wei-ren-wu-dui-lie-microtaskqueue" target="_blank" rel="noopener">微任务队列</a></p><p>简单地说，当一个 promise 准备就绪时，它的 <code>.then/catch/finally</code> 处理程序就会被放入队列中：但是它们<strong>不会立即被执行</strong>。当 JavaScript 引擎执行完当前的代码，它会从队列中获取任务并执行它。</p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>在函数前面的 “async” 这个单词表达了一个简单的事情：即这个函数总是返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。</p><p>关键字 <code>await</code> 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。</p><p>一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"done!"</span>), <span class="number">1000</span>)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> promise; <span class="comment">// 等待，直到 promise resolve (*)</span></span><br><span class="line"></span><br><span class="line">  alert(result); <span class="comment">// "done!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>这个函数在执行的时候，“暂停”在了 <code>(*)</code> 那一行，并在 promise settle 时，拿到 <code>result</code> 作为结果继续往下执行。所以上面这段代码在一秒后显示 “done!”。</p><h3 id="为什么总是无法同步？"><a href="#为什么总是无法同步？" class="headerlink" title="为什么总是无法同步？"></a>为什么总是无法同步？</h3><p>总是在使用<code>async/await</code>配合使用的时候没有成功同步，关键在于两点：</p><h4 id="1-await要等待一个promise才有用"><a href="#1-await要等待一个promise才有用" class="headerlink" title="1. await要等待一个promise才有用"></a>1. await要等待一个promise才有用</h4><p>当你在await一个函数的结果时，那个函数必须要返回的是一个promise，这样await才有用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;<span class="comment">// return 不写那么就是 1111 -&gt; 3333 -&gt; 2222</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1111'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'done'</span>), <span class="number">1000</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2222'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> f1()<span class="comment">// 等到一个promise，如果不写await，那么顺序就是 1111 -&gt; 3333 -&gt; 2222</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3333'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2()<span class="comment">// 1111 -&gt; 2222 -&gt; 3333</span></span><br></pre></td></tr></table></figure><blockquote><p>为什么先输出1111再输出3333？</p><ul><li><a href="https://towardsdev.com/promises-in-javascript-285f523c3e8d" target="_blank" rel="noopener">Promise对象的构造函数中的函数（executor）是同步执行的，也就是说，它会在Promise对象创建后立即运行</a><a href="https://towardsdev.com/promises-in-javascript-285f523c3e8d" target="_blank" rel="noopener">4</a>。但是，executor中可以包含异步操作，比如网络请求或者定时器，所以如果有这些异步操作，如果不使用await就会先执行promise后面的代码。</li></ul></blockquote><h4 id="2-await的同步作用只保留在当前函数内部，async让其异步上抛了"><a href="#2-await的同步作用只保留在当前函数内部，async让其异步上抛了" class="headerlink" title="2. await的同步作用只保留在当前函数内部，async让其异步上抛了"></a>2. await的同步作用只保留在当前函数内部，async让其异步上抛了</h4><p><code>await</code>关键字只是在标记了<code>async</code>的函数内同步，而<code>async</code>字段的作用是表明此函数是异步函数（默认给此函数返回一个promise），所以在调用该函数的地方是异步。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟异步发数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(str)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求方法,通过声明async/await,可等待异步完成之后再执行</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">await</span> req(data).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;<span class="comment">// 只能做到对req函数的同步效果</span></span><br><span class="line">str = result;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"结果2:"</span> + str); <span class="comment">// 代码1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 代码更新后区域</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"结果3:"</span> + str); <span class="comment">// 代码2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"你好"</span>; <span class="comment">// 代码3</span></span><br><span class="line">update(<span class="string">"hello"</span>); <span class="comment">// 代码4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"结果1:"</span> + str); <span class="comment">// 代码5</span></span><br></pre></td></tr></table></figure><img src="http://xwjpics.gumptlu.work/image-20230227103355005.png" alt="image-20230227103355005" style="zoom:50%;" /><p>步骤：第一步将父级方法也就是update，声明为异步方法（async），然后再需要等待同步的地方标注为await，这样即可等待<code>req(data).then()</code>请求执行成功之后，再执行下面代码。注意：async必不可少，否则报错。</p><p>分析：代码执行完3时，因为代码4声明为异步了，故先执行了代码5，执行请求时，发现请求为等待，故等then执行结束后，即执行了代码1，最后执行了代码2。所以代码2区域能够解决实际问题。虽然这样是<strong>解决了update方法内部的同步代码问题，但是变相的将异步问题向上拋了</strong>。update方法为异步了。</p><p>上述代码的解决方法就是：</p><ol><li>再对update返回的Promise使用await </li><li>对update之后要做的事放到<code>.then()</code>处理 （也就是promise的基础用法）</li></ol><h2 id="6-Promise链式调用的i一个误解"><a href="#6-Promise链式调用的i一个误解" class="headerlink" title="6. Promise链式调用的i一个误解"></a>6. Promise链式调用的i一个误解</h2><p>以下两种调用的代码看似相同，其实差别很大</p><p>第一种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>); <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123; <span class="comment">// (**)</span></span><br><span class="line"></span><br><span class="line">  alert(result); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123; <span class="comment">// (***)</span></span><br><span class="line"></span><br><span class="line">  alert(result); <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  alert(result); <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样是Promise的链式调用，每一次then的返回结果都会向下传递，核心原因在于：<strong>then返回的还是一个Promise</strong></p><img src="http://xwjpics.gumptlu.work/image-20230301150527027.png" alt="image-20230301150527027" style="zoom:50%;" /><p>第二种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  alert(result); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  alert(result); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  alert(result); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是一种典型的<strong>伪链式调用</strong>，其不是链式调用，所做的就仅仅是添加promise的几个处理程序而已，所以，在上面的代码中，所有 <code>alert</code> 都显示相同的内容：<code>1</code>。</p><img src="http://xwjpics.gumptlu.work/image-20230301150644010.png" alt="image-20230301150644010" style="zoom:50%;" /><h2 id="7-计算属性如何带参数"><a href="#7-计算属性如何带参数" class="headerlink" title="7. 计算属性如何带参数"></a>7. 计算属性如何带参数</h2><blockquote><ul><li><a href="https://blog.csdn.net/qq_42988836/article/details/106542901" target="_blank" rel="noopener">https://blog.csdn.net/qq_42988836/article/details/106542901</a></li></ul></blockquote><p>在使用计算属性的时候如果返回的是一个字符串值而不是一个函数是无法携带参数的，会报如下错：</p><p><img src="http://xwjpics.gumptlu.work/image-20230427105909629.png" alt="image-20230427105909629"></p><p>解决方法：</p><p>return一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算select的样式</span></span><br><span class="line">computeSelectClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">record</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.onlyShowMode) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'special-select-showmode-style'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (record.disabled) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'special-select-disable-style'</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'special-select-style'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>日记_0438</title>
    <link href="https://xwjahahahaha.github.io/2023/02/12/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2023/2023-02/%E6%97%A5%E8%AE%B0-0438/"/>
    <id>https://xwjahahahaha.github.io/2023/02/12/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2023/2023-02/%E6%97%A5%E8%AE%B0-0438/</id>
    <published>2023-02-12T03:19:45.000Z</published>
    <updated>2023-07-06T06:07:35.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><a id="more"></a><p>2022:</p><p>3～4月</p><ul><li><input checked="" disabled="" type="checkbox"> 找到一份暑期实习(网易)</li></ul><p>5～6月</p><ul><li><input checked="" disabled="" type="checkbox"> 论文修改重新投稿 5.3<ul><li><input checked="" disabled="" type="checkbox"> 5.16 退修</li><li><input checked="" disabled="" type="checkbox"> 7.4 录用修改</li></ul></li></ul><p>6～7月</p><ul><li><input checked="" disabled="" type="checkbox"> 实习<ul><li><input checked="" disabled="" type="checkbox"> kube-eagle项目</li></ul></li><li><input disabled="" type="checkbox"> 基础知识<ul><li><input disabled="" type="checkbox"> linux内核源码 =&gt; 《深入理解linux内核》</li></ul></li></ul><p>8～10月</p><ul><li><input checked="" disabled="" type="checkbox"> 秋招 =&gt; 工作找的只能说中规中矩，希望春招再试一下</li></ul><p>11月～12月</p><ul><li><input disabled="" type="checkbox"> 准备春招<ul><li><input disabled="" type="checkbox"> 操作系统、虚拟化方向</li></ul></li></ul><h2 id="这段时间的待完成任务："><a href="#这段时间的待完成任务：" class="headerlink" title="这段时间的待完成任务："></a>这段时间的待完成任务：</h2><ul><li><input disabled="" type="checkbox"> <p>准备春招</p><ul><li><input disabled="" type="checkbox"> 操作系统、虚拟化方向</li></ul></li><li><input disabled="" type="checkbox"> <p>大论文</p><ul><li><input checked="" disabled="" type="checkbox"> 看之前的论文</li><li><input checked="" disabled="" type="checkbox"> 中期ppt制作</li><li><input checked="" disabled="" type="checkbox"> 论文第二个点</li><li><input disabled="" type="checkbox"> 论文代码/项目重构</li><li><input disabled="" type="checkbox"> 大论文写作</li></ul></li><li><input disabled="" type="checkbox"> <p>修整之前实习的项目（考虑中….）</p><ul><li><input disabled="" type="checkbox"> 基于eBPF的云原生profile观测系统项目</li></ul></li><li><input disabled="" type="checkbox"> <p>操作系统45讲-实现一个自己的OS </p></li><li><input disabled="" type="checkbox"> <p>runC项目</p><ul><li><input disabled="" type="checkbox"> 看之前的文档和源码过一遍</li><li><input disabled="" type="checkbox"> 重构源代码、加入seccomp功能 </li><li><input disabled="" type="checkbox"> runC源码项目阅读</li><li><input disabled="" type="checkbox"> OCI 镜像格式标准文件包 bundles</li></ul></li><li><input disabled="" type="checkbox"> <p>看书 </p><ul><li><input disabled="" type="checkbox"> 《C语言程序设计现代方法》（看不懂的地方再找着看，直接过基础枯燥且浪费时间）</li><li><input disabled="" type="checkbox"> 《深入理解计算机系统》CSAPP</li></ul></li><li><input disabled="" type="checkbox"> <p>myMiniDB：C++实现一个简易数据库</p></li><li><input disabled="" type="checkbox"> <p>春招准备：</p><ul><li><input disabled="" type="checkbox"> 总体方向：linux内核开发、虚拟化方向<ul><li><input disabled="" type="checkbox"> c++ <ul><li><input disabled="" type="checkbox"> 《C++ Primer》</li></ul></li><li><input disabled="" type="checkbox"> linux内核<ul><li><input disabled="" type="checkbox"> 《深入理解linux内核》</li></ul></li><li><input disabled="" type="checkbox"> 虚拟化<ul><li><input disabled="" type="checkbox"> 《深度探索linux系统虚拟化》原理与实现</li></ul></li></ul></li></ul></li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 大论文<ul><li><input disabled="" type="checkbox"> 大论文写作<ul><li><input checked="" disabled="" type="checkbox"> 封面页和扉页（coverpage）</li><li><input checked="" disabled="" type="checkbox"> 摘要</li><li><input checked="" disabled="" type="checkbox"> 目录框架</li><li><input checked="" disabled="" type="checkbox"> 第一章 绪论</li><li><input disabled="" type="checkbox"> 第二章 基本概念</li></ul></li></ul></li><li><input disabled="" type="checkbox"> 操作系统45讲-实现一个自己的OS <ul><li><input disabled="" type="checkbox"> 09丨瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</li></ul></li><li><input disabled="" type="checkbox"> C++实现一个简易数据库<ul><li><input disabled="" type="checkbox"> 3-实现insert和select</li></ul></li><li><input disabled="" type="checkbox"> 大论文</li><li><input disabled="" type="checkbox"> 《C++ Primer》<ul><li><input disabled="" type="checkbox"> 第八章 IO库</li></ul></li><li><input disabled="" type="checkbox"> 《深入理解linux内核》<ul><li><input disabled="" type="checkbox"> 第三章 进程  记了笔记还未完成</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>go-zero使用心得</title>
    <link href="https://xwjahahahaha.github.io/2023/02/10/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-zero/go-zero%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://xwjahahahaha.github.io/2023/02/10/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-zero/go-zero%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</id>
    <published>2023-02-10T07:33:39.000Z</published>
    <updated>2023-07-06T06:07:34.946Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><blockquote><p>参考：</p><ul><li></li></ul></blockquote><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><h2 id="1-api配置文件含义"><a href="#1-api配置文件含义" class="headerlink" title="1. api配置文件含义"></a>1. api配置文件含义</h2><p>API语法介绍：<a href="https://go-zero.dev/cn/docs/design/grammar/" target="_blank" rel="noopener">https://go-zero.dev/cn/docs/design/grammar/</a></p><h3 id="from与json区别"><a href="#from与json区别" class="headerlink" title="from与json区别"></a>from与json区别</h3><p>在编写接口的api文件时，其中<code>from</code>与<code>json</code>有不同的含义</p><p>如果是get类型的接口，那么Req结构体的字段就必须是from，如果是post那么就应该用json</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RuleGetOneReq &#123;</span><br><span class="line">  RuleId <span class="keyword">int64</span> <span class="string">`from:"rule_id"`</span></span><br><span class="line">&#125;</span><br><span class="line">RuleGetOneResp &#123;</span><br><span class="line">  Rule Rule <span class="string">`json:"rule"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@doc <span class="string">"查询一个规则"</span></span><br><span class="line">@handler getOneRule</span><br><span class="line">get /getOneRule(RuleGetOneReq) returns (RuleGetOneResp)</span><br></pre></td></tr></table></figure><table><thead><tr><th>tag key</th><th>描述</th><th>提供方</th><th>有效范围</th><th>示例</th></tr></thead><tbody><tr><td>json</td><td>json序列化tag</td><td>golang</td><td>request、response</td><td><code>json:&quot;fooo&quot;</code></td></tr><tr><td>path</td><td>路由path，如<code>/foo/:id</code></td><td>go-zero</td><td>request</td><td><code>path:&quot;id&quot;</code></td></tr><tr><td>form</td><td>标志请求体是一个form（POST方法时）或者一个query(GET方法时<code>/search?name=keyword</code>)</td><td>go-zero</td><td>request</td><td><code>form:&quot;name&quot;</code></td></tr><tr><td>header</td><td>HTTP header，如 <code>Name: value</code></td><td>go-zero</td><td>request</td><td><code>header:&quot;name&quot;</code></td></tr></tbody></table><h2 id="2-createTime、updateTime"><a href="#2-createTime、updateTime" class="headerlink" title="2. createTime、updateTime"></a>2. createTime、updateTime</h2><p>根据文档：</p><blockquote><p><a href="https://go-zero.dev/cn/docs/goctl/model#%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99" target="_blank" rel="noopener">https://go-zero.dev/cn/docs/goctl/model#%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99</a></p><p>默认规则</p><p>我们默认用户在建表时会创建createTime、updateTime字段(忽略大小写、下划线命名风格)且默认值均为<code>CURRENT_TIMESTAMP</code>，而updateTime支持<code>ON UPDATE CURRENT_TIMESTAMP</code>，对于这两个字段生成<code>insert</code>、<code>update</code>时会被移除，不在赋值范畴内，当然，如果你不需要这两个字段那也无大碍</p></blockquote><p>所以我们只要在定义数据库Sql的时候定义这两个字段就可以了，在golang代码中无需赋值这两个字段，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line"><span class="string">`update_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br></pre></td></tr></table></figure><h2 id="3-如何添加更多的CURD操作"><a href="#3-如何添加更多的CURD操作" class="headerlink" title="3. 如何添加更多的CURD操作"></a>3. 如何添加更多的CURD操作</h2><p>默认<code>goctl model</code>生成的CURD代码可能无法满足需求，那</p><h2 id="4-返回http状态码的原则"><a href="#4-返回http状态码的原则" class="headerlink" title="4. 返回http状态码的原则"></a>4. 返回http状态码的原则</h2><p>对于go-zero我们可以自己创建自定义的错误类型，然后定制化返回错误(<a href="https://go-zero.dev/cn/docs/advance/error-handle" target="_blank" rel="noopener">https://go-zero.dev/cn/docs/advance/error-handle</a>)</p><p>其中可以自己写状态码，一般情况下后端返回结果的httpcode状态，不能都是200，应该遵循以下规则</p><ul><li>如果是服务端能感知的错误就返回400（用户请求导致失败）（自定义的错误的http状态码应该为400，因为这是我们自定义的错误，能够感知到）</li><li>如果是服务端本身的错误（无法感知的）那么就返回500（例如空指针等无法自定义感知到的错误）</li><li>请求流程都成功了才返回200</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟网络基础总结</title>
    <link href="https://xwjahahahaha.github.io/2023/02/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E8%99%9A%E6%8B%9F%E5%8C%96/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>https://xwjahahahaha.github.io/2023/02/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E8%99%9A%E6%8B%9F%E5%8C%96/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</id>
    <published>2023-02-09T03:15:14.000Z</published>
    <updated>2023-07-06T06:07:34.967Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><blockquote><p>参考：</p><ul><li></li></ul></blockquote><p>记录一些看文档中需要了解的虚拟网络相关的基本概念，尽量用最简单的描述理解，便于复习</p><h1 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h1><p>Ethernet is a networking protocol, specified by the IEEE 802.3 standard. </p><p>In the <a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener">OSI model</a> of networking protocols, Ethernet occupies the second layer, which is known as the data link layer. When discussing Ethernet, you will often hear terms such as <em>local network</em>, <em>layer 2</em>, <em>L2</em>, <em>link layer</em> and <em>data link layer</em>. </p><p>通常说的数据连接层、layer 2和L2都是指Ethernet工作的第二层-数据链路层</p><h1 id="通用路由封装-Generic-routing-encapsulation-GRE-¶"><a href="#通用路由封装-Generic-routing-encapsulation-GRE-¶" class="headerlink" title="通用路由封装 Generic routing encapsulation (GRE)¶"></a>通用路由封装 Generic routing encapsulation (GRE)<a href="https://docs.openstack.org/ocata/networking-guide/intro-overlay-protocols.html#generic-routing-encapsulation-gre" target="_blank" rel="noopener">¶</a></h1><p>是一种可以在虚拟<a href="https://zh.wikipedia.org/wiki/点对点" target="_blank" rel="noopener">点对点</a>链路中<a href="https://zh.wikipedia.org/wiki/封装" target="_blank" rel="noopener">封装</a>多种<a href="https://zh.wikipedia.org/wiki/网络层" target="_blank" rel="noopener">网络层</a>协议的<a href="https://zh.wikipedia.org/wiki/隧道协议" target="_blank" rel="noopener">隧道协议</a></p><img src="http://xwjpics.gumptlu.work/image-20230209114522824.png" alt="image-20230209114522824" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>随笔/每日一记/日记/2023/2023-01/日记-0437</title>
    <link href="https://xwjahahahaha.github.io/2023/01/25/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2023/2023-01/%E6%97%A5%E8%AE%B0-0437/"/>
    <id>https://xwjahahahaha.github.io/2023/01/25/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2023/2023-01/%E6%97%A5%E8%AE%B0-0437/</id>
    <published>2023-01-25T06:31:52.000Z</published>
    <updated>2023-07-06T06:07:35.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><a id="more"></a><p>2022:</p><p>3～4月</p><ul><li><input checked="" disabled="" type="checkbox"> 找到一份暑期实习(网易)</li></ul><p>5～6月</p><ul><li><input checked="" disabled="" type="checkbox"> 论文修改重新投稿 5.3<ul><li><input checked="" disabled="" type="checkbox"> 5.16 退修</li><li><input checked="" disabled="" type="checkbox"> 7.4 录用修改</li></ul></li></ul><p>6～7月</p><ul><li><input checked="" disabled="" type="checkbox"> 实习<ul><li><input checked="" disabled="" type="checkbox"> kube-eagle项目</li></ul></li><li><input disabled="" type="checkbox"> 基础知识<ul><li><input disabled="" type="checkbox"> linux内核源码 =&gt; 《深入理解linux内核》</li></ul></li></ul><p>8～10月</p><ul><li><input checked="" disabled="" type="checkbox"> 秋招 =&gt; 工作找的只能说中规中矩，希望春招再试一下</li></ul><p>11月～12月</p><ul><li><input disabled="" type="checkbox"> <p>准备春招</p><ul><li><input disabled="" type="checkbox"> 操作系统、虚拟化方向</li></ul></li><li><input disabled="" type="checkbox"> <p>大论文</p><ul><li><input disabled="" type="checkbox"> 看之前的论文</li><li><input disabled="" type="checkbox"> 中期ppt制作</li><li><input disabled="" type="checkbox"> 论文代码/项目重构</li><li><input disabled="" type="checkbox"> 论文第二个点</li></ul></li><li><input disabled="" type="checkbox"> <p>修整之前实习的项目（考虑中….）</p><ul><li><input disabled="" type="checkbox"> 基于eBPF的云原生profile观测系统项目</li></ul></li><li><input disabled="" type="checkbox"> <p>操作系统45讲-实现一个自己的OS </p></li><li><input disabled="" type="checkbox"> <p>runC项目</p><ul><li><input disabled="" type="checkbox"> 看之前的文档和源码过一遍</li><li><input disabled="" type="checkbox"> 重构源代码、加入seccomp功能 </li><li><input disabled="" type="checkbox"> runC源码项目阅读</li><li><input disabled="" type="checkbox"> OCI 镜像格式标准文件包 bundles</li></ul></li><li><input disabled="" type="checkbox"> <p>看书 </p><ul><li><input disabled="" type="checkbox"> 《C语言程序设计现代方法》（看不懂的地方再找着看，直接过基础枯燥且浪费时间）</li><li><input disabled="" type="checkbox"> 《深入理解计算机系统》CSAPP</li></ul></li><li><input disabled="" type="checkbox"> <p>myMiniDB：C++实现一个简易数据库</p></li><li><input disabled="" type="checkbox"> <p>春招准备：</p><ul><li><input disabled="" type="checkbox"> 总体方向：linux内核开发、虚拟化方向<ul><li><input disabled="" type="checkbox"> c++ <ul><li><input disabled="" type="checkbox"> 《C++ Primer》</li></ul></li><li><input disabled="" type="checkbox"> linux内核<ul><li><input disabled="" type="checkbox"> 《深入理解linux内核》</li></ul></li><li><input disabled="" type="checkbox"> 虚拟化<ul><li><input disabled="" type="checkbox"> 《深度探索linux系统虚拟化》原理与实现</li></ul></li></ul></li></ul></li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 操作系统45讲-实现一个自己的OS <ul><li><input checked="" disabled="" type="checkbox"> 08｜锁：并发操作中，解决数据同步的四种方法</li><li><input disabled="" type="checkbox"> 09丨瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</li></ul></li><li><input disabled="" type="checkbox"> C++实现一个简易数据库<ul><li><input disabled="" type="checkbox"> 3-实现insert和select</li></ul></li><li><input disabled="" type="checkbox"> 大论文</li><li><input disabled="" type="checkbox"> 《C++ Primer》<ul><li><input disabled="" type="checkbox"> 第八章 IO库</li></ul></li><li><input disabled="" type="checkbox"> 《深入理解linux内核》<ul><li><input disabled="" type="checkbox"> 第三章 进程  记了笔记还未完成</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0436</title>
    <link href="https://xwjahahahaha.github.io/2023/01/14/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2023/2023-01/%E6%97%A5%E8%AE%B0-0436/"/>
    <id>https://xwjahahahaha.github.io/2023/01/14/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2023/2023-01/%E6%97%A5%E8%AE%B0-0436/</id>
    <published>2023-01-14T13:44:40.000Z</published>
    <updated>2023-07-06T06:07:35.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><a id="more"></a><p>2022:</p><p>3～4月</p><ul><li><input checked="" disabled="" type="checkbox"> 找到一份暑期实习(网易)</li></ul><p>5～6月</p><ul><li><input checked="" disabled="" type="checkbox"> 论文修改重新投稿 5.3<ul><li><input checked="" disabled="" type="checkbox"> 5.16 退修</li><li><input checked="" disabled="" type="checkbox"> 7.4 录用修改</li></ul></li></ul><p>6～7月</p><ul><li><input checked="" disabled="" type="checkbox"> 实习<ul><li><input checked="" disabled="" type="checkbox"> kube-eagle项目</li></ul></li><li><input disabled="" type="checkbox"> 基础知识<ul><li><input disabled="" type="checkbox"> linux内核源码 =&gt; 《深入理解linux内核》</li></ul></li></ul><p>8～10月</p><ul><li><input checked="" disabled="" type="checkbox"> 秋招 =&gt; 工作找的只能说中规中矩，希望春招再试一下</li></ul><p>11月～12月</p><ul><li><input disabled="" type="checkbox"> <p>准备春招</p><ul><li><input disabled="" type="checkbox"> 操作系统、虚拟化方向</li></ul></li><li><input disabled="" type="checkbox"> <p>大论文</p><ul><li><input disabled="" type="checkbox"> 看之前的论文</li><li><input disabled="" type="checkbox"> 中期ppt制作</li><li><input disabled="" type="checkbox"> 论文代码/项目重构</li><li><input disabled="" type="checkbox"> 论文第二个点</li></ul></li><li><input disabled="" type="checkbox"> <p>修整之前实习的项目（考虑中….）</p><ul><li><input disabled="" type="checkbox"> 基于eBPF的云原生profile观测系统项目</li></ul></li><li><input disabled="" type="checkbox"> <p>操作系统45讲-实现一个自己的OS </p></li><li><input disabled="" type="checkbox"> <p>runC项目</p><ul><li><input disabled="" type="checkbox"> 看之前的文档和源码过一遍</li><li><input disabled="" type="checkbox"> 重构源代码、加入seccomp功能 </li><li><input disabled="" type="checkbox"> runC源码项目阅读</li><li><input disabled="" type="checkbox"> OCI 镜像格式标准文件包 bundles</li></ul></li><li><input disabled="" type="checkbox"> <p>看书 </p><ul><li><input disabled="" type="checkbox"> 《C语言程序设计现代方法》（看不懂的地方再找着看，直接过基础枯燥且浪费时间）</li><li><input disabled="" type="checkbox"> 《深入理解计算机系统》CSAPP</li></ul></li><li><input disabled="" type="checkbox"> <p>myMiniDB：C++实现一个简易数据库</p></li><li><input disabled="" type="checkbox"> <p>春招准备：</p><ul><li><input disabled="" type="checkbox"> 总体方向：linux内核开发、虚拟化方向<ul><li><input disabled="" type="checkbox"> c++ <ul><li><input disabled="" type="checkbox"> 《C++ Primer》</li></ul></li><li><input disabled="" type="checkbox"> linux内核<ul><li><input disabled="" type="checkbox"> 《深入理解linux内核》</li></ul></li><li><input disabled="" type="checkbox"> 虚拟化<ul><li><input disabled="" type="checkbox"> 《深度探索linux系统虚拟化》原理与实现</li></ul></li></ul></li></ul></li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 操作系统45讲-实现一个自己的OS <ul><li><input checked="" disabled="" type="checkbox"> 07丨Cache与内存：程序放在哪儿？</li></ul></li><li><input disabled="" type="checkbox"> C++实现一个简易数据库<ul><li><input disabled="" type="checkbox"> 3-实现insert和select</li></ul></li><li><input disabled="" type="checkbox"> 《C++ Primer》<ul><li><input disabled="" type="checkbox"> 第八章 IO库</li></ul></li><li><input disabled="" type="checkbox"> 《深入理解linux内核》<ul><li><input disabled="" type="checkbox"> 第三章 进程  记了笔记还未完成</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>6-锁:并发操作中解决数据同步的四种方法</title>
    <link href="https://xwjahahahaha.github.io/2023/01/14/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F45%E8%AE%B2%E3%80%8B/6-%E9%94%81:%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E4%B8%AD%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://xwjahahahaha.github.io/2023/01/14/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F45%E8%AE%B2%E3%80%8B/6-%E9%94%81:%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E4%B8%AD%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2023-01-14T08:13:01.000Z</published>
    <updated>2023-07-06T06:07:34.949Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><blockquote><p>参考：</p><ul><li>极客时间-《操作系统45讲》<ul><li>购买地址： <a href="https://time.geekbang.org/column/intro/100078401" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/100078401</a> </li><li>作者：LMOS</li></ul></li></ul></blockquote><h1 id="6-锁-并发操作中解决数据同步的四种方法"><a href="#6-锁-并发操作中解决数据同步的四种方法" class="headerlink" title="6-锁:并发操作中解决数据同步的四种方法"></a>6-锁:并发操作中解决数据同步的四种方法</h1><p>你好，我是 LMOS。</p><p>我们在前面的课程中探索了，开发操作系统要了解的最核心的硬件——CPU、MMU、Cache、内存，知道了它们的工作原理。在程序运行中，它们起到了至关重要的作用。</p><p>在开发我们自己的操作系统以前，还不能一开始就把机器跑起来，而是先要弄清楚数据同步的问题。如果不解决掉数据同步的问题，后面机器跑起来，就会出现很多不可预知的结果。</p><p>通过这节课，我会给你讲清楚为什么在并发操作里，很可能得不到预期的访问数据，还会带你分析这个问题的原因以及解决方法。有了这样一个研究、解决问题的过程，对最重要的几种锁（<strong>原子变量，关中断，信号量，自旋锁</strong>），你就能做到心中有数了。</p><h2 id="非预期结果的全局变量"><a href="#非预期结果的全局变量" class="headerlink" title="非预期结果的全局变量"></a>非预期结果的全局变量</h2><p>来看看下面的代码，描述的是一个线程中的函数和中断处理函数，它们分别对一个全局变量执行加 1 操作，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interrupt_handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们梳理一下编译器的翻译过程，通常编译器会把 a++ 语句翻译成这 3 条指令：</p><ol><li><p>把 a 加载某个寄存器中。</p></li><li><p>这个寄存器加 1。</p></li><li><p>把这个寄存器写回内存。</p></li></ol><p>那么不难推断，可能导致结果不确定的情况是这样的：thread_func 函数还没运行完第 2 条指令时，中断就来了。</p><p>因此，CPU 转而处理中断，也就是开始运行 interrupt_handle 函数，这个函数运行完 a=1，CPU 还会回去继续运行第 3 条指令，此时 a 依然是 1，这显然是错的。</p><p>下面来看一下表格，你就明白了：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20230114163223503.png" alt="image-20230114163223503" style="zoom:50%;" /><p>显然在 t2 时刻发生了中断，导致了 t2 到 t4 运行了 interrupt_handle 函数，t5 时刻 thread_func 又恢复运行，导致 interrupt_handle 函数中 a 的操作丢失，因此出错。</p><h2 id="方法一：原子操作-拿下单体变量"><a href="#方法一：原子操作-拿下单体变量" class="headerlink" title="方法一：原子操作 拿下单体变量"></a>方法一：原子操作 拿下单体变量</h2><p>要解决上述场景中的问题，有这样两种思路。一种是<strong>把 a++ 变成原子操作</strong>，这里的原子是不可分隔的，也就是说要 a++ 这个操作不可分隔，即 a++ 要么不执行，要么一口气执行完；另一种就是<strong>控制中断</strong>，比如在执行 a++ 之前关掉中断，执行完了之后打开中断。</p><p>我们先来看看原子操作，显然靠编译器自动生成原子操作不太可能。第一，编译器没有这么智能，能检测哪个变量需要原子操作；第二，编译器必须要考虑代码的移植性，例如有些硬件平台支持原子操作的机器指令，有的硬件平台不支持原子操作。</p><p>既然实现原子操作无法依赖于具体编译器，那就需要我们自己动手，x86 平台支持很多原子指令，我们只需要直接应用这些指令，比如原子加、原子减，原子读写等，用汇编代码写出对应的原子操作函数就行了。</p><p>好在现代 C 语言已经支持嵌入汇编代码，可以<strong>在 C 函数中按照特定的方式嵌入汇编代码</strong>了，实现原子操作就更方便了，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个原子类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_ATOMIC</span>&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">s32_t</span> a_count; <span class="comment">//在变量前加上volatile，是为了禁止编译器优化，使其每次都从内存中加载变量</span></span><br><span class="line">&#125;<span class="keyword">atomic_t</span>;</span><br><span class="line"><span class="comment">//原子读</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">s32_t</span> <span class="title">atomic_read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">        <span class="comment">//x86平台取地址处是原子</span></span><br><span class="line">        <span class="keyword">return</span> (*(<span class="keyword">volatile</span> <span class="keyword">u32_t</span>*)&amp;(v)-&gt;a_count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子写</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">atomic_write</span><span class="params">(<span class="keyword">atomic_t</span> *v, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//x86平台把一个值写入一个地址处也是原子的 </span></span><br><span class="line">        v-&gt;a_count = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子加上一个整数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">atomic_add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        __asm__ __volatile__(<span class="string">"lock;"</span> <span class="string">"addl %1,%0"</span></span><br><span class="line">                     : <span class="string">"+m"</span> (v-&gt;a_count)</span><br><span class="line">                     : <span class="string">"ir"</span> (i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子减去一个整数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">atomic_sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        __asm__ __volatile__(<span class="string">"lock;"</span> <span class="string">"subl %1,%0"</span></span><br><span class="line">                     : <span class="string">"+m"</span> (v-&gt;a_count)</span><br><span class="line">                     : <span class="string">"ir"</span> (i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子加1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">atomic_inc</span><span class="params">(<span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        __asm__ __volatile__(<span class="string">"lock;"</span> <span class="string">"incl %0"</span></span><br><span class="line">                       : <span class="string">"+m"</span> (v-&gt;a_count));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子减1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">atomic_dec</span><span class="params">(<span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       __asm__ __volatile__(<span class="string">"lock;"</span> <span class="string">"decl %0"</span></span><br><span class="line">                     : <span class="string">"+m"</span> (v-&gt;a_count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上代码中，加上 lock 前缀的 addl、subl、incl、decl 指令都是原子操作，lock 前缀表示锁定总线。</strong></p><p>我们还是来看看 GCC 支持嵌入汇编代码的模板，不同于其它 C 编译器支持嵌入汇编代码的方式，为了优化用户代码，GCC 设计了一种特有的嵌入方式，它规定了汇编代码嵌入的形式和嵌入汇编代码需要由哪几个部分组成，如下面代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(汇编代码部分:输出部分列表:输入部分列表:损坏部分列表);</span><br></pre></td></tr></table></figure><p>可以看到代码模板从 <strong>asm</strong> 开始（当然也可以是 asm），紧跟着 <strong>volatile</strong>，然后是跟着一对括号，最后以分号结束。括号里大致分为 4 个部分：</p><ol><li><p>汇编代码部分，这里是实际嵌入的汇编代码。</p></li><li><p>输出列表部分，让 GCC 能够处理 C 语言左值表达式与汇编代码的结合。</p></li><li><p>输入列表部分，也是让 GCC 能够处理 C 语言表达式、变量、常量，让它们能够输入到汇编代码中去。</p></li><li><p>损坏列表部分，告诉 GCC 汇编代码中用到了哪些寄存器，以便 GCC 在汇编代码运行前，生成保存它们的代码，并且在生成的汇编代码运行后，恢复它们（寄存器）的代码。</p></li></ol><p>它们之间用冒号隔开，如果只有汇编代码部分，后面的冒号可以省略。但是有输入列表部分而没有输出列表部分的时候，输出列表部分的冒号就必须要写，否则 GCC 没办法判断，同样的道理对于其它部分也一样。</p><p>这里不会过多展开讲这个技术，详情可参阅<a href="https://gcc.gnu.org/onlinedocs/" target="_blank" rel="noopener">GCC手册</a>。你可以重点看 GAS 相关的章节</p><p>下面将用上面一个函数 atomic_add 为例子说一下，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">atomic_add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        __asm__ __volatile__(<span class="string">"lock;"</span> <span class="string">"addl %1,%0"</span></span><br><span class="line">                     : <span class="string">"+m"</span> (v-&gt;a_count)</span><br><span class="line">                     : <span class="string">"ir"</span> (i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//"lock;" "addl %1,%0" 是汇编指令部分，%1,%0是占位符，它表示输出、输入列表中变量或表态式，占位符的数字从输出部分开始依次增加，这些变量或者表态式会被GCC处理成寄存器、内存、立即数放在指令中。 </span></span><br><span class="line"><span class="comment">//: "+m" (v-&gt;a_count) 是输出列表部分，“+m”表示(v-&gt;a_count)和内存地址关联</span></span><br><span class="line"><span class="comment">//: "ir" (i) 是输入列表部分，“ir” 表示i是和立即数或者寄存器关联</span></span><br></pre></td></tr></table></figure><p>有了这些原子操作函数之后 ，前面场景中的代码就变成下面这样了：无论有没有中断，或者什么时间来中断，都不会出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">atomic_t</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interrupt_handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    atomic_inc(&amp;a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    atomic_inc(&amp;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，说完了原子操作，我们再看看怎么用中断控制的思路解决数据并发访问的问题。</p><h2 id="方法二：中断控制-搞定复杂变量"><a href="#方法二：中断控制-搞定复杂变量" class="headerlink" title="方法二：中断控制  搞定复杂变量"></a>方法二：中断控制  搞定复杂变量</h2><p>中断是 CPU 响应外部事件的重要机制，时钟、键盘、硬盘等 IO 设备都是通过发出中断来请求 CPU 执行相关操作的（即执行相应的中断处理代码），比如下一个时钟到来、用户按下了键盘上的某个按键、硬盘已经准备好了数据。</p><p>但是中断处理代码中如果操作了其它代码的数据，这就需要相应的控制机制了，这样才能保证在操作数据过程中不发生中断。</p><p>你或许在想，可以用原子操作啊？不过，<strong>原子操作只适合于单体变量</strong>，如整数。操作系统的数据结构有的可能有几百字节大小，其中可能包含多种不同的基本数据类型。这显然用原子操作无法解决</p><p>下面，我们就要写代码实现关闭开启、中断了，x86 CPU 上关闭、开启中断有专门的指令，即 cli、sti 指令，它们主要是<strong>对 CPU 的 eflags 寄存器的 IF 位（第 9 位）进行清除和设置</strong>，CPU 正是通过此位来决定是否响应中断信号。这两条指令只能 Ring0 权限才能执行，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hal_cli</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__(<span class="string">"cli"</span>: : :<span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开启中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hal_sti</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__(<span class="string">"sti"</span>: : :<span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用场景</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hal_cli();</span><br><span class="line">    <span class="comment">//操作数据……</span></span><br><span class="line">    hal_sti();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hal_cli();</span><br><span class="line">    <span class="comment">//操作数据……</span></span><br><span class="line">    hal_sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以自己思考一下，前面这段代码效果如何？</p><p>它看似完美地解决了问题，其实有重大缺陷，hal_cli()，hal_sti()，<strong>无法嵌套使用</strong>，看一个例子你就明白了，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hal_cli();</span><br><span class="line">    <span class="comment">//操作数据第一步……</span></span><br><span class="line">    hal_sti();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hal_cli();</span><br><span class="line">    foo();</span><br><span class="line">    <span class="comment">//操作数据第二步……</span></span><br><span class="line">    hal_sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的关键问题在 bar 函数在关中断下调用了 foo 函数，foo 函数中先关掉中断，处理好数据然后开启中断，回到 bar 函数中，bar 函数还天真地以为中断是关闭的，接着处理数据，以为不会被中断抢占。</p><p>那么怎么解决上面的问题呢？我们只要修改一下开启、关闭中断的函数就行了。</p><p>我们可以这样操作：<strong>在关闭中断函数中先保存 eflags 寄存器，然后执行 cli 指令，在开启中断函数中直接恢复之前保存的 eflags 寄存器就行了</strong>，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">u32_t</span> <span class="keyword">cpuflg_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hal_save_flags_cli</span><span class="params">(<span class="keyword">cpuflg_t</span>* flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     __asm__ __volatile__(</span><br><span class="line">            <span class="string">"pushfl \t\n"</span> <span class="comment">//把eflags寄存器压入当前栈顶</span></span><br><span class="line">            <span class="string">"cli    \t\n"</span> <span class="comment">//关闭中断</span></span><br><span class="line">            <span class="string">"popl %0 \t\n"</span><span class="comment">//把当前栈顶弹出到flags为地址的内存中（写到flags地址中临时保存）        </span></span><br><span class="line">            : <span class="string">"=m"</span>(*flags)</span><br><span class="line">            :</span><br><span class="line">            : <span class="string">"memory"</span></span><br><span class="line">          );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hal_restore_flags_sti</span><span class="params">(<span class="keyword">cpuflg_t</span>* flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">              <span class="string">"pushl %0 \t\n"</span><span class="comment">//把flags为地址处的值寄存器压入当前栈顶 （读取flags地址中上次的eflags寄存器的值）</span></span><br><span class="line">              <span class="string">"popfl \t\n"</span>   <span class="comment">//把当前栈顶弹出到flags寄存器中（存储到当前eflags寄存器中）</span></span><br><span class="line">              :</span><br><span class="line">              : <span class="string">"m"</span>(*flags)</span><br><span class="line">              : <span class="string">"memory"</span></span><br><span class="line">              );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中不难发现，硬件工程师早就想到了如何解决在嵌套函数中关闭、开启中断的问题：pushfl 指令把 eflags 寄存器压入当前栈顶，popfl 把当前栈顶的数据弹出到 eflags 寄存器中</p><p>hal_restore_flags_sti() 函数的执行，<strong>是否开启中断完全取决于上一次 eflags 寄存器中的值</strong>，并且 popfl 指令只会影响 eflags 寄存器中的 IF 位。这样，无论函数嵌套调用多少层都没有问题</p><blockquote><p><font color='#39b54a'>这里没看懂，貌似说不通，主要在于如果关了一次，那么eflag寄存器的值和内存临时保存的值都是关闭中断的值，那么再需要开启就开启不了了（因为复制上次的值也是关闭中断的值），可能这里作者做了简化</font></p></blockquote><h2 id="方法三：自旋锁-协调多核心-CPU"><a href="#方法三：自旋锁-协调多核心-CPU" class="headerlink" title="方法三：自旋锁 协调多核心 CPU"></a>方法三：自旋锁 协调多核心 CPU</h2><p>前面说的控制中断，看似解决了问题，那是因为以前是单 CPU，同一时刻只有一条代码执行流，除了中断会中止当前代码执行流，转而运行另一条代码执行流（中断处理程序），再无其它代码执行流。这种情况下只要控制了中断，就能安全地操作全局数据。</p><p>但是我们都知道，现在情况发生了改变，<strong>CPU 变成了多核心</strong>，或者主板上安装了多颗 CPU，同一时刻下系统中存在多条代码执行流，控制中断只能控制本地 CPU 的中断，无法控制其它 CPU 核心的中断。</p><p>所以，原先通过控制中断来维护全局数据安全的方案失效了，这就需要全新的机制来处理这样的情况，于是就轮到自旋锁登场了。</p><p>我们先看看自旋锁的原理，它是这样的：首先读取锁变量，判断其值是否已经加锁，如果未加锁则执行加锁，然后返回，表示加锁成功；如果已经加锁了，就要返回第一步继续执行后续步骤，因而得名自旋锁。为了让你更好理解，下面来画一个图描述这个算法。</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20230114173417655.png" alt="image-20230114173417655" style="zoom: 33%;" /><p>这个算法看似很好，但是想要正确执行它，就<strong>必须保证读取锁变量和判断并加锁的操作是原子执行的。</strong>否则，CPU0 在读取了锁变量之后，CPU1 读取锁变量判断未加锁执行加锁，然后 CPU0 也判断未加锁执行加锁，这时就会发现两个 CPU 都加锁成功，因此这个算法出错了。</p><p>怎么解决这个问题呢？这就要找硬件要解决方案了，x86 CPU 给我们提供了一个<strong>原子交换指令，<code>xchg</code></strong>，它可以让寄存器里的一个值跟内存空间中的一个值做交换。例如，让<code>eax=memlock，memlock=eax</code> 这个动作是原子的，<strong>不受其它 CPU 干扰</strong></p><p>下面我们就去实现自旋锁，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自旋锁结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">volatile</span> <span class="keyword">u32_t</span> lock;<span class="comment">//volatile可以防止编译器优化，保证其它代码始终从内存加载lock变量的值 </span></span><br><span class="line">&#125; <span class="keyword">spinlock_t</span>;</span><br><span class="line"><span class="comment">//锁初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">x86_spin_lock_init</span><span class="params">(<span class="keyword">spinlock_t</span> * lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     lock-&gt;lock = <span class="number">0</span>;<span class="comment">//锁值初始化为0是未加锁状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加锁函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">x86_spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> * lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">    <span class="string">"1: \n"</span></span><br><span class="line">    <span class="string">"lock; xchg  %0, %1 \n"</span><span class="comment">//把值为1的寄存器和lock内存中的值进行交换</span></span><br><span class="line">    <span class="string">"cmpl   $0, %0 \n"</span> <span class="comment">//用0和交换回来的值进行比较</span></span><br><span class="line">    <span class="string">"jnz    2f \n"</span>  <span class="comment">//不等于0则跳转后面2标号处运行</span></span><br><span class="line">    <span class="string">"jmp 3f \n"</span>     <span class="comment">//若等于0则跳转后面3标号处返回</span></span><br><span class="line">    <span class="string">"2:         \n"</span> </span><br><span class="line">    <span class="string">"cmpl   $0, %1  \n"</span><span class="comment">//用0和lock内存中的值进行比较</span></span><br><span class="line">    <span class="string">"jne    2b      \n"</span><span class="comment">//若不等于0则跳转到前面2标号处运行继续比较  </span></span><br><span class="line">    <span class="string">"jmp    1b      \n"</span><span class="comment">//若等于0则跳转到前面1标号处运行，交换并加锁</span></span><br><span class="line">    <span class="string">"3:  \n"</span>     :</span><br><span class="line">    : <span class="string">"r"</span>(<span class="number">1</span>), <span class="string">"m"</span>(*lock));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解锁函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">x86_spin_unlock</span><span class="params">(<span class="keyword">spinlock_t</span> * lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">    <span class="string">"movl   $0, %0\n"</span><span class="comment">//解锁把lock内存中的值设为0就行</span></span><br><span class="line">    :</span><br><span class="line">    : <span class="string">"m"</span>(*lock));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的中注释已经很清楚了，关键点在于 xchg 指令，<code>xchg %0, %1</code></p><p>其中，<code>%0</code>对应<code>&quot;r&quot;(1)</code>，表示由编译器自动分配一个通用寄存器，并填入值 1，例如 <code>mov eax，1</code>。而 <code>%1</code>对应<code>&quot;m&quot;(*lock)</code>，表示 lock 是内存地址。把 1 和内存中的值进行交换，若内存中是 1，则不会影响；因为本身写入就是 1，若内存中是 0，一交换，内存中就变成了 1，即加锁成功。</p><p>自旋锁依然有<strong>中断嵌套</strong>的问题，也就是说，<strong>在使用自旋锁的时候我们仍然要注意中断</strong>。</p><p>在中断处理程序访问某个自旋锁保护的某个资源时，依然有问题，所以我们要写的自旋锁函数必须适应这样的中断环境，也就是说，它需要在处理中断的过程中也能使用（其实也就是在cpu自旋之前先关闭中断），如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">x86_spin_lock_disable_irq</span><span class="params">(<span class="keyword">spinlock_t</span> * lock,<span class="keyword">cpuflg_t</span>* flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">    <span class="string">"pushfq                 \n\t"</span></span><br><span class="line">    <span class="string">"cli                    \n\t"</span></span><br><span class="line">    <span class="string">"popq %0                \n\t"</span><span class="comment">// 前三行代表关闭中断</span></span><br><span class="line">    <span class="string">"1:         \n\t"</span></span><br><span class="line">    <span class="string">"lock; xchg  %1, %2 \n\t"</span></span><br><span class="line">    <span class="string">"cmpl   $0,%1       \n\t"</span></span><br><span class="line">    <span class="string">"jnz    2f      \n\t"</span></span><br><span class="line">    <span class="string">"jmp    3f      \n"</span>  </span><br><span class="line">    <span class="string">"2:         \n\t"</span></span><br><span class="line">    <span class="string">"cmpl   $0,%2       \n\t"</span> </span><br><span class="line">    <span class="string">"jne    2b      \n\t"</span></span><br><span class="line">    <span class="string">"jmp    1b      \n\t"</span></span><br><span class="line">    <span class="string">"3:     \n"</span>     </span><br><span class="line">     :<span class="string">"=m"</span>(*flags)</span><br><span class="line">    : <span class="string">"r"</span>(<span class="number">1</span>), <span class="string">"m"</span>(*lock));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">x86_spin_unlock_enabled_irq</span><span class="params">(<span class="keyword">spinlock_t</span>* lock,<span class="keyword">cpuflg_t</span>* flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">    <span class="string">"movl   $0, %0\n\t"</span><span class="comment">// 重新开启中断</span></span><br><span class="line">    <span class="string">"pushq %1 \n\t"</span></span><br><span class="line">    <span class="string">"popfq \n\t"</span></span><br><span class="line">    :</span><br><span class="line">    : <span class="string">"m"</span>(*lock), <span class="string">"m"</span>(*flags));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码实现了关中断下获取自旋锁，以及恢复中断状态释放自旋锁。在中断环境下也完美地解决了问题</p><h2 id="方法四：信号量-CPU-时间管理大师"><a href="#方法四：信号量-CPU-时间管理大师" class="headerlink" title="方法四：信号量  CPU 时间管理大师"></a>方法四：信号量  CPU 时间管理大师</h2><p>无论是原子操作，还是自旋锁，都不适合长时间等待的情况，因为有很多资源（数据）它有一定的时间性，你想去获取它，CPU 并不能立即返回给你，而是要等待一段时间，才能把数据返回给你。这种情况，你用自旋锁来同步访问这种资源，你会发现这是对 <strong>CPU 时间的巨大浪费</strong>。</p><p>下面我们看看另一种同步机制，既能对资源数据进行保护（同一时刻只有一个代码执行流访问），又能在资源无法满足的情况下，让 CPU 可以执行其它任务。</p><p>如果你翻过操作系统的理论书，应该对信号量这个词并不陌生。信号量是 1965 年荷兰学者 Edsger Dijkstra 提出的，是一种用于资源互斥或者进程间同步的机制。这里我们就来看看如何实现这一机制。</p><p>你不妨想象这样一个情境：微信等待你从键盘上的输入信息，然后把这个信息发送出去。</p><p>这个功能我们怎么实现呢？下面我们就来说说实现它的一般方法，当然具体实现中可能不同，但是原理是相通的，具体如下。</p><ol><li><p>一块内存，相当于缓冲区，用于保存键盘的按键码。</p></li><li><p>需要一套控制机制，比如微信读取这个缓冲区，而该缓冲区为空时怎么处理；该缓冲区中有了按键码，却没有代码执行流来读取，又该怎么处理。</p></li></ol><p>我们期望是这样的，一共有三点。</p><ol><li><p>当微信获取键盘输入信息时，发现键盘缓冲区中是空的，就进入等待状态。</p></li><li><p>同一时刻，只能有一个代码执行流操作键盘缓冲区。</p></li><li><p>当用户按下键盘时，我们有能力把按键码写入缓冲区中，并且能看一看微信或者其它程序是否在等待该缓冲区，如果是就重新激活微信和其它的程序，让它们重新竞争读取键盘缓冲区，如果竞争失败依然进入等待状态。</p></li></ol><p>其实以上所述无非是三个问题：<strong>等待、互斥、唤醒（即重新激活等待的代码执行流）。</strong></p><p>这就需要一种全新的数据结构来解决这些问题。根据上面的问题，这个数据结构至少需要一个变量来表示互斥，比如大于 0 则代码执行流可以继续运行，等于 0 则让代码执行流进入等待状态。还需要一个等待链，用于保存等待的代码执行流。</p><p>这个数据结构的实现代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_FLG_MUTEX 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_FLG_MULTI 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_MUTEX_ONE_LOCK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_MULTI_LOCK 0</span></span><br><span class="line"><span class="comment">//等待链数据结构，用于挂载等待代码执行流（线程）的结构，里面有用于挂载代码执行流的链表和计数器变量，这里我们先不深入研究这个数据结构。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_KWLST</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="keyword">spinlock_t</span> wl_lock;</span><br><span class="line">    <span class="keyword">uint_t</span>   wl_tdnr;</span><br><span class="line">    <span class="keyword">list_h_t</span> wl_list;</span><br><span class="line">&#125;<span class="keyword">kwlst_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_SEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> sem_lock;<span class="comment">//维护sem_t自身数据的自旋锁</span></span><br><span class="line">    <span class="keyword">uint_t</span> sem_flg;<span class="comment">//信号量相关的标志</span></span><br><span class="line">    <span class="keyword">sint_t</span> sem_count;<span class="comment">//信号量计数值</span></span><br><span class="line">    <span class="keyword">kwlst_t</span> sem_waitlst;<span class="comment">//用于挂载等待代码执行流（线程）结构</span></span><br><span class="line">&#125;<span class="keyword">sem_t</span>;</span><br></pre></td></tr></table></figure><p>搞懂了信号量的结构，我们再来看看信号量的一般用法，注意信号量在使用之前需要<strong>先进行初始化</strong>。这里假定信号量数据结构中的 sem_count 初始化为 1，sem_waitlst 等待链初始化为空。</p><p>使用信号量的步骤，我已经给你列好了。</p><p><strong>第一步，获取信号量。</strong></p><ol><li><p>首先对用于保护信号量自身的自旋锁 sem_lock 进行加锁。</p></li><li><p>对信号值 sem_count 执行“减 1”操作，并检查其值是否小于 0。</p></li><li><p>上步中检查 sem_count 如果小于 0，就让进程进入等待状态并且将其挂入 sem_waitlst 中，然后调度其它进程运行。否则表示获取信号量成功。当然最后别忘了对自旋锁 sem_lock 进行解锁。</p></li></ol><p><strong>第二步，代码执行流开始执行相关操作，例如读取键盘缓冲区。</strong></p><p><strong>第三步，释放信号量。</strong></p><ol><li><p>首先对用于保护信号量自身的自旋锁 sem_lock 进行加锁。</p></li><li><p>对信号值 sem_count 执行“加 1”操作，并检查其值是否大于 0。</p></li><li><p>上步中检查 sem_count 值如果大于 0，就执行唤醒 sem_waitlst 中进程的操作，并且需要调度进程时就执行进程调度操作，不管 sem_count 是否大于 0（通常会大于 0）都标记信号量释放成功。当然最后别忘了对自旋锁 sem_lock 进行解锁。</p></li></ol><p>这里我给你额外分享一个小技巧，<strong>写代码之前我们常常需要先想清楚算法步骤，建议你像我这样分条列出，因为串联很容易含糊其辞，不利于后面顺畅编码。</strong></p><p>好，下面我们来看看实现上述这些功能的代码，按照理论书籍上说，信号量有两个操作：down，up，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">krlsem_down</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">cpuflg_t</span> cpufg;</span><br><span class="line">start_step:    </span><br><span class="line">    krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">    <span class="keyword">if</span>(sem-&gt;sem_count&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;<span class="comment">//如果信号量值小于1,则让代码执行流（线程）睡眠</span></span><br><span class="line">        krlwlst_wait(&amp;sem-&gt;sem_waitlst);</span><br><span class="line">        krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">        krlschedul();<span class="comment">//切换代码执行流，下次恢复执行时依然从下一行开始执行，所以要goto开始处重新获取信号量</span></span><br><span class="line">        <span class="keyword">goto</span> start_step; </span><br><span class="line">    &#125;</span><br><span class="line">    sem-&gt;sem_count--;<span class="comment">//信号量值减1,表示成功获取信号量</span></span><br><span class="line">    krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">krlsem_up</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">cpuflg_t</span> cpufg;</span><br><span class="line">    krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">    sem-&gt;sem_count++;<span class="comment">//释放信号量</span></span><br><span class="line">    <span class="keyword">if</span>(sem-&gt;sem_count&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;<span class="comment">//如果小于1,则说数据结构出错了，挂起系统</span></span><br><span class="line">        krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">        hal_sysdie(<span class="string">"sem up err"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒该信号量上所有等待的代码执行流（线程）</span></span><br><span class="line">    krlwlst_allup(&amp;sem-&gt;sem_waitlst);</span><br><span class="line">    krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">    krlsched_set_schedflgs();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>又到了这节课结束的时候，我们回顾一下今天都讲了什么。我把这节课的内容为你梳理一下，要点如下。</p><ol><li><p>原子变量，在只有<strong>单个变量全局数据</strong>的情况下，这种变量非常实用，如全局计数器、状态标志变量等。我们利用了 CPU 的原子指令实现了一组操作原子变量的函数。</p></li><li><p>中断的控制。当要操作的数据很多的情况下，用原子变量就不适合了。但是我们发现在单核心的 CPU，同一时刻只有一个代码执行流，除了响应中断导致代码执行流切换，不会有其它条件会干扰全局数据的操作，所以我们只要在操作全局数据时关闭或者开启中断就行了，为此我们开发了控制中断的函数。</p></li><li><p>自旋锁。由于多核心的 CPU 出现，控制中断已经失效了，因为<strong>系统中同时有多个代码执行流</strong>，为了解决这个问题，我们开发了自旋锁，自旋锁要么一下子获取锁，要么循环等待最终获取锁。</p></li><li><p>信号量。如果长时间等待后才能获取数据，在这样的情况下，前面中断控制和自旋锁都不能很好地解决，于是我们开发了信号量。信号量由一套数据结构和函数组成，它能使获取数据的代码执行流进入睡眠，然后在相关条件满足时被唤醒，这样就能让 CPU 能有时间处理其它任务。所以信号量同时解决了三个问题：<strong>等待、互斥、唤醒。</strong></p></li></ol><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>请用代码展示一下自旋锁或者信号量，可能的使用形式是什么样的？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>日记_0435</title>
    <link href="https://xwjahahahaha.github.io/2022/12/04/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-12/%E6%97%A5%E8%AE%B0-0435/"/>
    <id>https://xwjahahahaha.github.io/2022/12/04/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-12/%E6%97%A5%E8%AE%B0-0435/</id>
    <published>2022-12-04T04:50:25.000Z</published>
    <updated>2023-07-06T06:07:35.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><a id="more"></a><p>2022:</p><p>3～4月</p><ul><li><input checked="" disabled="" type="checkbox"> 找到一份暑期实习(网易)</li></ul><p>5～6月</p><ul><li><input checked="" disabled="" type="checkbox"> 论文修改重新投稿 5.3<ul><li><input checked="" disabled="" type="checkbox"> 5.16 退修</li><li><input checked="" disabled="" type="checkbox"> 7.4 录用修改</li></ul></li></ul><p>6～7月</p><ul><li><input checked="" disabled="" type="checkbox"> 实习<ul><li><input checked="" disabled="" type="checkbox"> kube-eagle项目</li></ul></li><li><input disabled="" type="checkbox"> 基础知识<ul><li><input disabled="" type="checkbox"> linux内核源码 =&gt; 《深入理解linux内核》</li></ul></li></ul><p>8～10月</p><ul><li><input checked="" disabled="" type="checkbox"> 秋招 =&gt; 工作找的只能说中规中矩，希望春招再试一下</li></ul><p>11月～12月</p><ul><li><input disabled="" type="checkbox"> <p>准备春招</p><ul><li><input disabled="" type="checkbox"> 操作系统、虚拟化方向</li></ul></li><li><input disabled="" type="checkbox"> <p>大论文</p><ul><li><input disabled="" type="checkbox"> 看之前的论文</li><li><input disabled="" type="checkbox"> 中期ppt制作</li><li><input disabled="" type="checkbox"> 论文代码/项目重构</li><li><input disabled="" type="checkbox"> 论文第二个点</li></ul></li><li><input disabled="" type="checkbox"> <p>修整之前实习的项目（考虑中….）</p><ul><li><input disabled="" type="checkbox"> 基于eBPF的云原生profile观测系统项目</li></ul></li><li><input disabled="" type="checkbox"> <p>操作系统45讲-实现一个自己的OS </p></li><li><input disabled="" type="checkbox"> <p>runC项目</p><ul><li><input disabled="" type="checkbox"> 看之前的文档和源码过一遍</li><li><input disabled="" type="checkbox"> 重构源代码、加入seccomp功能 </li><li><input disabled="" type="checkbox"> runC源码项目阅读</li><li><input disabled="" type="checkbox"> OCI 镜像格式标准文件包 bundles</li></ul></li><li><input disabled="" type="checkbox"> <p>看书 </p><ul><li><input disabled="" type="checkbox"> 《C语言程序设计现代方法》（看不懂的地方再找着看，直接过基础枯燥且浪费时间）</li><li><input disabled="" type="checkbox"> 《深入理解计算机系统》CSAPP</li></ul></li><li><input disabled="" type="checkbox"> <p>myMiniDB：C++实现一个简易数据库</p></li><li><input disabled="" type="checkbox"> <p>春招准备：</p><ul><li><input disabled="" type="checkbox"> 总体方向：linux内核开发、虚拟化方向<ul><li><input disabled="" type="checkbox"> c++ <ul><li><input disabled="" type="checkbox"> 《C++ Primer》</li></ul></li><li><input disabled="" type="checkbox"> linux内核<ul><li><input disabled="" type="checkbox"> 《深入理解linux内核》</li></ul></li><li><input disabled="" type="checkbox"> 虚拟化<ul><li><input disabled="" type="checkbox"> 《深度探索linux系统虚拟化》原理与实现</li></ul></li></ul></li></ul></li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 中期<ul><li><input checked="" disabled="" type="checkbox"> 中期报告</li><li><input checked="" disabled="" type="checkbox"> 修改ppt</li></ul></li><li><input disabled="" type="checkbox"> C++实现一个简易数据库<ul><li><input disabled="" type="checkbox"> 3-实现insert和select</li></ul></li><li><input disabled="" type="checkbox"> 《C++ Primer》<ul><li><input disabled="" type="checkbox"> 第八章 IO库</li></ul></li><li><input disabled="" type="checkbox"> 操作系统45讲-实现一个自己的OS <ul><li><input disabled="" type="checkbox"> 07丨Cache与内存：程序放在哪儿？</li></ul></li><li><input disabled="" type="checkbox"> 《深入理解linux内核》<ul><li><input disabled="" type="checkbox"> 第三章 进程  记了笔记还未完成</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0434</title>
    <link href="https://xwjahahahaha.github.io/2022/11/30/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-11/%E6%97%A5%E8%AE%B0-0434/"/>
    <id>https://xwjahahahaha.github.io/2022/11/30/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-11/%E6%97%A5%E8%AE%B0-0434/</id>
    <published>2022-11-30T07:03:54.000Z</published>
    <updated>2023-07-06T06:07:35.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><a id="more"></a><p>2022:</p><p>3～4月</p><ul><li><input checked="" disabled="" type="checkbox"> 找到一份暑期实习(网易)</li></ul><p>5～6月</p><ul><li><input checked="" disabled="" type="checkbox"> 论文修改重新投稿 5.3<ul><li><input checked="" disabled="" type="checkbox"> 5.16 退修</li><li><input checked="" disabled="" type="checkbox"> 7.4 录用修改</li></ul></li></ul><p>6～7月</p><ul><li><input checked="" disabled="" type="checkbox"> 实习<ul><li><input checked="" disabled="" type="checkbox"> kube-eagle项目</li></ul></li><li><input disabled="" type="checkbox"> 基础知识<ul><li><input disabled="" type="checkbox"> linux内核源码 =&gt; 《深入理解linux内核》</li></ul></li></ul><p>8～10月</p><ul><li><input checked="" disabled="" type="checkbox"> 秋招 =&gt; 工作找的只能说中规中矩，希望春招再试一下</li></ul><p>11月～12月</p><ul><li><input disabled="" type="checkbox"> 准备春招<ul><li><input disabled="" type="checkbox"> 操作系统、虚拟化方向</li></ul></li></ul><h2 id="这段时间的待完成任务："><a href="#这段时间的待完成任务：" class="headerlink" title="这段时间的待完成任务："></a>这段时间的待完成任务：</h2><ul><li><input disabled="" type="checkbox"> <p>大论文</p><ul><li><input disabled="" type="checkbox"> 看之前的论文</li><li><input disabled="" type="checkbox"> 中期ppt制作</li><li><input disabled="" type="checkbox"> 论文代码/项目重构</li><li><input disabled="" type="checkbox"> 论文第二个点</li></ul></li><li><input disabled="" type="checkbox"> <p>修整之前实习的项目（考虑中….）</p><ul><li><input disabled="" type="checkbox"> 基于eBPF的云原生profile观测系统项目</li></ul></li><li><input disabled="" type="checkbox"> <p>操作系统45讲-实现一个自己的OS </p></li><li><input disabled="" type="checkbox"> <p>runC项目</p><ul><li><input disabled="" type="checkbox"> 看之前的文档和源码过一遍</li><li><input disabled="" type="checkbox"> 重构源代码、加入seccomp功能 </li><li><input disabled="" type="checkbox"> runC源码项目阅读</li><li><input disabled="" type="checkbox"> OCI 镜像格式标准文件包 bundles</li></ul></li><li><input disabled="" type="checkbox"> <p>看书 </p><ul><li><input disabled="" type="checkbox"> 《C语言程序设计现代方法》（看不懂的地方再找着看，直接过基础枯燥且浪费时间）</li><li><input disabled="" type="checkbox"> 《深入理解计算机系统》CSAPP</li></ul></li><li><input disabled="" type="checkbox"> <p>myMiniDB：C++实现一个简易数据库</p></li><li><input disabled="" type="checkbox"> <p>春招准备：</p><ul><li><input disabled="" type="checkbox"> 总体方向：linux内核开发、虚拟化方向<ul><li><input disabled="" type="checkbox"> c++ <ul><li><input disabled="" type="checkbox"> 《C++ Primer》</li></ul></li><li><input disabled="" type="checkbox"> linux内核<ul><li><input disabled="" type="checkbox"> 《深入理解linux内核》</li></ul></li><li><input disabled="" type="checkbox"> 虚拟化<ul><li><input disabled="" type="checkbox"> 《深度探索linux系统虚拟化》原理与实现</li></ul></li></ul></li></ul></li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> C++实现一个简易数据库<ul><li><input checked="" disabled="" type="checkbox"> 2-实现解析前端与虚拟机</li><li><input disabled="" type="checkbox"> 3-实现insert和select</li></ul></li><li><input checked="" disabled="" type="checkbox"> 《C++ Primer》<ul><li><input checked="" disabled="" type="checkbox"> 第七章 类</li></ul></li><li><input checked="" disabled="" type="checkbox"> 回顾操作系统45讲前面的内容</li><li><input disabled="" type="checkbox"> 操作系统45讲-实现一个自己的OS <ul><li><input disabled="" type="checkbox"> 07丨Cache与内存：程序放在哪儿？</li></ul></li><li><input disabled="" type="checkbox"> 《深入理解linux内核》<ul><li><input disabled="" type="checkbox"> 第三章 进程  记了笔记还未完成</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2-实现解析前端和虚拟机</title>
    <link href="https://xwjahahahaha.github.io/2022/11/29/%E6%8A%80%E6%9C%AF%E8%B4%B4/C++/c++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E6%95%B0%E6%8D%AE%E5%BA%93-MyMiniDB/2-%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90%E5%89%8D%E7%AB%AF%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://xwjahahahaha.github.io/2022/11/29/%E6%8A%80%E6%9C%AF%E8%B4%B4/C++/c++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E6%95%B0%E6%8D%AE%E5%BA%93-MyMiniDB/2-%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90%E5%89%8D%E7%AB%AF%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2022-11-29T13:54:21.000Z</published>
    <updated>2023-07-06T06:07:34.919Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><blockquote><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/463791156" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/463791156</a></li></ul></blockquote><h1 id="一、修改测试代码"><a href="#一、修改测试代码" class="headerlink" title="一、修改测试代码"></a>一、修改测试代码</h1><p>因为是测试驱动，所以第一步修改我们的测试代码以适配新的需求开发：</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">describe <span class="string">'database'</span> <span class="keyword">do</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_script</span><span class="params">(commands)</span></span></span><br><span class="line">        raw_output = <span class="literal">nil</span></span><br><span class="line">        IO.popen(<span class="string">"./db"</span>, <span class="string">"r+"</span>) <span class="keyword">do</span> <span class="params">|pipe|</span></span><br><span class="line">            commands.each <span class="keyword">do</span> <span class="params">|command|</span></span><br><span class="line">                pipe.puts command</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            pipe.close_write</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Read entire ouput</span></span><br><span class="line">            raw_output = pipe.gets(<span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        raw_output.split(<span class="string">"\n"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    it <span class="string">'test exit and unrecognized command'</span> <span class="keyword">do</span> </span><br><span class="line">        result = run_script([</span><br><span class="line">            <span class="string">"hello world"</span>,</span><br><span class="line">            <span class="string">".HELLO WORLD"</span>,</span><br><span class="line">            <span class="string">".exit"</span>,</span><br><span class="line">        ])</span><br><span class="line">        expect(result).to match_array([</span><br><span class="line">            <span class="string">"db &gt; Unrecognized keyword at start of 'hello world'."</span>,</span><br><span class="line">            <span class="string">"db &gt; Unrecognized command: .HELLO WORLD"</span>,</span><br><span class="line">            <span class="string">"db &gt; Bye!"</span>,</span><br><span class="line">        ])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    it <span class="string">'test insert and select'</span> <span class="keyword">do</span></span><br><span class="line">        result = run_script([</span><br><span class="line">            <span class="string">"insert 1 user1"</span>,</span><br><span class="line">            <span class="string">"select"</span>,</span><br><span class="line">            <span class="string">".exit"</span>,</span><br><span class="line">        ])</span><br><span class="line">        expect(result).to match_array([</span><br><span class="line">            <span class="string">"db &gt; Executing insert statement"</span>,</span><br><span class="line">            <span class="string">"db &gt; Executing select statement"</span>,</span><br><span class="line">            <span class="string">"db &gt; Bye!"</span>,</span><br><span class="line">        ])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="二、解析前端"><a href="#二、解析前端" class="headerlink" title="二、解析前端"></a>二、解析前端</h1><ul><li>SQL的解析前端是什么？</li></ul><p>它将传统输入的<code>string</code>字符串，解析成可被机器识别的字节码内部表现形式，并传递给虚拟机进一步执行</p><ul><li>怎么实现一个SQL的解析前端？</li></ul><p>先从我们上一章所解析的<code>command</code>来看起。我们将以<code>.</code>开头的非sql语句称作元命令 <strong><em>(meta command)</em></strong> 所以我们在一开始就检查是否以其开头，并单独封装一个<code>do_meta_command</code>函数来处理它</p><p>前端需要修改的所有代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元命令结果</span></span><br><span class="line"><span class="keyword">enum</span> MetaCommandResult &#123;</span><br><span class="line">    META_COMMAND_SUCCESS,</span><br><span class="line">    META_COMMAND_UNRECONGNIZED,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sql前端解析结果</span></span><br><span class="line"><span class="keyword">enum</span> PrepareResult &#123;</span><br><span class="line">    PREPARE_SUCCESS,</span><br><span class="line">    PREPARE_UNRECONGNIZED,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sql状态类型</span></span><br><span class="line"><span class="keyword">enum</span> StatementType &#123;</span><br><span class="line">    STATEMENT_INSERT,</span><br><span class="line">    STATEMENT_SELECT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Statement</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StatementType type;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parse_meta_command</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line">    <span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line">    <span class="function">PrepareResult <span class="title">prepare_statement</span><span class="params">(<span class="built_in">string</span>&amp;, Statement&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parse_statement</span><span class="params">(<span class="built_in">string</span>&amp;, Statement&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute_statement</span><span class="params">(Statement&amp;)</span></span>; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_prompt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DB::print_prompt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"db &gt; "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析元命令</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DB::parse_meta_command</span><span class="params">(<span class="built_in">string</span> command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command[<span class="number">0</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (do_meta_command(command.substr(<span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="keyword">case</span> META_COMMAND_SUCCESS:</span><br><span class="line">        <span class="keyword">case</span> META_COMMAND_UNRECONGNIZED:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unrecognized command: "</span> &lt;&lt; command &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;            <span class="comment">// 只要前缀是.则都属于元命令</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行元命令</span></span><br><span class="line"><span class="function">MetaCommandResult <span class="title">DB::do_meta_command</span><span class="params">(<span class="built_in">string</span> command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="string">"exit"</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bye!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> META_COMMAND_UNRECONGNIZED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断前端状态</span></span><br><span class="line"><span class="function">PrepareResult <span class="title">DB::prepare_statement</span><span class="params">(<span class="built_in">string</span> &amp;input_line, Statement &amp;statement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!input_line.compare(<span class="number">0</span>, <span class="number">6</span>, <span class="string">"insert"</span>)) &#123;        <span class="comment">// 只有相同为0时才进入</span></span><br><span class="line">        statement.type = STATEMENT_INSERT;</span><br><span class="line">        <span class="keyword">return</span> PREPARE_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!input_line.compare(<span class="number">0</span>, <span class="number">6</span>, <span class="string">"select"</span>)) &#123;</span><br><span class="line">        statement.type = STATEMENT_SELECT;</span><br><span class="line">        <span class="keyword">return</span> PREPARE_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PREPARE_UNRECONGNIZED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析前端状态</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DB::parse_statement</span><span class="params">(<span class="built_in">string</span> &amp;input_line, Statement &amp;statement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (prepare_statement(input_line, statement)) &#123;</span><br><span class="line">    <span class="keyword">case</span> PREPARE_SUCCESS:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;               </span><br><span class="line">    <span class="keyword">case</span> PREPARE_UNRECONGNIZED:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unrecognized keyword at start of '"</span> &lt;&lt; input_line &lt;&lt; <span class="string">"'."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;             </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码以及注释来看，理解起来应该不是很难，据此我们能够根据输入获得当前的状态</p><h1 id="三、虚拟机"><a href="#三、虚拟机" class="headerlink" title="三、虚拟机"></a>三、虚拟机</h1><p>其实感觉这里叫“虚拟机”可能叫做状态机更加合适一点，目前此部分仅仅是简单的演示（输出）一下sql执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行当前状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DB::execute_statement</span><span class="params">(Statement &amp;statement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (statement.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> STATEMENT_INSERT:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Executing insert statement"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> STATEMENT_SELECT:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Executing select statement"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DB::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        print_prompt();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> input_line;</span><br><span class="line">        getline(<span class="built_in">cin</span>, input_line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析元命令</span></span><br><span class="line">        <span class="keyword">if</span> (parse_meta_command(input_line)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Statement statement;</span><br><span class="line">        <span class="comment">// 解析状态</span></span><br><span class="line">        <span class="keyword">if</span> (parse_statement(input_line, statement)) &#123;</span><br><span class="line">            execute_statement(statement);           <span class="comment">// 解析后执行状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后跑一下测试案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ db.cpp -o db</span><br><span class="line">rspec spec db_test.rb</span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221129231530718.png" alt="image-20221129231530718"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>日记_0433</title>
    <link href="https://xwjahahahaha.github.io/2022/11/29/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-11/%E6%97%A5%E8%AE%B0-0433/"/>
    <id>https://xwjahahahaha.github.io/2022/11/29/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-11/%E6%97%A5%E8%AE%B0-0433/</id>
    <published>2022-11-29T01:01:37.000Z</published>
    <updated>2023-07-06T06:07:35.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><a id="more"></a><p>2022:</p><p>3～4月</p><ul><li><input checked="" disabled="" type="checkbox"> 找到一份暑期实习(网易)</li></ul><p>5～6月</p><ul><li><input checked="" disabled="" type="checkbox"> 论文修改重新投稿 5.3<ul><li><input checked="" disabled="" type="checkbox"> 5.16 退修</li><li><input checked="" disabled="" type="checkbox"> 7.4 录用修改</li></ul></li></ul><p>6～7月</p><ul><li><input checked="" disabled="" type="checkbox"> 实习<ul><li><input checked="" disabled="" type="checkbox"> kube-eagle项目</li></ul></li><li><input disabled="" type="checkbox"> 基础知识<ul><li><input disabled="" type="checkbox"> linux内核源码 =&gt; 《深入理解linux内核》</li></ul></li></ul><p>8～10月</p><ul><li><input checked="" disabled="" type="checkbox"> 秋招 =&gt; 工作找的只能说中规中矩，希望春招再试一下</li></ul><p>11月～12月</p><ul><li><input disabled="" type="checkbox"> 准备春招<ul><li><input disabled="" type="checkbox"> 操作系统、虚拟化方向</li></ul></li></ul><h2 id="这段时间的待完成任务："><a href="#这段时间的待完成任务：" class="headerlink" title="这段时间的待完成任务："></a>这段时间的待完成任务：</h2><ul><li><input disabled="" type="checkbox"> <p>大论文</p><ul><li><input disabled="" type="checkbox"> 看之前的论文</li><li><input disabled="" type="checkbox"> 中期ppt制作</li><li><input disabled="" type="checkbox"> 论文代码/项目重构</li><li><input disabled="" type="checkbox"> 论文第二个点</li></ul></li><li><input disabled="" type="checkbox"> <p>修整之前实习的项目</p><ul><li><input disabled="" type="checkbox"> 基于eBPF的云原生profile观测系统项目</li></ul></li><li><input disabled="" type="checkbox"> <p>操作系统45讲-实现一个自己的OS </p></li><li><input disabled="" type="checkbox"> <p>runC项目</p><ul><li><input disabled="" type="checkbox"> 看之前的文档和源码过一遍</li><li><input disabled="" type="checkbox"> 重构源代码、加入seccomp功能 </li><li><input disabled="" type="checkbox"> runC源码项目阅读</li><li><input disabled="" type="checkbox"> OCI 镜像格式标准文件包 bundles</li></ul></li><li><input disabled="" type="checkbox"> <p>看书 </p><ul><li><input disabled="" type="checkbox"> 《C语言程序设计现代方法》（看不懂的地方再找着看，直接过基础枯燥且浪费时间）</li><li><input disabled="" type="checkbox"> 《深入理解计算机系统》CSAPP</li></ul></li><li><input disabled="" type="checkbox"> <p>myMiniDB：C++实现一个简易数据库</p></li><li><input disabled="" type="checkbox"> <p>春招准备：</p><ul><li><input disabled="" type="checkbox"> 总体方向：linux内核开发、虚拟化方向<ul><li><input disabled="" type="checkbox"> c++ <ul><li><input disabled="" type="checkbox"> 《C++ Primer》</li></ul></li><li><input disabled="" type="checkbox"> linux内核<ul><li><input disabled="" type="checkbox"> 《深入理解linux内核》<ul><li><input disabled="" type="checkbox"> 第三章 进程  记了笔记还未完成</li></ul></li></ul></li><li><input disabled="" type="checkbox"> 虚拟化<ul><li><input disabled="" type="checkbox"> 《深度探索linux系统虚拟化》原理与实现</li></ul></li></ul></li></ul></li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> C++实现一个简易数据库<ul><li><input disabled="" type="checkbox"> 2-实现解析前端与虚拟机</li><li><input disabled="" type="checkbox"> 3-实现insert和select</li></ul></li><li><input checked="" disabled="" type="checkbox"> 《C++ Primer》<ul><li><input checked="" disabled="" type="checkbox"> 第七章 类</li></ul></li><li><input disabled="" type="checkbox"> 回顾操作系统45讲前面的内容</li><li><input disabled="" type="checkbox"> 操作系统45讲-实现一个自己的OS <ul><li><input disabled="" type="checkbox"> 07丨Cache与内存：程序放在哪儿？</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>myMiniDB:c++实现简易数据库-1-基本架构和环境构建</title>
    <link href="https://xwjahahahaha.github.io/2022/11/28/%E6%8A%80%E6%9C%AF%E8%B4%B4/C++/c++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E6%95%B0%E6%8D%AE%E5%BA%93-MyMiniDB/1-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%92%8C%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/"/>
    <id>https://xwjahahahaha.github.io/2022/11/28/%E6%8A%80%E6%9C%AF%E8%B4%B4/C++/c++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E6%95%B0%E6%8D%AE%E5%BA%93-MyMiniDB/1-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%92%8C%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/</id>
    <published>2022-11-28T13:45:43.000Z</published>
    <updated>2023-07-06T06:07:34.919Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><blockquote><p>学习自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/463791156" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/463791156</a></li></ul></blockquote><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>秋招后的封控日子里，因为实在是无聊到游戏都已经玩腻，所以决定重整旗鼓开始学习，因为本身一直想学习C++，这次在看完《C++ Primer》第一部分后实在觉得直接撸书太无聊（是我现在太浮躁了吗…），遂找个项目想边做边练（当然遇到无法理解的内容便会重新滚回去看书了…）</p><p>因为网上C++相关的httpd项目太多了，所以找了一个实现简易数据库的项目来做，学习资料来自<a href="https://www.zhihu.com/column/c_1472652536327389184" target="_blank" rel="noopener">知乎大佬：[氰化钾不爱打代码]</a></p><p>大佬对应代码的github在于：<a href="https://github.com/KCNyu/db_tutorial_cpp" target="_blank" rel="noopener">https://github.com/KCNyu/db_tutorial_cpp</a></p><p>我的学习仓库在于：<a href="https://github.com/xwjahahahaha/myMiniDB" target="_blank" rel="noopener">https://github.com/xwjahahahaha/myMiniDB</a></p><blockquote><p>因为大佬已经写了详细的tutorial，所以我只会在此记录核心内容 &amp; 疑问/问题 &amp; 扩充的理解？/ 后续能拓展的功能？，算是一个输出的途径吧…</p><p>所以文章内容转载居多，当然阅读的你也可以看原文学习后写点心得</p></blockquote><h1 id="二、项目基本架构"><a href="#二、项目基本架构" class="headerlink" title="二、项目基本架构"></a>二、项目基本架构</h1><p>最终实现的架构如图：</p><img src="https://pic4.zhimg.com/80/v2-342ade98e4b2c50cfe2eb6513c0f8d17_1440w.webp" alt="img" style="zoom: 67%;" /><p>前端 <strong><em>(front-end)</em></strong> （对应图中的<code>SQL Compiler</code>）</p><ul><li>分词器 <strong><em>(tokenizer)</em></strong></li><li>解析器 <strong><em>(parser)</em></strong></li><li>代码生成器 <strong><em>(code generator)</em></strong></li></ul><p>后端 <strong><em>(back-end)</em></strong></p><ul><li>虚拟机 <strong><em>(virtual machine)</em></strong></li><li>B树 <strong><em>(B-tree)</em></strong></li><li>分页 <strong><em>(pager)</em></strong></li><li>操作系统层接口 <strong><em>(os interface)</em></strong></li></ul><p><code>Accessories</code>部分：项目采用TDD的模式，也就是测试驱动开发，简单来说就是先写测试再写核心逻辑代码，跑过了就算完成一个需求</p><p>在此补一张MySQL的基本架构图：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221128215748760.png" alt="image-20221128215748760" style="zoom:50%;" /><p>（感觉麻雀虽小但是已经五脏俱全了！虽然没有链接池）</p><h1 id="三、环境搭建"><a href="#三、环境搭建" class="headerlink" title="三、环境搭建"></a>三、环境搭建</h1><p>安装测试环境需要的软件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y ruby gem</span><br><span class="line">sudo gem install rspec    # gem应该是和apt一样的linux上的包管理工具</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://rspec.info/" target="_blank" rel="noopener">RSpec</a> is a testing tool for Ruby, created for behavior-driven development (BDD). rspec是一个专门用来测试ruby的测试工具，下面的代码就可以看出来与一般语言的测试框架大查不查，很容易看懂</p></blockquote><p>编写第一个测试文件：</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">describe <span class="string">'database'</span> <span class="keyword">do</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_script</span><span class="params">(commands)</span></span></span><br><span class="line">        raw_output = <span class="literal">nil</span></span><br><span class="line">        IO.popen(<span class="string">"./db"</span>, <span class="string">"r+"</span>) <span class="keyword">do</span> <span class="params">|pipe|</span></span><br><span class="line">            commands.each <span class="keyword">do</span> <span class="params">|command|</span></span><br><span class="line">                pipe.puts command</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            pipe.close_write</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Read entire ouput</span></span><br><span class="line">            raw_output = pipe.gets(<span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        raw_output.split(<span class="string">"\n"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    it <span class="string">'test exit and unrecognized command'</span> <span class="keyword">do</span> </span><br><span class="line">        result = run_script([</span><br><span class="line">            <span class="string">"hello world"</span>,</span><br><span class="line">            <span class="string">"HELLO WORLD"</span>,</span><br><span class="line">            <span class="string">".exit"</span>,</span><br><span class="line">        ])</span><br><span class="line">        expect(result).to match_array([</span><br><span class="line">            <span class="string">"db &gt; Unrecognized command: hello world"</span>,</span><br><span class="line">            <span class="string">"db &gt; Unrecognized command: HELLO WORLD"</span>,</span><br><span class="line">            <span class="string">"db &gt; Bye!"</span>,</span><br><span class="line">        ])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>结果显示当然是错误的，因为我们没有db文件：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221128223218266.png" alt="image-20221128223218266" style="zoom:50%;" /><p>REPL：“读取-求值-输出”循环 <strong><em>(英語：Read-Eval-Print Loop，简称REPL)</em></strong>，也被称做交互式顶层构件 <strong><em>(英語：interactive toplevel)</em></strong>，是一个简单的，交互式的编程环境。</p><p>先实现和一个简易版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_prompt</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parse_meta_command</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DB::print_prompt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"db &gt; "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析元命令</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DB::parse_meta_command</span><span class="params">(<span class="built_in">string</span> command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="string">".exit"</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bye!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unrecognized command: "</span> &lt;&lt; command &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DB::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        print_prompt();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> input_line;</span><br><span class="line">        getline(<span class="built_in">cin</span>, input_line);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parse_meta_command(input_line)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    DB db;</span><br><span class="line">    db.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后并再次测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ db.cpp -o db</span><br><span class="line">rspec spec db_test.rb</span><br></pre></td></tr></table></figure><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221129001047365.png" alt="image-20221129001047365" style="zoom: 67%;" /><p>测试成功！nice</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>日记_0432</title>
    <link href="https://xwjahahahaha.github.io/2022/11/28/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-11/%E6%97%A5%E8%AE%B0-0432/"/>
    <id>https://xwjahahahaha.github.io/2022/11/28/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-11/%E6%97%A5%E8%AE%B0-0432/</id>
    <published>2022-11-28T06:16:25.000Z</published>
    <updated>2023-07-06T06:07:35.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><a id="more"></a><p>2022:</p><p>3～4月</p><ul><li><input checked="" disabled="" type="checkbox"> 找到一份暑期实习(网易)</li></ul><p>5～6月</p><ul><li><input checked="" disabled="" type="checkbox"> 论文修改重新投稿 5.3<ul><li><input checked="" disabled="" type="checkbox"> 5.16 退修</li><li><input checked="" disabled="" type="checkbox"> 7.4 录用修改</li></ul></li></ul><p>6～7月</p><ul><li><input checked="" disabled="" type="checkbox"> 实习<ul><li><input checked="" disabled="" type="checkbox"> kube-eagle项目</li></ul></li><li><input disabled="" type="checkbox"> 基础知识<ul><li><input disabled="" type="checkbox"> linux内核源码 =&gt; 《深入理解linux内核》</li></ul></li></ul><p>8～10月</p><ul><li><input checked="" disabled="" type="checkbox"> 秋招 =&gt; 工作找的只能说中规中矩，希望春招再试一下</li></ul><p>11月～12月</p><ul><li><input disabled="" type="checkbox"> 准备春招<ul><li><input disabled="" type="checkbox"> 操作系统内核、虚拟化方向</li></ul></li></ul><h2 id="这段时间的待完成任务："><a href="#这段时间的待完成任务：" class="headerlink" title="这段时间的待完成任务："></a>这段时间的待完成任务：</h2><ul><li><input disabled="" type="checkbox"> <p>大论文</p><ul><li><input disabled="" type="checkbox"> <font color='#39b54a'>看之前的论文</font></li><li><input disabled="" type="checkbox"> 中期ppt制作</li><li><input disabled="" type="checkbox"> 论文代码/项目重构</li><li><input disabled="" type="checkbox"> 论文第二个点</li></ul></li><li><input disabled="" type="checkbox"> <p>修整之前实习的项目</p><ul><li><input disabled="" type="checkbox"> 基于eBPF的云原生profile观测系统项目</li></ul></li><li><input disabled="" type="checkbox"> <p>操作系统45讲-实现一个自己的OS </p></li><li><input disabled="" type="checkbox"> <p>runC项目</p><ul><li><input disabled="" type="checkbox"> 看之前的文档和源码过一遍</li><li><input disabled="" type="checkbox"> 重构源代码、加入seccomp功能 </li><li><input disabled="" type="checkbox"> runC源码项目阅读</li><li><input disabled="" type="checkbox"> OCI 镜像格式标准文件包 bundles</li></ul></li><li><input disabled="" type="checkbox"> <p>看书 </p><ul><li><input disabled="" type="checkbox"> 《C语言程序设计现代方法》（看不懂的地方再找着看，直接过基础枯燥且浪费时间）</li><li><input disabled="" type="checkbox"> 《深入理解计算机系统》CSAPP</li></ul></li><li><input disabled="" type="checkbox"> <p>C++实现一个简易数据库</p><ul><li><input checked="" disabled="" type="checkbox"> 1-基本架构和环境构建</li></ul></li><li><input disabled="" type="checkbox"> <p>春招准备：</p><ul><li><input disabled="" type="checkbox"> 总体方向：linux内核开发、虚拟化方向<ul><li><input disabled="" type="checkbox"> c++ <ul><li><input disabled="" type="checkbox"> 《C++ Primer》</li></ul></li><li><input disabled="" type="checkbox"> linux内核<ul><li><input disabled="" type="checkbox"> 《深入理解linux内核》<ul><li><input disabled="" type="checkbox"> 第三章 进程  记了笔记还未完成</li></ul></li></ul></li><li><input disabled="" type="checkbox"> 虚拟化<ul><li><input disabled="" type="checkbox"> 《深度探索linux系统虚拟化》原理与实现</li></ul></li></ul></li></ul></li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> C++实现一个简易数据库<ul><li><input checked="" disabled="" type="checkbox"> 1-基本架构和环境构建</li></ul></li><li><input disabled="" type="checkbox"> 《C++ Primer》<ul><li><input disabled="" type="checkbox"> 第七章 类</li></ul></li><li><input disabled="" type="checkbox"> 回顾操作系统45讲前面的内容</li><li><input disabled="" type="checkbox"> 操作系统45讲-实现一个自己的OS <ul><li><input disabled="" type="checkbox"> 07丨Cache与内存：程序放在哪儿？</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0431</title>
    <link href="https://xwjahahahaha.github.io/2022/11/14/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-11/%E6%97%A5%E8%AE%B0-0431/"/>
    <id>https://xwjahahahaha.github.io/2022/11/14/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-11/%E6%97%A5%E8%AE%B0-0431/</id>
    <published>2022-11-14T05:17:35.000Z</published>
    <updated>2023-07-06T06:07:35.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><a id="more"></a><p>3～4月</p><ul><li><input checked="" disabled="" type="checkbox"> 找到一份暑期实习(网易)</li></ul><p>5～6月</p><ul><li><input checked="" disabled="" type="checkbox"> 论文修改重新投稿 5.3<ul><li><input checked="" disabled="" type="checkbox"> 5.16 退修</li><li><input checked="" disabled="" type="checkbox"> 7.4 录用修改</li></ul></li></ul><p>6～7月</p><ul><li><input checked="" disabled="" type="checkbox"> 实习<ul><li><input checked="" disabled="" type="checkbox"> kube-eagle项目</li></ul></li><li><input disabled="" type="checkbox"> 基础知识<ul><li><input disabled="" type="checkbox"> linux内核源码 =&gt; 《深入理解linux内核》</li></ul></li></ul><p>8～10月</p><ul><li><input disabled="" type="checkbox"> 秋招</li></ul><h2 id="这段时间的待完成任务："><a href="#这段时间的待完成任务：" class="headerlink" title="这段时间的待完成任务："></a>这段时间的待完成任务：</h2><ul><li><input disabled="" type="checkbox"> </li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> <p>大论文</p><ul><li><input disabled="" type="checkbox"> <font color='#39b54a'>看之前的论文</font></li><li><input disabled="" type="checkbox"> 中期ppt制作</li><li><input disabled="" type="checkbox"> 论文代码/项目重构</li><li><input disabled="" type="checkbox"> 论文第二个点</li></ul></li><li><input disabled="" type="checkbox"> <p>修整之前实习的项目</p><ul><li><input disabled="" type="checkbox"> 基于eBPF的云原生profile观测系统项目</li></ul></li><li><input disabled="" type="checkbox"> <p><font color='#39b54a'>操作系统45讲-实现一个自己的OS </font></p><ul><li><input disabled="" type="checkbox"> 07丨Cache与内存：程序放在哪儿？</li></ul></li><li><input disabled="" type="checkbox"> <p>runC项目</p><ul><li><input disabled="" type="checkbox"> 看之前的文档和源码过一遍</li><li><input disabled="" type="checkbox"> 重构源代码、加入seccomp功能 </li><li><input disabled="" type="checkbox"> runC源码项目阅读</li><li><input disabled="" type="checkbox"> OCI 镜像格式标准文件包 bundles</li></ul></li><li><input disabled="" type="checkbox"> <p>看书 </p><ul><li><input disabled="" type="checkbox"> 《C语言程序设计现代方法》（看不懂的地方再找着看，直接过基础枯燥且浪费时间）</li><li><input disabled="" type="checkbox"> 《深入理解计算机系统》CSAPP</li></ul></li><li><input disabled="" type="checkbox"> <p>春招准备：</p><ul><li><input disabled="" type="checkbox"> 总体方向：linux内核开发、虚拟化方向<ul><li><input disabled="" type="checkbox"> c++ <ul><li><input disabled="" type="checkbox"> <font color='#39b54a'>《C++ Primer》</font><ul><li><input disabled="" type="checkbox"> 第七章 类</li></ul></li></ul></li><li><input disabled="" type="checkbox"> linux内核<ul><li><input disabled="" type="checkbox"> 《深入理解linux内核》<ul><li><input disabled="" type="checkbox"> 第三章 进程  记了笔记还未完成</li></ul></li></ul></li><li><input disabled="" type="checkbox"> 虚拟化<ul><li><input disabled="" type="checkbox"> 《深度探索linux系统虚拟化》原理与实现</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>5-Cache与内存:程序放在哪儿？</title>
    <link href="https://xwjahahahaha.github.io/2022/10/27/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F45%E8%AE%B2%E3%80%8B/5-Cache%E4%B8%8E%E5%86%85%E5%AD%98-%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%9C%A8%E5%93%AA%E5%84%BF%EF%BC%9F/"/>
    <id>https://xwjahahahaha.github.io/2022/10/27/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F45%E8%AE%B2%E3%80%8B/5-Cache%E4%B8%8E%E5%86%85%E5%AD%98-%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%9C%A8%E5%93%AA%E5%84%BF%EF%BC%9F/</id>
    <published>2022-10-27T03:10:36.000Z</published>
    <updated>2023-07-06T06:07:34.949Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><blockquote><p>参考：</p><ul><li>极客时间-《操作系统45讲》<ul><li>购买地址： <a href="https://time.geekbang.org/column/intro/100078401" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/100078401</a> </li><li>作者：LMOS</li></ul></li></ul></blockquote><h1 id="Cache与内存-程序放在哪儿？"><a href="#Cache与内存-程序放在哪儿？" class="headerlink" title="Cache与内存: 程序放在哪儿？"></a>Cache与内存: 程序放在哪儿？</h1><p>在前面的课程里，我们已经知道了 CPU 是如何执行程序的，也研究了程序的地址空间，这里我们终于到了程序的存放地点——内存。</p><p>你知道什么是 Cache 吗？在你心中，真实的内存又是什么样子呢？今天我们就来重新认识一下 Cache 和内存，这对我们利用 Cache 写出高性能的程序代码和实现操作系统管理内存，有着巨大的帮助</p><p>通过这节课的内容，我们一起来看看内存到底是啥，它有什么特性。有了这个认识，你就能更加深入地理解我们看似熟悉的<strong>局部性原理</strong>，从而搞清楚，为啥 <strong>Cache 是解决内存瓶颈的神来之笔</strong>。最后，我还会带你分析 x86 平台上的 Cache，规避 Cache 引发的一致性问题，并让你掌握获取内存视图的方法。</p><p>那话不多说，带着刚才的问题，我们正式进入今天的学习吧！</p><h2 id="从一段“经典”代码看局部性原理"><a href="#从一段“经典”代码看局部性原理" class="headerlink" title="从一段“经典”代码看局部性原理"></a>从一段“经典”代码看局部性原理</h2><p>不知道，你还记不记得 C 语言打印九九乘法表的代码，想不起来也没关系，下面我把它贴出来，代码很短，也很简单，就算你自己写一个也用不了一分钟，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;        </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d*%d=%2d  "</span>,i,j,i*j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们当然不是为了研究代码本身，这个代码非常简单，这里我们主要是观察这个结构，代码的结构主要是<strong>顺序、分支、循环</strong>，这三种结构可以写出现存所有算法的程序。</p><p>我们常规情况下写的代码是顺序和循环结构居多。上面的代码中有两重循环，内层循环的次数受到外层循环变量的影响。就是这么简单，但是越简单的东西越容易看到本质。</p><p>可以看到，这个代码大数时间在执行一个乘法计算和调用一个 printf 函数，而程序一旦编译装载进内存中，它的地址就确定了。也就是说，<strong>CPU 大多数时间在访问相同或者与此相邻的地址</strong>，换句话说就是：CPU 大多数时间在执行相同的指令或者与此相邻的指令。这就是大名鼎鼎的<strong>程序局部性原理</strong></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>明白了程序的局部性原理之后，我们再来看看内存。你或许感觉这跨越有点大，但是只有明白了内存的结构和特性，你才能明白程序局部性原理的应用场景和它的重要性</p><p>内存也可称为主存，不管硬盘多大、里面存放了多少程序和数据，只要程序运行或者数据要进行计算处理，就必须先将它们装入内存。我们先来看看内存长什么样（你也可以上网自行搜索），如下图所示:</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221130183950725.png" alt="image-20221130183950725" style="zoom:50%;" /><p>从上图可以看到在 PCB 板上有内存颗粒芯片，主要是用来存放数据的。SPD 芯片用于存放内存自身的容量、频率、厂商等信息。还有最显眼的金手指，用于连接数据总线和地址总线，电源等。</p><p>其实从专业角度讲，内存应该叫 <strong>DRAM</strong>，即<strong>动态随机存储器</strong>。内存储存颗粒芯片中的存储单元是由电容和相关元件做成的，电容存储电荷的多、少代表数字信号 0 和 1。</p><p>而随着时间的流逝，电容存在漏电现象，这导致电荷不足，就会让存储单元的数据出错，所以 <strong>DRAM 需要周期性刷新</strong>，以保持电荷状态。DRAM 结构较简单且集成度很高，通常用于制造内存条中的储存颗粒芯片。</p><p>虽然内存技术标准不断更新，但是储存颗粒的内部结构没有本质改变，还是电容存放电荷，标准看似更多，实际上只是提升了位宽、工作频率，以及传输时预取的数据位数。</p><p>比如 DDR SDRAM，即双倍速率同步动态随机存储器，它使用 2.5V 的工作电压，数据位宽为 64 位，核心频率最高为 166MHz。下面简称 DDR 内存，它表示每一个时钟脉冲传输两次数据，分别在时钟脉冲的上升沿和下降沿各传输一次数据，因此称为双倍速率的 SDRAM。</p><p>后来的 DDR2、DDR3、DDR4 也都在核心频率和预取位数上做了提升。最新的 DDR4 采用 1.2V 工作电压，数据位宽为 64 位，预取 16 位数据。DDR4 取消了双通道机制，一条内存即为一条通道，工作频率最高可达 4266MHz，单根 DDR4 内存的数据传输带宽最高为 34GB/s。</p><p>其实我们无需过多关注内存硬件层面的技术规格标准，重点需要关注的是，<strong>内存的速度还有逻辑上内存和系统的连接方式和结构</strong>，这样你就能意识到内存有多慢，还有是什么原因导致内存慢的。</p><p>我们还是画幅图说明吧，如下图所示:</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221130184448864.png" alt="image-20221130184448864" style="zoom:50%;" /><p>结合图片我们看到，<strong>控制内存刷新和内存读写的是内存控制器，而内存控制器集成在北桥芯片中</strong>。传统方式下，北桥芯片存在于系统主板上，而现在由于芯片制造工艺的升级，芯片集成度越来越高，所以北桥芯片被就集成到 CPU 芯片中了，同时这也大大提升了 CPU 访问内存的性能。</p><p>而作为软件开发人员，从逻辑上我们只需要把内存看成一个巨大的字节数组就可以，而内存地址就是这个数组的下标。</p><h2 id="CPU-到内存的性能瓶颈"><a href="#CPU-到内存的性能瓶颈" class="headerlink" title="CPU 到内存的性能瓶颈"></a>CPU 到内存的性能瓶颈</h2><p>尽管 CPU 和内存是同时代发展的，但 CPU 所使用技术工艺的材料和内存是不同的，侧重点也不同，价格也不同。如果内存使用 CPU 的工艺和材料制造，那内存条的昂贵程度会超乎想象，没有多少人能买得起。</p><p>由于这些不同，导致了 CPU 和内存条的数据吞吐量天差地别。尽管最新的 DDR4 内存条带宽高达 34GB/s，然而这相比 CPU 的数据吞吐量要慢上几个数量级。再加上多核心 CPU 同时访问内存，会导致总线争用问题，数据吞吐量会进一步下降。</p><p>CPU 要数据，内存一时给不了怎么办？CPU 就得等，通常 CPU 会让总线插入等待时钟周期，直到内存准备好，到这里你就会发现，无论 CPU 的性能多高都没用，而<strong>内存才是决定系统整体性能的关键</strong>。显然依靠目前的理论直接提升内存性能，达到 CPU 的同等水平，这是不可行的，得想其它的办法</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>让我们重新回到前面的场景中，回到程序的局部性原理，它告诉我们：CPU 大多数时间在访问相同或者与此相邻的地址。那么，我们立马就可以想到用一块<strong>小而快</strong>的储存器，放在 CPU 和内存之间，就可以利用程序的局部性原理来缓解 CPU 和内存之间的性能瓶颈。这块<strong>小而快</strong>的储存器就是 Cache，即<strong>高速缓存</strong>。</p><p>Cache 中存放了内存中的一部分数据，CPU 在访问内存时要先访问 Cache，若 Cache 中有需要的数据就直接从 Cache 中取出，若没有则需要从内存中读取数据，并同时把这块数据放入 Cache 中。但是由于程序的局部性原理，在一段时间内，CPU 总是能从 Cache 中读取到自己想要的数据。</p><p>Cache 可以集成在 CPU 内部，也可以做成独立的芯片放在总线上，现在 x86 CPU 和 ARM CPU 都是集成在 CPU 内部的。其逻辑结构如下图所示:</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20221130190515261.png" alt="image-20221130190515261" style="zoom:50%;" /><p>Cache 主要由高速的静态储存器、地址转换模块和 Cache 行替换模块组成。</p><p>Cache 会把自己的高速静态储存器和内存分成大小相同的行，一行大小通常为 32 字节或者 64 字节。Cache 和内存交换数据的最小单位是一行，为方便管理，在 Cache 内部的高速储存器中，多个行又会形成一组。</p><p>除了正常的数据空间外，Cache 行中还有一些标志位，如脏位、回写位，访问位等，这些位会被 Cache 的替换模块所使用。</p><p>Cache 大致的逻辑工作流程如下:</p><ol><li><p>CPU 发出的地址由 Cache 的地址转换模块分成 3 段：组号，行号，行内偏移。</p></li><li><p>Cache 会根据组号、行号查找高速静态储存器中对应的行。如果找到即命中，用行内偏移读取并返回数据给 CPU，否则就分配一个新行并访问内存，把内存中对应的数据加载到 Cache 行并返回给 CPU。写入操作则比较直接，分为回写和直通写，回写是写入对应的 Cache 行就结束了，直通写则是在写入 Cache 行的同时写入内存。</p></li><li><p>如果没有新行了，就要进入行替换逻辑，即找出一个 Cache 行写回内存，腾出空间，替换行有相关的算法，<strong>替换算法是为了让替换的代价最小化</strong>。例如，找出一个没有修改的 Cache 行，这样就不用把它其中的数据回写到内存中了，还有找出存在时间最久远的那个 Cache 行，因为它大概率不会再访问了。</p></li></ol><p>以上这些逻辑都<strong>由 Cache 硬件独立实现</strong>，软件不用做任何工作，对软件是透明的</p><h2 id="Cache-带来的问题"><a href="#Cache-带来的问题" class="headerlink" title="Cache 带来的问题"></a>Cache 带来的问题</h2><p>Cache 虽然带来性能方面的提升，但同时也给和硬件和软件开发带来了问题，那就是数据一致性问题</p><p>为了搞清楚这个问题，我们必须先搞清楚 Cache 在硬件层面的结构，下面我画了 x86 CPU 的 Cache 结构图：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20230114145143829.png" alt="image-20230114145143829" style="zoom:50%;" /><p>这是一颗最简单的双核心 CPU，它有三级 Cache，第一级 Cache 是指令和数据分开的，第二级 Cache 是独立于 CPU 核心的，第三级 Cache 是所有 CPU 核心共享的。</p><p>下面来看看 Cache 的一致性问题，主要包括这三个方面.</p><ol><li><p>一个 CPU 核心中的指令 Cache 和数据 Cache 的一致性问题。</p></li><li><p>多个 CPU 核心各自的 2 级 Cache 的一致性问题。</p></li><li><p>CPU 的 3 级 Cache 与设备内存，如 DMA、网卡帧储存，显存之间的一致性问题。这里我们不需要关注这个问题。</p></li></ol><p>我们先来看看 CPU 核心中的指令 Cache 和数据 Cache 的一致性问题，对于程序代码运行而言，指令都是经过指令 Cache，而指令中涉及到的数据则会经过数据 Cache。</p><p>所以，对自修改的代码（即修改运行中代码指令数据，变成新的程序）而言，比如我们修改了内存地址 A 这个位置的代码（典型的情况是 Java 运行时编译器），这个时候我们是通过储存的方式去写的地址 A，所以新的指令会进入<strong>数据 Cache</strong>。</p><p>但是我们接下来去执行地址 A 处的指令的时候，指令 Cache 里面可能命中的是修改之前的指令(新指令还存储在Cache中，还没同步到内存)。所以，这个时候软件需要把数据 Cache 中的数据写入到内存中，然后让指令 Cache 无效，重新加载内存中的数据。</p><p>再来看看多个 CPU 核心各自的 2 级 Cache 的一致性问题。从上图中可以发现，两个 CPU 核心共享了一个 3 级 Cache。比如第一个 CPU 核心读取了一个 A 地址处的变量，第二个 CPU 也读取 A 地址处的变量，那么第二个 CPU 核心是不是需要从内存里面经过第 3、2、1 级 Cache 再读一遍，这个显然是没有必要的。</p><p>在硬件上 Cache 相关的控制单元，可以把第一个 CPU 核心的 A 地址处 Cache 内容<strong>直接复制</strong>到第二个 CPU 的第 2、1 级 Cache，这样两个 CPU 核心都得到了 A 地址的数据。不过如果这时第一个 CPU 核心改写了 A 地址处的数据，而第二个 CPU 核心的 2 级 Cache 里面还是原来的值，数据显然就不一致了。</p><p>为了解决这些问题，硬件工程师们开发了多种协议，<strong>典型的多核心 Cache 数据同步协议有 <code>MESI</code> 和<code>MOESI</code></strong>。MOESI 和 MESI 大同小异，下面我们就去研究一下 MESI 协议。</p><h2 id="Cache-的-MESI-协议"><a href="#Cache-的-MESI-协议" class="headerlink" title="Cache 的 MESI 协议"></a>Cache 的 MESI 协议</h2><p>MESI 协议定义了 4 种基本状态：M、E、S、I，即修改（Modified）、独占（Exclusive）、共享（Shared）和无效（Invalid）。下面我结合示意图，给你解释一下这四种状态：</p><ol><li>M 修改（Modified）：当前 Cache 的内容有效，数据已经被修改而且与内存中的数据不一致，数据只在当前 Cache 里存在。比如说，内存里面 X=5，而 CPU 核心 1 的 Cache 中 X=2，Cache 与内存不一致，CPU 核心 2 中没有 X。</li></ol><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20230114145309210.png" alt="image-20230114145309210" style="zoom:50%;" /><ol start="2"><li>E 独占（Exclusive）：当前 Cache 中的内容有效，数据与内存中的数据一致，数据只在当前 Cache 里存在；类似 RAM 里面 X=5，同样 CPU 核心 1 的 Cache 中 X=5（Cache 和内存中的数据一致），CPU 核心 2 中没有 X</li></ol><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20230114145331171.png" alt="image-20230114145331171" style="zoom:50%;" /><ol start="3"><li><p>S 共享（Shared）：当前 Cache 中的内容有效，Cache 中的数据与内存中的数据一致，数据在多个 CPU 核心中的 Cache 里面存在。例如在 CPU 核心 1、CPU 核心 2 里面 Cache 中的 X=5，而内存中也是 X=5 保持一致</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20230114151458723.png" alt="image-20230114151458723" style="zoom:50%;" /></li><li><p>无效（Invalid）：当前 Cache 无效。前面三幅图 Cache 中没有数据的那些，都属于这个情况</p></li></ol><p>最后还要说一下 Cache 硬件，它会监控所有 CPU 上 Cache 的操作，根据相应的操作使得 Cache 里的数据行在上面这些状态之间切换。Cache 硬件通过这些状态的变化，就能安全地控制各 Cache 间、各 Cache 与内存之间的数据一致性了。</p><p>这里不再深入探讨 MESI 协议了，感兴趣的话你可以自行拓展学习。这里只是为了让你明白，有了 Cache 虽然提升了系统性能，却也带来了很多问题，好在这些问题都由硬件自动完成，<strong>对软件而言是透明的</strong>。</p><p>不过看似对软件透明，这却是有代价的，因为硬件需要耗费时间来处理这些问题。如果我们编程的时候不注意，不能很好地规避这些问题，就会引起硬件去维护大量的 Cache 数据同步，这就会使程序运行的效能大大下降</p><h2 id="开启-Cache"><a href="#开启-Cache" class="headerlink" title="开启 Cache"></a>开启 Cache</h2><p>前面我们研究了大量的 Cache 底层细节和问题，就是为了使用 Cache，目前 Cache 已经成为了现代计算机的标配，但是 <strong>x86 CPU 上默认是关闭 Cache 的</strong>，需要在 CPU 初始化时将其开启。</p><p>在 x86 CPU 上开启 Cache 非常简单，只需要<strong>将 CR0 寄存器中 CD、NW 位同时清 0 即可</strong>。CD=1 时表示 Cache 关闭，NW=1 时 CPU 不维护内存数据一致性。所以 <strong>CD=0、NW=0 的组合</strong>才是开启 Cache 的正确方法。</p><p>开启 Cache 只需要用四行汇编代码，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0  ;开启 CACHE    </span><br><span class="line">btr eax, 29   ;CR0.NW&#x3D;0</span><br><span class="line">btr eax, 30   ;CR0.CD&#x3D;0</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure><h2 id="获取内存视图"><a href="#获取内存视图" class="headerlink" title="获取内存视图"></a>获取内存视图</h2><p>作为系统软件开发人员，与其了解内存内部构造原理，不如了解系统内存有多大。这个作用更大。</p><p>根据前面课程所讲，给出一个物理地址并不能准确地定位到内存空间，内存空间只是映射物理地址空间中的一个子集，物理地址空间中可能有空洞，有 ROM，有内存，有显存，有 I/O 寄存器，所以获取内存有多大没用，关键是<strong>要获取哪些物理地址空间是可以读写的内存</strong>。</p><p><strong>物理地址空间是由北桥芯片控制管理的</strong>，那我们是不是要找北桥要内存的地址空间呢？当然不是，在 x86 平台上还有更方便简单的办法，那就是 BIOS 提供的实模式下中断服务，就是 int 指令后面跟着一个常数的形式</p><blockquote><p><font color='#39b54a'>在x86中我们可以简单的通过中断服务实现获取物理地址（可读写的）</font></p></blockquote><p>由于 PC 机上电后由 BIOS 执行硬件初始化，中断向量表是 BIOS 设置的，所以执行中断自然执行 BIOS 服务。这个中断服务是 <code>int 15h</code>，但是它需要一些参数，就是在执行<code>int 15h</code>之前，对特定寄存器设置一些值，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_getmemmap:</span><br><span class="line">  xor ebx,ebx ;ebx设为0</span><br><span class="line">  mov edi,E80MAP_ADR ;edi设为存放输出结果的1MB内的物理内存地址</span><br><span class="line">loop:</span><br><span class="line">  mov eax,0e820h ;eax必须为0e820h</span><br><span class="line">  mov ecx,20 ;输出结果数据项的大小为20字节：8字节内存基地址，8字节内存长度，4字节内存类型</span><br><span class="line">  mov edx,0534d4150h ;edx必须为0534d4150h</span><br><span class="line">  int 15h ;执行中断</span><br><span class="line">  jc error ;如果flags寄存器的C位置1，则表示出错</span><br><span class="line">  add edi,20;更新下一次输出结果的地址</span><br><span class="line">  cmp ebx,0 ;如ebx为0，则表示循环迭代结束</span><br><span class="line">  jne loop  ;还有结果项，继续迭代</span><br><span class="line">    ret</span><br><span class="line">error:;出错处理</span><br></pre></td></tr></table></figure><p>上面的代码是在迭代中执行中断，每次中断都输出一个 20 字节大小数据项，最后会形成一个该数据项（结构体）的数组，可以用 C 语言结构表示，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_USABLE 1 <span class="comment">//可用内存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_RESERV 2 <span class="comment">//保留内存不可使用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_ACPIREC 3 <span class="comment">//ACPI表相关的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_ACPINVS 4 <span class="comment">//ACPI NVS空间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_AREACON 5 <span class="comment">//包含坏内存</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_e820</span>&#123;</span></span><br><span class="line">    <span class="keyword">u64_t</span> saddr;    <span class="comment">/* 内存开始地址 */</span></span><br><span class="line">    <span class="keyword">u64_t</span> lsize;    <span class="comment">/* 内存大小 */</span></span><br><span class="line">    <span class="keyword">u32_t</span> type;    <span class="comment">/* 内存类型 */</span></span><br><span class="line">&#125;<span class="keyword">e820map_t</span>;</span><br></pre></td></tr></table></figure><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>又到了课程尾声，内存和 Cache 的学习就告一段落了。今天我们主要讲了四部分内容，局部性原理、内存结构特性、Cache 工作原理和 x86 上的应用。我们一起来回顾一下这节课的重点。</p><p>首先从一个场景开始，我们了解了程序通常的结构。通过观察这种结构，我们发现 CPU 大多数时间在访问相同或者与此相邻的地址，执行相同的指令或者与此相邻的指令。这种现象就是程序<strong>局部性原理</strong></p><p>然后，我们研究了内存的结构和特性。了解它的工艺标准和内部原理，知道内存容量相对可以做得较大，程序和数据都要放在其中才能被 CPU 执行和处理。但是内存的速度却远远赶不上 CPU 的速度。</p><p>因为内存和 CPU 之间性能瓶颈和程序局部性原理，所以才开发出了 Cache（即高速缓存），它由高速静态储存器和相应的控制逻辑组成。</p><p>Cache 容量比内存小，速度却比内存高，它在 CPU 和内存之间，CPU 访问内存首先会访问 Cache，如果访问命中则会大大提升性能，然而它却带来了问题，那就是<strong>数据的一致性问题</strong>，为了解决这个问题，工程师又开发了 Cache<strong>一致性协议 MESI</strong>。这个协议由 Cache 硬件执行，对软件透明。</p><p>最后，我们掌握了 x86 平台上开启 Cache 和获取物理内存视图的方法。</p><p>因为这节课也是我们硬件模块的最后一节，可以说<strong>没有硬件平台知识，写操作系统就如同空中建楼</strong>，通过这个部分的学习，就算是为写操作系统打好了地基。为了让你更系统地认识这个模块，我给你整理了这三节课的知识导图：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20230114155020028.png" alt="image-20230114155020028" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>日记_0430</title>
    <link href="https://xwjahahahaha.github.io/2022/10/27/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-10/%E6%97%A5%E8%AE%B0-0430/"/>
    <id>https://xwjahahahaha.github.io/2022/10/27/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-10/%E6%97%A5%E8%AE%B0-0430/</id>
    <published>2022-10-27T01:46:37.000Z</published>
    <updated>2023-07-06T06:07:35.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><a id="more"></a><p>3～4月</p><ul><li><input checked="" disabled="" type="checkbox"> 找到一份暑期实习(网易)</li></ul><p>5～6月</p><ul><li><input checked="" disabled="" type="checkbox"> 论文修改重新投稿 5.3<ul><li><input checked="" disabled="" type="checkbox"> 5.16 退修</li><li><input checked="" disabled="" type="checkbox"> 7.4 录用修改</li></ul></li></ul><p>6～7月</p><ul><li><input checked="" disabled="" type="checkbox"> 实习<ul><li><input checked="" disabled="" type="checkbox"> kube-eagle项目</li></ul></li><li><input disabled="" type="checkbox"> 基础知识<ul><li><input disabled="" type="checkbox"> linux内核源码 =&gt; 《深入理解linux内核》</li></ul></li></ul><p>8～10月</p><ul><li><input disabled="" type="checkbox"> 秋招</li></ul><h2 id="这段时间的待完成任务："><a href="#这段时间的待完成任务：" class="headerlink" title="这段时间的待完成任务："></a>这段时间的待完成任务：</h2><ul><li><input disabled="" type="checkbox"> </li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> <p>环境搭建</p><ul><li><input checked="" disabled="" type="checkbox"> k8s环境搭建</li></ul></li><li><input disabled="" type="checkbox"> <p>runC项目</p><ul><li><input disabled="" type="checkbox"> 看之前的文档和源码过一遍</li><li><input disabled="" type="checkbox"> 有余力：<ul><li><input disabled="" type="checkbox"> 重构源代码、加入seccomp功能 </li><li><input disabled="" type="checkbox"> runC源码项目看一下</li><li><input disabled="" type="checkbox"> OCI 镜像格式标准文件包 bundles</li></ul></li></ul></li><li><input disabled="" type="checkbox"> <p>看书 </p><ul><li><input disabled="" type="checkbox"> 《C语言程序设计现代方法》（看不懂的地方再找着看，直接过基础枯燥且浪费时间）</li><li><input disabled="" type="checkbox"> 《深入理解计算机系统》CSAPP</li></ul></li><li><input disabled="" type="checkbox"> <p><font color='#39b54a'>操作系统45讲-实现一个自己的OS </font></p><ul><li><input checked="" disabled="" type="checkbox"> 06 虚幻与真实：程序中的地址如何转换？</li><li><input disabled="" type="checkbox"> 07丨Cache与内存：程序放在哪儿？</li></ul></li><li><input disabled="" type="checkbox"> <p>春招准备：</p><ul><li><input disabled="" type="checkbox"> 总体方向：linux内核开发、虚拟化方向<ul><li><input disabled="" type="checkbox"> c++ <ul><li><input disabled="" type="checkbox"> <font color='#39b54a'>《C++ Primer》</font><ul><li><input disabled="" type="checkbox"> 第七章 类</li></ul></li></ul></li><li><input disabled="" type="checkbox"> linux内核<ul><li><input disabled="" type="checkbox"> 《深入理解linux内核》<ul><li><input disabled="" type="checkbox"> 第三章 进程  记了笔记还未完成</li></ul></li></ul></li><li><input disabled="" type="checkbox"> 虚拟化<ul><li><input disabled="" type="checkbox"> 《深度探索linux系统虚拟化》原理与实现</li></ul></li></ul></li></ul></li><li><input disabled="" type="checkbox"> </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0429</title>
    <link href="https://xwjahahahaha.github.io/2022/10/26/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-10/%E6%97%A5%E8%AE%B0-0429/"/>
    <id>https://xwjahahahaha.github.io/2022/10/26/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2022/2022-10/%E6%97%A5%E8%AE%B0-0429/</id>
    <published>2022-10-26T03:11:45.000Z</published>
    <updated>2023-07-06T06:07:35.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><a id="more"></a><p>3～4月</p><ul><li><input checked="" disabled="" type="checkbox"> 找到一份暑期实习(网易)</li></ul><p>5～6月</p><ul><li><input checked="" disabled="" type="checkbox"> 论文修改重新投稿 5.3<ul><li><input checked="" disabled="" type="checkbox"> 5.16 退修</li><li><input checked="" disabled="" type="checkbox"> 7.4 录用修改</li></ul></li></ul><p>6～7月</p><ul><li><input checked="" disabled="" type="checkbox"> 实习<ul><li><input checked="" disabled="" type="checkbox"> kube-eagle项目</li></ul></li><li><input disabled="" type="checkbox"> 基础知识<ul><li><input disabled="" type="checkbox"> linux内核源码 =&gt; 《深入理解linux内核》</li></ul></li></ul><p>8～10月</p><ul><li><input disabled="" type="checkbox"> 秋招</li></ul><h2 id="这段时间的待完成任务："><a href="#这段时间的待完成任务：" class="headerlink" title="这段时间的待完成任务："></a>这段时间的待完成任务：</h2><ul><li><input disabled="" type="checkbox"> </li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> <p>环境搭建</p><ul><li><input checked="" disabled="" type="checkbox"> k8s环境搭建</li></ul></li><li><input disabled="" type="checkbox"> <p>runC项目</p><ul><li><input disabled="" type="checkbox"> 看之前的文档和源码过一遍</li><li><input disabled="" type="checkbox"> 有余力：<ul><li><input disabled="" type="checkbox"> 重构源代码、加入seccomp功能 </li><li><input disabled="" type="checkbox"> runC源码项目看一下</li><li><input disabled="" type="checkbox"> OCI 镜像格式标准文件包 bundles</li></ul></li></ul></li><li><input disabled="" type="checkbox"> <p>看书 </p><ul><li><input disabled="" type="checkbox"> 《C语言程序设计现代方法》（看不懂的地方再找着看，直接过基础枯燥且浪费时间）</li><li><input disabled="" type="checkbox"> 《深入理解计算机系统》CSAPP</li></ul></li><li><input disabled="" type="checkbox"> <p><font color='#39b54a'>操作系统45讲-实现一个自己的OS </font></p><ul><li><input disabled="" type="checkbox"> 07丨Cache与内存：程序放在哪儿？</li></ul></li><li><input disabled="" type="checkbox"> <p>春招准备：</p><ul><li><input disabled="" type="checkbox"> 总体方向：linux内核开发、虚拟化方向<ul><li><input disabled="" type="checkbox"> c++ <ul><li><input disabled="" type="checkbox"> <font color='#39b54a'>《C++ Primer》</font><ul><li><input checked="" disabled="" type="checkbox"> 第六章 函数</li><li><input disabled="" type="checkbox"> 第七章 类</li></ul></li></ul></li><li><input disabled="" type="checkbox"> linux内核<ul><li><input disabled="" type="checkbox"> 《深入理解linux内核》<ul><li><input disabled="" type="checkbox"> 第三章 进程  记了笔记还未完成</li></ul></li></ul></li><li><input disabled="" type="checkbox"> 虚拟化<ul><li><input disabled="" type="checkbox"> 《深度探索linux系统虚拟化》原理与实现</li></ul></li></ul></li></ul></li><li><input disabled="" type="checkbox"> </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
</feed>
