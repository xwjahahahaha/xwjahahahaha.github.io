<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识与头发不可兼得</title>
  
  <subtitle>文杰的博客</subtitle>
  <link href="https://xwjahahahaha.github.io/atom.xml" rel="self"/>
  
  <link href="https://xwjahahahaha.github.io/"/>
  <updated>2021-05-25T15:26:03.139Z</updated>
  <id>https://xwjahahahaha.github.io/</id>
  
  <author>
    <name>DDDemons hide</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo出现的问题</title>
    <link href="https://xwjahahahaha.github.io/2021/05/25/%E6%8A%80%E6%9C%AF%E8%B4%B4/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://xwjahahahaha.github.io/2021/05/25/%E6%8A%80%E6%9C%AF%E8%B4%B4/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-25T15:11:19.000Z</published>
    <updated>2021-05-25T15:26:03.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Nunjucks-Error-Line-319-Column-36-unexpected-token"><a href="#1-Nunjucks-Error-Line-319-Column-36-unexpected-token" class="headerlink" title="1. Nunjucks Error: [Line 319, Column 36] unexpected token: ."></a>1. Nunjucks Error: [Line 319, Column 36] unexpected token: .</h1><a id="more"></a><blockquote><p><strong>错误描述:</strong></p><p>Version 9 of Highlight.js has reached EOL and is no longer supported.</p><p>Please upgrade or ask whatever dependency you are using to upgrade.</p><p><a href="https://github.com/highlightjs/highlight.js/issues/2877" target="_blank" rel="noopener">https://github.com/highlightjs/highlight.js/issues/2877</a></p><p>FATAL Something’s wrong. Maybe you can find the solution here: <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">https://hexo.io/docs/troubleshooting.html</a></p><p>Nunjucks Error: [Line 319, Column 36] unexpected token: .</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/770zhs.png" alt="770zhs"></p><p><strong>错误原因:</strong></p><p>在提示给出的解决文档中说明了原因:</p><p>Hexo使用Nunjucks来渲染帖子(旧版本中使用了Swig，它共享类似的语法)。使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;或&#123;%%&#125;</span><br></pre></td></tr></table></figure><p>封装的内容将被解析，并可能导致问题。您可以通过使用原始标记插件包装它来跳过解析，例如单反勾或三反勾。 或者，Nunjucks标签可以通过渲染器的选项(如果支持)，API或前端问题禁用。</p><ul><li>意思就是<strong>你写的文章内容含有两个大括号这样的字符,会导致Nunjucks解析渲染的错误(因为它解析也是两个大括号)</strong></li></ul><p><font color='#e54d42'>解决方法:</font></p><p>根据蓝字的提示,找到对应的文章位置,将导致混乱的地方修改(使用三个大括号):</p><p>例如:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/YEiPGd.png" alt="YEiPGd"></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-Nunjucks-Error-Line-319-Column-36-unexpected-token&quot;&gt;&lt;a href=&quot;#1-Nunjucks-Error-Line-319-Column-36-unexpected-token&quot; class=&quot;headerlink&quot; title=&quot;1. Nunjucks Error: [Line 319, Column 36] unexpected token: .&quot;&gt;&lt;/a&gt;1. Nunjucks Error: [Line 319, Column 36] unexpected token: .&lt;/h1&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="hexo" scheme="https://xwjahahahaha.github.io/categories/technical/hexo/"/>
    
    
    <category term="hexo" scheme="https://xwjahahahaha.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>日记_0175</title>
    <link href="https://xwjahahahaha.github.io/2021/05/25/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0175/"/>
    <id>https://xwjahahahaha.github.io/2021/05/25/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0175/</id>
    <published>2021-05-25T02:14:33.000Z</published>
    <updated>2021-05-25T05:18:35.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li><li><input disabled="" type="checkbox"> 4-1 ~ 4-31 Go网络编程Base + 专利一篇</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、 专利2篇  </li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 第一篇论文初稿与老师讨论</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 Go设计模式  </li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-31 docker、k8s</li></ul><p>七月</p><ul><li><input disabled="" type="checkbox"> 7-1 ~ 7-20 缓存、日志</li><li><input disabled="" type="checkbox"> 7-20 ~ 7-31 微服务(消息队列、任务调度、rpc)</li></ul><p>八月</p><ul><li><input disabled="" type="checkbox"> 8-1 ~ 8-20  微服务(消息队列、任务调度、rpc)</li><li><input disabled="" type="checkbox"> 8-20 ~ 8-31 </li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语</li><li><input disabled="" type="checkbox"> leetcode一题</li><li><input disabled="" type="checkbox"> </li><li><input disabled="" type="checkbox"> </li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>swarm_bee单机多开教程</title>
    <link href="https://xwjahahahaha.github.io/2021/05/23/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Swarm/swarm-bee%E5%8D%95%E6%9C%BA%E5%A4%9A%E5%BC%80%E6%95%99%E7%A8%8B/"/>
    <id>https://xwjahahahaha.github.io/2021/05/23/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Swarm/swarm-bee%E5%8D%95%E6%9C%BA%E5%A4%9A%E5%BC%80%E6%95%99%E7%A8%8B/</id>
    <published>2021-05-23T03:34:40.000Z</published>
    <updated>2021-05-23T03:41:58.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows下"><a href="#Windows下" class="headerlink" title="Windows下"></a>Windows下</h1><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><blockquote><ol><li>下载了git,有gitbush</li><li></li></ol></blockquote><a id="more"></a><h1 id="Linux下"><a href="#Linux下" class="headerlink" title="Linux下"></a>Linux下</h1><h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Windows下&quot;&gt;&lt;a href=&quot;#Windows下&quot; class=&quot;headerlink&quot; title=&quot;Windows下&quot;&gt;&lt;/a&gt;Windows下&lt;/h1&gt;&lt;h2 id=&quot;前置条件&quot;&gt;&lt;a href=&quot;#前置条件&quot; class=&quot;headerlink&quot; title=&quot;前置条件&quot;&gt;&lt;/a&gt;前置条件&lt;/h2&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;下载了git,有gitbush&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>swarm-2-bee的搭建</title>
    <link href="https://xwjahahahaha.github.io/2021/05/15/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Swarm/swarm-2-bee%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://xwjahahahaha.github.io/2021/05/15/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Swarm/swarm-2-bee%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2021-05-15T05:20:29.000Z</published>
    <updated>2021-05-23T03:09:06.705Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>资料:</p><p><a href="https://docs.ethswarm.org/docs/installation/quick-start" target="_blank" rel="noopener">https://docs.ethswarm.org/docs/installation/quick-start</a></p><p><a href="https://www.yuque.com/docs/share/712630dc-fa67-4318-a36e-502f871a0136?#" target="_blank" rel="noopener">https://www.yuque.com/docs/share/712630dc-fa67-4318-a36e-502f871a0136?#</a></p><p>环境:</p><ul><li>Ubuntu:  18.04.2 LTS</li></ul></blockquote><h1 id="一、安装Bee"><a href="#一、安装Bee" class="headerlink" title="一、安装Bee"></a>一、安装Bee</h1><p><a href="https://geth.ethereum.org/docs/clef/tutorial" target="_blank" rel="noopener">https://geth.ethereum.org/docs/clef/tutorial</a></p><h2 id="1-1-Bee-Clef"><a href="#1-1-Bee-Clef" class="headerlink" title="1.1 Bee Clef"></a>1.1 Bee Clef</h2><p>Go Ethereum’s Clef是以太坊的上的签名和密钥管理工具, 对于Swarm, 对应的工具就是Bee Clef, 能够方便的帮助我们签名大量交易与管理密钥.</p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装:"></a>1. 安装:</h3><p>Ubuntu:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ethersphere/bee-clef/releases/download/v0.4.9/bee-clef_0.4.9_amd64.deb</span><br><span class="line">sudo dpkg -i bee-clef_0.4.9_amd64.deb</span><br></pre></td></tr></table></figure><p>centOS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ethersphere/bee-clef/releases/download/v0.4.9/bee-clef_0.4.9_amd64.rpm</span><br><span class="line">sudo rpm -i bee-clef_0.4.9_amd64.rpm</span><br></pre></td></tr></table></figure><p><a href="https://docs.ethswarm.org/docs/installation/bee-clef/" target="_blank" rel="noopener">其他系统安装</a></p><p>文件已经下载到<code>/etc/bee-clef</code>文件夹下,默认情况不需要修改配置</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/uXe1eR.png" alt="uXe1eR"></p><h3 id="2-运行服务"><a href="#2-运行服务" class="headerlink" title="2. 运行服务"></a>2. 运行服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status bee-clef</span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/wLaNsJ.png" alt="wLaNsJ"></p><a id="more"></a><p>持续输出log:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -f -u bee-clef.service</span><br></pre></td></tr></table></figure><p>后面当连接到Bee后就会显示:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/Zi5Bk7.png" alt="Zi5Bk7"></p><h3 id="3-文件位置"><a href="#3-文件位置" class="headerlink" title="3. 文件位置"></a>3. 文件位置</h3><p>Configuration files are stored in <code>/etc/bee-clef/</code></p><p>Key material and other data is stored in <code>/var/lib/bee-clef/</code></p><h3 id="4-账户列表"><a href="#4-账户列表" class="headerlink" title="4. 账户列表"></a>4. 账户列表</h3><p>由于Bee需要Clef来自动签署许多事务，所以我们必须将Clef作为一种服务来运行，并且具有宽松的权限和规则集。</p><p>为了确保Clef只与Bee签署交易，我们必须保护<code>Clef.ipc</code>文件。通过创建一个Bee用户并设置权限，使得只有这个用户才能使用ipc套接字。</p><p>通过外部API来获取Clef中管理的账户列表:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo '&#123;"id": 1, "jsonrpc": "2.0", "method": "account_list"&#125;' | nc -U /var/lib/bee-clef/clef.ipc</span><br></pre></td></tr></table></figure><blockquote><p>注意:  后面是ipc文件地址,默认在<code>/var/lib/bee-clef/</code>下</p></blockquote><h2 id="1-2-Bee"><a href="#1-2-Bee" class="headerlink" title="1.2 Bee"></a>1.2 Bee</h2><h3 id="1-安装-1"><a href="#1-安装-1" class="headerlink" title="1.安装"></a>1.安装</h3><p>Ubuntu</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ethersphere/bee/releases/download/v0.5.3/bee_0.5.3_amd64.deb</span><br><span class="line">sudo dpkg -i bee_0.5.3_amd64.deb</span><br><span class="line">bee version # 检查版本</span><br></pre></td></tr></table></figure><p>CentOS:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ethersphere/bee/releases/download/v0.5.3/bee_0.5.3_amd64.rpm</span><br><span class="line">sudo rpm -i bee_0.5.3_amd64.rpm</span><br></pre></td></tr></table></figure><h3 id="2-默认启动"><a href="#2-默认启动" class="headerlink" title="2.默认启动"></a>2.默认启动</h3><p>加权限再启动否则会报错:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R bee:bee /var/lib/bee</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按/etc/bee/bee.yaml的配置启动</span></span><br><span class="line">systemctl start bee # 启动</span><br><span class="line">systemctl stop bee# 停止</span><br><span class="line">systemctl status bee# 查看状态</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 手动启动</span></span><br><span class="line">bee start</span><br></pre></td></tr></table></figure><blockquote><p><font color='#e54d42'>注意: 两种启动方式选择一种即可, 在使用按配置启动时如果不成功会反复自动尝试启动,可能会造成<code>bee start</code>的无法启动,所以使用第二种启动时需要先<code>systemctl stop bee</code></font></p></blockquote><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/ZOR0Wq.png" alt="ZOR0Wq"></p><p>输入密码, 这个密码用于保护你私钥以及可以代表你的Swarm地址</p><blockquote><p>Error: get chain id: Post “<a href="http://localhost:8545&quot;">http://localhost:8545&quot;</a>: dial tcp 127.0.0.1:8545: connect: connection refused</p><p>原因: 在默认配置下连接的是本地的8545端口测试网络, 如果本地没有区块链网络的话就会报错</p><p>解决: <strong>后面会使用以太坊的Goerli测试网络,会在启动时加上参数或者自行修改配置文件</strong></p></blockquote><p><strong>还需要一些配置和要求见下方</strong></p><h3 id="3-Goerli测试网启动配置"><a href="#3-Goerli测试网启动配置" class="headerlink" title="3.Goerli测试网启动配置"></a>3.Goerli测试网启动配置</h3><p><strong>当第一运行Bee节点到测试网络上会在测试网络中借助支票工厂合约部署你的“支票”合约(支票簿), 支票用于链下核算(类似于微支付通道), 减轻链上压力提高交易效率.</strong></p><p>一旦部署了支票簿，Bee将在支票簿合同中存入一定数量的gBZZ (Goerli测试网上的BZZ代币)，这样它就可以为其他节点的服务支付报酬。</p><p>所以首先我们需要<strong>能够连接上测试网络Goerli</strong></p><ul><li><p>首先注册测试网依赖节点服务</p><p>注册一个swap-endpoint地址：<a href="https://infura.io" target="_blank" rel="noopener">https://infura.io</a></p><p><strong>第7分钟开始看,</strong>注册视频教程：<a href="https://www.bilibili.com/video/BV1EV411Y7yM" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1EV411Y7yM</a>   </p><p>拿到Goerli的的swap-endpoint地址：<a href="https://goerli.infura.io/v3/fe00e6f4a50b4a2fb2dc25ecb532a5ad" target="_blank" rel="noopener">https://goerli.infura.io/v3/</a><strong>*****</strong></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/owFB2v.png" alt="owFB2v"></p></li></ul><p>重新加参数启动:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bee start \</span><br><span class="line">  --verbosity 5 \</span><br><span class="line">  --swap-endpoint https://mainnet.infura.io/v3/xxxxxxxx \# 依赖的地址</span><br><span class="line">  --debug-api-enable</span><br></pre></td></tr></table></figure><p>部署支票簿合约没有足够的资金(需要10gbzz)而warning:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/ZevDvK.png" alt="ZevDvK"></p><h3 id="4-连接Clef配置"><a href="#4-连接Clef配置" class="headerlink" title="4.连接Clef配置"></a>4.连接Clef配置</h3><p>在获取代币之前还需要一步,就是连接自己创建的Bee_Clef账户管理工具, 使用Clef管理的账户而不使用自动创建的账户:</p><p>重新配置启动:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.bee# 因为之前没有启用clef, 先删除掉之前的文件,需要重新设置密码</span><br><span class="line">bee start --verbosity 5 --swap-endpoint https://goerli.infura.io/v3/xxxxxxxxxxxxxx --debug-api-enable --clef-signer-enable --clef-signer-endpoint /var/lib/bee-clef/clef.ipc</span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/TM775e.png" alt="TM775e"></p><h3 id="5-获取fund代币"><a href="#5-获取fund代币" class="headerlink" title="5.获取fund代币"></a>5.获取fund代币</h3><p>部署支票簿合约需要一个基本的资金, 所以我们需要在测试网Goerli上通过其<strong>水龙头合约</strong>获取基本的gBzz代币</p><p>水龙头地址: <a href="https://faucet.ethswarm.org/" target="_blank" rel="noopener">Swarm Goerli Faucet</a>. (现在很难拿到)</p><p>gETH水龙头地址: <a href="https://goerli-faucet.slock.it/" target="_blank" rel="noopener">https://goerli-faucet.slock.it/</a></p><p>或者根据这篇文章中的方法通过发推特获取gEth(推荐): <a href="https://www.yundongfang.com/Yun41916.html" target="_blank" rel="noopener">https://www.yundongfang.com/Yun41916.html</a></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/TVsF6k.png" alt="TVsF6k"></p><h3 id="6-clef钱包导入MetaMask"><a href="#6-clef钱包导入MetaMask" class="headerlink" title="6.clef钱包导入MetaMask"></a>6.clef钱包导入MetaMask</h3><p>将clef账户导入到MetaMask中</p><p><code>cd /var/lib/bee-clef</code></p><p>文件夹下:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/82lRk0.png" alt="82lRk0"></p><p>或者终端运行<code>bee-clef-keys</code></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/eydkFy.png" alt="eydkFy"></p><p>会自动导入到主目录下,txt中就是密码</p><p>打开MetaMask中导入:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/719qCf.png" alt="719qCf"></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/fPc6RB.png" alt="fPc6RB"></p><h3 id="7-gETH转换gBZZ"><a href="#7-gETH转换gBZZ" class="headerlink" title="7. gETH转换gBZZ"></a>7. gETH转换gBZZ</h3><p>通过点击在启动warning中的提示地址<font color='#e54d42'><strong>转换</strong>一些gETH为gBZZ:</font></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/9IJcpA.png" alt="9IJcpA"></p><p><code>https://bzz.ethswarm.org/?transaction=buy&amp;amount=10&amp;slippage=30&amp;receiver=你的地址</code></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/vKC9a5.png" alt="vKC9a5"></p><p>成功后上测试网浏览器检查是否到账:</p><p><a href="https://goerli.etherscan.io/address/0xBEd09CeAe4517236A778c9D5D43DA3e80794012C" target="_blank" rel="noopener">https://goerli.etherscan.io/address/<strong>你的地址</strong></a></p><p>把<strong>加重的</strong>那一段改成你的，然后进入看看。有没有币。</p><blockquote><p><font color='#e54d42'><strong>注意: 发布发票合约最少需要10个gBZZ以及少量(0.01?)的gETH, 如果不够的话就多弄几次</strong></font></p><p>在Metamsk中可以添加代币显示你的gBzz余额, 点击添加代币, <font color='#39b54a'><strong>gBZZ的地址为: 0x2ac3c1d3e24b45c6c310534bc2dd84b5ed576335</strong></font></p></blockquote><h3 id="8-修改配置文件启动"><a href="#8-修改配置文件启动" class="headerlink" title="8. 修改配置文件启动"></a>8. 修改配置文件启动</h3><p>启动加很多参数过于麻烦, 这里将所有的配置修改到配置文件中,然后默认启动即可, 需要修改的几项配置文件如下(主要修改的就是<code>swap-endpoint</code>):</p><p>位置: <code>/etc/bee/bee.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clef-signer-enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">clef-signer-endpoint:</span> <span class="string">/var/lib/bee-clef/clef.ipc</span></span><br><span class="line"><span class="attr">config:</span> <span class="string">/etc/bee/bee.yaml</span></span><br><span class="line"><span class="attr">data-dir:</span> <span class="string">/var/lib/bee</span></span><br><span class="line"><span class="attr">debug-api-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:1635</span></span><br><span class="line"><span class="attr">debug-api-enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">password-file:</span> <span class="string">/var/lib/bee/password</span></span><br><span class="line"><span class="attr">swap-enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">swap-endpoint:</span> <span class="string">https://goerli.infura.io/v3/*************</span></span><br></pre></td></tr></table></figure><p>按配置启动:</p><p><code>systemctl start bee</code></p><p>或者手动配置启动:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前项目目录下, 运行</span></span><br><span class="line">vim mypsw.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出密码保存</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动(替换你的依赖)</span></span><br><span class="line">bee start --verbosity 5 --swap-endpoint https://goerli.infura.io/v3/xxxxxxxxx --debug-api-enable --clef-signer-enable --clef-signer-endpoint /var/lib/bee-clef/clef.ipc --password-file ./mypsw.txt --db-capacity 5000000</span><br></pre></td></tr></table></figure><p>启动后就会自动消费gETH和gBZZ调用Goerli测试网上的工厂合约,部署<font color='#e54d42'>我们的支票簿合约</font></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/o8lVMA.png" alt="o8lVMA"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO[2021-05-16T13:39:55+08:00] no chequebook found, deploying new one.      </span><br><span class="line">TRAC[2021-05-16T13:39:56+08:00] sending transaction 50491f8e17d91a8cd0dcecf39223f9162d8d89a0f5bca761ae037cd4d03d4181 with nonce 6 </span><br><span class="line">INFO[2021-05-16T13:39:57+08:00] deploying new chequebook in transaction 50491f8e17d91a8cd0dcecf39223f9162d8d89a0f5bca761ae037cd4d03d4181</span><br></pre></td></tr></table></figure><blockquote><p>支票簿工厂合约地址: 0xf0277caffea72734853b834afc9892461ea18474</p><p>可自行在<a href="https://goerli.etherscan.io/上搜索查看" target="_blank" rel="noopener">https://goerli.etherscan.io/上搜索查看</a></p></blockquote><h3 id="9-启动后测试"><a href="#9-启动后测试" class="headerlink" title="9. 启动后测试"></a>9. 启动后测试</h3><ol><li><p>查看bee日志</p><p><code>journalctl -u bee -f</code><br>查看bee-clef日志:</p><p><code>journalctl -u bee-clef -f</code></p></li><li><p>查看bee链接状态</p><p><code>curl http://localhost:1633</code></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/u3weRf.png" alt="u3weRf"></p></li><li><p>查看链接对等节点数:</p><p><code>curl -s http://localhost:1635/peers | jq &#39;.peers | length&#39;</code></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/pEXxS2.png" alt="pEXxS2"></p></li><li><p>查看自己钱包地址</p><p><code>curl -s localhost:1635/addresses | jq .ethereum</code></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/CWHDF5.png" alt="CWHDF5"></p></li><li><p>查看支票合约账本地址</p><p><code>curl -s http://localhost:1635/chequebook/address | jq .chequebookaddress</code></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/KmK9N2.png" alt="KmK9N2"></p></li></ol><h3 id="10-支票查看与提取"><a href="#10-支票查看与提取" class="headerlink" title="10. 支票查看与提取"></a>10. 支票查看与提取</h3><ol start="0"><li><p>查看区块欢迎度:</p><p><code>curl -X GET http://localhost:1645/topology | jq .population</code></p></li><li><p>下载cashout.sh脚本并赋予执行权限:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O cashout.sh https://gist.githubusercontent.com/ralph-pichler/3b5ccd7a5c5cd0500e6428752b37e975/raw/b40510f1172b96c21d6d20558ca1e70d26d625c4/cashout.sh &amp;&amp; chmod +x cashout.sh</span><br></pre></td></tr></table></figure></li><li><p>修改提取阈值</p><p>默认阈值太大,难以积攒,我们改小一点 <code>vim cashout.sh</code></p><p>修改第三行:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/Hrps0w.png" alt="Hrps0w"></p><p>保存退出</p></li><li><p>查看是否有支票</p><ul><li><p>自动</p><p><code>./cashout.sh</code></p><p>有支票就会有返回结果,没有的话就什么都不显示</p></li><li><p>手动</p><p><code>curl localhost:1635/settlements | jq</code></p><p>余额：<code>curl localhost:1635/chequebook/balance | jq</code></p><p>支票：<code>curl localhost:1635/chequebook/cheque | jq</code></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/z1R0K6.png" alt="z1R0K6"></p></li></ul></li><li><p>提取支票</p><ul><li><p>自动</p><p><code>./cashout.sh cashout-all</code></p></li><li><p>手动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://你的ip:1635/chequebook/cashout/peer地址</span><br></pre></td></tr></table></figure><p>会返回交易地址</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/bCpkE0.png" alt="bCpkE0"></p><p>成功后上测试网查看如下:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/4k3Ax3.png" alt="4k3Ax3"></p></li></ul></li><li><p>创建定时提取支票任务</p><p><code>crontab -e</code></p><p>输入3回车, 在文件中写入:</p><p><code>00 02 * * * [你的cashout.sh脚本目录] cashout-all</code></p><p>例如: <code>00 02 * * * /root/cashout.sh cashout-all</code></p><p>前面的02…是指每天凌晨两点执行cashout</p></li><li><p>自动查看状态脚本:</p><p>五秒查看一次:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while true ;do</span><br><span class="line">  echo "当前运行状态:"</span><br><span class="line">  curl http://localhost:1633</span><br><span class="line">  echo "连接数:"</span><br><span class="line">  curl -s http://localhost:1635/peers | jq '.peers | length'</span><br><span class="line">  echo "存储状态:"</span><br><span class="line">  df -h | awk 'NR==4&#123;print $3, $4, $5&#125;NR==1&#123;print $3, $4, $5&#125;'</span><br><span class="line">  echo "支票:"</span><br><span class="line">  bash /root/projects/swarm_bee/cashout.sh</span><br><span class="line">  echo "==================="</span><br><span class="line"> 12 sleep 10; done;</span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/o4vRt8.png" alt="o4vRt8"></p></li></ol><h3 id="11-文件位置"><a href="#11-文件位置" class="headerlink" title="11.文件位置"></a>11.文件位置</h3><p>Configuration files are stored in <code>/etc/bee/</code></p><p>State, chunks and other data is stored in <code>/var/lib/bee/</code></p><h2 id="1-3-windows运行Bee"><a href="#1-3-windows运行Bee" class="headerlink" title="1.3 windows运行Bee"></a>1.3 windows运行Bee</h2><p><a href="https://www.yuque.com/docs/share/77e34e79-24ac-4cdf-adfa-3b0399d5242c?#" target="_blank" rel="noopener">https://www.yuque.com/docs/share/77e34e79-24ac-4cdf-adfa-3b0399d5242c?#</a></p><p>winodws导出私钥工具地址 :</p><p><a href="https://github.com/jmozah/exportSwarmKey" target="_blank" rel="noopener">https://github.com/jmozah/exportSwarmKey</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;资料:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.ethswarm.org/docs/installation/quick-start&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.ethswarm.org/docs/installation/quick-start&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/docs/share/712630dc-fa67-4318-a36e-502f871a0136?#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.yuque.com/docs/share/712630dc-fa67-4318-a36e-502f871a0136?#&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu:  18.04.2 LTS&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、安装Bee&quot;&gt;&lt;a href=&quot;#一、安装Bee&quot; class=&quot;headerlink&quot; title=&quot;一、安装Bee&quot;&gt;&lt;/a&gt;一、安装Bee&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://geth.ethereum.org/docs/clef/tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://geth.ethereum.org/docs/clef/tutorial&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-1-Bee-Clef&quot;&gt;&lt;a href=&quot;#1-1-Bee-Clef&quot; class=&quot;headerlink&quot; title=&quot;1.1 Bee Clef&quot;&gt;&lt;/a&gt;1.1 Bee Clef&lt;/h2&gt;&lt;p&gt;Go Ethereum’s Clef是以太坊的上的签名和密钥管理工具, 对于Swarm, 对应的工具就是Bee Clef, 能够方便的帮助我们签名大量交易与管理密钥.&lt;/p&gt;
&lt;h3 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1. 安装:&quot;&gt;&lt;/a&gt;1. 安装:&lt;/h3&gt;&lt;p&gt;Ubuntu:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget https://github.com/ethersphere/bee-clef/releases/download/v0.4.9/bee-clef_0.4.9_amd64.deb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo dpkg -i bee-clef_0.4.9_amd64.deb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;centOS&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget https://github.com/ethersphere/bee-clef/releases/download/v0.4.9/bee-clef_0.4.9_amd64.rpm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo rpm -i bee-clef_0.4.9_amd64.rpm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;a href=&quot;https://docs.ethswarm.org/docs/installation/bee-clef/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;其他系统安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文件已经下载到&lt;code&gt;/etc/bee-clef&lt;/code&gt;文件夹下,默认情况不需要修改配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/uXe1eR.png&quot; alt=&quot;uXe1eR&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-运行服务&quot;&gt;&lt;a href=&quot;#2-运行服务&quot; class=&quot;headerlink&quot; title=&quot;2. 运行服务&quot;&gt;&lt;/a&gt;2. 运行服务&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;systemctl status bee-clef&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/wLaNsJ.png&quot; alt=&quot;wLaNsJ&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="swarm" scheme="https://xwjahahahaha.github.io/categories/technical/swarm/"/>
    
    
    <category term="swarm" scheme="https://xwjahahahaha.github.io/tags/swarm/"/>
    
  </entry>
  
  <entry>
    <title>日记_0174</title>
    <link href="https://xwjahahahaha.github.io/2021/05/13/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0174/"/>
    <id>https://xwjahahahaha.github.io/2021/05/13/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0174/</id>
    <published>2021-05-13T00:41:02.000Z</published>
    <updated>2021-05-15T04:38:45.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li><li><input disabled="" type="checkbox"> 4-1 ~ 4-31 Go网络编程Base + 专利一篇</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、 专利2篇  </li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 第一篇论文初稿与老师讨论</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 Go设计模式  </li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-31 docker、k8s</li></ul><p>七月</p><ul><li><input disabled="" type="checkbox"> 7-1 ~ 7-20 缓存、日志</li><li><input disabled="" type="checkbox"> 7-20 ~ 7-31 微服务(消息队列、任务调度、rpc)</li></ul><p>八月</p><ul><li><input disabled="" type="checkbox"> 8-1 ~ 8-20  微服务(消息队列、任务调度、rpc)</li><li><input disabled="" type="checkbox"> 8-20 ~ 8-31 </li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> swarm</li><li><input checked="" disabled="" type="checkbox"> solidity</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>微支付通道合约</title>
    <link href="https://xwjahahahaha.github.io/2021/05/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Ethereum/solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/%E5%90%88%E7%BA%A6/%E5%BE%AE%E6%94%AF%E4%BB%98%E9%80%9A%E9%81%93%E5%90%88%E7%BA%A6/"/>
    <id>https://xwjahahahaha.github.io/2021/05/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Ethereum/solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/%E5%90%88%E7%BA%A6/%E5%BE%AE%E6%94%AF%E4%BB%98%E9%80%9A%E9%81%93%E5%90%88%E7%BA%A6/</id>
    <published>2021-05-12T08:54:58.000Z</published>
    <updated>2021-05-13T07:43:12.288Z</updated>
    
    <content type="html"><![CDATA[<p>除了比特币的链下闪电网络,以太坊也有链下扩容的许多方式,微支付通道合约就是其中的一种方式</p><p><a href="https://learnblockchain.cn/docs/solidity/solidity-by-example.html#id7" target="_blank" rel="noopener">https://learnblockchain.cn/docs/solidity/solidity-by-example.html#id7</a></p><a id="more"></a><h1 id="创建与验证签名"><a href="#创建与验证签名" class="headerlink" title="创建与验证签名"></a>创建与验证签名</h1><p><strong>具体大量详细内容见上方链接</strong></p><p>合约工作有以下几步：</p><blockquote><ol><li>Alice 部署 <code>ReceiverPays</code> 合约, 并附上足够的以太来负担支付通道的付款。</li><li>Alice 通过自己的私钥签名来授权一个支付。</li><li>Alice 发送签名信息给Bob，这个信息是不需要保密的（稍后解释），用什么发送也无关紧要。</li><li>Bob 通过把签名信息提交给合约来索取这笔支付， 合约将验证信息的真实性并发送金额。</li></ol></blockquote><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/IMG_A6808C913C17-1.jpeg" alt="IMG_A6808C913C17-1"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.7</span><span class="number">.0</span> &lt; <span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract ReceivePays &#123;</span><br><span class="line">    <span class="comment">// 支付方</span></span><br><span class="line">    address owner = msg.sender;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// nonce标记map</span></span><br><span class="line">    mapping(<span class="function"><span class="params">uint256</span> =&gt;</span> bool) usedNonces;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数需要payable, 构造就需要转钱</span></span><br><span class="line">    <span class="keyword">constructor</span> () payable &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// claimPayment 收款方提取付款调用此函数</span></span><br><span class="line">    <span class="comment">// amount : 金额, nonce : 随机数, signature : 待验证签名信息 </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">claimPayment</span>(<span class="params">uint256 amount, uint256 nonce, bytes memory signature</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断nonce是否已使用</span></span><br><span class="line">        <span class="built_in">require</span>(!usedNonces[nonce]);</span><br><span class="line">        <span class="comment">// 标记此nonce的使用</span></span><br><span class="line">        usedNonces[nonce] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合约中重建客户端签名信息(取hash)</span></span><br><span class="line">        <span class="comment">// 签名的数据有: 1. 收款人地址 2. 数额 3. 随机数 4. 本合约地址</span></span><br><span class="line">        bytes32 message = prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, <span class="keyword">this</span>)));</span><br><span class="line">        <span class="comment">// 验证与参数签名信息是否为支付者</span></span><br><span class="line">        <span class="built_in">require</span>(recoverSigner(message, signature) == owner);</span><br><span class="line">        <span class="comment">// 验证成功支付</span></span><br><span class="line">        payable(msg.sender).transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入一个前缀，因为在eth_sign签名的时候会加上。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">prefixed</span>(<span class="params">bytes32 hash</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bytes32</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keccak256(abi.encodePacked(<span class="string">"\x19Ethereum Signed Message:\n32"</span>, hash));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证签名,并返回签名者地址</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recoverSigner</span>(<span class="params">bytes32 message, bytes memory signature</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">address</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 分离签名</span></span><br><span class="line">        (uint8 v, bytes32 r, bytes32 s) = splitSignature(signature);</span><br><span class="line">        <span class="keyword">return</span> ecrecover(message, v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分离签名</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">splitSignature</span>(<span class="params">bytes memory signature</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint8 v, bytes32 r, bytes32 s</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(signature.length == <span class="number">65</span>);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            <span class="comment">// 前32个字节，在长度前缀之后。</span></span><br><span class="line">            r := mload(add(signature, <span class="number">32</span>))</span><br><span class="line">            <span class="comment">// 第二个32字节</span></span><br><span class="line">            s := mload(add(signature, <span class="number">64</span>))</span><br><span class="line">            <span class="comment">// 最后一个byte,在随后32字节的第一个字节</span></span><br><span class="line">            v := byte(<span class="number">0</span>, mload(add(signature, <span class="number">96</span>)))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付方销毁合约,收回剩余资金</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == owner);</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="微支付通道"><a href="#微支付通道" class="headerlink" title="微支付通道"></a>微支付通道</h1><h2 id="什么是支付通道？"><a href="#什么是支付通道？" class="headerlink" title="什么是支付通道？"></a><strong>什么是支付通道？</strong></h2><p>支付通道允许在无需发生交易的情况下多次转移以太。这意味着可以避免与交易相关的延迟和费用。 我们将探讨两方（Alice和Bob）之间的简单单向支付通道。 它涉及三个步骤：</p><blockquote><ol><li>Alice 附加一些以太创建智能合约，可以称为“打开”了支付通道</li><li>Alice会签署一些消息指明给接收者付款金额。 每次付款都会重复此步骤。</li><li>Bob“关闭”支付通道，取回以太币，并将剩余部分发送回发送者。</li></ol></blockquote><p>注解</p><blockquote><p>只有步骤1和3需要以太坊交易，步骤2意味着发送者通过离线方法（例如电子消息）将加密签名的消息发送给接收者。 这意味着只需要两个交易就可以支持任意数量（次数）的以太币转账。</p></blockquote><p>Bob 保证会收到资金，因为智能合约托管以太并根据合法的签名消息来执行。 合约<font color='#39b54a'><strong>还可以强制超时执行，</strong></font>即使收款人拒绝关闭通道，Alice也能保证最终收回资金。 付款通道的参与者可以决定支付通道打开的持续时间。 对于短期交易，例如为网络访问的每一分钟支付一次网费，或者是长期的，例如向员工支付小时工资，支付可能持续数月或数年。</p><h2 id="打开支付通道"><a href="#打开支付通道" class="headerlink" title="打开支付通道"></a>打开支付通道</h2><p>要打开支付通道，Alice 需要部署智能合约，附加要托管的以太币并指定预期的收款人，以及通道存在有效时间。 合约的 <code>SimplePaymentChannel</code> 函数就是来做这个事情，代码在本节末尾。</p><h2 id="进行支付"><a href="#进行支付" class="headerlink" title="进行支付"></a>进行支付</h2><p>Alice 通过向 Bob 发送签名消息来付款。<font color='#e54d42'>该步骤完全在以太坊网络之外执行。</font> 消息由发送者以加密方式签名，然后直接传输给收款人。</p><p>每条消息都包含以下信息：</p><blockquote><ul><li>智能合约的地址，用于防止交叉合约重放攻击。</li><li>到目前为止所发送的以太总量。</li></ul></blockquote><p><strong>在一系列转账结束时，付款通道仅需关闭一次</strong>。因此，<font color='#e54d42'><strong>只有一条消息被兑换。</strong></font> 这就是为什么<strong>每条消息都指定了以太的累计总量，而不是每次的微支付金额</strong>。 收款人自然而然的会选择兑换最新消息，因为这是以太总数最高的消息。 <strong>每条信息包含的nonce 将不再需要，因为智能合约仅执行一条信息。</strong></p><p><strong>包含合约地址用于防止一个支付通道的消息被用于不同的通道。</strong></p><p>以下是修改后的JavaScript代码，用于对上一节中的消息进行加密签名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructPaymentMessage</span>(<span class="params">contractAddress, amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> abi.soliditySHA3(</span><br><span class="line">        [<span class="string">"address"</span>, <span class="string">"uint256"</span>],</span><br><span class="line">        [contractAddress, amount]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">signMessage</span>(<span class="params">message, callback</span>) </span>&#123;</span><br><span class="line">    web3.eth.personal.sign(</span><br><span class="line">        <span class="string">"0x"</span> + message.toString(<span class="string">"hex"</span>),</span><br><span class="line">        web3.eth.defaultAccount,</span><br><span class="line">        callback</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// contractAddress is used to prevent cross-contract replay attacks.</span></span><br><span class="line"><span class="comment">// amount, in wei, specifies how much Ether should be sent.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">signPayment</span>(<span class="params">contractAddress, amount, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = constructPaymentMessage(contractAddress, amount);</span><br><span class="line">    signMessage(message, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭状态通道"><a href="#关闭状态通道" class="headerlink" title="关闭状态通道"></a>关闭状态通道</h3><p>当Bob准备好收到他们的资金时，就可以通过调用智能合约上的 <code>关闭</code> 功能来关闭支付通道。 关闭通道会向接收方支付所欠的以太币并销毁合约，剩余的以太币返回Alice。为了关闭通道，Bob需要提供 Alice 签名过的消息。</p><p>智能合约必须验证信息是否包含发送者的有效签名。执行此验证的过程与上面收款人使用的方法相同。 Solidity函数 <code>isValidSignature</code> 和 <code>recoverSigner</code> 就是完成这个工作。</p><p><strong>只有付款通道收款人可以调用 <code>close</code> 函数</strong>，其会选择最近的付款消息，因为该消息有最高的付款总额。 如果允许发送者调用此函数，他们可以提供较低金额的消息，来欺骗收款人。</p><p>函数会验证签名的消息是否与给定的参数匹配，如果匹配，收款人将收到应得的部分，余下的部分通过 <code>selfdestruct</code> 返还给发送者。 可以在完整的合约代码中看到 <code>close</code> 函数。</p><h3 id="通道有效期"><a href="#通道有效期" class="headerlink" title="通道有效期"></a>通道有效期</h3><p>Bob可以随时关闭支付通道，但如果他没有这样做，Alice 需要一种方法来收回他们托管的资金。 一个方法是在合约部署时设置 <em>到期时间</em> ，一旦达到那个时间，Alice 就可以调用 <code>claimTimeout</code>收回他们的资金。 可以在完整的合约代码中查看 <code>claimTimeout</code> 函数。</p><p>调用此功能后，Bob无法再接收任何以太币，因此，Bob必须在到期前关闭频道。</p><h3 id="完整链上合约"><a href="#完整链上合约" class="headerlink" title="完整链上合约"></a>完整链上合约</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.7</span><span class="number">.6</span> &lt;<span class="number">0.9</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract PaymentChannel &#123;</span><br><span class="line">    <span class="comment">// 支付者</span></span><br><span class="line">    address payable sender;</span><br><span class="line">    <span class="comment">// 接受者</span></span><br><span class="line">    address payable recipient;</span><br><span class="line">    <span class="comment">// 结束期限, 到时间会强制结束通道</span></span><br><span class="line">    uint256 public expiration;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span> (address payable _recipient, uint256 duration) public payable &#123;</span><br><span class="line">        sender = payable(msg.sender);</span><br><span class="line">        recipient = payable(_recipient);</span><br><span class="line">        expiration = block.timestamp + duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否是有效的签名</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isValidSignature</span>(<span class="params">uint256 amount, bytes memory signature</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 取hash</span></span><br><span class="line">        bytes32 message = prefixed(keccak256(abi.encodePacked(<span class="keyword">this</span>, amount)));</span><br><span class="line">        <span class="keyword">return</span> recoverSigner(message, signature) == sender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加入一个前缀，因为在eth_sign签名的时候会加上。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">prefixed</span>(<span class="params">bytes32 hash</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bytes32</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keccak256(abi.encodePacked(<span class="string">"\x19Ethereum Signed Message:\n32"</span>, hash));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证签名,并返回签名者地址</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recoverSigner</span>(<span class="params">bytes32 message, bytes memory signature</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">address</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 分离签名</span></span><br><span class="line">        (uint8 v, bytes32 r, bytes32 s) = splitSignature(signature);</span><br><span class="line">        <span class="keyword">return</span> ecrecover(message, v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分离签名</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">splitSignature</span>(<span class="params">bytes memory signature</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint8 v, bytes32 r, bytes32 s</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(signature.length == <span class="number">65</span>);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            <span class="comment">// 前32个字节，在长度前缀之后。</span></span><br><span class="line">            r := mload(add(signature, <span class="number">32</span>))</span><br><span class="line">            <span class="comment">// 第二个32字节</span></span><br><span class="line">            s := mload(add(signature, <span class="number">64</span>))</span><br><span class="line">            <span class="comment">// 最后一个byte,在随后32字节的第一个字节</span></span><br><span class="line">            v := byte(<span class="number">0</span>, mload(add(signature, <span class="number">96</span>)))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受者关闭通道, 接受者可以用任意的签名信息来获得自己的余额(一般选择余额最大的), 如果有剩余则会返还给发送者</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params">uint256 amount, bytes memory signature</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 必须是接受者调用, 不能是支付者</span></span><br><span class="line">        <span class="built_in">require</span>(msg.sender == recipient);</span><br><span class="line">        <span class="comment">// 验证签名有效性</span></span><br><span class="line">        <span class="built_in">require</span>(isValidSignature(amount, signature));</span><br><span class="line">        <span class="comment">// 接受者返还金额</span></span><br><span class="line">        recipient.transfer(amount);</span><br><span class="line">        <span class="comment">// 销魂合约并且支付者返还余额</span></span><br><span class="line">        selfdestruct(sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付者可以随时延长最后期限时间, 但是接受者可以在最后期限之前随时关闭通道而不受其限制</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">uint256 newExpiration</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 必须是支付者</span></span><br><span class="line">        <span class="built_in">require</span>(msg.sender == sender);</span><br><span class="line">        <span class="built_in">require</span>(newExpiration &gt; expiration);</span><br><span class="line">        expiration = newExpiration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到达最后期限时间, 任何人都可以关闭通道, 直接将剩下的钱返还给sender</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">claimTimeout</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(block.timestamp &gt;= expiration);</span><br><span class="line">        selfdestruct(sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解</p><blockquote><p>函数 <code>splitSignature</code> 没有做足够的安全检查，完整的产品里应该使用严格测试的库，如：<a href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ECRecovery.sol" target="_blank" rel="noopener">openzepplin 的版本</a> 。</p></blockquote><h3 id="验证支付-链下"><a href="#验证支付-链下" class="headerlink" title="验证支付(链下)"></a>验证支付(链下)</h3><p><strong>与上一节不同，付款通道中的消息不是马上赎回。</strong> <strong>收款人会跟踪最新消息及在关闭付款通道时兑换它。 这意味着接收者对每条消息进行验证就至关重要。</strong> 否则，无法保证收款人能够最终获得付款。</p><p>收款人使用以下过程验证每条消息：</p><blockquote><ol><li>验证信息中的合约地址是否与付款通道匹配。</li><li>验证新金额是否为预期金额。</li><li>确认新金额不超过托管的以太币总额。</li><li>验证签名是否有效并来自通道的付款方。</li></ol></blockquote><p>我们使用 <a href="https://github.com/ethereumjs/ethereumjs-util" target="_blank" rel="noopener">ethereumjs-util</a> 库来编写验证过程，这里使用 JavaScript ，当然实现的方式有很多。下面的代码借鉴了 上面的 constructMessage 函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this mimics the prefixing behavior of the eth_sign JSON-RPC method.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prefixed</span>(<span class="params">hash</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ethereumjs.ABI.soliditySHA3(</span><br><span class="line">        [<span class="string">"string"</span>, <span class="string">"bytes32"</span>],</span><br><span class="line">        [<span class="string">"\x19Ethereum Signed Message:\n32"</span>, hash]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recoverSigner</span>(<span class="params">message, signature</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> split = ethereumjs.Util.fromRpcSig(signature);</span><br><span class="line">    <span class="keyword">var</span> publicKey = ethereumjs.Util.ecrecover(message, split.v, split.r, split.s);</span><br><span class="line">    <span class="keyword">var</span> signer = ethereumjs.Util.pubToAddress(publicKey).toString(<span class="string">"hex"</span>);</span><br><span class="line">    <span class="keyword">return</span> signer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isValidSignature</span>(<span class="params">contractAddress, amount, signature, expectedSigner</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = prefixed(constructPaymentMessage(contractAddress, amount));</span><br><span class="line">    <span class="keyword">var</span> signer = recoverSigner(message, signature);</span><br><span class="line">    <span class="keyword">return</span> signer.toLowerCase() ==</span><br><span class="line">        ethereumjs.Util.stripHexPrefix(expectedSigner).toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;除了比特币的链下闪电网络,以太坊也有链下扩容的许多方式,微支付通道合约就是其中的一种方式&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://learnblockchain.cn/docs/solidity/solidity-by-example.html#id7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://learnblockchain.cn/docs/solidity/solidity-by-example.html#id7&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="solidity" scheme="https://xwjahahahaha.github.io/categories/technical/solidity/"/>
    
    
    <category term="solidity" scheme="https://xwjahahahaha.github.io/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>swarm-1-概念知识</title>
    <link href="https://xwjahahahaha.github.io/2021/05/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Swarm/swarm-1-%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86/"/>
    <id>https://xwjahahahaha.github.io/2021/05/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Swarm/swarm-1-%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86/</id>
    <published>2021-05-12T06:07:08.000Z</published>
    <updated>2021-05-15T05:22:18.907Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习资料原文与链接:</p><p><a href="https://gateway.ethswarm.org/bzz/latest.bookofswarm.eth/" target="_blank" rel="noopener">https://gateway.ethswarm.org/bzz/latest.bookofswarm.eth/</a></p><p><a href="https://swarm.ethereum.org/#section-ecosystem" target="_blank" rel="noopener">https://swarm.ethereum.org/#section-ecosystem</a></p><p><a href="https://www.chainnews.com/articles/227689130917.htm?share_token=dd91ac29-f839-4956-8ec6-cebfceabd795" target="_blank" rel="noopener">https://www.chainnews.com/articles/227689130917.htm?share_token=dd91ac29-f839-4956-8ec6-cebfceabd795</a></p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/LiGCOI.png" alt="LiGCOI"></p><p>首先 Swarm 是以太坊项目官方的一部分，它主要是由以太坊基金会领投和开发，允许矿池存储、带宽和算力资源来支持基于以太坊网络的应用。从一开始，它就被认为是与以太坊和 Whisper 一起，定义了 Web 3.0 组件的三大支柱之一。</p><p>“如果说以太坊是全球计算cpu, 那么Swarm的目标就是它的<strong>硬盘</strong>”</p><p>Swarm 团队试图创建一个<strong>不停机、零故障和防审查的点对点存储和服务解决方案</strong>。<font color='#e54d42'><strong>在 Swarm 内创建一个经济激励的系统将促进资源交换价值的支付和转移。</strong></font>项目使用了以太坊区块链中不同的协议和技术。Swarm 的存在使互联网可以再次分散化，Swarm 的长期愿景是成为重新分散的 Internet 的操作系统。它将为数据的供应链经济性提供可扩展且可自我维持的基础架构。</p><a id="more"></a><h2 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h2><p>Swarm 的主要目标是<strong>提供充分分散和冗余存储的以太坊公共记录</strong>，<strong>尤其是存储和分发 DApp 的代码和数据以及区块链数据</strong>。从经济角度来看，它<strong>允许参与者有效汇集他们的存储容量和带宽资源，以给网络的所有参与者提供这些服务，同时接受以太坊的激励。</strong></p><p>Swarm 更广泛的目标，是<strong>为去中心化的 Web 应用程序 (DApp) 开发人员提供基础设施服务，特别是：消息传递、数据流、点对点记账、可变资源更新、存储保险、监管扫描和修复、支付渠道和数据库服务。</strong></p><p>以太坊对世界计算机的愿景，构成了即将到来的<strong>数据场景的无需信任（即完全可信任）结构</strong>：<strong>支持数据存储，传输和处理的全球基础架构。</strong></p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>从开发人员的角度来看，Swarm 最好地看作是<strong>公共基础结构</strong>，它为 Web 2.0 时代所熟悉的实时交互式 Web 应用程序提供了动力。<strong>它为作为复杂应用程序<font color='#e54d42'>构建块的基元</font>提供了低级 API，并为基于 Swarm 的 Web 3.0 开发堆栈的工具和库提供了基础。</strong>API 和工具旨在允许从任何传统的 Web 浏览器访问 Swarm 网络，因此 Swarm 可以立即提供私有和分散的替代方法来替代当今的 World Wide Web （WWW）。</p><p>swarm为自我主权的数字社会的提供分布式存储与通信, 作为分布式网络的后端存储栈</p><p>目标是构建一个人人平等、容错、弹性可拓展的互联网底层激励机制</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/0PoWcs.png" alt="0PoWcs"></p><ol><li><p>对等网络协议，用作底层传输，</p></li><li><p>具有协议的覆盖网络，该协议为块（固定大小的数据块）的分布式不可变存储提供支持，</p></li><li><p>提供<strong>高层数据访问并为基本层功能定义 API 的组件</strong></p></li><li><p>定义标准的应用程序层，并概述更精细的用例的最佳实践。</p></li></ol><h1 id="Incentives激励模式"><a href="#Incentives激励模式" class="headerlink" title="Incentives激励模式"></a>Incentives激励模式</h1><p>没有货币的新用户可以为其他节点提供服务，直到他们积累足够的货币来使用自己的服务</p><p>Swarm 总体激励设计图:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/z1ImLW.jpg" alt="z1ImLW"></p><p>总体激励总结:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/%E6%BF%80%E5%8A%B1%E6%9C%BA%E5%88%B6.png" alt="激励机制"></p><h2 id="1-Sharing-bandwidth-分享带宽"><a href="#1-Sharing-bandwidth-分享带宽" class="headerlink" title="1. Sharing bandwidth 分享带宽"></a>1. Sharing bandwidth 分享带宽</h2><h3 id="1-1-Incentives-for-serving-and-relaying-服务与接力的激励"><a href="#1-1-Incentives-for-serving-and-relaying-服务与接力的激励" class="headerlink" title="1.1 Incentives for serving and relaying 服务与接力的激励"></a>1.1 Incentives for serving and relaying 服务与接力的激励</h3><h4 id="1-1-1-Forwarding-kademlia-and-repeated-dealings"><a href="#1-1-1-Forwarding-kademlia-and-repeated-dealings" class="headerlink" title="1.1.1 Forwarding kademlia and repeated dealings"></a>1.1.1 Forwarding kademlia and repeated dealings</h4><p><strong>付费检索:</strong> 检索区块的成本由发起人提供</p><p>块的检索可以被视为一个功能单元，其中存储者充当服务提供者，请求者充当消费者。</p><p>块检索需要中继转发时, 对于转发的节点也需要激励</p><hr><h4 id="1-1-2-反向响应收费-charging-for-backwarded-response"><a href="#1-1-2-反向响应收费-charging-for-backwarded-response" class="headerlink" title="1.1.2 反向响应收费(charging for backwarded response):"></a>1.1.2 <strong>反向响应收费(charging for backwarded response):</strong></h4><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/aquawr.png" alt="aquawr"></p><p>激励检索。节点D (Downloader)向块的地址发送一个检索请求。检索使用转发，所以请求通过转发节点F0，…从Fn一直到节点S，即<strong>最接近</strong>块地址的存储节点。块通过沿着相同的路径传回到下载程序来传递。接收块响应将触发一个记帐事件。</p><p>Downloader请求不存在的区块则会给予制裁</p><p>一旦一个节点发起(启动或转发)一个请求，如果<strong>该块在定义的生存时间(TTL)内被交付，它就可以获得该块支付费用，</strong>因此，当该块被传递回来时，就不存在阻止及时交付的动机(防止超时)</p><hr><h3 id="1-2-块检索定价协议-Pricing-protocol-for-chunk-retrieval"><a href="#1-2-块检索定价协议-Pricing-protocol-for-chunk-retrieval" class="headerlink" title="1.2 块检索定价协议(Pricing protocol for chunk retrieval)"></a>1.2 <strong>块检索定价协议(Pricing protocol for chunk retrieval)</strong></h3><p>此部分是在Swarm网络中，节点用来传递它们的块的价格的协议。</p><h4 id="1-2-1-市场定价-Price-discovery"><a href="#1-2-1-市场定价-Price-discovery" class="headerlink" title="1.2.1 市场定价(Price discovery)"></a>1.2.1 市场定价(Price discovery)</h4><p>它允许市场定价机制仅<strong>基于本地决策</strong>，这是必要的，原因如下:</p><ol><li><p>带宽成本在世界各地是不同的:允许节点通过其价格表达其成本结构将使价格和质量竞争，最终使终端用户受益。</p></li><li><p>由于使用率或连通性的波动，对带宽资源的需求是不断变化的。</p></li><li><p>能够直接对变化做出反应，就能创造一个<strong>自我调节的系统。</strong></p></li></ol><blockquote><p>防止节点负责者在节点费用成本上升时关闭节点来保护自己的利润,而对整个系统造成服务的缺失</p></blockquote><p>引入了一个协议消息，它可以将这些价格传递给上游对等点(见8.4)。我们可以将此消息概念化为对请求的另一种响应。<font color='#e54d42'><strong>节点为每个邻近距离维护与每个对等体相关联的价格</strong>，因此当它们发出检索请求时，它们已经知道下游对等体在生存期内成功交付有效块时承诺支付的价格。</font></p><p>为了防止价格变化消息充斥上游对等体的DoS攻击(让上游节点只接受和处理消息变化消息)，<strong>价格消息的速率被限制</strong>。</p><p><font color='#e54d42'>表现良好、价格有竞争力的节点受到同行的青睐;如果一个节点的价格设定过高，或者其价格的波动性比网络中的其他节点高得多，那么其他节点就不太愿意向它们请求区块.</font></p><p>根据每个节点的价格波动性与合作成功率相关</p><p>表现良好、价格有竞争力的节点受到同行的青睐;如果一个节点的价格设定过高，或者其价格的波动性比网络中的其他节点高得多，那么同行将不太愿意请求</p><hr><h4 id="1-2-2-差别定价-Differential-pricing-of-proximities"><a href="#1-2-2-差别定价-Differential-pricing-of-proximities" class="headerlink" title="1.2.2 差别定价(Differential pricing of proximities)"></a>1.2.2 差别定价(Differential pricing of proximities)</h4><p>如果在一个区域内请求一个块的价格相同,那么除了可能缓存块并通过转售它来赚取收入之外，<strong>节点没有转发请求的真正动机</strong>。对于新块来说，这个选项是不合理的，特别是当它们处于一个节点的浅层邻近顺序时，它们不太可能被请求。更重要的是，如果区块的定价在邻近的订单中是统一的，合谋的节点可以产生区块流量，并捕获它们发送的数据，这实际上是一次免费的DoS攻击(见图21)。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/rywTPZ.png" alt="rywTPZ"></p><p>在邻近地区统一的块价格将允许DoS攻击。攻击者可以通过向S(只有S可以提供服务)发送检索请求，在两个节点D和S之间创建一个流量。如果相邻区域的价格相同，则这种攻击不会给攻击者带来任何成本。</p><blockquote><p>因为节点之间的价格都相同,所以可以不考虑距离而随意的转发</p></blockquote><p>为了减少这种攻击，当请求从请求者路由到存储者时，<strong>请求者为块付出的代价必须严格大于存储节点所得到的补偿。</strong></p><p>我们需要有一个奖励转发节点的定价方案，因此，这就需要对节点进行差异化定价</p><p>在这个定价模型中，<font color='#e54d42'><strong>如果对等端距离块地址更远，交付成本更高，也就是说，对块交付的奖励是一个接近度递减的函数。</strong></font></p><hr><h4 id="1-2-3-同类产品价格的一致性-Uniformity-of-price-across-peers"><a href="#1-2-3-同类产品价格的一致性-Uniformity-of-price-across-peers" class="headerlink" title="1.2.3 同类产品价格的一致性(Uniformity of price across peers)"></a>1.2.3 同类产品价格的一致性(Uniformity of price across peers)</h4><ol><li><p>在整个网络中对于相同的邻近顺序(OP)的统一价格</p></li><li><p>价格作为邻近性的函数线性下降</p></li><li><p>节点可以增加连接性并保持价格较低。</p></li></ol><p>通过这种方式，奖励机制的设计使得有利于单个节点的策略也被整齐地对齐，从而有利于整个系统的健康发展。</p><h4 id="1-2-4-容器密度-bin-density"><a href="#1-2-4-容器密度-bin-density" class="headerlink" title="1.2.4 容器密度(bin density)"></a>1.2.4 容器密度(bin density)</h4><p> 基于下游对等体与区块的邻近性进行计费导致一个转发请求的距离越远，我们赚的就越多。这种动机与下载者的兴趣相一致，即在服务他们的请求时节省跳跃，从而降低延迟交付和带宽开销。<strong>节省跳数将改善延迟，并使对等端更有效率</strong></p><h4 id="1-2-5-缓存和伸缩-Caching-and-auto-scaling"><a href="#1-2-5-缓存和伸缩-Caching-and-auto-scaling" class="headerlink" title="1.2.5 缓存和伸缩 Caching and auto-scaling"></a>1.2.5 缓存和伸缩 Caching and auto-scaling</h4><p><strong>节点每服务一个数据块就会获得奖励，因此数据块的盈利能力与它的受欢迎程度成正比:数据块被请求的频率越高，相对于每个时间单位存储的固定成本，其奖励就越高。当节点达到存储容量限制，并决定删除哪些块时，理性利润最大化代理的最优策略是删除利润率最低的块。</strong></p><p>为了最大化可选择的块集，节点会有机会缓存它们所传递的数据以及它们同步的数据块。这将导致流行内容更广泛地传播和更快地服务，使整个群体成为一个自动扩展和自动平衡的内容分发网络。</p><h4 id="1-2-6-非缓存节点-Non-caching-nodes"><a href="#1-2-6-非缓存节点-Non-caching-nodes" class="headerlink" title="1.2.6 非缓存节点 Non-caching nodes"></a>1.2.6 非缓存节点 Non-caching nodes</h4><p>非缓存节点: 仅转发功能,不缓存节点</p><p>任何留给中继节点利润的方案都为仅转发的非缓存节点进入网络创造了积极的激励。这样的节点对网络并没有本质上的好处，因为它们会产生不必要的带宽开销。一方面，它们的存在原则上可以减轻存储节点重新铺设通信量的负担，因此在浅箱中使用它们可能没有坏处。</p><p>另一方面，在邻近深度更接近的情况下，它们的同行会倾向于为它们提供缓存/存储节点，因为至少在它们假设的责任区域内，它们的缺点是不适合块。<strong>非缓存节点也有助于增加匿名性(见2.3.1)。</strong></p><h3 id="1-3-Incentivising-push-syncing-推-同步激励"><a href="#1-3-Incentivising-push-syncing-推-同步激励" class="headerlink" title="1.3 Incentivising push-syncing 推-同步激励"></a>1.3 Incentivising push-syncing 推-同步激励</h3><p>推同步是一种协议，它<strong>确保上传到网络的数据块到达其正确的地址</strong>。</p><p>推同步协议类似于检索协议，它们各自的消息交换序列通过相同的路由。推送同步协议中的数据块传递类似于检索请求，相反，推送同步中的保管接收语句类似于检索中的数据块传递响应。</p><h2 id="2-Swap-accounting-and-settlement-交换-账户与结算"><a href="#2-Swap-accounting-and-settlement-交换-账户与结算" class="headerlink" title="2. Swap: accounting and settlement 交换:账户与结算"></a>2. Swap: accounting and settlement 交换:账户与结算</h2><h3 id="2-1-Peer-to-peer-accounting"><a href="#2-1-Peer-to-peer-accounting" class="headerlink" title="2.1 Peer to peer accounting"></a>2.1 Peer to peer accounting</h3><p>一种机制来跟踪对等点之间的数据流量，并为消息中继提供对等<strong>计费</strong>。</p><h3 id="2-2-Cheques-as-off-chain-commitments-to-pay"><a href="#2-2-Cheques-as-off-chain-commitments-to-pay" class="headerlink" title="2.2 Cheques as off-chain commitments to pay"></a>2.2 Cheques as off-chain commitments to pay</h3><p>区块链网络中直接链上支付的一个主要问题是，每笔交易都必须由参与网络的每个节点来处理，导致交易成本很高。然而，创建支付而不在链上显示这种支付是可能的。这种支付被称为第二层支付策略。其中一种策略是<strong>延迟付款并批量处理</strong>。为了降低成本，受益人必须愿意承担更高的结算失败风险。</p><p>….</p><h2 id="3-storage-incentives-存储激励"><a href="#3-storage-incentives-存储激励" class="headerlink" title="3. storage incentives 存储激励"></a>3. storage incentives 存储激励</h2><p>见总结图</p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>基础层提供以下服务:</p><ol><li>参与与访问不需要许可</li><li>节点运营商零现金进入</li><li>最大的资源利用率</li><li>数据的负载均衡分布</li><li>拓展性</li><li>审查阻力和存储和检索的隐私</li><li>自动拓展受欢迎的内容</li><li>基本合理的推诿和保密</li><li>在一个动态网络中，节点的阻力和最终一致性</li><li>由于内在的经济激励，无需干预的可持续性</li><li>稳健的私人对等会计</li><li>激励带宽共享</li><li>链上结算的链外微承诺</li><li>DoS抵抗和垃圾邮件保护</li><li>积极的(即受到奖励的)储存激励</li><li>消极的(即通过威胁惩罚措施来劝阻)对数据丢失的激励。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习资料原文与链接:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gateway.ethswarm.org/bzz/latest.bookofswarm.eth/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gateway.ethswarm.org/bzz/latest.bookofswarm.eth/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://swarm.ethereum.org/#section-ecosystem&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://swarm.ethereum.org/#section-ecosystem&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.chainnews.com/articles/227689130917.htm?share_token=dd91ac29-f839-4956-8ec6-cebfceabd795&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.chainnews.com/articles/227689130917.htm?share_token=dd91ac29-f839-4956-8ec6-cebfceabd795&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/LiGCOI.png&quot; alt=&quot;LiGCOI&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先 Swarm 是以太坊项目官方的一部分，它主要是由以太坊基金会领投和开发，允许矿池存储、带宽和算力资源来支持基于以太坊网络的应用。从一开始，它就被认为是与以太坊和 Whisper 一起，定义了 Web 3.0 组件的三大支柱之一。&lt;/p&gt;
&lt;p&gt;“如果说以太坊是全球计算cpu, 那么Swarm的目标就是它的&lt;strong&gt;硬盘&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;Swarm 团队试图创建一个&lt;strong&gt;不停机、零故障和防审查的点对点存储和服务解决方案&lt;/strong&gt;。&lt;font color=&#39;#e54d42&#39;&gt;&lt;strong&gt;在 Swarm 内创建一个经济激励的系统将促进资源交换价值的支付和转移。&lt;/strong&gt;&lt;/font&gt;项目使用了以太坊区块链中不同的协议和技术。Swarm 的存在使互联网可以再次分散化，Swarm 的长期愿景是成为重新分散的 Internet 的操作系统。它将为数据的供应链经济性提供可扩展且可自我维持的基础架构。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="swarm" scheme="https://xwjahahahaha.github.io/categories/technical/swarm/"/>
    
    
    <category term="swarm" scheme="https://xwjahahahaha.github.io/tags/swarm/"/>
    
  </entry>
  
  <entry>
    <title>208-实现Trie前缀树</title>
    <link href="https://xwjahahahaha.github.io/2021/05/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E8%AE%BE%E8%AE%A1%E7%B1%BB/208-%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <id>https://xwjahahahaha.github.io/2021/05/12/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E8%AE%BE%E8%AE%A1%E7%B1%BB/208-%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/</id>
    <published>2021-05-12T02:03:12.000Z</published>
    <updated>2021-05-12T02:05:07.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></p><p>难度中等754</p><p><strong><a href="https://baike.baidu.com/item/字典树/9825209?fr=aladdin" target="_blank" rel="noopener">Trie</a></strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code>。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><a id="more"></a> <p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 True</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li><li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    isEnd <span class="keyword">bool</span></span><br><span class="line">    children [<span class="number">26</span>]*Trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Trie</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Insert</span><span class="params">(word <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">    node := this</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> word &#123;</span><br><span class="line">        i := c - <span class="string">'a'</span></span><br><span class="line">        <span class="keyword">if</span> node.children[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 不存在就创建</span></span><br><span class="line">            node.children[i] = <span class="built_in">new</span>(Trie)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向下遍历</span></span><br><span class="line">        node = node.children[i]</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Search</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   node := this</span><br><span class="line">   <span class="keyword">for</span> _, c := <span class="keyword">range</span> word &#123;</span><br><span class="line">       i := c - <span class="string">'a'</span></span><br><span class="line">       <span class="keyword">if</span> node.children[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">       node = node.children[i]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 注意: 返回最后一个单词的结束字符而不是直接返回true</span></span><br><span class="line">   <span class="keyword">return</span> node.isEnd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line"><span class="comment">// 判断 Trie 中是或有以 prefix 为前缀的单词</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">StartsWith</span><span class="params">(prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    node := this</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">        i := c - <span class="string">'a'</span></span><br><span class="line">        <span class="keyword">if</span> node.children[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意: 这里就是直接返回true,因为只需要判断前缀存在即可,后续是否还有不用考虑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Insert(word);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.StartsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-trie-prefix-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;208. 实现 Trie (前缀树)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等754&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/字典树/9825209?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Trie&lt;/a&gt;&lt;/strong&gt;（发音类似 “try”）或者说 &lt;strong&gt;前缀树&lt;/strong&gt; 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。&lt;/p&gt;
&lt;p&gt;请你实现 Trie 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Trie()&lt;/code&gt; 初始化前缀树对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void insert(String word)&lt;/code&gt; 向前缀树中插入字符串 &lt;code&gt;word&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean search(String word)&lt;/code&gt; 如果字符串 &lt;code&gt;word&lt;/code&gt; 在前缀树中，返回 &lt;code&gt;true&lt;/code&gt;（即，在检索之前已经插入）；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean startsWith(String prefix)&lt;/code&gt; 如果之前已经插入的字符串 &lt;code&gt;word&lt;/code&gt; 的前缀之一为 &lt;code&gt;prefix&lt;/code&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0173</title>
    <link href="https://xwjahahahaha.github.io/2021/05/12/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0173/"/>
    <id>https://xwjahahahaha.github.io/2021/05/12/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0173/</id>
    <published>2021-05-12T01:20:19.000Z</published>
    <updated>2021-05-13T00:40:49.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li><li><input disabled="" type="checkbox"> 4-1 ~ 4-31 Go网络编程Base + 专利一篇</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、 专利2篇  </li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 第一篇论文初稿与老师讨论</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 Go设计模式  </li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-31 docker、k8s</li></ul><p>七月</p><ul><li><input disabled="" type="checkbox"> 7-1 ~ 7-20 缓存、日志</li><li><input disabled="" type="checkbox"> 7-20 ~ 7-31 微服务(消息队列、任务调度、rpc)</li></ul><p>八月</p><ul><li><input disabled="" type="checkbox"> 8-1 ~ 8-20  微服务(消息队列、任务调度、rpc)</li><li><input disabled="" type="checkbox"> 8-20 ~ 8-31 </li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语70词 + 听力复盘</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> solidity</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0172</title>
    <link href="https://xwjahahahaha.github.io/2021/05/10/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0172/"/>
    <id>https://xwjahahahaha.github.io/2021/05/10/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0172/</id>
    <published>2021-05-10T06:05:29.000Z</published>
    <updated>2021-05-11T01:19:00.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li><li><input disabled="" type="checkbox"> 4-1 ~ 4-31 Go网络编程Base + 专利一篇</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、 专利2篇  </li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 第一篇论文初稿与老师讨论</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 Go设计模式  </li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-31 docker、k8s</li></ul><p>七月</p><ul><li><input disabled="" type="checkbox"> 7-1 ~ 7-20 缓存、日志</li><li><input disabled="" type="checkbox"> 7-20 ~ 7-31 微服务(消息队列、任务调度、rpc)</li></ul><p>八月</p><ul><li><input disabled="" type="checkbox"> 8-1 ~ 8-20  微服务(消息队列、任务调度、rpc)</li><li><input disabled="" type="checkbox"> 8-20 ~ 8-31 </li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 英语</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> 论文</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>322-零钱兑换</title>
    <link href="https://xwjahahahaha.github.io/2021/05/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>https://xwjahahahaha.github.io/2021/05/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</id>
    <published>2021-05-09T05:05:37.000Z</published>
    <updated>2021-05-09T05:07:40.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></p><p>难度中等1256</p><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p>你可以认为每种硬币的数量是无限的。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp递推式: dp[i] = min(dp[i-coins[0]], dp[i-coins[1]], ..., dp[i-coins[n-1]]) + 1</span></span><br><span class="line"><span class="comment">// 时间复杂度O(SN) S: 金额,N: 数组长度</span></span><br><span class="line"><span class="keyword">const</span> INT_MAX = <span class="keyword">int</span>(^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(coins)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i &lt;= amount; i++&#123;</span><br><span class="line">        min := INT_MAX          <span class="comment">// 设置最小值为最大值</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;n; j++ &#123;</span><br><span class="line">            <span class="comment">// 子dp需要满足三个条件才能为最小值:</span></span><br><span class="line">            <span class="comment">// 1. dp金额&gt;0, 即 i-coins[j] &gt; 0, 这才是有效的(也是防止数组越界)</span></span><br><span class="line">            <span class="comment">// 2. 子dp本身有效, 即子dp != -1 即 &gt; 0</span></span><br><span class="line">            <span class="comment">// 3. 子dp小于当前最小子dp即min, 为了找出最小的子dp</span></span><br><span class="line">            <span class="keyword">if</span> i - coins[j] &gt;= <span class="number">0</span> &amp;&amp; dp[i-coins[j]] &gt;= <span class="number">0</span> &amp;&amp; dp[i-coins[j]] &lt; min&#123;</span><br><span class="line">                min = dp[i-coins[j]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> min != INT_MAX &#123;</span><br><span class="line">            <span class="comment">// 找到了最小子dp,那么就记录当前dp</span></span><br><span class="line">            dp[i] = min + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果所有子dp都满足条件那么此dp也不满足</span></span><br><span class="line">            dp[i] = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;322. 零钱兑换&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等1256&lt;/p&gt;
&lt;p&gt;给定不同面额的硬币 &lt;code&gt;coins&lt;/code&gt; 和一个总金额 &lt;code&gt;amount&lt;/code&gt;。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你可以认为每种硬币的数量是无限的。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0171</title>
    <link href="https://xwjahahahaha.github.io/2021/05/09/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0171/"/>
    <id>https://xwjahahahaha.github.io/2021/05/09/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0171/</id>
    <published>2021-05-09T01:01:10.000Z</published>
    <updated>2021-05-10T06:05:07.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li><li><input disabled="" type="checkbox"> 4-1 ~ 4-31 Go网络编程Base + 专利一篇</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、 专利2篇  </li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 第一篇论文初稿与老师讨论</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 Go设计模式  </li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-31 docker、k8s</li></ul><p>七月</p><ul><li><input disabled="" type="checkbox"> 7-1 ~ 7-20 缓存、日志</li><li><input disabled="" type="checkbox"> 7-20 ~ 7-31 微服务(消息队列、任务调度、rpc)</li></ul><p>八月</p><ul><li><input disabled="" type="checkbox"> 8-1 ~ 8-20  微服务(消息队列、任务调度、rpc)</li><li><input disabled="" type="checkbox"> 8-20 ~ 8-31 </li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语单词 + 听力</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> 论文</li><li><input checked="" disabled="" type="checkbox"> go项目</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>62-不同路径</title>
    <link href="https://xwjahahahaha.github.io/2021/05/08/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>https://xwjahahahaha.github.io/2021/05/08/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2021-05-08T02:15:56.000Z</published>
    <updated>2021-05-08T02:18:23.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></p><p>难度中等984</p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p> <a id="more"></a><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><p>通过次数246,418</p><p>提交次数379,054</p><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs搜索</span></span><br><span class="line"><span class="comment">// m、n过大时超时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> i == m<span class="number">-1</span> &amp;&amp; j == n<span class="number">-1</span> &#123;</span><br><span class="line">            count ++</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向右走</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; n<span class="number">-1</span> &#123;</span><br><span class="line">            dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向下走</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; m<span class="number">-1</span> &#123;</span><br><span class="line">            dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 设走到当前位置的路径数是f(i, j)</span></span><br><span class="line"><span class="comment">// 那么其上一步一定是从f(i-1, j) 或者 f(i, j-1)走过来的</span></span><br><span class="line"><span class="comment">// =&gt; 递推式: f(i, j) = f(i-1, j) + f(i, j-1)</span></span><br><span class="line"><span class="comment">// 边界条件: dp[0][0] = dp[0][j] = dp[i][0] = 1</span></span><br><span class="line"><span class="comment">// 时间复杂度O(mn)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建二维数组</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; j<span class="number">-1</span> &gt;= <span class="number">0</span> &#123;       <span class="comment">// 确保i-1、j-1有效</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">0</span> &amp;&amp; j<span class="number">-1</span> &gt;= <span class="number">0</span>&#123;    <span class="comment">// 边界条件: 第一行都为1</span></span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>]</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> j == <span class="number">0</span> &amp;&amp; i<span class="number">-1</span> &gt;= <span class="number">0</span>&#123;    <span class="comment">// 边界条件: 第一列都为1</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;62. 不同路径&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等984&lt;/p&gt;
&lt;p&gt;一个机器人位于一个 &lt;code&gt;m x n&lt;/code&gt; 网格的左上角 （起始点在下图中标记为 “Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>《The_Bitcoin_Lightning_Network:Scalable_Off-Chain_Instant_Payments》精读</title>
    <link href="https://xwjahahahaha.github.io/2021/05/07/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E8%AE%BA%E6%96%87/%E3%80%8AThe-Bitcoin-Lightning-Network-Scalable-Off-Chain-Instant-Payments%E3%80%8B%E7%B2%BE%E8%AF%BB/"/>
    <id>https://xwjahahahaha.github.io/2021/05/07/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E8%AE%BA%E6%96%87/%E3%80%8AThe-Bitcoin-Lightning-Network-Scalable-Off-Chain-Instant-Payments%E3%80%8B%E7%B2%BE%E8%AF%BB/</id>
    <published>2021-05-07T12:40:16.000Z</published>
    <updated>2021-05-25T14:22:25.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>闪电网络白皮书</p><a id="more"></a><h1 id="1-The-Bitcoin-Blockchain-Scalability-Problem"><a href="#1-The-Bitcoin-Blockchain-Scalability-Problem" class="headerlink" title="1. The Bitcoin Blockchain Scalability Problem"></a>1. The Bitcoin Blockchain Scalability Problem</h1><p>当前比特币区块链的问题:</p><ul><li><p>TPS太小, 大量的小微支付交易以比特币网络的块大小将会造成大量的存储需求, 从而导致只有能够承担的节点只有中心化的节点逐渐导致网络成为中心化的网络</p></li><li><p>增加区块大小的方式会造成手续费的升高, 提高了交易的成本</p></li></ul><h1 id="2-A-Network-of-Micropayment-Channels-Can-Solve-Scalability"><a href="#2-A-Network-of-Micropayment-Channels-Can-Solve-Scalability" class="headerlink" title="2. A Network of Micropayment Channels Can Solve Scalability"></a>2. A Network of Micropayment Channels Can Solve Scalability</h1><p>微支付通道闪电网络可以解决可拓展性问题</p><blockquote><p>If a tree falls in the forest and no one is around to hear it, does it make a sound ? </p></blockquote><p>区块链中的交易双方的一些交易可以不需要让其他人/节点知道这些交易的发生, 相反的,只需要区块链知道一些(最少的)重要的信息即可</p><p><font color='#e54d42'><strong>通过将每笔交易的信息延迟告知整个世界，在晚些时候对他们的关系进行净结算，</strong></font>使比特币用户能够进行许多交易，而不会膨胀区块链或在一个集中的对手方中造成中心化信任</p><p>通过<strong>时间锁(time locks)</strong>作为全局共识机制的组件, 实现中一个高效的不可信的结构</p><p>微支付渠道使用的是真实的比特币交易，只是选择将交易延迟广播到区块链，以保证双方在区块链上的当前余额;</p><p>这不是一个可信的覆盖网络，小额支付渠道是真正的比特币在<font color='#e54d42'><strong>链下</strong></font>通信和交换。</p><h3 id="2-1-Micropayments-Channels-Do-Not-Require-Trust"><a href="#2-1-Micropayments-Channels-Do-Not-Require-Trust" class="headerlink" title="2.1 Micropayments Channels Do Not Require Trust"></a>2.1 Micropayments Channels Do Not Require Trust</h3><p>当有区块链中出现不一致的行为时, 区块链的时间戳系统可以避免, 例如相同的交易双方只有最新的交易有效.</p><p>微支付通道大致流程:</p><ol><li><p>Alice 和 Bob 都可以创建fund交易将资金存储到一个2-2多重签名的地址(双方都签名才能支出)中</p><p>fundTx : Alice 0.05btc,  Bob 0.05btc  =&gt; 2-2 account</p></li><li><p>双方各自都可以签名一个refund交易(2-2多重签名的交易)返还金额给自己,并且不广播其到区块上(在合适的时候可以广播)</p><p>refundTx1: 2-2 account =&gt; Alice 0.05btc, Bob 0.05btc    (双方都互相签过名)</p></li><li><p>更新余额</p><p>refundTx2: 2-2 account =&gt; Alice 0.07btc, Bob 0.03btc    (双方都互相签过名)</p></li></ol><p>问题: refundTx1 和 refundTx2 怎样防止作恶,知道哪一个交易是正确的?</p><p>要保证当前只有一个正确的余额, 并且旧的余额会被丢弃</p><p><strong>比特币脚本</strong>: 在比特币中可以设计一个比特币脚本，让所有旧的交易失效，只有新交易有效。无效是通过比特币输出脚本和依赖的交易强制执行的，这些交易迫使另一方将他们所有的资金交给渠道对手方。通过将所有资金作为一种惩罚给予对方，所有旧的交易因此失效。</p><blockquote><p>论文中并没有详细的说明这样的脚本如何设计,可能后面会详细讨论</p></blockquote><p>这种无效过程可以通过渠道共识的过程来存在，如果双方同意当前的余额状态(并建立新的状态)，那么实际余额就会更新。只有当有一方不同意时，余额才会反映在区块链上。从概念上讲，这个系统不是一个独立的覆盖网络;这更像是当前系统的一种状态延迟，因为执行仍发生在区块链本身(尽管推迟到未来的日期和交易)。</p><h3 id="2-2-A-Network-of-Channels"><a href="#2-2-A-Network-of-Channels" class="headerlink" title="2.2 A Network of Channels"></a>2.2 A Network of Channels</h3><p>建立一个庞大的微支付网络来解决比特币拓展性问题</p><p>每个用户只要有一个通道能够接入到这个微支付网络,那么他就可以实现微支付</p><p>通过<strong>哈希锁hashlock</strong>和<strong>时间锁timelock</strong>阻碍比特币交易输出,能够确保交易金额不被偷窃</p><p>通过使用<strong>交错超时staggered timeouts</strong>，可以通过网络中的多个中介发送资金，而不会有中介窃取资金的风险。</p><h1 id="3-Bidirectional-Payment-Channels-双向微支付通道"><a href="#3-Bidirectional-Payment-Channels-双向微支付通道" class="headerlink" title="3. Bidirectional Payment Channels 双向微支付通道"></a>3. Bidirectional Payment Channels 双向微支付通道</h1><p>目前，Hub-and-Spoke微支付渠道[7][8]<a href="以及可信的支付渠道网络[10][11]">9</a>已经开始着手构建一个现在的Hub-and-Spoke网络。</p><p>闪电网络的双向微支付通道需要附录A中描述的<strong>可延展性软分叉</strong>，以实现近乎无限的可扩展性，同时降低中间节点违约的风险。</p><p>通过将多个微支付渠道链接在一起，就有可能创建一个交易路径网络</p><p>路径选择可以类似于使用BGP路由协议,发送方可以指定到接收方的特定路径</p><p><strong>输出脚本被接受方的hash所阻碍, 通过向该hash披露输入，接收方的交易对手将能够沿着该路线提取资金。</strong></p><h2 id="3-1-The-Problem-of-Blame-in-Channel-Creation-渠道创建过程中的过错问题"><a href="#3-1-The-Problem-of-Blame-in-Channel-Creation-渠道创建过程中的过错问题" class="headerlink" title="3.1 The Problem of Blame in Channel Creation 渠道创建过程中的过错问题"></a>3.1 The Problem of Blame in Channel Creation 渠道创建过程中的过错问题</h2><h3 id="3-1-1-Creating-an-Unsigned-Funding-Transaction"><a href="#3-1-1-Creating-an-Unsigned-Funding-Transaction" class="headerlink" title="3.1.1 Creating an Unsigned Funding Transaction"></a>3.1.1 Creating an Unsigned Funding Transaction</h3><p>==Initial Channel Funding Tx==</p><p>初始渠道资金交易(Initial Channel Funding Tx)是由<strong>一个或双方</strong>的交易双方为该交易的输入提供资金而产生的。</p><p>输出为一个关于通道双方的2-2多重签名脚本, <font color='#e54d42'>使用这个output需要双方的签名</font></p><p>双方为该交易创建输入与输出,但是<font color='#e54d42'><strong>不签署交易</strong>目前该交易还是无效的</font></p><ol><li><p>输入: 来自于单方或双方</p></li><li><p>输出: 2-2双方的多重签名</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/Lfj7Db.png" alt="Lfj7Db"></p></li></ol><p>两个参与者都<strong>不交换资金交易的签名</strong>，直到他们从这2-2的输出中创建新的输出——refunding 将原始金额退还给各自的资助者。</p><p><font color='#e54d42'>不签署交易的目的是允许<strong>一个人从一个还不存在的交易中消费。</strong></font></p><p>如果他们不合作(交换funding Tx的签名),那么这个交易就会永远的被锁定</p><p><strong>确定通道资金总额:</strong> 该交易中的来自于Alice和Bob的输入需要双方<strong>交换各自的input,</strong> 这样就能够确定整个通道中的资金总额为多少</p><p><strong>交换密钥</strong>: 交换一对密钥用于后续的签名, 这个密钥用于funding Tx中2-2多重签名output的解锁(并非Funding Tx)</p><h3 id="3-1-2-Spending-from-an-Unsigned-Transaction"><a href="#3-1-2-Spending-from-an-Unsigned-Transaction" class="headerlink" title="3.1.2 Spending from an Unsigned Transaction"></a>3.1.2 Spending from an Unsigned Transaction</h3><p>==SIGHASH_NOINPUT Tx==</p><p>从未签名的交易中消费</p><p>闪电网络使用<code>SIGHASH_NOINPUT</code>交易去花费2-2 Funding Tx output, <font color='#e54d42'>前提是<strong>Funding Tx还没有交换签名即Funding Tx还没有生效</strong></font></p><p><code>SIGHASH_NOINPUT</code>使用<strong>软分叉</strong>确保交易能够在其各方签名之前进行消费, 因为交易都需要签名才能够计算出交易的ID/Hash<strong>(对于Funding Tx来说双方没有签名就无法计算其Hash)</strong></p><p>没有<code>SIGHASH NOINPUT</code>，比特币交易在可能被广播之前就不能被消费——就好像一个人不能在没有先支付给另一方的情况下起草合同一样。<code>SIGHASH NOINPUT</code>的实现细节见附录A</p><p>没有<code>SIGHASH NOINPUT</code>，就不可能在不交换签名的情况下从交易中生成支出, 因为使用Funding Transaction需要一个交易ID作为子输入中的签名的一部分。</p><blockquote><p><font color='#39b54a'>使用Funding Tx的子交易的输入的签名需要对整个这个子交易整个交易签名,但是Funding Tx是没有被签名的,没有Tx Hash, 所以子交易中前一个交易的Hash字段为空,所以无法签名</font></p></blockquote><p>交易ID的一个组件是父交易(Funding Tx)的签名，所以双方需要交换父交易的签名，然后才能花掉子交易。</p><blockquote><p><font color='#39b54a'>子交易的签名需要父交易的ID,父交易的ID需要父交易的签名,所以双方需要先交换父交易的签名</font></p></blockquote><p>因为一方或双方必须知道父方的签名才能使用它，这意味着一方或双方能够在子方存在之前广播父方(funding Tx)。</p><blockquote><p><font color='#39b54a'>双方必须互相在创建子交易之前知道父交易的(对方的)签名,所以双方都能够在知道后任何时间广播父交易, <strong>这就违背了闪电网络的要求</strong></font></p></blockquote><p><code>SIGHASH NOINPUT</code>通过允许子交易<strong>在没有对输入进行签名的情况下消费</strong>来解决这个问题</p><blockquote><p><font color='#e54d42'><code>SIGHASH_NOINOUT</code>实现了即使在父交易没有签名的情况下,子交易也可以先签名. 即花费未签名的交易</font></p></blockquote><p>操作流程如下:</p><ol><li>创建父交易(funding Tx)</li><li>创建子交易(Commitment Tx 和所有花费Commitment Tx的交易)</li><li>签名子交易(自己签自己)</li><li>交换子交易的签名</li><li>签名父交易(自己签自己)</li><li><strong>交换父交易的签名</strong></li><li><strong>广播父交易</strong></li></ol><blockquote><p>注意: </p><ol><li>子交易的签名与父交易的签名所用的公私钥对不是相同的</li><li>在步骤6完成之前，不能广播父交易(步骤7)</li><li>直到步骤6双方都不交换他们的funding Tx签名</li></ol></blockquote><h3 id="3-1-3-Commitment-Transactions-Unenforcible-Construction"><a href="#3-1-3-Commitment-Transactions-Unenforcible-Construction" class="headerlink" title="3.1.3 Commitment Transactions : Unenforcible Construction"></a>3.1.3 Commitment Transactions : Unenforcible Construction</h3><p>==Commitment Transaction==</p><p>在未签署(和未广播)的funding Tx创建后，双方签署并交换初始Commitment Transaction。</p><p>这些借助于Funding Tx outputs的Commitment Txs不会被广播(其实最后一个也会被广播),最后只有Funding Tx会被广播</p><p>当Funding Transaction已经进入区块链，其output是2-2的多签名交易，需要双方同意支出，因此<font color='#e54d42'><strong>使用最新的Commitment transactions来表示当前余额。</strong></font></p><p>参与者们只需要交换一个Commitment Tx时其余额就代表着参与者们应拿回的钱,当然,需要在founding Tx广播上链之后</p><p><strong>一方广播交换中最新的Commitment Tx就代表着微支付通道的关闭(结束当前余额变动/清算)</strong></p><hr><p>一种简单的实现方式:</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/RWvZ4f.png" alt="RWvZ4f"></p><blockquote><p>​    图中只有Funding Tx被广播上链了, Commitment Tx还没上链</p></blockquote><p>创建两个输出分别将初始资金返回给Alice和Bob</p><p><strong>Commitment Tx首先被签名，密钥被交换，因此双方都能够在任何时间广播Commitment Tx，前提是Funding Tx已在区块链。基于这一点,Funding Tx的签名能够被放心的交换, 因为每个人都可以赎回自己的金额</strong></p><hr><p>改变交易状态中的余额 =&gt; 修改Commitment Tx的输出金额</p><p>当双方同意一个新的Commitment Tx并交换新的Commitment Tx的签名时，<strong>任何一个Commitment Tx都可以广播。</strong> </p><p><font color='#e54d42'><strong>双方都有一份相同的Commitment Tx但是最终只会有一个上链</strong></font></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/3CRZlF.png" alt="3CRZlF"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h1&gt;&lt;p&gt;闪电网络白皮书&lt;/p&gt;</summary>
    
    
    
    <category term="knowledge" scheme="https://xwjahahahaha.github.io/categories/knowledge/"/>
    
    
  </entry>
  
  <entry>
    <title>55-跳跃游戏</title>
    <link href="https://xwjahahahaha.github.io/2021/05/07/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>https://xwjahahahaha.github.io/2021/05/07/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</id>
    <published>2021-05-07T08:31:58.000Z</published>
    <updated>2021-05-07T08:34:56.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></p><p>难度中等1176</p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><a id="more"></a> <p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><p>通过次数231,638</p><p>提交次数550,464</p><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>贪心算法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从后往前,动态规划</span></span><br><span class="line"><span class="comment">// 1. 前面有一步可达, 此步可达前一步 2. 此步直接可达末尾</span></span><br><span class="line"><span class="comment">// dp[i] = dp[i+j] || nums[i] &gt;= n-i-1</span></span><br><span class="line"><span class="comment">// 耗时较高564ms, 时间复杂度很高</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">bool</span>, n)</span><br><span class="line">    dp[n<span class="number">-1</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i:=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;=nums[i]; j++ &#123;</span><br><span class="line">            dp[i] = dp[i+j] || nums[i] &gt;= n-i<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记最远位置、贪心算法</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    end := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; end &#123;                <span class="comment">// 当i大于最远位置时,当前位置已经不可达所以直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i + nums[i] &gt; end &#123;      <span class="comment">// 替换较大者, 保持最远位置</span></span><br><span class="line">            end =  i + nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> end &gt;= n<span class="number">-1</span> &#123;             <span class="comment">// 当前能够到达最远位置就结束</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最早到达的位置、贪心算法</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    start := n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i:=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] + i &gt;= start &#123;       <span class="comment">// 如果当前位置能够到达上一个最早到达的位置,那么就更新</span></span><br><span class="line">            start = i   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;55. 跳跃游戏&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等1176&lt;/p&gt;
&lt;p&gt;给定一个非负整数数组 &lt;code&gt;nums&lt;/code&gt; ，你最初位于数组的 &lt;strong&gt;第一个下标&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个下标。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>33-搜索旋转排序数组</title>
    <link href="https://xwjahahahaha.github.io/2021/05/07/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://xwjahahahaha.github.io/2021/05/07/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2021-05-07T07:35:58.000Z</published>
    <updated>2021-05-07T07:37:09.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></p><p>难度中等1351</p><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><a id="more"></a> <p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(log n)</code> 的解决方案吗？</p><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索</span></span><br><span class="line"><span class="comment">// 虽然旋转了,但是部分有序</span></span><br><span class="line"><span class="comment">// 二分查找到中点时,左右两侧一定有一部分是完全有序(升序)的,所以可以判断舍弃那一部分</span></span><br><span class="line"><span class="comment">// 时间复杂度O(logN)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    l, r := <span class="number">0</span>, n<span class="number">-1</span> </span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := (l+r) &gt;&gt; <span class="number">1</span></span><br><span class="line">        fmt.Println(l, r, mid)</span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[l] &lt;= nums[mid] &#123;</span><br><span class="line">                <span class="keyword">if</span> target &gt;= nums[l] &amp;&amp; target &lt; nums[mid] &#123;</span><br><span class="line">                    <span class="comment">// 舍弃右边</span></span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 舍弃左边</span></span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> target &gt; nums[mid] &amp;&amp; target &lt;= nums[r]&#123;</span><br><span class="line">                    <span class="comment">// 舍弃左边</span></span><br><span class="line">                    l = mid + <span class="number">1</span>   </span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 舍弃右边</span></span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;33. 搜索旋转排序数组&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等1351&lt;/p&gt;
&lt;p&gt;整数数组 &lt;code&gt;nums&lt;/code&gt; 按升序排列，数组中的值 &lt;strong&gt;互不相同&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;在传递给函数之前，&lt;code&gt;nums&lt;/code&gt; 在预先未知的某个下标 &lt;code&gt;k&lt;/code&gt;（&lt;code&gt;0 &amp;lt;= k &amp;lt; nums.length&lt;/code&gt;）上进行了 &lt;strong&gt;旋转&lt;/strong&gt;，使数组变为 &lt;code&gt;[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]&lt;/code&gt;（下标 &lt;strong&gt;从 0 开始&lt;/strong&gt; 计数）。例如， &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 在下标 &lt;code&gt;3&lt;/code&gt; 处经旋转后可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;给你 &lt;strong&gt;旋转后&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;target&lt;/code&gt; ，如果 &lt;code&gt;nums&lt;/code&gt; 中存在这个目标值 &lt;code&gt;target&lt;/code&gt; ，则返回它的下标，否则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0170</title>
    <link href="https://xwjahahahaha.github.io/2021/05/07/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0170/"/>
    <id>https://xwjahahahaha.github.io/2021/05/07/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0170/</id>
    <published>2021-05-07T05:46:13.000Z</published>
    <updated>2021-05-08T01:01:18.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li><li><input disabled="" type="checkbox"> 4-1 ~ 4-31 Go网络编程Base + 专利一篇</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、 专利2篇  </li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 第一篇论文初稿与老师讨论</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 Go设计模式  </li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-31 docker、k8s</li></ul><p>七月</p><ul><li><input disabled="" type="checkbox"> 7-1 ~ 7-20 缓存、日志</li><li><input disabled="" type="checkbox"> 7-20 ~ 7-31 微服务(消息队列、任务调度、rpc)</li></ul><p>八月</p><ul><li><input disabled="" type="checkbox"> 8-1 ~ 8-20  微服务(消息队列、任务调度、rpc)</li><li><input disabled="" type="checkbox"> 8-20 ~ 8-31 </li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语140词 + 订正</li><li><input checked="" disabled="" type="checkbox"> leetcode两题</li><li><input checked="" disabled="" type="checkbox"> 论文</li><li><input checked="" disabled="" type="checkbox"> go项目</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>56-合并区间</title>
    <link href="https://xwjahahahaha.github.io/2021/05/03/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>https://xwjahahahaha.github.io/2021/05/03/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</id>
    <published>2021-05-03T03:22:39.000Z</published>
    <updated>2021-05-03T03:26:34.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></p><p>难度中等918</p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><h1 id="解题思路和代码"><a href="#解题思路和代码" class="headerlink" title="解题思路和代码"></a>解题思路和代码</h1><p>时间复杂度O(nlongn)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接的思路: 快速排序 + 合并</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(intervals)</span><br><span class="line">    <span class="comment">// 先排序</span></span><br><span class="line">    quickSort(<span class="number">0</span>, n<span class="number">-1</span>, intervals)</span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    ans := mergeOnce(intervals)</span><br><span class="line">    m := <span class="built_in">len</span>(ans)</span><br><span class="line">    <span class="comment">// 循环合并</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; m &#123;</span><br><span class="line">        n = m</span><br><span class="line">        ans = mergeOnce(ans)</span><br><span class="line">        m = <span class="built_in">len</span>(ans)</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(l, r <span class="keyword">int</span>, intervals [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    pivot := intervals[l]</span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        <span class="keyword">for</span> intervals[r][<span class="number">0</span>] &gt;= pivot[<span class="number">0</span>] &amp;&amp; l &lt; r &#123; r -- &#125;</span><br><span class="line">        intervals[l] = intervals[r]</span><br><span class="line">        <span class="keyword">for</span> intervals[l][<span class="number">0</span>] &lt;= pivot[<span class="number">0</span>] &amp;&amp; l &lt; r &#123; l ++ &#125;</span><br><span class="line">        intervals[r] = intervals[l]</span><br><span class="line">    &#125;</span><br><span class="line">    intervals[l] = pivot</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(l, r <span class="keyword">int</span>, intervals [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">        mid := partition(l, r, intervals)</span><br><span class="line">        quickSort(l, mid<span class="number">-1</span>, intervals)</span><br><span class="line">        quickSort(mid+<span class="number">1</span>, r, intervals)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeOnce</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(intervals)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        <span class="comment">// 1. 前后相同, 直接去重</span></span><br><span class="line">        <span class="comment">// 2. 中间交集: 前者[1] &gt; 后者[0] &amp;&amp; 前者[1] &lt; 后者[1]</span></span><br><span class="line">        <span class="comment">// 3. 全包子集: 前者[1] &gt;= 后者[1]</span></span><br><span class="line">        <span class="keyword">if</span> i == n<span class="number">-1</span> &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, intervals[n<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> intervals[i][<span class="number">0</span>] == intervals[i+<span class="number">1</span>][<span class="number">0</span>] &amp;&amp; intervals[i][<span class="number">1</span>] == intervals[i+<span class="number">1</span>][<span class="number">1</span>] || intervals[i][<span class="number">1</span>] &gt; intervals[i+<span class="number">1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, []<span class="keyword">int</span>&#123;intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>]&#125;)</span><br><span class="line">            i ++</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> intervals[i][<span class="number">1</span>] &gt;= intervals[i+<span class="number">1</span>][<span class="number">0</span>]&#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, []<span class="keyword">int</span>&#123;intervals[i][<span class="number">0</span>], intervals[i+<span class="number">1</span>][<span class="number">1</span>]&#125;)</span><br><span class="line">            i ++</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, intervals[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二: 简洁的方法, 排序+归并</span></span><br><span class="line"><span class="comment">// 维护一个ans结果切片, 依次考察原切片中的每个区间, 现将第一个区间直接放入ans</span></span><br><span class="line"><span class="comment">// 依次遍历后面的区间, 如果当前考察区间的前一位 &gt; ans数组最后一个区间的后一位, 那么直接插入到ans中</span></span><br><span class="line"><span class="comment">// 如果 &lt; 那么判断ans最后一区间的最后一位与考察区间的最后一位谁大, 然后[替换]ans最后区间的最后一位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(intervals)</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    quickSort(<span class="number">0</span>, n<span class="number">-1</span>, intervals)</span><br><span class="line">    ans := [][]<span class="keyword">int</span>&#123;intervals[<span class="number">0</span>]&#125;</span><br><span class="line">    <span class="comment">// 考察</span></span><br><span class="line">    <span class="keyword">for</span> _, interval := <span class="keyword">range</span> intervals &#123;</span><br><span class="line">        last := ans[<span class="built_in">len</span>(ans)<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> interval[<span class="number">0</span>] &gt; last &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, interval)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> last &lt; interval[<span class="number">1</span>]&#123;</span><br><span class="line">            ans[<span class="built_in">len</span>(ans)<span class="number">-1</span>][<span class="number">1</span>] = interval[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-intervals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;56. 合并区间&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等918&lt;/p&gt;
&lt;p&gt;以数组 &lt;code&gt;intervals&lt;/code&gt; 表示若干个区间的集合，其中单个区间为 &lt;code&gt;intervals[i] = [starti, endi]&lt;/code&gt; 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0169</title>
    <link href="https://xwjahahahaha.github.io/2021/05/03/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0169/"/>
    <id>https://xwjahahahaha.github.io/2021/05/03/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-05/%E6%97%A5%E8%AE%B0-0169/</id>
    <published>2021-05-03T01:20:10.000Z</published>
    <updated>2021-05-06T10:53:35.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>研二实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input checked="" disabled="" type="checkbox"> Proof of Federated Learning: A Novel Energy-recycling Consensus Algorithm</li><li><input checked="" disabled="" type="checkbox"> Scalable and Communication-efficient Decentralized Federated Edge Learning with Multi-blockchain Framework</li><li><input checked="" disabled="" type="checkbox"> DEEP GRADIENT COMPRESSION:REDUCING THE COMMUNICATION BANDWIDTH FOR DISTRIBUTED TRAINING</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li><li><input disabled="" type="checkbox"> 4-1 ~ 4-31 Go网络编程Base + 专利一篇</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、 专利2篇  </li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 第一篇论文初稿与老师讨论</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm) 、Go设计模式  </li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 Go设计模式  </li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-31 docker、k8s</li></ul><p>七月</p><ul><li><input disabled="" type="checkbox"> 7-1 ~ 7-20 缓存、日志</li><li><input disabled="" type="checkbox"> 7-20 ~ 7-31 微服务(消息队列、任务调度、rpc)</li></ul><p>八月</p><ul><li><input disabled="" type="checkbox"> 8-1 ~ 8-20  微服务(消息队列、任务调度、rpc)</li><li><input disabled="" type="checkbox"> 8-20 ~ 8-31 </li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语40词 + 阅读一篇</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> 密码学第一课</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;研二实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MIT公开课-15.S12区块链与金钱-1</title>
    <link href="https://xwjahahahaha.github.io/2021/05/02/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/MIT_15-S12/MIT%E5%85%AC%E5%BC%80%E8%AF%BE-15-S12%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E9%87%91%E9%92%B1-1/"/>
    <id>https://xwjahahahaha.github.io/2021/05/02/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/MIT_15-S12/MIT%E5%85%AC%E5%BC%80%E8%AF%BE-15-S12%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E9%87%91%E9%92%B1-1/</id>
    <published>2021-05-02T09:29:31.000Z</published>
    <updated>2021-05-08T08:56:43.254Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>课程视频链接: <a href="https://www.bilibili.com/video/BV1pK4y1r7Jf" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1pK4y1r7Jf</a></p><p>对应的课件资料地址: <a href="https://ocw.mit.edu/courses/sloan-school-of-management/15-s12-blockchain-and-money-fall-2018/lecture-slides/" target="_blank" rel="noopener">https://ocw.mit.edu/courses/sloan-school-of-management/15-s12-blockchain-and-money-fall-2018/lecture-slides/</a></p><p>以下为个人笔记(简单的记录)…… </p></blockquote><h1 id="一、Introduction-for-15S12-Blockchain-and-money"><a href="#一、Introduction-for-15S12-Blockchain-and-money" class="headerlink" title="一、Introduction for 15S12 Blockchain and money"></a>一、Introduction for 15S12 Blockchain and money</h1><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/Kf4Ez2.png" alt="Kf4Ez2"></p><a id="more"></a><p>peer-to-peer的去中心化交易方式会为下一代互联网的主要组成吗?</p><blockquote><p>个人赞成的观点是: 只会成为下一代互联网的重要组成部分,因为在某些场景中我们还是需要中心化结构的支持</p></blockquote><ul><li>金融不仅仅是金钱的流动, 也是风险的流动</li><li></li></ul><h1 id="二、Money-Ledgers-Bitcoin"><a href="#二、Money-Ledgers-Bitcoin" class="headerlink" title="二、Money Ledgers Bitcoin"></a>二、Money Ledgers Bitcoin</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;课程视频链接: &lt;a href=&quot;https://www.bilibili.com/video/BV1pK4y1r7Jf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/BV1pK4y1r7Jf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应的课件资料地址: &lt;a href=&quot;https://ocw.mit.edu/courses/sloan-school-of-management/15-s12-blockchain-and-money-fall-2018/lecture-slides/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ocw.mit.edu/courses/sloan-school-of-management/15-s12-blockchain-and-money-fall-2018/lecture-slides/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下为个人笔记(简单的记录)…… &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、Introduction-for-15S12-Blockchain-and-money&quot;&gt;&lt;a href=&quot;#一、Introduction-for-15S12-Blockchain-and-money&quot; class=&quot;headerlink&quot; title=&quot;一、Introduction for 15S12 Blockchain and money&quot;&gt;&lt;/a&gt;一、Introduction for 15S12 Blockchain and money&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/Kf4Ez2.png&quot; alt=&quot;Kf4Ez2&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="knowledge" scheme="https://xwjahahahaha.github.io/categories/knowledge/"/>
    
    
  </entry>
  
</feed>
