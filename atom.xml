<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识与头发不可兼得</title>
  
  <subtitle>文杰的博客</subtitle>
  <link href="https://xwjahahahaha.github.io/atom.xml" rel="self"/>
  
  <link href="https://xwjahahahaha.github.io/"/>
  <updated>2021-11-02T11:33:22.183Z</updated>
  <id>https://xwjahahahaha.github.io/</id>
  
  <author>
    <name>DDDemons hide</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日记_0237</title>
    <link href="https://xwjahahahaha.github.io/2021/11/02/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0237/"/>
    <id>https://xwjahahahaha.github.io/2021/11/02/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0237/</id>
    <published>2021-11-02T04:39:10.000Z</published>
    <updated>2021-11-02T11:33:22.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> docker第二章结束</li><li><input disabled="" type="checkbox"> 算法：<ul><li><input disabled="" type="checkbox"> 排序算法完结</li><li><input disabled="" type="checkbox"> 数组中第k个最大元素</li></ul></li><li><input disabled="" type="checkbox"> </li><li><input disabled="" type="checkbox"> go面经</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0236</title>
    <link href="https://xwjahahahaha.github.io/2021/11/01/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0236/"/>
    <id>https://xwjahahahaha.github.io/2021/11/01/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-11/%E6%97%A5%E8%AE%B0-0236/</id>
    <published>2021-11-01T01:08:58.000Z</published>
    <updated>2021-11-01T15:05:33.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经</li><li><input disabled="" type="checkbox"> 下午：刷leetcode 4道老题+2新题<ul><li><input checked="" disabled="" type="checkbox"> 二分法查找</li><li><input checked="" disabled="" type="checkbox"> 搜索插入位置</li><li><input disabled="" type="checkbox"> 数组中最大的第k个元素</li></ul></li><li><input checked="" disabled="" type="checkbox"> 晚上：做项目<ul><li><input checked="" disabled="" type="checkbox"> Cgroups</li></ul></li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>二分法边界问题</title>
    <link href="https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86%E6%B3%95%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86%E6%B3%95%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-31T14:07:28.000Z</published>
    <updated>2021-11-01T05:39:16.670Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习自：<a href="https://blog.csdn.net/Lin_RD/article/details/105186081" target="_blank" rel="noopener">https://blog.csdn.net/Lin_RD/article/details/105186081</a></p></blockquote><h1 id="一、二分法流程"><a href="#一、二分法流程" class="headerlink" title="一、二分法流程"></a>一、二分法流程</h1><p>二分法的一般流程如下：</p><ol><li>确定左右边界：[left, right)</li><li>确定终止条件</li><li>获得中点</li><li>比较，缩减一半区间</li></ol><a id="more"></a><h1 id="二、确定左右边界"><a href="#二、确定左右边界" class="headerlink" title="二、确定左右边界"></a>二、确定左右边界</h1><p>对于一个有序序列最小索引是0，最大索引是$n-1$</p><p>可以使用两种方法表示其区间：</p><ul><li>左闭右开： $[0, n)$</li><li>左闭右闭：$[0, n-1]$</li></ul><p>一般情况符合使用习惯的话都会使用左闭右开的方式</p><h1 id="三、确定终止条件"><a href="#三、确定终止条件" class="headerlink" title="三、确定终止条件"></a>三、确定终止条件</h1><p>需要明确的是，我们需要遍历整个数组，因此终止条件必须要确保数组的所有元素被包含</p><p>如果使用$[0, n)$此时右值不可取，因此终止条件是: <code>while left &lt; right</code></p><p>如果使用$[0, n-1]$此时右值可取，因此终止条件是:<code>while left &lt;= right</code></p><p>例子：假设数组只有一个元素，n=1，左闭右开$[0, 1)$则当设置$left&lt;right$则$0&lt;1$满足可以进入考察全部元素</p><p>如果是左闭右闭$[0,0]$那么只有设置$left&lt;=right$即有等号才能进入循环，判断所有元素</p><p><strong><font color='#e54d42'>取右值用&lt;=    不取右值用&lt;  </font></strong></p><h1 id="四、获取中点"><a href="#四、获取中点" class="headerlink" title="四、获取中点"></a>四、获取中点</h1><p>最主要的是防止溢出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">mid := (left+right)&gt;&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="五、收缩区间"><a href="#五、收缩区间" class="headerlink" title="五、收缩区间"></a>五、收缩区间</h1><p>避免死循环，所以需要保证每次进入while可行区间必须缩小即要么left变大或者right变小</p><p>升序序列下，当<code>nums[mid]&lt;target</code>时，应该将<code>left</code>右移，省略左半部分</p><p>此时有两种情况：</p><ol><li><code>left=mid</code></li><li><code>left=mid+1</code></li></ol><p>选择哪一种考察的原则是：<strong>对于位置<code>mid</code>的值是否是可能的<code>target</code></strong></p><p>这里很明显不是，所以我们采用第二种（因为两种情况都是左闭，所以<code>left</code>都可以取到）</p><p>当<code>nums[mid]&gt;target</code>时，<code>right</code>左移，省略右半部分</p><p>此时也有两种情况：</p><ol><li><code>right=mid</code></li><li><code>right=mid-1</code></li></ol><p>相同的对应上面的原则，<code>mid</code>的值也一定不是可能的<code>target</code>，要舍去</p><ul><li><p>左闭右开[0, n)： 因为<code>right</code>取不到，所以对应第一种可以直接舍去<code>mid</code>位置，满足；第二种则会多舍去一个<code>mid-1</code>位置，让<code>mid-1</code>位置无法考察到，所以应该选择<code>right=mid</code> （隐式收缩）</p></li><li><p>左闭右闭[0, n]：<code>right</code>可以取到，所以要舍去的话只能选择第二种方式即<code>right=mid-1</code> （显式收缩）</p></li></ul><blockquote><p><font color='#39b54a'>right是否能取到，是对应while条件，如是是left &lt; right，那么当left==right时是无法进入while循环中的，所以无法取到；对于left&lt;=right条件，当left等于right时可以取到right </font></p></blockquote><p>总结如下(都假设mid值不是要找的值)：</p><table><thead><tr><th align="center">while条件</th><th align="center">收缩左半部</th><th align="center">收缩右半部</th></tr></thead><tbody><tr><td align="center">Left &lt; Right</td><td align="center">Left=mid+1</td><td align="center">Right=mid</td></tr><tr><td align="center">Left &lt;= Right</td><td align="center">Left=mid+1</td><td align="center">Right=mid-1</td></tr></tbody></table><h1 id="六、退出循环的位置"><a href="#六、退出循环的位置" class="headerlink" title="六、退出循环的位置"></a>六、退出循环的位置</h1><p>while退出后，left和right分别指向哪？</p><h2 id="1-while-left-lt-right"><a href="#1-while-left-lt-right" class="headerlink" title="1. while left &lt; right"></a>1. while left &lt; right</h2><p>首先明确的是，这个条件下退出时<code>left == right</code></p><p>因为此条件下每次<code>right=mid</code>而判断收缩右半部的条件是:<code>nums[mid]&gt;target</code>所以可以明确的是<code>nums[right]&gt;target</code>，即退出循环后<code>right</code>指针指向的值一定是大于<code>target</code>的</p><p>再者，推出循环时<code>left==right</code>，所以退出循环后<code>left</code>、<code>right</code>指向的值都是大于目标值的</p><p>实际上，<strong><code>left</code>、<code>right</code>都指向第一个大于<code>target</code>的值</strong></p><blockquote><ul><li><p>假设left-1存在：</p><ul><li>如果执行过赋值left = mid + 1， 那么nums[mid] &lt; target。所以nums[left-1] &lt; target。nums[left-1] &lt; target &lt; nums[left]，显然nums[left]是nums中大于target的最小值。</li><li>如果left = mid + 1没有执行过， 那么说明left == 0，没有移动过，这就相当于left-1不存在。</li></ul></li><li><p>如果left-1不存在， left-1不存在说明left == 0， 因为0是第一个索引，所以nums[left]还是第一个大于target的数(target小于nums[0])</p></li></ul></blockquote><h2 id="2-while-left-lt-right"><a href="#2-while-left-lt-right" class="headerlink" title="2. while left &lt;= right"></a>2. while left &lt;= right</h2><p>退出时，<code>left==right+1</code></p><p>如果执行过赋值<code>right = mid - 1</code>，<code>nums[mid] &gt; target</code>， 换句话说<code>nums[right+1] == nums[mid] &gt; target</code>。<code>left = right + 1</code>所以<code>nums[left] &gt; target</code>。</p><p>如果没执行过<code>right = mid-1</code>， 那么<code>right == n-1</code>, <code>left == right+1 == n</code>。也就是说不存在大于<code>target</code>的数字(<code>nums[n-1]&lt;target</code>)。</p><p>如果执行过赋值<code>left = mid + 1</code>，<code>nums[mid] &lt; target</code>所以<code>nums[mid+1]=nums[left]&gt;target</code></p><p>如果没执行过<code>left = mid + 1</code>， 那么<code>left == 0</code>，是第一个索引，所以<code>left</code>仍然是第一个大于<code>target</code>的数字。</p><p><strong><font color='#e54d42'>综上所述：不论哪种情况，结束二分时left都是指向第一个大于target的数，或者不存在大于target的数，那么left指向序列的末尾n， 需要注意的是，nums[left-1]并不一定就是目标值，因为目标值不一定存在于序列中</font></strong></p><h1 id="七、训练"><a href="#七、训练" class="headerlink" title="七、训练"></a>七、训练</h1><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></p><p>两种情况如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右开</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            l = mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            r = mid </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// l的位置是第一个大于target的值，但是l-1不一定就是目标值</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; <span class="built_in">len</span>(nums) &amp;&amp; l &gt; <span class="number">0</span> &amp;&amp; nums[l<span class="number">-1</span>] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> l<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := l + (r-l)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            l = mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            r = mid<span class="number">-1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l &gt; <span class="number">0</span> &amp;&amp; l &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[l<span class="number">-1</span>] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> l<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r, n := <span class="number">0</span>, <span class="built_in">len</span>(nums), <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        mid := (l+r) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            l = mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            r = mid</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在于数组的三种情况</span></span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> l == n &#123; <span class="keyword">return</span> n &#125;</span><br><span class="line">    <span class="comment">// if nums[l-1] != target &#123; return l &#125;</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习自：&lt;a href=&quot;https://blog.csdn.net/Lin_RD/article/details/105186081&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/Lin_RD/article/details/105186081&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、二分法流程&quot;&gt;&lt;a href=&quot;#一、二分法流程&quot; class=&quot;headerlink&quot; title=&quot;一、二分法流程&quot;&gt;&lt;/a&gt;一、二分法流程&lt;/h1&gt;&lt;p&gt;二分法的一般流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定左右边界：[left, right)&lt;/li&gt;
&lt;li&gt;确定终止条件&lt;/li&gt;
&lt;li&gt;获得中点&lt;/li&gt;
&lt;li&gt;比较，缩减一半区间&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-31T07:15:55.000Z</published>
    <updated>2021-11-02T13:32:59.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习自：</p><ul><li><p><a href="https://blog.csdn.net/zxzxzx0119/article/details/79826380" target="_blank" rel="noopener">https://blog.csdn.net/zxzxzx0119/article/details/79826380</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/42586566" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42586566</a></p></li></ul></blockquote><p>对常见的排序算法进行三方面总结：</p><ol><li>基本思路与实现</li><li>稳定性</li><li>复杂度分析</li></ol><a id="more"></a> <p>[TOC]</p><h1 id="一、总览"><a href="#一、总览" class="headerlink" title="一、总览"></a>一、总览</h1><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211031151426237.png" alt="image-20211031151426237"></p><p>什么是排序算法的<strong>稳定性</strong>？</p><p>简单来说如果原本数组中的两个相等的数的次序为相对一前一后，排序结束后仍然为相对一前一后，那么就可以说这个排序算法是稳定的。即保证排序前后两个相等的数的相对顺序不会改变</p><p>所以在具体的排序算法中可以进行特定的处理改变稳定性</p><p>举例：对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成<code>arr[i] &gt;= arr[i + 1]</code>，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。</p><h1 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h1><h2 id="1-基本思路"><a href="#1-基本思路" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>每次沉底一个最大的数，将大的数一直向后交换，大的沉底，小的自动上浮</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="comment">// i：当前需要冒泡的数组长度</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="built_in">len</span>(nums)<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="comment">// j：冒泡的位置</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;i; j++ &#123;</span><br><span class="line"><span class="comment">// 如果前一个数大就和后一个交换，不断沉底</span></span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li>最好$O(N)$: 唯一的情况是数组已经有序</li><li>平均$O(N^2)$</li><li>最差$O(N^2)$</li></ul><p><strong>优化思路一</strong>: 设立flag，如果当前长度没有发生任何交换，则说明已经有序，直接结束</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">   flag := <span class="literal">true</span></span><br><span class="line">   <span class="comment">// i：当前需要冒泡的数组长度</span></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="built_in">len</span>(nums)<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">      <span class="comment">// j：冒泡的位置</span></span><br><span class="line">      <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;i; j++ &#123;</span><br><span class="line">         <span class="comment">// 如果前一个数大就和后一个交换，不断沉底</span></span><br><span class="line">         <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">            nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">            <span class="comment">// 一旦发生了交换，就改变标记</span></span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 一旦发现没有交换就直接结束</span></span><br><span class="line">      <span class="keyword">if</span> flag &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：平均优化到$O(N)$</p><p><strong>优化思路二</strong>：记录上次最后一次交换的位置，最后一次交换位置后面的位置都是有序的，所以只需要到达这个位置即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">flag := <span class="literal">true</span></span><br><span class="line"><span class="comment">// i：当前需要冒泡的数组长度</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="built_in">len</span>(nums)<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="comment">// 记录上一次结束位置，初始化时为i</span></span><br><span class="line">end := i</span><br><span class="line"><span class="comment">// j：冒泡的位置</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;i; j++ &#123;</span><br><span class="line"><span class="comment">// 如果前一个数大就和后一个交换，不断沉底</span></span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line"><span class="comment">// 一旦发生了交换，就改变标记</span></span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 记录最后一次交换位置</span></span><br><span class="line">end = j+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 替换i</span></span><br><span class="line">i = end</span><br><span class="line"><span class="comment">// 一旦发现没有交换就直接结束</span></span><br><span class="line"><span class="keyword">if</span> flag &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性"><a href="#2-稳定性" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>因为当两个数相等时不交换，所以稳定</p><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(N)$: 唯一的情况是数组已经有序</li><li>平均$O(N^2)$，优化后可到达$O(N)$</li><li>最差$O(N^2)$</li></ul><p>空间复杂度$O(1)$</p><h1 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h1><h2 id="1-基本思路-1"><a href="#1-基本思路-1" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>每次找到最大的，然后与最后一个数交换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 一共需要n-1次</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">maxIndex := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(nums)-i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[maxIndex] &#123;</span><br><span class="line">maxIndex = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和最后一个交换</span></span><br><span class="line">nums[maxIndex], nums[<span class="built_in">len</span>(nums)-i<span class="number">-1</span>] = nums[<span class="built_in">len</span>(nums)-i<span class="number">-1</span>], nums[maxIndex]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性-1"><a href="#2-稳定性-1" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的</p><p>一般排序算法描述的都是数组，所以可以说是<strong>不稳定的</strong></p><h2 id="3-复杂度分析-1"><a href="#3-复杂度分析-1" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(N^2)$</li><li>平均$O(N^2)$，优化后可到达$O(N)$</li><li>最差$O(N^2)$</li></ul><p>空间复杂度$O(1)$</p><h1 id="四、插入排序"><a href="#四、插入排序" class="headerlink" title="四、插入排序"></a>四、插入排序</h1><h2 id="1-基本思路-2"><a href="#1-基本思路-2" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>从前往后维护一个有序窗口，每次考察窗口的下一个元素，如果比窗口的最右侧/最大元素小，则从右往左遍历窗口直到合适顺序的地方插入。初始化认为数组的第一个位置有序。 （像是一种向前的冒泡排序）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// i: 这个有序窗口的最右边位置的下一个考察的位置, 起始位置0默认有序</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="comment">// 从窗口的下一个判定位置，一直向左遍历</span></span><br><span class="line"><span class="keyword">for</span> j:=i; j&gt;<span class="number">0</span>; j-- &#123;</span><br><span class="line"><span class="comment">// 如果当前位置j比窗口位置j-1小，则一直向右侧交换</span></span><br><span class="line"><span class="keyword">if</span> nums[j] &lt; nums[j<span class="number">-1</span>] &#123;</span><br><span class="line">nums[j], nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>], nums[j]</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果已经大于，那么就已将该元素加入到了有序窗口</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化思路：二分法查找插入排序的位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// i: 有序窗口的下一个考察的位置(target), 起始位置0默认有序</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="comment">// 二分法找出当前窗口中合适顺序的位置，插入</span></span><br><span class="line">l, r, target := <span class="number">0</span>, i<span class="number">-1</span>, nums[i]</span><br><span class="line"><span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">mid := (l+r) &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">l = mid+<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 即使找到了相同的值，也舍去，目的是找到合适插入的位置(刚好大于target的位置)</span></span><br><span class="line">r = mid<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// l就是刚好大于target的位置</span></span><br><span class="line"><span class="comment">// 从i开始移位，赋值</span></span><br><span class="line"><span class="keyword">for</span> j:=i; j&gt;=l+<span class="number">1</span>; j-- &#123;</span><br><span class="line">nums[j] = nums[j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">nums[l]= target</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性-2"><a href="#2-稳定性-2" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>如果遇到相同的值比较，不会进行交换，所以是稳定的</p><h2 id="3-复杂度分析-2"><a href="#3-复杂度分析-2" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。</p><p>时间复杂度:</p><ul><li>最好$O(N)$</li><li>平均$O(N^2)$</li><li>最差$O(N^2)$</li></ul><p>空间复杂度$O(1)$</p><h1 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a>五、希尔排序</h1><h2 id="1-基本思路-3"><a href="#1-基本思路-3" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>希尔排序使更高效的插入排序，它的思想在于：</p><ul><li>把数组分成几块，每一块进行一个插入排序；</li><li>而分块的依据在于增量的选择分好块之后，从gap开始到n，每一组和它前面的元素（自己组内的）进行插入排序；</li></ul><p>每次和组内的元素比较完之后，最后的元素基本就是有序的了，希尔排序相对于插入排序的优势在于插入排序每次只能将数据移动一位，在数组较大且基本无序的情况下性能会迅速恶化。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=,size_16,color_FFFFFF,t_70-20211101141829191.png" alt="希尔排序"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// gap每次减小为原来的一半</span></span><br><span class="line"><span class="keyword">for</span> gap:=<span class="built_in">len</span>(nums)/<span class="number">2</span>; gap&gt;<span class="number">0</span>; gap/=<span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// i为每个分组的起始位置</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;gap; i++ &#123;</span><br><span class="line"><span class="comment">// 下面对每个分组进行插入排序</span></span><br><span class="line"><span class="keyword">for</span> j:=i+gap; j&lt;<span class="built_in">len</span>(nums); j+=gap &#123;</span><br><span class="line"><span class="keyword">for</span> k:=j; k&gt;i; k-=gap &#123;</span><br><span class="line"><span class="keyword">if</span> nums[k-gap] &gt; nums[k] &#123;</span><br><span class="line">nums[k-gap], nums[k] = nums[k], nums[k-gap]</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性-3"><a href="#2-稳定性-3" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p><strong>不稳定</strong>。插入排序是一种稳定的排序算法，但是希尔排序不是，因为在多次插入的过程中，相同元素完全有可能在不同的插入轮次中移动破坏稳定性</p><h2 id="3-复杂度分析-3"><a href="#3-复杂度分析-3" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(N^{1.3})$</li><li>平均$O(NlogN)$~$ O(N^2)$</li><li>最差$O(N^2)$</li></ul><p>空间复杂度$O(1)$</p><p>希尔排序时间复杂度的大小还是要取决于步长的合适度</p><p>在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。</p><h1 id="六、快速排序"><a href="#六、快速排序" class="headerlink" title="六、快速排序"></a>六、快速排序</h1><h2 id="1-基本思路-4"><a href="#1-基本思路-4" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><ol><li>从数列中挑出一个元素，称为”基准/轴值”（pivot），</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为<strong>分区（partition）操作</strong>。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/nNT0Di.jpg" alt="快速排序"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> quickProcess <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">gitMid := <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">pivot := nums[l]</span><br><span class="line"><span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line"><span class="keyword">for</span> l &lt; r &amp;&amp; nums[r] &gt;= pivot &#123; r-- &#125;</span><br><span class="line">nums[l] = nums[r]</span><br><span class="line"><span class="keyword">for</span> l &lt; r &amp;&amp; nums[l] &lt;= pivot &#123; l++ &#125;</span><br><span class="line">nums[r] = nums[l]</span><br><span class="line">&#125;</span><br><span class="line">nums[l] = pivot</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line">quickProcess = <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">mid := gitMid(l, r)</span><br><span class="line"><span class="comment">// 左半部</span></span><br><span class="line">quickProcess(l, mid<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 右半部</span></span><br><span class="line">quickProcess(mid+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">quickProcess(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点： 如果每次选择的pivot都是极端数值（最大或者最小），导致后面划分的数组极度不平衡，复杂度灰降低到$O(N^2)$</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/mB1jD1.jpg" alt="快速排序弊端"></p><p>改进策略： 随机快排/快速选择（就是选择pivot时不选择最左边的而是随机选择）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())        <span class="comment">// 随机种子</span></span><br><span class="line"><span class="keyword">var</span> quickProcess <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">gitMid := <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 选取最左边为pivot</span></span><br><span class="line">pivot := nums[l]</span><br><span class="line"><span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line"><span class="keyword">for</span> l &lt; r &amp;&amp; nums[r] &gt;= pivot &#123; r-- &#125;</span><br><span class="line">nums[l] = nums[r]</span><br><span class="line"><span class="keyword">for</span> l &lt; r &amp;&amp; nums[l] &lt;= pivot &#123; l++ &#125;</span><br><span class="line">nums[r] = nums[l]</span><br><span class="line">&#125;</span><br><span class="line">nums[l] = pivot</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line">quickProcess = <span class="function"><span class="keyword">func</span><span class="params">(l, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line"><span class="comment">// 改为随机选择</span></span><br><span class="line">randIdx := rand.Int() % (r-l+<span class="number">1</span>) + l</span><br><span class="line"><span class="comment">// 与最左边的数交换</span></span><br><span class="line">nums[randIdx], nums[l] = nums[l], nums[randIdx]</span><br><span class="line">mid := gitMid(l, r)</span><br><span class="line"><span class="comment">// 左半部</span></span><br><span class="line">quickProcess(l, mid<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 右半部</span></span><br><span class="line">quickProcess(mid+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">quickProcess(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性-4"><a href="#2-稳定性-4" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>不稳定，因为我们无法保证相等的数据按顺序被扫描到和按顺序存放。</p><h2 id="3-复杂度分析-4"><a href="#3-复杂度分析-4" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(NlogN)$</li><li>平均$O(NlogN)$</li><li>最差$O(N^2)$</li></ul><p>空间复杂度$O(logN)$~$O(N)$, $O(N)$是最坏情况，每次都选取到了最大/最小值，每次只能划分出一个数，调用栈的大小就是$O(N)$;如果每次运气都很好，选择的pivot都刚刚好平分数组，那么调用栈的时间复杂度就是$O(logN)$</p><p>时间复杂度$O(NlogN)$: 最优情况下， 对于每个pivot都需要折半的递归调用，折半递归到最底层一个数的时间复杂度就是$O(logN)$（共有$O(logN)$层，有这么多次操作）。在每一层中，需要遍历$N$个元素调换顺序，所以总的时间复杂度最优为$O(NlogN)$</p><h1 id="七、归并排序"><a href="#七、归并排序" class="headerlink" title="七、归并排序"></a>七、归并排序</h1><h2 id="1-基本思路-5"><a href="#1-基本思路-5" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>归并排序也是分治法一个很好的应用，先递归到最底层，然后从下往上每次两个序列进行归并合起来，是一个由上往下分开，再由下往上合并的过程，而对于每一次合并操作，对于每一次<code>merge</code>的操作过程如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/70.png" alt="归并排序"></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/3BCnUD.png" alt="归并排序"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">mergeProcess(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeProcess</span><span class="params">(nums []<span class="keyword">int</span>, l, r <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line"><span class="comment">// 分为两部分</span></span><br><span class="line">mid := l + (r-l) &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="comment">// 左右分离</span></span><br><span class="line">mergeProcess(nums, l, mid)</span><br><span class="line">mergeProcess(nums, mid+<span class="number">1</span>, r)</span><br><span class="line"><span class="comment">// 此时已经分割开，有序, 进行合并</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt; nums[mid+<span class="number">1</span>] &#123;<span class="comment">// 优化：如果两个部分前后已经有序就不需要合并了</span></span><br><span class="line">merge(nums, l, mid, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums []<span class="keyword">int</span>, l, mid, r <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="comment">// 两个部分的起始位置</span></span><br><span class="line">p1, p2 := l, mid+<span class="number">1</span></span><br><span class="line"><span class="comment">// 创建中间辅助数组</span></span><br><span class="line">help := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> p1&lt;=mid &amp;&amp; p2&lt;=r &#123;</span><br><span class="line"><span class="keyword">if</span> nums[p1] &lt;= nums[p2] &#123;</span><br><span class="line">help = <span class="built_in">append</span>(help, nums[p1])</span><br><span class="line">p1 ++</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">help = <span class="built_in">append</span>(help, nums[p2])</span><br><span class="line">p2 ++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理两边剩余部分</span></span><br><span class="line"><span class="keyword">for</span> p1 &lt;= mid &#123;</span><br><span class="line">help = <span class="built_in">append</span>(help, nums[p1])</span><br><span class="line">p1++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> p2 &lt;= r &#123;</span><br><span class="line">help = <span class="built_in">append</span>(help, nums[p2])</span><br><span class="line">p2++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值到原数组</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> help &#123;</span><br><span class="line">nums[l+i] = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意几点:</p><ul><li><strong>注意上面的代码中<code>if(arr[mid] &gt; arr[mid+1])</code>防止一开始数组很有序的情况；</strong></li><li><strong>注意在外排比较的时候，为了保证稳定性，左右相等的时候，先拷贝左边的；</strong></li></ul><h2 id="2-稳定性-5"><a href="#2-稳定性-5" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>归并排序是稳定的</p><h2 id="3-复杂度分析-5"><a href="#3-复杂度分析-5" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(NlogN)$</li><li>平均$O(NlogN)$</li><li>最差$O(NlogN)$</li></ul><p>因为不断的二分区域，所以分到长度为1即只有一个数时的时间复杂度为$O(logN)$(因为共有$O(logN)$层，分了这么多次)，再看每一层中都需要进行merge操作，看上面的过程图就可以发现每层不管分成几组几个，总的都是$N$个，所以每一层merge操作的时间复杂度就是$O(N)$, 总体就是$O(NlogN)$</p><p>空间复杂度$O(N)$, 来源于其中的辅助数组</p><p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度$O(n)$使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。</p><h1 id="八、堆排序"><a href="#八、堆排序" class="headerlink" title="八、堆排序"></a>八、堆排序</h1><h2 id="1-基本思路-6"><a href="#1-基本思路-6" class="headerlink" title="1. 基本思路"></a>1. 基本思路</h2><p>可用数组表示的完全二叉树。</p><ol><li><p>已知父节点数组索引i</p><p>父节点是i, 则左子节点为2i，右子节点为2i+1</p><blockquote><p>通常数据的0索引位置创建但不使用，根节点从index1开始，否则上述规律无意义</p></blockquote></li><li><p>已知子节点数组索引为i</p><p>则其父节点索引为i/2，其当前层为i/2 (除2也可以用效率更高的位运算)</p></li></ol><ul><li><p>大顶堆：父节点的值比其<strong>所有</strong>子节点都大</p></li><li><p>小顶堆：父节点的值比其<strong>所有</strong>子节点都小</p></li></ul><blockquote><p><font color='#e54d42'>这里的“值”可以代表为任意属性优先值，进而得到<strong>优先队列（也就是堆）：特殊的队列，取出元素的顺序按照元素的优先权而不是先后顺序</strong></font></p></blockquote><p>堆的根节点一定是最大/小值，但是节点的顺序未知</p><p>堆的原始操作，时间复杂度都为<code>nlogk</code>，<code>k</code>为按优先级分类的规模（例如按数组中元素出现次数划分，共有k个规模）</p><ul><li><strong>上浮</strong> shift up: 向堆尾新加入一个元素，堆规模 +1，依次向上与父节点比较，如小于父节点就交换。</li><li><strong>下沉</strong> shift down: 从堆顶取出一个元素（堆规模 -1，用于堆排序）或者更新堆中一个元素（本题），依次向下与子节点比较，如大于子节点就交换。</li></ul><p>堆排序的过程是一个反复调整堆的过程：</p><ul><li>利用数组建立一个小顶堆；</li><li>调用<code>siftDown</code>，把堆（无序区）的尺寸缩小<code>1</code>，取出栈顶元素，并从新的堆顶元素开始进行堆调整；</li><li>重复步骤，直到堆的大小为<code>1</code>；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myMinHeap []<span class="keyword">int</span><span class="comment">// 小顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *myMinHeap)</span> <span class="title">shiftUp</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, v)</span><br><span class="line"><span class="comment">// 调换位置</span></span><br><span class="line">i := <span class="built_in">len</span>(*h)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">1</span> &amp;&amp; (*h)[i] &lt; (*h)[i/<span class="number">2</span>] &#123;</span><br><span class="line"><span class="comment">// 小于父节点，调换位置</span></span><br><span class="line">(*h)[i], (*h)[i/<span class="number">2</span>] = (*h)[i/<span class="number">2</span>], (*h)[i]</span><br><span class="line">i /= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *myMinHeap)</span> <span class="title">shiftDown</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(*h)</span><br><span class="line">v := (*h)[<span class="number">1</span>]</span><br><span class="line">(*h)[<span class="number">1</span>] = (*h)[n<span class="number">-1</span>]</span><br><span class="line">*h = (*h)[:n<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// 调整</span></span><br><span class="line">minPoint, i := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 找出父、左右孩子中最小的节点</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span>*i &lt; n<span class="number">-1</span> &amp;&amp; (*h)[i] &gt; (*h)[<span class="number">2</span>*i] &#123;</span><br><span class="line">minPoint = <span class="number">2</span>*i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span>*i+<span class="number">1</span> &lt; n<span class="number">-1</span> &amp;&amp; (*h)[minPoint] &gt; (*h)[<span class="number">2</span>*i+<span class="number">1</span>] &#123;</span><br><span class="line">minPoint = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> minPoint == i &#123;</span><br><span class="line"><span class="comment">// 如果已经满足，则不需要调整了，因为底下本来就是有序的</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将父节点与最小的交换</span></span><br><span class="line">(*h)[i], (*h)[minPoint] = (*h)[minPoint], (*h)[i]</span><br><span class="line">i = minPoint</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建小顶堆</span></span><br><span class="line">minHeap := myMinHeap([]<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">minHeap.shiftUp(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每次删除掉一个</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">nums[i] = minHeap.shiftDown()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-稳定性-6"><a href="#2-稳定性-6" class="headerlink" title="2. 稳定性"></a>2. 稳定性</h2><p>不稳定</p><h2 id="3-复杂度分析-6"><a href="#3-复杂度分析-6" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><p>时间复杂度:</p><ul><li>最好$O(NlogN)$</li><li>平均$O(NlogN)$</li><li>最差$O(NlogN)$</li></ul><p>完美二叉树时间复杂度$O(logN)$, 每次删除一个共$N$个最坏情况下操作$O(NlogN)$次</p><p>空间复杂度$O(1)$</p><p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zxzxzx0119/article/details/79826380&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/zxzxzx0119/article/details/79826380&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/42586566&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/42586566&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;对常见的排序算法进行三方面总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本思路与实现&lt;/li&gt;
&lt;li&gt;稳定性&lt;/li&gt;
&lt;li&gt;复杂度分析&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go语言面经总结</title>
    <link href="https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E9%9D%A2%E8%AF%95/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://xwjahahahaha.github.io/2021/10/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E9%9D%A2%E8%AF%95/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-31T06:02:43.000Z</published>
    <updated>2021-10-31T07:11:18.092Z</updated>
    
    <content type="html"><![CDATA[<p>整理最近看面经的重要点</p><a id="more"></a><h1 id="一、基础语法细节"><a href="#一、基础语法细节" class="headerlink" title="一、基础语法细节"></a>一、基础语法细节</h1><h2 id="1-make与new的区别是什么"><a href="#1-make与new的区别是什么" class="headerlink" title="1. make与new的区别是什么"></a>1. make与new的区别是什么</h2><ul><li><p>new：只接受一个参数即类型（自定义类型也可以），返回指向该类型的指针，并赋值为该类型的零值*</p></li><li><p>make：只用于chan、map、slice的内存创建，返回的就是类型本身的对象而不是其指针（因为这仨个类型本省就是引用类型了）</p></li></ul><h2 id="2-Slice"><a href="#2-Slice" class="headerlink" title="2. Slice"></a>2. Slice</h2><h3 id="1-底层原理"><a href="#1-底层原理" class="headerlink" title="1.底层原理"></a>1.底层原理</h3><p>相比于数据是动态的，Slice本身是一个数据结构，分为data、len、cap三个字段，data指向底层数组的一个起始位置，len表示切片元素的个数，cap是底层数组的全部大小。初始化的时候省略cap时会讲cap设置与len一样，当向切片添加元素的时候如果元素个数超出了cap，那么底层会重新分配一个数组（2倍）并将原来的值复制过来。</p><h2 id="2-函数传参注意事项"><a href="#2-函数传参注意事项" class="headerlink" title="2.函数传参注意事项"></a>2.函数传参注意事项</h2><p>slice作为函数传参数可能在函数中添加元素导致底层数组的扩大，所以函数中修改无效</p><p>两种解决方法：</p><ol><li>参数中传递切片的指针</li><li>函数中return返回，调用的时候用原切片接收</li></ol><h2 id="3-类型可比较问题"><a href="#3-类型可比较问题" class="headerlink" title="3. 类型可比较问题"></a>3. 类型可比较问题</h2><h2 id="4-go怎么从源码编译到二进制文件"><a href="#4-go怎么从源码编译到二进制文件" class="headerlink" title="4. go怎么从源码编译到二进制文件"></a>4. go怎么从源码编译到二进制文件</h2><h1 id="二、进阶语法特点"><a href="#二、进阶语法特点" class="headerlink" title="二、进阶语法特点"></a>二、进阶语法特点</h1><h2 id="1-goroutine协程"><a href="#1-goroutine协程" class="headerlink" title="1. goroutine协程"></a>1. goroutine协程</h2><h2 id="2-GC机制"><a href="#2-GC机制" class="headerlink" title="2. GC机制"></a>2. GC机制</h2><h2 id="3-调度模型"><a href="#3-调度模型" class="headerlink" title="3. 调度模型"></a>3. 调度模型</h2><h2 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4. 内存管理"></a>4. 内存管理</h2><h2 id="5-Channel"><a href="#5-Channel" class="headerlink" title="5. Channel"></a>5. Channel</h2><h1 id="三、工程类、实践类"><a href="#三、工程类、实践类" class="headerlink" title="三、工程类、实践类"></a>三、工程类、实践类</h1><h2 id="1-生产者消费者模型"><a href="#1-生产者消费者模型" class="headerlink" title="1. 生产者消费者模型"></a>1. 生产者消费者模型</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理最近看面经的重要点&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0235</title>
    <link href="https://xwjahahahaha.github.io/2021/10/31/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0235/"/>
    <id>https://xwjahahahaha.github.io/2021/10/31/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0235/</id>
    <published>2021-10-31T01:10:15.000Z</published>
    <updated>2021-11-01T01:08:50.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经</li><li><input disabled="" type="checkbox"> 下午：刷leetcode <ul><li><input checked="" disabled="" type="checkbox"> 排序算法全部完结（部分）</li><li><input disabled="" type="checkbox"> 一题旧题：</li></ul></li><li><input disabled="" type="checkbox"> 晚上：<ul><li><input disabled="" type="checkbox"> 面经</li><li><input disabled="" type="checkbox"> docker项目</li></ul></li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>1.两数之和</title>
    <link href="https://xwjahahahaha.github.io/2021/10/30/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://xwjahahahaha.github.io/2021/10/30/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2021-10-30T12:44:59.000Z</published>
    <updated>2021-10-30T12:45:45.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></p><p>难度简单12464</p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表(快速查找用Hash表)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    hashMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> j, has := hashMap[target-v]; has &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;i, j&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashMap[v] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1. 两数之和&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度简单12464&lt;/p&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 &lt;strong&gt;和为目标值&lt;/strong&gt; &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; 的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>1-微服务概览与治理</title>
    <link href="https://xwjahahahaha.github.io/2021/10/30/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E6%B2%BB%E7%90%86/"/>
    <id>https://xwjahahahaha.github.io/2021/10/30/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E6%B2%BB%E7%90%86/</id>
    <published>2021-10-30T05:46:18.000Z</published>
    <updated>2021-10-30T11:48:31.939Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h1 id="一、微服务概览"><a href="#一、微服务概览" class="headerlink" title="一、微服务概览"></a>一、微服务概览</h1><h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1 单体架构"></a>1.1 单体架构</h2><p>单体式应用，拓展难可靠性低 ，敏捷性开发和部署无法完成</p><p>改变思路： 化繁为简，分而治之</p><h2 id="1-2-微服务起源"><a href="#1-2-微服务起源" class="headerlink" title="1.2 微服务起源"></a>1.2 微服务起源</h2><h3 id="1-SOA服务与微服务"><a href="#1-SOA服务与微服务" class="headerlink" title="1. SOA服务与微服务"></a>1. SOA服务与微服务</h3><p>SOA 面向服务架构的基本概念：</p><blockquote><p>面向服务架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和协议联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。</p></blockquote><p>简单的理解：SOA就是将把系统按照实际业务，拆分成刚刚好大小的、合适的、独立部署的模块，每个模块之间相互独立。</p><p><a href="https://www.zhihu.com/question/42061683" target="_blank" rel="noopener">https://www.zhihu.com/question/42061683</a></p><p>微服务就是SOA的一种实践，微服务起源于SOA，本质上都是面向服务的架构，微服务比SOA拆分更小一点，有更加细致的定义：</p><ul><li><p>小即是美：小的服务代码少、易测试、维护</p></li><li><p>单一职责：一个服务只需要做好一件事</p></li><li><p>尽可能早的创建原型：尽早的定义API，建立服务契约，达成服务间沟通的一致性约定，完善的事以后再做</p><blockquote><p><font color='#39b54a'>类似于前后端开发，事先商量好API，然后大家再一起开发</font></p></blockquote></li><li><p>可移植性比效率更重要：服务间的轻量级交互协议在效率与可移植性二者之间，首要考虑兼容性和可移植性</p></li></ul><h3 id="2-微服务定义"><a href="#2-微服务定义" class="headerlink" title="2. 微服务定义"></a>2. 微服务定义</h3><p>围绕业务功能构建，每个服务关注单一的业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言与数据存储技术。微服务架构通过业务拆分实现服务的组件化，通过组件的组合又可以实现快速的开发系统，业务单一的服务组件又可以独立部署。</p><p>主要特点如下：</p><ul><li>原子服务</li><li>独立进程</li><li>隔离部署</li><li>去中心化服务治理</li></ul><p>例图，微服务的架构：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211030143010567.png" alt="image-20211030143010567" style="zoom:50%;" /><h3 id="3-微服务的缺点"><a href="#3-微服务的缺点" class="headerlink" title="3. 微服务的缺点"></a>3. 微服务的缺点</h3><p>细粒度的划分会使整个系统变得复杂，基础设施要求高、查错排错相对麻烦</p><ul><li><strong>微服务是分布式系统，会带来分布式固有的复杂性。</strong>进程通讯交互采不得不使用RPC或消息传递；此外还需要写代码处理消息过慢或服务不可用等失效问题</li><li><strong>分布式数据库架构，同时更新多个业务主体的事务普遍</strong>。相比于单体，微服务需要快速更新多个不同的数据库，分布式一致性如何解决</li><li><strong>测试困难</strong> </li><li><strong>服务间的模块依赖</strong>，应用升级可能会设计多个服务的修改</li><li><strong>对运维基础设施的挑战较大</strong></li></ul><h2 id="1-3-组件服务化"><a href="#1-3-组件服务化" class="headerlink" title="1.3 组件服务化"></a>1.3 组件服务化</h2><p>传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。 通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。我们用 Go 实施一个微服务：</p><ul><li>kit: 一个微服务的基础库（框架）</li><li>service：业务代码+kit依赖+第三方依赖组成的业务微服务</li><li>rpc + message queue（消息队列）：轻量级通讯</li></ul><blockquote><p><font color='#e54d42'>本质上就是多个微服务组合完成一个完整的用户场景/应用</font></p></blockquote><h2 id="1-4-按业务组织服务"><a href="#1-4-按业务组织服务" class="headerlink" title="1.4. 按业务组织服务"></a>1.4. 按业务组织服务</h2><p>工作模型改变：</p><p>从原本的烟囱式： UI-&gt;中间件开发-&gt;测试-&gt;运维-&gt;监控 改变为：<strong>面向服务全栈</strong>，you build it, you fix it, 对完成这项服务的整个流程负责，因为你是最清楚的</p><p>运维、测试等则负责开发更加高效的平台/工具提供开发人员使用</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211030150042170.png" alt="image-20211030150042170" style="zoom: 50%;" /><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211030150103522.png" alt="image-20211030150103522" style="zoom:50%;" /><h2 id="1-5-去中心化"><a href="#1-5-去中心化" class="headerlink" title="1.5. 去中心化"></a>1.5. 去中心化</h2><p>每个服务面临的业务场景不同，可以针对性的选择合适的技术解决方案，但是注意不要过于的多样化。</p><p>去中心化主要分为以下几个方面：</p><ul><li>数据去中心化：每个服务独享自己的数据存储设施（缓存、数据库等），隔离相关干扰（见图）</li><li>治理去中心化：防止热点服务崩溃、多部署负载均衡</li><li>技术去中心化：使用合适的技术解决合适的问题</li></ul><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211030150309490.png" alt="image-20211030150309490" style="zoom: 50%;" /><h2 id="1-6-基础设置自动化"><a href="#1-6-基础设置自动化" class="headerlink" title="1.6. 基础设置自动化"></a>1.6. 基础设置自动化</h2><p>无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。</p><ul><li>CICD：Gitlab + Gitlab Hooks + k8s</li><li>Testing：测试环境、单元测试、API自动化测试</li><li>在线运行时：k8s，以及一系列监控 Prometheus、ELK（日志采集）、Conrtol Panle</li></ul><p>企业的自动化流程：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211030151841269.png" alt="image-20211030151841269"></p><h2 id="1-7-可用性与兼容性设计"><a href="#1-7-可用性与兼容性设计" class="headerlink" title="1.7. 可用性与兼容性设计"></a>1.7. 可用性与兼容性设计</h2><p>著名的 Design For Failure 思想（<strong>每一行代码都考虑是否会出错</strong>），微服务架构采用粗粒度的进程间通信（<strong>将请求设计为批量的请求</strong>），引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对“分布式计算的误解”。</p><p>可用性主要需要掌握以下几点：</p><ul><li>隔离</li><li>超时控制</li><li>负载保护 </li><li>限流</li><li>降级</li><li>重试</li><li>负载均衡</li></ul><p>一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，<strong>时刻谨记保持服务契约(接口)的兼容性。</strong></p><p><strong>发送时要保守，接收时要开放</strong>。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</p><h1 id="二、微服务设计"><a href="#二、微服务设计" class="headerlink" title="二、微服务设计"></a>二、微服务设计</h1><h2 id="2-1-API-Gateway的演进"><a href="#2-1-API-Gateway的演进" class="headerlink" title="2.1 API Gateway的演进"></a>2.1 API Gateway的演进</h2><p>原本的模式，按垂直功能进行了拆分，对外暴露一批微服务：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/O72Trc.png" alt="O72Trc"></p><p>但是缺乏统一的出口，面临困难：</p><ul><li>客户端到微服务直接通信，强耦合。</li><li>需要多次请求，客户端聚合数据，工作量巨大，延迟高。</li><li>协议不利于统一，各个部门间有差异，需要端来兼容。</li><li>面向“端”的API适配，耦合到了内部服务。</li><li>多终端兼容逻辑复杂，每个服务都需要处理。</li><li>统一逻辑无法收敛，比如安全认证、限流。</li></ul><p><font color='#e54d42'>需要面向用户业务场景的API而不要面向资源的API，业务场景的需求才是根本</font></p><p>所以需要内聚模式配合改进：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/CVEWwO.png" alt="CVEWwO"></p><p>​    新增了一个 app-interface 用于统一的协议出口，在服务内进行大量的 dataset join，按照业务场景来设计<strong>粗粒度的 API</strong>，给后续服务的演进带来的很多优势：</p><ul><li>轻量交互：协议精简、聚合。</li><li>差异服务：数据裁剪以及聚合、针对终端定制化API。</li><li>动态升级：原有系统兼容升级，更新服务而非协议。</li><li>沟通效率提升，协作模式演进为移动业务+网关小组。</li></ul><p><strong>BFF（Backend for Frontend）</strong>面向前端场景的后端服务，主要负责<strong>业务场景层聚合API</strong>。BFF 可以认为是一种适配服务，将后端的微服务进行适配(主要包括聚合裁剪和格式适配等逻辑)，向无线端设备暴露友好和统一的 API，方便无线设备接入访问后端服务。</p><p>但是可能面临的问题就是单点故障，单一的BFF故障会导致全体崩溃。</p><p>改进：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211030154325953.png" alt="image-20211030154325953"></p><p>多BFF分类负责聚合API服务，每个BFF核心负责的其实是<strong>数据的组装</strong>（从各个下游API中组装数据）</p><p>BFF设计模式也叫做API聚合：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/PCg8mS.png" alt="PCg8mS"></p><p>但是当业务多了之后，BFF的数量也逐步上升，更新一个下游横向切面的模块会导致非常多的BFF跟着需要更新，很多跨横切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多。</p><p>改进：将所有面向横向切面的服务都放在最上层引入<code>API Gateway</code>, 把业务集成度高的BFF层和通用功能服务层API Gateway进行了分层处理</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/NazW3s.png" alt="NazW3s"></p><p>在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF 实现了解耦拆分（不需要关心横向切面的服务），各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。另外，把跨横切面逻辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加专注业务逻辑交付，实现了架构上的<strong>关注分离(Separation of Concerns)</strong>。</p><p>我们业务流量流转过程实际为：</p><p>移动端 -&gt; API Gateway -&gt; BFF -&gt; Mircoservice（微服务），在 FE Web业务中，BFF 可以是 nodejs 来做服务端渲染(SSR，Server-Side Rendering)，注意这里忽略了上游的 CDN、4/7层负载均衡(ELB) （这些都是在API Gateway之上）。</p><p><strong>BFF与API Gateway的区别：</strong></p><ul><li>BFF主要负责下游<strong>数据</strong>的组装，拒绝涉及横向切面的业务</li><li>API Gateway则主要负责横向切面的业务（限流、账号限权等）</li></ul><h2 id="2-2-Mircoservice的划分"><a href="#2-2-Mircoservice的划分" class="headerlink" title="2.2 Mircoservice的划分"></a>2.2 Mircoservice的划分</h2><p>如何划分微服务的边界，每个业务场景微服务划分的依据是不同的</p><p>在实际项目中通常会采用两种不同的方式划分服务边界，即通过<strong>业务职能(Business Capability)</strong>或是 <strong>DDD 的限界上下文(Bounded Context)</strong>。</p><ul><li>Business Capability 业务职能<pre><code>由公司内部不同部门提供的职能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能。</code></pre></li><li>Bounded Context 限界上下文<pre><code>限界上下文是 DDD 中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。</code></pre></li></ul><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/mb2Zfh.png" alt="mb2Zfh"></p><p>能够闭环的解决用户的一个应用场景的就应该设计为一个服务</p><p><strong>CQRS（Command Query Responsibility Segregation）</strong>将应用程序分为两部分：<strong>命令端和查询端</strong>（简单来说就是读写分离）。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新. </p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/D4b9jw.png" alt="D4b9jw"></p><p>在稿件服务演进过程中，我们发现围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是<u>最终前台用户只关注稿件能否查看</u>，我们依赖稿件数据库 binlog 以及订阅 binlog 的中间件 canal，将我们的稿件结果发布到消息队列 kafka 中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来拆分复杂架构和业务。</p><p>我们架构也从 <code>Polling publisher</code> -&gt; <code>Transaction log tailing</code> 进行了演进(Pull vs Push)。</p><h2 id="2-3-Mircoservice安全"><a href="#2-3-Mircoservice安全" class="headerlink" title="2.3 Mircoservice安全"></a>2.3 Mircoservice安全</h2><p>对于外网的请求来说，我们通常在 API Gateway 进行统一的认证拦截，一旦认证成功，我们会使用 JWT 方式通过 RPC 元数据传递的方式带到 BFF 层，BFF 校验 Token 完整性后把身份信息注入到应用的 Context 中，BFF 到其他下层的微服务，建议是直接在 RPC Request 中带入用户身份信息(UserID)请求服务。</p><ul><li>API Gateway -&gt; BFF -&gt; Service    </li><li>Biz Auth  -&gt; JWT -&gt; Request Args</li></ul><p>对于服务内部（内网安全），一般要区分身份认证（jrpc证书等方式）和授权（RBAC等）。</p><ul><li>Full Trust （知道身份，通讯过程也加密）</li><li>Half Trust （知道身份，通讯过程不加密）</li><li>Zero Trust （都可以连接）</li></ul><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/dPseq0.png" alt="dPseq0"></p><p>授权变化：用户Token -&gt; JWT Token -&gt; Access Token（内网token）-&gt; 用户ID</p><h1 id="三、gRPC与服务发现"><a href="#三、gRPC与服务发现" class="headerlink" title="三、gRPC与服务发现"></a>三、gRPC与服务发现</h1><h2 id="3-1-gRPC"><a href="#3-1-gRPC" class="headerlink" title="3.1 gRPC"></a>3.1 gRPC</h2><h3 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h3><p>对比表解释：</p><table><thead><tr><th>名词</th><th>特点</th></tr></thead><tbody><tr><td>RPC</td><td>远程过程调用（分布式、微服务间的方法调用）</td></tr><tr><td>HTTP</td><td>无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp）</td></tr><tr><td>TCP</td><td>面向连接，三次握手保证通信可靠</td></tr><tr><td>UDP</td><td>非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ）</td></tr><tr><td>socket</td><td>TCP协议的接口实现，面向传输层进行网络编程</td></tr></tbody></table><p><strong>RPC是一种网络调用设计、框架，其面向服务而不是通信协议</strong>。使用的通讯协议只是其中的一部分，其中可能使用的就是Http协议，是在Http协议概念的上层，其主要<strong>在上层构建的一些优化通信</strong>，例如：负载均衡、寻址、序列化与反序列化</p><h3 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h3><p>官网的解释： “A high-performance, open-source universal RPC framework”</p><p>gRPC是谷歌开源的一个 <strong>RPC 框架</strong>，面向移动和 <strong>HTTP/2</strong> 设计。</p><ul><li>内容交换格式采用<strong>ProtoBuf</strong>(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。</li><li>传输协议 采用http2，性能比http1.1好了很多</li></ul><p>和很多RPC系统一样，服务端负责实现定义好的接口并处理客户端的请求，客户端根据接口描述直接调用需要的服务。客户端和服务端可以分别使用gPRC支持的不同语言实现。</p><p>ProtoBuf 具有强大的IDL（interface description language，接口描述语言）和相关工具集（主要是protoc）。用户写好.proto描述文件后，protoc可以将其编译成众多语言的接口代码。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/L9rv1Z.png" alt="L9rv1Z"></p><p>gRPC的优势：</p><ul><li>多语言：语言中立，支持多种语言。</li><li>轻量级、高性能：序列化支持 PB(Protocol Buffer)和 JSON，PB 是一种语言无关的高性能序列化框架。</li><li>可插拔</li><li>IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。</li><li>设计理念</li><li>移动端：基于标准的 HTTP2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量。</li></ul><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/X1R8Ap.png" alt="X1R8Ap"></p><ul><li><p><strong>服务而非对象、消息而非引用</strong>：促进微服务的系统间粗粒度消息交互（批量接口）设计理念。</p><p>如图所示<code>service</code>并不是一个对象，<code>message</code>也不是一个引用</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/tBSJr3-20211030190848785.png" alt="tBSJr3"></p></li><li><p>负载无关的：不同的服务需要使用不同的消息类型和编码，例如 protocol buffers、JSON、XML 和 Thrift。<br>流：Streaming API。</p></li><li><p>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。</p></li><li><p>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。</p></li><li><p>标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。</p></li></ul><h1 id="四、多集群与多租户"><a href="#四、多集群与多租户" class="headerlink" title="四、多集群与多租户"></a>四、多集群与多租户</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0234</title>
    <link href="https://xwjahahahaha.github.io/2021/10/30/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0234/"/>
    <id>https://xwjahahahaha.github.io/2021/10/30/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0234/</id>
    <published>2021-10-30T02:02:20.000Z</published>
    <updated>2021-10-30T13:54:43.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经</li><li><input checked="" disabled="" type="checkbox"> go进阶训练营 第一周（1）微服务与治理</li><li><input checked="" disabled="" type="checkbox"> 晚上：刷leetcode  2 老题<ul><li><input checked="" disabled="" type="checkbox"> 两数之和</li><li><input checked="" disabled="" type="checkbox"> 无重复字符的最长子串</li></ul></li><li><input disabled="" type="checkbox"> docker</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0233</title>
    <link href="https://xwjahahahaha.github.io/2021/10/29/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0233/"/>
    <id>https://xwjahahahaha.github.io/2021/10/29/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0233/</id>
    <published>2021-10-29T01:04:35.000Z</published>
    <updated>2021-10-29T15:38:44.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经</li><li><input disabled="" type="checkbox"> 下午：刷leetcode</li><li><input checked="" disabled="" type="checkbox"> 晚上：做项目</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>1-基础知识与技术</title>
    <link href="https://xwjahahahaha.github.io/2021/10/28/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker/%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5%E4%B8%80%E4%B8%AAdocker%E7%B3%BB%E5%88%97/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    <id>https://xwjahahahaha.github.io/2021/10/28/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker/%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5%E4%B8%80%E4%B8%AAdocker%E7%B3%BB%E5%88%97/1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E6%9C%AF/</id>
    <published>2021-10-28T12:14:59.000Z</published>
    <updated>2021-11-02T07:36:19.337Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习自《自己动手写Docker》</p><p>作者：<a href="https://www.zhihu.com/people/chen-xian-lu-10/activities" target="_blank" rel="noopener">陈显鹭（花名：遥鹭）-阿里云高级研发工程师</a>等</p><p>京东购买链接：<a href="https://item.jd.com/10033552355433.html" target="_blank" rel="noopener">https://item.jd.com/10033552355433.html</a></p><p>其他资料：</p><ul><li><a href="https://www.cnblogs.com/heyanan/p/7800284.html" target="_blank" rel="noopener">https://www.cnblogs.com/heyanan/p/7800284.html</a></li><li><a href="https://www.cnblogs.com/Philip-Tell-Truth/p/6284475.html" target="_blank" rel="noopener">https://www.cnblogs.com/Philip-Tell-Truth/p/6284475.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/166393945" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/166393945</a></li></ul></blockquote><blockquote><p>我的主机环境：</p><ul><li>内核版本：Linux version 4.15.0-48-generic (buildd@lgw01-amd64-036) </li><li>Ubuntu 7.3.0-16ubuntu3  </li></ul></blockquote><p>[TOC]</p><a id="more"></a><p>docker已经成为了容器化技术的代表名词，即使是k8s大行其道的今天，docker也是k8s的基石。所以打算跟着书一起用一个系列从零开始学习编写docker引擎。</p><p>前提：学习过docker基本操作使用、golang的基本使用</p><p>记录重点与实际遇到的难点、bug</p><h1 id="一、容器与开发语言"><a href="#一、容器与开发语言" class="headerlink" title="一、容器与开发语言"></a>一、容器与开发语言</h1><p>​    docker最直观的理解：一个隔离的虚拟环境，封装了所有应用程序需要的一切在其中（代码、工具、系统依赖等），这样就可以称为“容器”，并且这样的容器是可以复制的（都是一个模子里刻出来的），而生成容器的模版就是“镜像”，镜像可以将所有系统级别依赖打包成为一个文件，所有镜像共享一个Kernel(在同一个宿主机下)。</p><h2 id="什么是Kernel？"><a href="#什么是Kernel？" class="headerlink" title="什么是Kernel？"></a>什么是Kernel？</h2><p>计算机系统的结构：</p><ol><li><strong>硬件：</strong>物理机（这是系统的底层结构或基础）是由内存（RAM）、处理器（或 CPU）以及输入/输出（I/O）设备（例如<a href="https://www.redhat.com/zh/topics/data-storage" target="_blank" rel="noopener">存储</a>、<a href="https://www.redhat.com/zh/topics/hyperconverged-infrastructure/what-is-software-defined-networking" target="_blank" rel="noopener">网络</a>和图形）组成的。其中，CPU 负责执行计算和内存的读写操作。</li><li><strong>Linux 内核：</strong>操作系统的核心。（明白了吗？内核正居于核心位置。）<font color='#e54d42'>它是驻留在内存中的<strong>软件</strong>，用于告诉 CPU 要执行哪些操作。</font></li><li><strong>用户进程：</strong>这些是内核所<a href="https://www.redhat.com/zh/topics/management" target="_blank" rel="noopener">管理</a>的运行程序。用户进程共同构成了用户空间。用户进程有时也简称为<em>进程</em>。内核还允许这些进程和服务器彼此进行通信（称为进程间通信或 IPC）。</li></ol><h2 id="docker容器特点："><a href="#docker容器特点：" class="headerlink" title="docker容器特点："></a>docker容器特点：</h2><ol><li>轻量级： 占用内存少、磁盘使用率高、启动快 （相比于虚拟机）</li><li>开放：基于开放标准，可运行在主流linux、windows操作系统</li><li>安全：隔离保护</li></ol><h2 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h2><p>虚拟机（也被称为guest os）是一种模拟系统，即在软件层面上通过<u>模拟硬件的输入和输出</u>，让虚拟机的操作系统得以运行在<strong>没有物理硬件的环境中</strong>（也就是宿主机的操作系统上），其中能够模拟出硬件输入输出，让虚拟机的操作系统可以启动起来的程序，被叫做<strong>hypervisor</strong>， hypervisor能够创建出虚拟硬件。</p><p>虚拟机的缺点所在：</p><ul><li>每个虚拟机一般都有自己的kernel，并且开启之前需要先做开机自检，启动kernel，启动用户进程等一系列行为，启动很慢</li><li>虚拟机还需要模拟硬件的输入输出，效率很差</li><li>虚拟机需要包含用户的程序、函数库、整个客户操作系统，占用空间大</li></ul><p>docked的改进：</p><ul><li><p>docker<strong>所有容器（包括宿主机）之间共享内核kernel</strong>，各个容器在宿主机上相互隔离在用户态（cpu低级访问权限，一般程序的权限）下运行。docker的kernel version由宿主机决定</p><blockquote><p><font color='#39b54a'>因为共享kernel，所以不需要费大精力模拟硬件的输入输出，只需要模拟kernel的输入输出（因为共享），所以这种虚拟化也叫做<strong>操作系统层虚拟化</strong></font>  <a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Operating-system-level_virtualization">Operating-system-level virtualization</a></p></blockquote></li><li><p>docker通过隔离容器不让容器使用宿主机的文件、进程、内存等系统实现封闭的环境（具体操作会在后面详述），让用户感受到容器有自己的文件、进程等系统（类似于虚拟机）</p></li><li><p>容器不与任何基础设施绑定，移植性好</p></li></ul><p>虚拟机与docker架构对比：</p><p>虚拟机：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211028205122292.png" alt="image-20211028205122292" style="zoom: 50%;" /><p>docker容器：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211028205147983.png" alt="image-20211028205147983" style="zoom: 50%;" /><p>正因为这些特点，docker能够<strong>加速开发效率，隔离移植、使用环境</strong>，容器的合作分享可以使用Docker Hub（类似于github，能够管理、更新docker镜像的仓库）</p><h1 id="二、基础技术"><a href="#二、基础技术" class="headerlink" title="二、基础技术"></a>二、基础技术</h1><h2 id="2-1-容器的启动过程"><a href="#2-1-容器的启动过程" class="headerlink" title="2.1 容器的启动过程"></a>2.1 容器的启动过程</h2><p>linux进程实现的步骤：</p><ol><li>在内存中将主进程复制一份得到子进程，此时主、子进程上下文完全一致</li><li>设置子进程的pid、parent_pid等其他与主进程不一样的内容（所以子进程大部分资源还是与主进程一致的）</li></ol><p>docker需要制造一个虚拟的进程，所以进程的实现需要多做几步：</p><ol><li>自定义rootfs（根文件系统），将宿主机的一个文件目录设置为虚拟机的根目录，例如<code>rootfs=/root/ubuntu</code>,在容器中其就是<code>/</code></li><li>将自身的pid映射为0，并让其看不到其他任何进程pid，让其在容器中唯一</li><li>用户名隔离，可以把用户名变为<code>root</code></li><li><code>hostname</code>隔离，可以领取一个<code>hostname</code></li><li>IPC隔离，隔离进程之间的相互通信</li><li>网络隔离，隔离进程与主机之间的网络</li></ol><blockquote><p><font color='#39b54a'>这些隔离方式都是调用linux系统内置（kernel）的隔离方法：<a href="https://link.zhihu.com/?target=http%3A//man7.org/linux/man-pages/man2/clone.2.html">clone(2) - Linux manual page</a></font></p></blockquote><p><font color='#e54d42'><strong>docker是内核的搬运工：</strong>docker实现这些隔离就是调用内核kernel支持的已有的内置隔离资源的方法，当然在其上也有一些拓展，例如资源隔离等</font></p><p>所以出现了docker两个特性：</p><ol><li>启动速度快：因为本质上<strong>容器中的进程与宿主机进程没有很大区别</strong>，<font color='#e54d42'><strong>本质上docker启动的就是一个被隔离的进程</strong></font>，共享了很多资源（虽然多了很多步骤）</li><li>docker对linux内核版本有需求（版本号大于3.10），因为需要内核支持一些隔离特性的方法</li></ol><p><strong>对于容器启动后再新创建的进程，因为在创建容器时已经实现了与宿主机的资源隔离，所以在容器中新创建的进程天然就与宿主机实现了资源隔离！所以只需要刚开始的一次隔离（上面的6步）后面的进程就不需要再做了。</strong></p><p>=&gt; 找到启动快的原因：</p><p>linux启动流程如下图：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/8geyMe.png" alt="8geyMe" style="zoom: 50%;" /><p>问：启动容器需要执行以上几步？ 答：0步</p><h2 id="2-2-Linux-namespace-资源隔离"><a href="#2-2-Linux-namespace-资源隔离" class="headerlink" title="2.2 Linux namespace 资源隔离"></a>2.2 Linux namespace 资源隔离</h2><h3 id="1-基础介绍"><a href="#1-基础介绍" class="headerlink" title="1. 基础介绍"></a>1. 基础介绍</h3><p>Linux实现隔离的方式： <a href="http://link.zhihu.com/?target=http%3A//man7.org/linux/man-pages/man7/namespaces.7.html">namespaces(7)</a></p><p>命名空间将全局系统资源包装在一个抽象中 使名称空间内的进程看起来拥有自己的全局资源的独立实例。全局资源的修改对同一个命名空间下的其他进程是可见的，对于其他命名空间是不可见的。命名空间的一个用途是实现容器。</p><p>Linux Namespace各种命名空间：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/ItNpxb.png" alt="ItNpxb"></p><p>中文简版（6种）：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211031100831804.png" alt="image-20211031100831804"></p><p>第二列显示了用于在各种api中指定名称空间类型的标志值（系统调用参数），第三列标识了手册页中关于命名空间的详细信息，最后一列标识命名空间对应隔离的资源</p><p>Namespace能够实现在同一台主机下UID级别的隔离，给每一个UID的用户虚拟化出一个Namespace，这样多个用户之间可以访问系统资源的同时互相之间还实现了隔离。</p><p>从每个用户的角度看，每个命名空间都像一台单独的linux一样，有自己的init进程，并且pid不断递增</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211028230603400.png" alt="image-20211028230603400" style="zoom:67%;" /><p>例如上图：</p><p>用户A在命名空间A中认为自己的1号进程就是init进程，同理B如此。但是实际上都是分别映射到主进程3，4进程，从host的角度看只是3、4号进程虚拟化出来的一个空间而已。</p><h4 id="查看进程所有命名空间"><a href="#查看进程所有命名空间" class="headerlink" title="查看进程所有命名空间"></a>查看进程所有命名空间</h4><p>查看当前进程的所有命名空间：<code>ls -l /proc/$$/ns | awk &#39;{print $1, $9, $10, $11}&#39;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">total   </span><br><span class="line">lrwxrwxrwx cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx net -&gt; net:[4026531993]</span><br><span class="line">lrwxrwxrwx pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx pid_for_children -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx uts -&gt; uts:[4026532271]</span><br></pre></td></tr></table></figure><h4 id="单独查看命名空间"><a href="#单独查看命名空间" class="headerlink" title="单独查看命名空间"></a>单独查看命名空间</h4><p>例如查看UTS： <code>readlink /proc/$$/ns/uts</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> readlink /proc/$$/ns/uts</span></span><br><span class="line">uts:[4026532271]</span><br></pre></td></tr></table></figure><h3 id="2-命名空间API"><a href="#2-命名空间API" class="headerlink" title="2. 命名空间API"></a>2. 命名空间API</h3><p>目前Namespace的API的系统调用：</p><table><thead><tr><th>API</th><th>官方解释</th><th>简单解释</th></tr></thead><tbody><tr><td>clone(2)</td><td>系统调用创建一个新进程。如果调用的flags参数指定了上面列出的一个或多个<code>CLONE_NEW*</code>标志，则新的命名空间是为每个标志创建，并且子进程被创建为               这些命名空间的成员。</td><td>创建一个新进程，可以通过<code>CLONE_NEW*</code>参数指定哪些命名空间被创建，并且他们的子进程也会被包含在这些Namespace中</td></tr><tr><td>setns(2)</td><td>系统调用允许调用进程加入现有的命名空间。</td><td>将一个进程加入现有命名空间</td></tr><tr><td>unshare(2)</td><td>系统调用的调用进程移动到               新的命名空间。如果调用的标志参数 指定列出的一个或多个<code>CLONE_NEW*</code>标志上面，然后为每个标志创建新的命名空间，并且调用进程成为这些命名空间的成员。（这个系统调用还实现了许多功能与命名空间无关。）</td><td>调用进程移动到新的命名空间</td></tr><tr><td>ioctl(2)</td><td>发现有关命名空间的信息。</td><td>输出命名空间的信息</td></tr></tbody></table><h3 id="3-UTS-Namespace"><a href="#3-UTS-Namespace" class="headerlink" title="3. UTS Namespace"></a>3. UTS Namespace</h3><p>主要用于隔离Hostname、Domainname系统标识（主机与域名）</p><p>go实现UTS命名空间的调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build linux</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/exec"</span></span><br><span class="line"><span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">"sh"</span>)<span class="comment">// 被复制出来的新进程的初始命令，我们使用sh执行</span></span><br><span class="line">cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">Cloneflags: syscall.CLONE_NEWUTS,<span class="comment">// 使用CLONE标志创建一个UTS Namespace</span></span><br><span class="line">&#125;</span><br><span class="line">cmd.Stdin = os.Stdin</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码执行后我们会进入一个<code>sh</code>运行环境中，在这个环境中我们就实现了一个新的UTS Namespace</p><p>验证效果：</p><ul><li><p>查看当前宿主机进程之间的关系：<code>pstree -pl</code> (我的运行文件为test)</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211029165014390.png" alt="image-20211029165014390"></p></li><li><p>查看当前<code>sh</code>的pid: <code>echo $$</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $$  </span></span><br><span class="line">6372</span><br></pre></td></tr></table></figure></li><li><p>验证父进程与子进程是否在同一个UTS Namespace: <code>/proc/xxx/ns/uts</code> （<code>xxx</code>是进程pid）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> readlink /proc/6369/ns/uts// 父进程就是go可执行文件<span class="built_in">test</span></span></span><br><span class="line">uts:[4026531838]</span><br><span class="line"><span class="meta">$</span><span class="bash"> readlink /proc/6372/ns/uts                    </span></span><br><span class="line">uts:[4026532271]</span><br></pre></td></tr></table></figure></li><li><p>测试修改Hostname（正常情况下修改此环境内的hostname是不会影响外部主机的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hostname -b bird// 修改主机名为bird</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hostname</span></span><br><span class="line">bird</span><br></pre></td></tr></table></figure><p>在另一个终端中查看宿主机的<code>hostname</code>是否改变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hostname</span></span><br><span class="line">wenjie</span><br></pre></td></tr></table></figure><p>并没有因此改变，所以实现了主机名隔离</p></li></ul><h3 id="4-IPC-Namespace"><a href="#4-IPC-Namespace" class="headerlink" title="4. IPC Namespace"></a>4. IPC Namespace</h3><p>IPC Namespace用来隔离<code>System V IPC</code> 和<code>POSIX message queues</code>，每一个IPC Namespace都拥有自己唯一的<code>System V IPC</code> 和<code>POSIX message queues</code></p><h4 id="1-进程间通讯IPC基本概念"><a href="#1-进程间通讯IPC基本概念" class="headerlink" title="1. 进程间通讯IPC基本概念"></a>1. 进程间通讯IPC基本概念</h4><p>IPC(Inter-Process Communication)进程间通信有三种信息共享方式：1.随文件系统 2.随kernel内核 3.随共享内存</p><p>  相对的IPC的持续性（Persistence of IPC Object）也有三种：</p><ol><li><p><strong>随进程持续的（Process-Persistent IPC）</strong></p><p>IPC对象一直存在，直到最后拥有他的进程被关闭为止，典型的IPC有pipes（管道）和FIFOs（先进先出对象） </p></li><li><p><strong>随内核持续的（Kernel-persistent IPC）</strong></p><p>IPC对象一直存在直到内核被重启或者对象被显式关闭为止，在Unix中这种对象有<strong><em>System v 消息队列，信号量，共享内存</em>。</strong>（注意<strong><em>Posix消息队列，信号量和共享内存</em></strong>被要求为至少是内核持续的，但是也有可能是文件持续的，这样看系统的具体实现）。</p></li><li><p><strong>随文件系统持续的（FileSystem-persistent IPC）</strong></p><p>除非IPC对象被显式删除，否则IPC对象会一直保持（即使内核才重启了也是会留着的）。如果Posix消息队列，信号量，和共享内存都是用内存映射文件的方法，那么这些IPC都有着这样的属性。</p></li></ol><p>不同的Unix IPC的持续性：</p><ol><li><p><strong>随进程</strong></p><p><code>Pipe, FIFO, Posix的mutex（互斥锁）, condition variable（条件变量）, read-write lock（读写锁）,memory-based semaphore（基于内存的信号量） 以及 fcntl record lock，TCP和UDP套接字，Unix domain socket</code></p></li><li><p><strong>随内核</strong></p><p><code>Posix的message queue（消息队列）, named semaphore（命名信号量）, System V Message queue, semaphore, shared memory。</code></p></li></ol><p>要注意的是，虽然上面所列的IPC并没有随文件系统的，但是我们就像我们刚才所说的那样，Posix IPC可能会跟着系统具体实现而不同（具有不同的持续性），举个例子，写入文件肯定是一个文件系统持续性的操作，但是通常来说IPC不会这样实现。很少有IPC会实现文件系统持续，因为这会降低性能，不符合IPC的设计初衷。</p><p><strong>System V IPC与Posix IPC是两种IPC的标准，后者在前者之上进行了改进，但是基本的概念都是差不多</strong></p><p>具体的差别可见：<a href="https://blog.csdn.net/guiwin/article/details/82782151" target="_blank" rel="noopener">系统V IPC与POSIX IPC</a></p><p>System V IPC是UNIX系统上广泛使用的三种进程间通信机制的名称:消息队列、信号量和共享内存。是随内核持续的，直到内核被重启或者对象被显性关闭为止。</p><ol><li><p>System V 消息队列：</p><p>System V 消息队列允许<strong>数据以称为消息的单位交换</strong>，每个消息都可以有一个关联的优先级。POSIX消息队列提供了实现相同结果的替代API</p></li><li><p>System V 信号量：</p><p>System V信号量允许<strong>进程同步它们的动作</strong>。系统V的信号量被分配到称为集合的组中;集合中的每个信号量都是一个计数信号量。POSIX信号量提供了实现相同结果的替代API。</p></li><li><p>System V 共享内存:</p><p>系统V共享内存允许<strong>进程共享一个区域一个内存</strong>(一个scegment)。POSIX共享内存是实现相同结果的另一种API</p></li></ol><h4 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h4><p>实践其实很简单，在刚刚的程序上增加一个flag即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC,</span><br></pre></td></tr></table></figure><p>再次编译启动：</p><p>查看现有的ipc消息队列: <code>ipcs -q</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ipcs -q</span></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br></pre></td></tr></table></figure><p>创建一个消息队列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ipcmk -Q// 创建一个消息队列</span></span><br><span class="line">Message queue id: 0</span><br><span class="line"><span class="meta">$</span><span class="bash"> ipcs -q// 查看</span></span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages    </span><br><span class="line">0xcc4f9f77 0          root       644        0            0</span><br></pre></td></tr></table></figure><p>使用另一个终端查看消息队列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ipcs -q</span></span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br></pre></td></tr></table></figure><p>无法查看到，说明实现了消息队列的隔离</p><h3 id="5-PID-Namespace"><a href="#5-PID-Namespace" class="headerlink" title="5. PID Namespace"></a>5. PID Namespace</h3><p>pid Namespace就是用于隔离进程ID的，同样一个进程在不同的PID Namespace可以拥有不同的进程ID</p><p>同样的修改一下代码中的flag：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID,</span><br></pre></td></tr></table></figure><p>编译启动后，首先查看自己真实的PID</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/GHqSyk.png" alt="GHqSyk"></p><p>当前的Pid是10166</p><p>然后查看自己当前隔离之后的ID:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $$</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>（注意，这里不能使用ps、top等命令查看，因为会调用/proc内容，后面会解决这个问题）</p><h3 id="6-Mount-Namespace"><a href="#6-Mount-Namespace" class="headerlink" title="6. Mount Namespace"></a>6. Mount Namespace</h3><p><a href="https://man7.org/linux/man-pages/man7/mount_namespaces.7.html" target="_blank" rel="noopener">mount_namespaces(7)</a></p><p>负责隔离各个进程看到的挂载点视图，让每一个进程看到的文件系统层次是不同的。这也是Linux第一个实现的Namespace类型，所以注意他的flag是<code>CLONE_NEWNS</code>（new Namespace的缩写）</p><h4 id="1-Mount命令"><a href="#1-Mount命令" class="headerlink" title="1. Mount命令"></a>1. Mount命令</h4><p>在挂载了<code>/proc</code>的进程下可以使用<code>Mount</code>命令</p><p><code>mount</code>命令主要用于挂载linux中的文件系统等操作</p><p>关于此命令的详细使用可以查看：<a href="https://man7.org/linux/man-pages/man8/mount.8.html" target="_blank" rel="noopener">mount(8) — Linux manual page</a> </p><p>这里列出常用的几个并解释：</p><ul><li><p><code>mount</code> : 输出当前所有的设备、挂载目录以及类型</p></li><li><p><code>mount -t type device dir</code><br><strong>device</strong>：指定要挂载的设备，比如磁盘、光驱等。<br><strong>dir</strong>：指定把文件系统挂载到哪个目录。<br><strong>type</strong>：指定挂载的文件系统类型，一般不用指定，mount 命令能够自行判断。<br><strong>options</strong>：指定挂载参数，比如 ro 表示以只读方式挂载文件系统。</p><p>告诉内核将在device上(类型为type)上找到的文件系统附加到目录dir。选项<code>-t type</code>是可选的, 不写的话通常会自动检测。 </p></li><li><p><code>mount --bind olddir newdir</code></p><p>将文件系统层次结构的一部分重新挂载到其他地方，调用之后相同的内容可以在两个地方访问。重要的是要理解“bind”不会在内核VFS中创建任何二类或特殊的节点。“绑定”只是附加文件系统的另一个操作。</p></li></ul><h5 id="shared-subtree"><a href="#shared-subtree" class="headerlink" title="shared subtree"></a>shared subtree</h5><p>Mount有一个重要的地方，就是它的<strong>shared subtree</strong>机制：</p><p>该机制的出现主要是为了解决Mount Namespace操作不方便的问题：当宿主机有新的磁盘挂载后，我们希望能够通知所有的其他Namespace挂载这个磁盘，但是如果是完全隔离的状态，那么是需要每个都手动操作，非常麻烦。所以就出现了shared subtree机制，这个机制主要有两个关键点：</p><ol><li><p>peer group</p><p>表示一个或者多个挂载点的集合，有下面两种情况会分到一个集合（group）：</p><ul><li>通过<code>--bind</code>操作挂载的源挂载点（必须是一个挂载点）与目的挂载点</li><li>新生成mount ns复制过去的挂载点在同一个集合</li></ul></li><li><p><strong>propagate type 传播属性</strong></p><p>上述的问题依靠这个属性解决。传播属性重新定义了挂载对象/点之间的关系，定义的关系包括：</p><ul><li>共享关系： 一个挂载对象的挂载事件会传播到另一个挂载对象，反之亦然 （双向）</li><li>从属关系：一个挂载对象的挂载事件会传播给另一个，反之不会 （单向）</li></ul><p>一个挂载的状态可以有以下几种：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/8T4RPY.png" alt="8T4RPY"></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211030233301325.png" alt="image-20211030233301325"></p><p>​    默认情况下，所有挂载状态都是私有的，改变状态的方法如下所示：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mount --make-shared mountpoint// 共享</span><br><span class="line">mount --make-slave mountpoint// 从属</span><br><span class="line">mount --make-private mountpoint// 私有</span><br><span class="line">mount --make-unbindable mountpoint// 设置不可被绑定</span><br><span class="line">// 有r前缀的表示递归的修改挂载点以及其子目录</span><br><span class="line">mount --make-rshared mountpoint</span><br><span class="line">mount --make-rslave mountpoint</span><br><span class="line">mount --make-rprivate mountpoint</span><br><span class="line">mount --make-runbindable mountpoint</span><br></pre></td></tr></table></figure><h4 id="2-实践-1"><a href="#2-实践-1" class="headerlink" title="2. 实践"></a>2. 实践</h4><p>修改代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,</span><br></pre></td></tr></table></figure><p>编译启动：</p><p>查看一下<code>/proc</code>的文件内容</p><blockquote><p><code>/proc</code>是一个文件系统，可以通过特殊的机制将内核和内核信息发送给进程</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /proc</span></span><br><span class="line">1      19510  21767  21800  21833  21866  21900  21942  21975  22006  22039  22072  22105  22138  22172  22206  24     5299       driver        softirqs</span><br><span class="line">10     19570  21768  21801  21834  21867  21901  21943  21976  22007  22040  22073  22106  22139  22173  22207  24819  5300       execdomains   stat</span><br><span class="line">10143  19615  21769  21802  21835  21868  21902  21944  21977  22008  22041  22074  22107  22140  22174  22208  249    584        fb            swaps</span><br><span class="line">11     2      21770  21803  21836  21869  21903  21945  21978  22009  22042  22075  22108  22141  22175  22209  25     589        filesystems   sys</span><br><span class="line">115    20     21771  21804  21837  21870  21904  21946  21979  22010  22043  22076  22109  22142  22176  22210  25538  6          fs            sysrq-trigger</span><br><span class="line">12     20444  21772  21805  21838  21871  21905  21947  21980  22011  22044  22077  22110  22143  22177  22211  258    6021       interrupts    sysvipc</span><br><span class="line">13     20474  21773  21806  21839  21872  21906  21948  21981  22012  22045  22078  22111  22144  22178  22212  26     672        iomem         thread-self</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>这是宿主机的<code>/proc</code>，我们还需要手动的将<code>/proc</code> mount(挂载)到我们自己的Namespace下</p><p>使用命令<code>mount -t proc proc /proc</code>将宿主机的<code>proc</code>文件系统挂载到自己的Namespace下的<code>/proc</code>目录上</p><p>再次查看<code>/proc</code>文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /proc</span></span><br><span class="line">1          cgroups   devices      fb           ioports   key-users    loadavg  modules       partitions   slabinfo  sysrq-trigger  uptime             zoneinfo</span><br><span class="line">5          cmdline   diskstats    filesystems  irq       kmsg         locks    mounts        sched_debug  softirqs  sysvipc        version</span><br><span class="line">acpi       consoles  dma          fs           kallsyms  kpagecgroup  mdstat   mtrr          schedstat    stat      thread-self    version_signature</span><br><span class="line">buddyinfo  cpuinfo   driver       interrupts   kcore     kpagecount   meminfo  net           scsi         swaps     timer_list     vmallocinfo</span><br><span class="line">bus        crypto    execdomains  iomem        keys      kpageflags   misc     pagetypeinfo  self         sys       tty            vmstat</span><br></pre></td></tr></table></figure><p>相比宿主机的<code>/proc</code>已经少了很多内容</p><p>使用<code>ps -ef</code>查看进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef</span></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 22:21 pts/1    00:00:00 sh</span><br><span class="line">root         8     1  0 22:34 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><p>可以看到这时候就只能看到自己Namespace下的进程了</p><p>我们回到宿主机，发现宿主机的<code>/proc</code>不能使用了，这就是因为宿主机的Namespace文件中本来对挂载点<code>/proc</code>设置的就是共享挂载，所以我们使用clone复制的时候，新的Mount Namespace也是共享挂载，两者是共享和传播的方式。</p><p>回到宿主机通过查看<code>cat /proc/self/mountinfo</code>当前宿主机NS的挂载点信息：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211031092033846.png" alt="image-20211031092033846"></p><p><code>/proc</code>等系统的挂载点都是<code>shared</code>的状态</p><p>为了让新建的Mount Namespace不影响其他的Mount Namespace，所以我们需要设置为私有挂载模式：</p><p>一样的编译启动新的Mount Namespace，但是这次挂载的操作不同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将/proc目录设置为私有挂载</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mount --make-rprivate /proc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载/proc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mount -t proc proc /proc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls /proc</span></span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/u6ByLy.png" alt="u6ByLy"></p><p>通过运行可以看到在新的NS中我们实现了隔离</p><p>现在返回原来的NS，直接查看<code>/proc</code>看看是否受到影响</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/x0UWFs.png" alt="x0UWFs"></p><p>可以看到并没有收到影响。我们不需要再重新挂载了，实现了隔离。</p><p>mount实现了和外部空间的隔离，在本Namespace下挂载的文件系统不回影响外部，<font color='#e54d42'><strong>所以这也是docker数据卷的特性原因之一</strong></font></p><h3 id="7-User-Namespace"><a href="#7-User-Namespace" class="headerlink" title="7. User Namespace"></a>7. User Namespace</h3><p>User Namespace主要隔离用户的用户组ID。比较常见的做法是将宿主机上的一个非root用户在新建的User Namespace中映射成一个root用户，这意味着这个进程在User Namespace内部是有root权限的。</p><p><strong>在Linux Kernel 3.8开始非root进程也可以创建User Namespace了，并且实现了在新创的User Namespace中拥有root权限</strong></p><p>修改代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line">cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置凭证</span></span><br><span class="line">cmd.SysProcAttr.Credential = &amp;syscall.Credential&#123;</span><br><span class="line">Uid: <span class="keyword">uint32</span>(<span class="number">1</span>),</span><br><span class="line">Gid: <span class="keyword">uint32</span>(<span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line">cmd.Stdin = os.Stdin</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看当前宿主机的用户与用户组: <code>id</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><p>接下来运行程序再同样执行：</p><blockquote><p>报错：<code>fork/exec /bin/sh: operation not permitted</code></p><p>原因：<a href="https://github.com/xianlubird/mydocker/issues/3" target="_blank" rel="noopener">https://github.com/xianlubird/mydocker/issues/3</a></p><p>Linux kernel 在 3.19 以上的版本中对 <code>user namespace</code>做了些修改</p><p>解决：删除掉<code>cmd.SysProcAttr.Credential</code></p><p><em>注意：centos不支持user namspace需要额外的设置，见原因链接</em></p></blockquote><p>再次运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> id</span></span><br><span class="line">uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup)</span><br></pre></td></tr></table></figure><p>可以看到UID已经不同了，因此User Namespace生效了</p><h3 id="8-Network-Namespace"><a href="#8-Network-Namespace" class="headerlink" title="8. Network Namespace"></a>8. Network Namespace</h3><p>用于隔离网络设备、IP地址端口等网络栈的Namespace。可以让每个容器拥有自己独立的（虚拟的）网络设备，并且容器可以绑定到自己端口，每个Namespace内的端口都不会互相冲突。</p><p>在宿主机上搭建网桥后就可以很方便的实现容器之间的通信，并且不同的容器可以使用相同的端口！</p><p>同样的添加flag:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER | syscall.CLONE_NEWNET,</span><br></pre></td></tr></table></figure><p>首先查看宿主机的网路设备情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ifconfig</span></span><br><span class="line">docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255</span><br><span class="line">        ether 02:42:df:81:27:f6  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 585  bytes 140849 (140.8 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 611  bytes 987099 (987.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.59.2  netmask 255.255.192.0  broadcast 172.17.63.255</span><br><span class="line">        ether 00:16:3e:0e:2d:b8  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 1168249932  bytes 1131213773283 (1.1 TB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 683891978  bytes 296842597629 (296.8 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 67191390  bytes 8889749352 (8.8 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 67191390  bytes 8889749352 (8.8 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><blockquote><p>错误：宿主机的<code>/proc</code>不见了 <code>/proc is empty (not mounted ?)</code></p><p>解决：在宿舍机上重新挂载<code>mount -t proc proc /proc</code></p></blockquote><p>运行程序，在新的Network Namespace中查看网络：</p><p>运行的结果是：啥也没有。所以已经处于隔离状态了。</p><h2 id="2-3-Linux-Cgroups-资源限制"><a href="#2-3-Linux-Cgroups-资源限制" class="headerlink" title="2.3 Linux Cgroups 资源限制"></a>2.3 Linux Cgroups 资源限制</h2><p>在Namespace中，我们只实现了隔离，但是怎样<strong>限制</strong>每个容器空间的大小呢，这就要使用到Cgroups</p><p>Linux Cgroups(Control Groups)提供了对一组进程以及将来子进程的资源限制，包括CPU、内存、存储与网络等</p><p>使用Cgroups可以方便的限制某个资源的占用并且可以实时的监控和统计信息</p><blockquote><p>Control Groups，通常被称为cgroups，是Linux内核的一个特性，它允许进程被组织成分层的组，这些组可以被限制和监视各种类型的资源的使用。<strong>内核的cgroup接口是通过一个名为cgroupfs的伪文件系统提供的。分组是在核心cgroup内核代码中实现的，而资源跟踪和限制是在一组每个资源类型的子系统(内存、CPU等)中实现的。</strong></p></blockquote><p>最初发布的cgroups是在linux 2.6.24中运行的，但是随后的不协调的更新导致了cgroups分为了两个版本维护：v1和v2 </p><p>v2发布在linux 3.10之后，v1成为了老版本，因为兼容性没有被移除</p><p>详细内容见：<a href="https://man7.org/linux/man-pages/man7/cgroups.7.html" target="_blank" rel="noopener">cgroups(7) — Linux manual page</a></p><h3 id="1-三大组件"><a href="#1-三大组件" class="headerlink" title="1. 三大组件"></a>1. 三大组件</h3><p>Cgroups构成主要是三个组件：Cgroup、Subsystem、Hierarchy</p><h4 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h4><p>cgroup用于对进程进行分组管理的机制，一个cgroup包含一组进程，然后可以以cgroup为单位来进行subsystem的各种参数配置。</p><h4 id="Subsystem"><a href="#Subsystem" class="headerlink" title="Subsystem"></a>Subsystem</h4><p>subsystem是一组资源控制的模块，包含如下几项：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211101193901382.png" alt="image-20211101193901382"></p><p>每个subsystem关联到相应的cgroup上并对其中的进程进行资源的限制与控制。这些subsystem都是逐步合并到内核中的。</p><p>查看自己linux内核支持的subsystem：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装cgroup命令工具</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt-get install cgroup-bin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lssubsys</span></span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/mJmFWQ.png" alt="mJmFWQ"></p><h4 id="Hierarchy"><a href="#Hierarchy" class="headerlink" title="Hierarchy"></a>Hierarchy</h4><p>hierarchy的作用是将一组cgroup串成一个树状的结构，这样的一棵树就可以称为一个hierarchy</p><p><strong>cgroup是一组进程的集合， hierarchy是一组cgroup的集合</strong></p><p>通过这样的树结构，cgroups可以实现<strong>继承</strong></p><p>例如：将多个进程设置为一组cgroup，并在其中设置了限制cpu的使用率。但是其中一个特殊的进程活动需要限制磁盘的I/O，如果单独设置就可能会影响其他同cgroup的进程。此时就可以将这个进程单独化为一个新的cgroup2，让其继承于cgroup1，这样单独对cgroup2设置限制就不会影响到cgroup1的其他进程。</p><h4 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h4><ul><li>系统创建hierarchy之后，默认创建一个cgrouop根节点，系统会将所有进程加入到此cgroup中</li><li>一个subsystem只能附加到一个hierarchy上（一对一的关系）</li><li>一个hierarchy可以附加多个subsystem（一对多的关系）</li><li>一个进程可以作为多个cgroup的成员，但是这些cgroup不能在一个hierarchy上（hierarchy与进程一对一）</li><li>一个进程fork出的子进程与父进程在同一个cgroup上，当然也可以通过操作移动</li></ul><h3 id="2-配置与操作Cgroups"><a href="#2-配置与操作Cgroups" class="headerlink" title="2. 配置与操作Cgroups"></a>2. 配置与操作Cgroups</h3><p>kernel为了让cgroups的配置更加直观，通过一个虚拟的树状文件系统配置Cgroups，通过层级的目录虚拟出Cgroup树(hierarchy)。</p><p>配置案例：</p><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir cgroup-test<span class="comment"># 创建挂载点</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载一个hierarchy， -o表示添加可选项</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mount -t cgroup -o none,name=cgroup-test cgroup-test ./cgroup-test</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看挂载点信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/self/mountinfo</span></span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/ocpDDK.png" alt="ocpDDK"></p><p>可以看到刚刚设置的挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 挂载后可以在目录下看到生成了许多默认文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree ./cgroup-test</span></span><br></pre></td></tr></table></figure><p>默认文件以及其解释如下：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/Jng8oK.png" alt="Jng8oK" style="zoom:150%;" /><h4 id="2-创建子cgroup"><a href="#2-创建子cgroup" class="headerlink" title="2. 创建子cgroup"></a>2. 创建子cgroup</h4><p>创建两个子cgroup</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir cgroup-1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir cgroup-2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/P7lzMt.png" alt="P7lzMt"></p><p>可以看到在一个cgroup的目录下创建文件夹时，内核会把这个文件夹标记为子cgroup创建必要文件并<strong>继承父cgroup的属性</strong></p><h4 id="3-移动进程"><a href="#3-移动进程" class="headerlink" title="3. 移动进程"></a>3. 移动进程</h4><p>一个进程在一个hierarchy上只能存在于一个cgroup，移动进程cgroup修改task文件即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $$</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将我的终端进程移动到cgroup-1中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> cgroup-1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sh -c <span class="string">"echo $$ &gt;&gt; tasks"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/17795/cgroup</span></span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/aJnSgh.png" alt="aJnSgh"></p><h4 id="4-subsystem限制进程资源"><a href="#4-subsystem限制进程资源" class="headerlink" title="4. subsystem限制进程资源"></a>4. subsystem限制进程资源</h4><p>上面在创建hierarchy的之后并没有指定关联到任何的subsystem，但是系统默认给每个subsystem创建了一个默认的hierarchy，例如memory的hierarchy</p><p>在subsystem的根目录下的memory目录，这是一个hierarchy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mount | grep memory</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls /sys/fs/cgroup/</span></span><br></pre></td></tr></table></figure><p>下面就通过在这个hierarchy中创建cgroup限制如下进程占用的内存资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在没有限制的情况下，启动一个占用内存的stress进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apt install stress</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> stress --vm-bytes 200m --vm-keep -m 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个cgroup</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir <span class="built_in">limit</span>-memory-test &amp;&amp; <span class="built_in">cd</span> <span class="built_in">limit</span>-memory-test</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置最大占用内存为100MB</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sh -c <span class="string">"echo  "</span>100m<span class="string">" &gt; memory.limit_in_bytes"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat memory.limit_in_bytes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将当前进程移动到此group</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sh -c <span class="string">"echo $$ &gt; tasks"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次运行占用内存200MB的stress进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> stress --vm-bytes 200m --vm-keep -m 1</span></span><br></pre></td></tr></table></figure><p>发现200m的压力测试启动失败（我这里与书上的测试结果不同，不知道为什么），只有小于这个限制的stress才可以跑起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stress: info: [17728] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br><span class="line">stress: FAIL: [17728] (415) &lt;-- worker 17729 got signal 9</span><br><span class="line">stress: WARN: [17728] (417) now reaping child worker processes</span><br><span class="line">stress: FAIL: [17728] (451) failed run completed in 0s</span><br></pre></td></tr></table></figure><h3 id="3-Docker如何使用Cgroups"><a href="#3-Docker如何使用Cgroups" class="headerlink" title="3. Docker如何使用Cgroups"></a>3. Docker如何使用Cgroups</h3><p>通过实例查看一个docker容器怎样配置Cgroups</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置内存限制启动容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -itd -m 128m ubuntu</span></span><br></pre></td></tr></table></figure><p>docker会为每个容器在系统的hierarchy中创建cgroup</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /sys/fs/cgroup/memory/docker/b496830a00213173ec4d43aee2ae01be6c524cda8e6f71e66e1defb90e10c32e</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看cgroup中进程使用的内存大小</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat memory.usage_in_bytes</span></span><br></pre></td></tr></table></figure><p>docker为每个容器创建cgroup并通过cgroup配置资源限制与监控</p><h3 id="4-Go实现通过cgroup限制容器资源"><a href="#4-Go实现通过cgroup限制容器资源" class="headerlink" title="4. Go实现通过cgroup限制容器资源"></a>4. Go实现通过cgroup限制容器资源</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/exec"</span></span><br><span class="line"><span class="string">"path"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载了memory subsystem的hierarchy的根目录位置</span></span><br><span class="line"><span class="keyword">const</span> cgroupMemoryHierarchyMount = <span class="string">"/sys/fs/cgroup/memory"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"os.Args[0] is %s\n"</span>, os.Args[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// /proc/self/exe 它代表当前程序</span></span><br><span class="line"><span class="keyword">if</span> os.Args[<span class="number">0</span>] == <span class="string">"/proc/self/exe"</span> &#123;</span><br><span class="line"><span class="comment">// 容器进程执行函数</span></span><br><span class="line">fmt.Printf(<span class="string">"current pid %d\n"</span>, syscall.Getegid())<span class="comment">// 获得自己Namespace下的pid</span></span><br><span class="line">cmd := exec.Command(<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">`stress --vm-bytes 60m --vm-keep -m 1`</span>)</span><br><span class="line">cmd.SysProcAttr=&amp;syscall.SysProcAttr&#123;&#125;</span><br><span class="line">cmd.Stdin = os.Stdin</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line"><span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Errorf(<span class="string">"run err : %s \n"</span>, err.Error())</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行当前程序</span></span><br><span class="line">cmd := exec.Command(<span class="string">"/proc/self/exe"</span>)</span><br><span class="line"><span class="comment">// fork一个子进程并设置Namespace</span></span><br><span class="line">cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,</span><br><span class="line">&#125;</span><br><span class="line">cmd.Stdin = os.Stdin</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line"><span class="comment">// start启动一个命令，但是不会等待其运行结束</span></span><br><span class="line"><span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Errorf(<span class="string">"start err : %s\n"</span>, err.Error())</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到fork出来的进程在外部命名空间的pid</span></span><br><span class="line">fmt.Printf(<span class="string">"cmd pid is %v\n"</span>, cmd.Process.Pid)</span><br><span class="line"><span class="comment">// 在系统默认创建挂载了memory subsystem的Hierarchy上创建新的cgroup</span></span><br><span class="line">os.Mkdir(path.Join(cgroupMemoryHierarchyMount, <span class="string">"testmemorylimit"</span>), <span class="number">0755</span>)</span><br><span class="line"><span class="comment">// 将容器进程(cmd进程)放到这个cgroup中(在task文件中写入进程id)</span></span><br><span class="line">ioutil.WriteFile(path.Join(cgroupMemoryHierarchyMount, <span class="string">"testmemorylimit"</span>, <span class="string">"tasks"</span>), []<span class="keyword">byte</span>(strconv.Itoa(cmd.Process.Pid)), <span class="number">0644</span>)</span><br><span class="line"><span class="comment">// 限制cgroup进程使用</span></span><br><span class="line">ioutil.WriteFile(path.Join(cgroupMemoryHierarchyMount, <span class="string">"testmemorylimit"</span>, <span class="string">"memory.limit_in_bytes"</span>), []<span class="keyword">byte</span>(<span class="string">"50m"</span>), <span class="number">0644</span>)</span><br><span class="line"><span class="comment">// 等待进程结束</span></span><br><span class="line">cmd.Process.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/cOIHnY.png" alt="cOIHnY"></p><p><code>/proc/self/exe</code>它代表当前执行的程序，是一个软链接. <code>os.Args[0]</code>就是当前执行文件路径</p><p>运行<code>go run 2-cgroups.go</code>：</p><p>首先，当前执行路径是go编译器在tmp里面临时编译的可执行文件路径（见输出第一行），所以<code>if os.Args[0] == &quot;/proc/self/exe&quot; {...}</code>不会进入</p><p>而是使用cmd创建隔离Namespace环境再次执行当前程序（创建一个新的进程），因为采用的是<code>cmd.Start()</code>并不会等待此次执行结束（第二次执行当前程序），所以先输出了底下的<code>cmd pid is 31669</code>，然后一系列操作将这个新的进程设置了cgroup的内存限制为<code>50m</code>。</p><p>随后已经第二次执行也同步开始，符合<code>if</code>条件进入if体内，输出当前进程的<code>pid</code>为<code>0</code>（因为<code>PID Namespace</code>的隔离），值得注意的是这个进程与上面输出的<code>31669</code>进程是同一个进程，只是在外部<code>Namespace</code>中看此进程是<code>31669</code>,而在新的Namespace中其被隔离为<code>0</code>. 所以上面的进程限制就是设置在此进程。</p><p>随后在子进程中启动<code>stress</code>压力测试程序，内存占用要求为<code>60m</code>，因为收到了限制，所以无法启动，发生了报错。</p><p>可以尝试修改启动的限制，当在限制下启动是没有问题的。所以说明我们的内存限制起了作用。</p><h2 id="2-4-Union-File-System"><a href="#2-4-Union-File-System" class="headerlink" title="2.4 Union File System"></a>2.4 Union File System</h2><p>Union File System简称UnionFS，是一种为Linux、FreeBSD和NetBSD操作系统设计的</p><p>UnionFS<strong>把其他文件系统联合到一个联合挂载点的文件系统服务</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习自《自己动手写Docker》&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://www.zhihu.com/people/chen-xian-lu-10/activities&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;陈显鹭（花名：遥鹭）-阿里云高级研发工程师&lt;/a&gt;等&lt;/p&gt;
&lt;p&gt;京东购买链接：&lt;a href=&quot;https://item.jd.com/10033552355433.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://item.jd.com/10033552355433.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/heyanan/p/7800284.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/heyanan/p/7800284.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Philip-Tell-Truth/p/6284475.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/Philip-Tell-Truth/p/6284475.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/166393945&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/166393945&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;我的主机环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核版本：Linux version 4.15.0-48-generic (buildd@lgw01-amd64-036) &lt;/li&gt;
&lt;li&gt;Ubuntu 7.3.0-16ubuntu3  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>146.LRU缓存机制</title>
    <link href="https://xwjahahahaha.github.io/2021/10/28/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E8%AE%BE%E8%AE%A1%E7%B1%BB/146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://xwjahahahaha.github.io/2021/10/28/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E8%AE%BE%E8%AE%A1%E7%B1%BB/146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2021-10-28T08:37:37.000Z</published>
    <updated>2021-10-28T08:38:57.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU 缓存机制</a></p><p>难度中等1692</p><p>运用你所掌握的数据结构，设计和实现一个 <a href="https://baike.baidu.com/item/LRU" target="_blank" rel="noopener">LRU (最近最少使用) 缓存机制</a> 。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><p><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</p></li><li><p><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</p></li><li><p><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><a id="more"></a></li></ul><p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class="line">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class="line">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br><span class="line">lRUCache.get(4);    &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hash表 + 双向链表</span></span><br><span class="line"><span class="comment">// Hash表实现链表节点的O(1)访问</span></span><br><span class="line"><span class="comment">// 双向链表实现访问时间顺序以及交换</span></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// map + 双向链表</span></span><br><span class="line">    linkMap <span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    list *ToWayLinkedList</span><br><span class="line"></span><br><span class="line">    dataMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> LRUCache&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node), NewToWayLinkedList(), <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>), capacity&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, has := this.dataMap[key]; !has &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新访问时间</span></span><br><span class="line">    this.list.Update(this.linkMap[key])</span><br><span class="line">    <span class="keyword">return</span> this.dataMap[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    _, hasKey := this.dataMap[key]      <span class="comment">//注意： 如果当前达到容量上限但是原本的键存在则依然更新</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.dataMap) &lt; this.<span class="built_in">len</span> || hasKey &#123;</span><br><span class="line">        <span class="comment">// 未满，直接存储</span></span><br><span class="line">        <span class="keyword">if</span> _, has := this.dataMap[key]; has &#123;</span><br><span class="line">            <span class="comment">// 更新操作</span></span><br><span class="line">            this.dataMap[key] = value</span><br><span class="line">            <span class="comment">// 更新时间</span></span><br><span class="line">            this.list.Update(this.linkMap[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建操作</span></span><br><span class="line">            this.dataMap[key] = value</span><br><span class="line">            this.linkMap[key] = this.list.Insert(key)   <span class="comment">// 创建链表节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 满了，替换存储</span></span><br><span class="line">        <span class="comment">// 删除当前时间最久的</span></span><br><span class="line">        delNode := this.list.DeleteFirst()</span><br><span class="line">        <span class="built_in">delete</span>(this.linkMap, delNode.data)      <span class="comment">// 注意：这里删除的是最久未使用节点的key</span></span><br><span class="line">        <span class="built_in">delete</span>(this.dataMap, delNode.data)</span><br><span class="line">        <span class="comment">// 加入新的节点</span></span><br><span class="line">        this.dataMap[key] = value</span><br><span class="line">        this.linkMap[key] = this.list.Insert(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ToWayLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head *node      <span class="comment">// 头节点</span></span><br><span class="line">    tail *node      <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span>         <span class="comment">// 节点数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    data <span class="keyword">int</span>        </span><br><span class="line">    pre *node       <span class="comment">// 前指针</span></span><br><span class="line">    next *node      <span class="comment">// 后指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewToWayLinkedList</span><span class="params">()</span> *<span class="title">ToWayLinkedList</span></span> &#123;</span><br><span class="line">    head, tail := &amp;node&#123;<span class="number">-1</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;, &amp;node&#123;<span class="number">-1</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    head.next = tail</span><br><span class="line">    tail.pre = head</span><br><span class="line">    <span class="keyword">return</span> &amp;ToWayLinkedList&#123;head, tail, <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部插入一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ToWayLinkedList)</span> <span class="title">Insert</span><span class="params">(data <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    newNode := &amp;node&#123;data, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    l.tail.pre.next = newNode</span><br><span class="line">    newNode.next = l.tail</span><br><span class="line">    newNode.pre = l.tail.pre</span><br><span class="line">    l.tail.pre = newNode</span><br><span class="line">    l.<span class="built_in">len</span> ++</span><br><span class="line">    <span class="keyword">return</span> newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除首节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ToWayLinkedList)</span> <span class="title">DeleteFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> l.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"not have node"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    delNode := l.head.next</span><br><span class="line">    l.head.next = l.head.next.next</span><br><span class="line">    delNode.pre = <span class="literal">nil</span></span><br><span class="line">    delNode.next = <span class="literal">nil</span></span><br><span class="line">    l.head.next.pre = l.head</span><br><span class="line">    l.<span class="built_in">len</span> --</span><br><span class="line">    <span class="keyword">return</span> delNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将特定节点移动到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ToWayLinkedList)</span> <span class="title">Update</span><span class="params">(kNode *node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> kNode.next == l.tail &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除原本位置</span></span><br><span class="line">    preNode := kNode.pre</span><br><span class="line">    preNode.next = preNode.next.next</span><br><span class="line">    kNode.pre = <span class="literal">nil</span></span><br><span class="line">    kNode.next = <span class="literal">nil</span></span><br><span class="line">    preNode.next.pre = preNode</span><br><span class="line">    <span class="comment">// 插入末尾</span></span><br><span class="line">    l.tail.pre.next = kNode</span><br><span class="line">    kNode.next = l.tail</span><br><span class="line">    kNode.pre = l.tail.pre</span><br><span class="line">    l.tail.pre = kNode</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(capacity);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Get(key);</span></span><br><span class="line"><span class="comment"> * obj.Put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lru-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;146. LRU 缓存机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度中等1692&lt;/p&gt;
&lt;p&gt;运用你所掌握的数据结构，设计和实现一个 &lt;a href=&quot;https://baike.baidu.com/item/LRU&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LRU (最近最少使用) 缓存机制&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;LRUCache&lt;/code&gt; 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;LRUCache(int capacity)&lt;/code&gt; 以正整数作为容量 &lt;code&gt;capacity&lt;/code&gt; 初始化 LRU 缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;int get(int key)&lt;/code&gt; 如果关键字 &lt;code&gt;key&lt;/code&gt; 存在于缓存中，则返回关键字的值，否则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;void put(int key, int value)&lt;/code&gt; 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>日记_0232</title>
    <link href="https://xwjahahahaha.github.io/2021/10/28/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0232/"/>
    <id>https://xwjahahahaha.github.io/2021/10/28/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0232/</id>
    <published>2021-10-28T01:52:30.000Z</published>
    <updated>2021-10-28T15:30:06.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 上午：看go、面经</li><li><input checked="" disabled="" type="checkbox"> 下午：刷leetcode 2道老题+1道新题<ul><li><input checked="" disabled="" type="checkbox"> 堆排序</li><li><input checked="" disabled="" type="checkbox"> LRU缓存机制</li><li><input checked="" disabled="" type="checkbox"> 最大子序列和</li></ul></li><li><input checked="" disabled="" type="checkbox"> 晚上：做项目docker<ul><li><input checked="" disabled="" type="checkbox"> 第一～二章</li></ul></li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>堆的实现</title>
    <link href="https://xwjahahahaha.github.io/2021/10/27/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%A0%86%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://xwjahahahaha.github.io/2021/10/27/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%A0%86%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-10-27T15:14:33.000Z</published>
    <updated>2021-10-28T06:14:59.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现一个建议堆</p><a id="more"></a><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Heap <span class="keyword">interface</span> &#123;</span><br><span class="line">Len(heap *MyHeap) <span class="keyword">int</span></span><br><span class="line">Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">Compare(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">ShiftUp(value <span class="keyword">int</span>)</span><br><span class="line">ShiftDown()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个小顶堆</span></span><br><span class="line"><span class="keyword">type</span> MyHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">items []<span class="keyword">int</span></span><br><span class="line">k <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个堆实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHeap</span><span class="params">(size <span class="keyword">int</span>)</span> *<span class="title">MyHeap</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyHeap&#123;<span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1</span>), size&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MyHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(h.items) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较堆的两个元素大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MyHeap)</span> <span class="title">Compare</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt;= <span class="number">0</span> || j &lt;= <span class="number">0</span> || i &gt; h.k || j &gt; h.k &#123;</span><br><span class="line">fmt.Println(<span class="string">"Compare error"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h.items[i] &gt; h.items[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MyHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt;= <span class="number">0</span> || j &lt;= <span class="number">0</span> || i &gt; h.k || j &gt; h.k &#123;</span><br><span class="line">fmt.Println(<span class="string">"Swap error"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">h.items[i], h.items[j] = h.items[j], h.items[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上浮，新加入一个元素并重新调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MyHeap)</span> <span class="title">ShiftUp</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 检查堆是否已满</span></span><br><span class="line"><span class="keyword">if</span> h.k == h.Len() &#123;</span><br><span class="line">fmt.Println(<span class="string">"ShiftUp error"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">h.items = <span class="built_in">append</span>(h.items, value)</span><br><span class="line"><span class="comment">// 调整, 依次将新加入节点与其父节点比较</span></span><br><span class="line">index := <span class="built_in">len</span>(h.items)<span class="number">-1</span>          <span class="comment">// 比较过程中使用的指针</span></span><br><span class="line"><span class="keyword">for</span> index &gt; <span class="number">0</span> &amp;&amp; index&gt;&gt;<span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; h.Compare(index&gt;&gt;<span class="number">1</span>, index) &#123;</span><br><span class="line"><span class="comment">// 如果有父节点并且当前值小于父节点（最小堆）则交换</span></span><br><span class="line">h.Swap(index, index&gt;&gt;<span class="number">1</span>)</span><br><span class="line">index &gt;&gt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下沉，删除根节点元素并重新平衡</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MyHeap)</span> <span class="title">ShiftDown</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 检查是否为空堆</span></span><br><span class="line"><span class="keyword">if</span> h.Len() == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ShiftDown error"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将最底部元素替换堆根节点</span></span><br><span class="line">h.items[<span class="number">1</span>] = h.items[h.Len()]       <span class="comment">// 注意：最后一个元素的下标就是Len</span></span><br><span class="line">h.items = h.items[:h.Len()]         <span class="comment">// 剔除最后一个元素</span></span><br><span class="line"><span class="comment">// 重新调整堆结构特性, 从根节点往下</span></span><br><span class="line">index, minPos := <span class="number">1</span>, <span class="number">1</span>                   <span class="comment">// minPos表示三者中最小的位置</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 如果左右孩子都存在，那么找到minPos</span></span><br><span class="line"><span class="keyword">if</span> (index &lt;&lt; <span class="number">1</span>) &lt;= h.Len() &amp;&amp; h.Compare(index, index &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">minPos = index &lt;&lt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &lt;= h.Len() &amp;&amp; h.Compare(minPos, index &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &#123;</span><br><span class="line">minPos = index &lt;&lt; <span class="number">1</span> | <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="keyword">if</span> minPos == index &#123;</span><br><span class="line"><span class="comment">// 如果没变化，说明无需调整，已经满足结构特点</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">h.Swap(minPos, index)</span><br><span class="line"><span class="comment">// 更新下一个调整考察点</span></span><br><span class="line">index = minPos</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下堆的数据结构应该是一个二位数组，一维表示对象名，二维则表示优先值/属性值，可以用空接口实现</p><p>堆排序(借助于上面的最小堆)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">7</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"堆排序结果: "</span>, HeapSort(arr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 构造小顶堆</span></span><br><span class="line">minHeap := NewHeap(<span class="built_in">len</span>(arr))</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">minHeap.ShiftUp(v)</span><br><span class="line">&#125;</span><br><span class="line">ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> arr &#123;</span><br><span class="line"><span class="comment">// 删除堆顶元素，重新构建堆结构</span></span><br><span class="line"><span class="comment">// 堆顶加入结果集合</span></span><br><span class="line">ret = <span class="built_in">append</span>(ret, minHeap.ShiftDown())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;实现一个建议堆&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0231</title>
    <link href="https://xwjahahahaha.github.io/2021/10/27/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0231/"/>
    <id>https://xwjahahahaha.github.io/2021/10/27/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0231/</id>
    <published>2021-10-27T02:13:24.000Z</published>
    <updated>2021-10-27T15:19:34.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input checked="" disabled="" type="checkbox"> 论文实验 编码实现FedSharing（Cosmos、p2p）)</li></ul><a id="more"></a><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input checked="" disabled="" type="checkbox"> 第一篇投稿</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 实习：1.go云服务、云容器 2.区块链</li><li><input disabled="" type="checkbox"> 项目一：docker从0实现</li><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 看面经（语言基础）</li><li><input disabled="" type="checkbox"> 刷题（算法基础）</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 投稿论文</li><li><input checked="" disabled="" type="checkbox"> 下午：刷leetcode 3老 + 1新<ul><li>快排✅</li><li>翻转链表✅</li><li>前k个高频元素  ✅</li><li>堆的实现 ✅</li></ul></li><li>LRU缓存机制 ❎</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 论文实验 编码实现FedSharing（Cosmos、p2p）)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>go项目cli与配置文件：cobra与viper项目</title>
    <link href="https://xwjahahahaha.github.io/2021/10/07/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E5%8C%85%E5%AD%A6%E4%B9%A0/go%E9%A1%B9%E7%9B%AEcli%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9Acobra%E4%B8%8Eviper%E9%A1%B9%E7%9B%AE/"/>
    <id>https://xwjahahahaha.github.io/2021/10/07/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E5%8C%85%E5%AD%A6%E4%B9%A0/go%E9%A1%B9%E7%9B%AEcli%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9Acobra%E4%B8%8Eviper%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-10-07T11:47:49.000Z</published>
    <updated>2021-10-07T13:33:30.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料：</p><ul><li><p><a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">https://github.com/spf13/cobra</a></p></li><li><p><a href="https://github.com/spf13/viper" target="_blank" rel="noopener">https://github.com/spf13/viper</a></p></li><li><p><a href="https://github.com/spf13/cobra/blob/master/user_guide.md" target="_blank" rel="noopener">https://github.com/spf13/cobra/blob/master/user_guide.md</a></p></li></ul></blockquote><p>作者<a href="https://github.com/spf13" target="_blank" rel="noopener">spf13</a>有两个明星项目—cobra &amp; viper （眼睛蛇与蝮蛇）</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/zTvvSe.png" alt="cobra和viper的代表图案"></p><p>能够帮助我们的go项目添加cmd应用以及读取初始的配置文件，并且两者还可以高效配合使用。</p><p>本文就记录了一下这两个项目的基本使用方式（也是个人使用的记录），方便快速上手，如果想更详细了解的话可以去官网查看详细的文档.</p><a id="more"></a><p>[TOC]</p><h1 id="一、Cobra"><a href="#一、Cobra" class="headerlink" title="一、Cobra"></a>一、Cobra</h1><p>Cobra是一个库，提供了一个简单的界面，可以创建类似于git和go工具的强大的现代CLI界面。  Cobra也是一个应用程序，它可以生成应用程序脚手架来快速开发基于Cobra的应用程序。</p><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/spf13/cobra</span><br></pre></td></tr></table></figure><h2 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h2><h3 id="1-2-1-架构"><a href="#1-2-1-架构" class="headerlink" title="1.2.1 架构"></a>1.2.1 架构</h3><p>项目一般架构：</p><ul><li>cmd： 目录下存放你的cli各种命令（根命令、子命令等）</li><li>main.go: 项目入口函数</li><li>Init.go: 初始化函数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">▾ appName/</span><br><span class="line">  ▾ cmd/</span><br><span class="line">      add.go</span><br><span class="line">      your.go</span><br><span class="line">      commands.go</span><br><span class="line">      here.go</span><br><span class="line">      root.go</span><br><span class="line">    main.go</span><br><span class="line">    init.go</span><br></pre></td></tr></table></figure><p><code>root.go</code>编写go项目可执行程序的根命令(以<code>hugo</code>为例)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">  Use:   <span class="string">"hugo"</span>,</span><br><span class="line">  Short: <span class="string">"Hugo is a very fast static site generator"</span>,</span><br><span class="line">  Long: <span class="string">`A Fast and Flexible Static Site Generator built with</span></span><br><span class="line"><span class="string">                love by spf13 and friends in Go.</span></span><br><span class="line"><span class="string">                Complete documentation is available at http://hugo.spf13.com`</span>,</span><br><span class="line">  Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Do Stuff Here</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := rootCmd.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.go</code>一般只需要调用根目录的执行函数即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"&#123;pathToYourApp&#125;/cmd"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-添加子命令"><a href="#1-2-2-添加子命令" class="headerlink" title="1.2.2 添加子命令"></a>1.2.2 添加子命令</h3><p>添加一个子命令<code>add</code>在<code>add.go</code>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = &amp;cobra.Command&#123;</span><br><span class="line">  Use:   <span class="string">"add [Person]"</span>,</span><br><span class="line">  Short: <span class="string">"add one item"</span>,</span><br><span class="line">  Long:  <span class="string">`add one item`</span>,</span><br><span class="line">  Args: cobra.ExactArgs(<span class="number">1</span>),<span class="comment">// 指定该命令的参数输入个数 </span></span><br><span class="line">  Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;<span class="comment">// RunE表示可以返回一个错误</span></span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在在项目的<code>init.go</code>中的<code>init</code>函数中初始化操作：在root命令下添加这个子命令(可以多行添加多个)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cmd.rootCmd.AddCommand(add)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-添加flag"><a href="#1-2-3-添加flag" class="headerlink" title="1.2.3 添加flag"></a>1.2.3 添加flag</h3><p>flag有两种类型：</p><ol><li><p>Persistent Flags: 持久型的Flag，即设置在根命令上，其本身以及所有子命令都会有这个全局Flag</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rootCmd.PersistentFlags().BoolVarP(&amp;Verbose, <span class="string">"verbose"</span>, <span class="string">"v"</span>, <span class="literal">false</span>, <span class="string">"verbose output"</span>)</span><br></pre></td></tr></table></figure></li><li><p>Local Flags: 这种flag只应用在特定的命令上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localCmd.Flags().StringVarP(&amp;Source, <span class="string">"source"</span>, <span class="string">"s"</span>, <span class="string">""</span>, <span class="string">"Source directory to read from"</span>)</span><br></pre></td></tr></table></figure></li></ol><p>Flag 默认是可选的，但是有的命令我们希望其变为必选，可以这样操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Local Flags</span></span><br><span class="line">rootCmd.Flags().StringVarP(&amp;Region, <span class="string">"region"</span>, <span class="string">"r"</span>, <span class="string">""</span>, <span class="string">"AWS region (required)"</span>)</span><br><span class="line">rootCmd.MarkFlagRequired(<span class="string">"region"</span>)</span><br><span class="line"><span class="comment">// Persistent Flags</span></span><br><span class="line">rootCmd.PersistentFlags().StringVarP(&amp;Region, <span class="string">"region"</span>, <span class="string">"r"</span>, <span class="string">""</span>, <span class="string">"AWS region (required)"</span>)</span><br><span class="line">rootCmd.MarkPersistentFlagRequired(<span class="string">"region"</span>)</span><br></pre></td></tr></table></figure><h1 id="二、Viper"><a href="#二、Viper" class="headerlink" title="二、Viper"></a>二、Viper</h1><p>Viper是一个完整的Go应用<strong>配置解决方案</strong>，包括12-Factor应用。它被设计用于在应用程序中工作，可以处理<strong>所有类型</strong>的配置需求和格式。</p><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure><h2 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h2><h3 id="2-2-1-设置默认值"><a href="#2-2-1-设置默认值" class="headerlink" title="2.2.1 设置默认值"></a>2.2.1 设置默认值</h3><p>一个好的项目需要在引入配置文件之前使用一些默认值，可以通过以下方式构建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viper.SetDefault(<span class="string">"ContentDir"</span>, <span class="string">"content"</span>)</span><br><span class="line">viper.SetDefault(<span class="string">"LayoutDir"</span>, <span class="string">"layouts"</span>)</span><br><span class="line">viper.SetDefault(<span class="string">"Taxonomies"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"tag"</span>: <span class="string">"tags"</span>, <span class="string">"category"</span>: <span class="string">"categories"</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-2-2-读取配置文件"><a href="#2-2-2-读取配置文件" class="headerlink" title="2.2.2 读取配置文件"></a>2.2.2 读取配置文件</h3><p>支持的配置文件格式：<code>JSON, TOML, YAML, HCL, envfile and Java properties config files</code></p><p>Viper可以搜索多个路径，但目前单个Viper实例只支持单个配置文件。</p><p>具体的使用规则如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载配置文件之前，设置一些配置</span></span><br><span class="line">viper.SetConfigName(<span class="string">"config"</span>) <span class="comment">// 配置文件名称</span></span><br><span class="line">viper.SetConfigType(<span class="string">"yaml"</span>) <span class="comment">// 配置文件的拓展名</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"/etc/appname/"</span>)   <span class="comment">// 配置文件的路径</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"$HOME/.appname"</span>)  <span class="comment">// 可设置多个搜索路径</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"."</span>)               <span class="comment">// 可选在当前工作空间中查找</span></span><br><span class="line">err := viper.ReadInConfig() <span class="comment">// 找到并加载配置文件</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// 处理错误</span></span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">"Fatal error config file: %w \n"</span>, err))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-写配置文件"><a href="#2-2-3-写配置文件" class="headerlink" title="2.2.3 写配置文件"></a>2.2.3 写配置文件</h3><p>有时您希望存储在运行时所做的所有修改。为此，可以使用一些命令，每个命令都有自己的用途:</p><ul><li><p>WriteConfig——如果存在，则将当前viper配置写入预定义路径。如果没有预定义的路径，则返回错误。将覆盖当前配置文件，如果它存在。 </p></li><li><p>SafeWriteConfig——将当前的viper配置写入预定义的路径。如果没有预定义的路径，则返回错误。将不会覆盖当前配置文件，如果它存在。</p></li><li><p>WriteConfigAs—将当前viper配置写入给定的文件路径。将覆盖给定的文件，如果它存在。 </p></li><li><p>SafeWriteConfigAs—将当前的viper配置写入给定的文件路径。如果给定的文件存在，则不会覆盖该文件。</p></li></ul><p>所有标记为Safe的函数都不会覆盖任何文件，如果不存在，就创建，而默认行为是创建或截断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">viper.WriteConfig() <span class="comment">// 将viper中的配置保存到'viper.AddConfigPath()' and 'viper.SetConfigName'预定义的配置文件中</span></span><br><span class="line">viper.SafeWriteConfig()</span><br><span class="line">viper.WriteConfigAs(<span class="string">"/path/to/my/.config"</span>)</span><br><span class="line">viper.SafeWriteConfigAs(<span class="string">"/path/to/my/.config"</span>) <span class="comment">// will error since it has already been written</span></span><br><span class="line">viper.SafeWriteConfigAs(<span class="string">"/path/to/my/.other_config"</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-4-运行时读取配置文件"><a href="#2-2-4-运行时读取配置文件" class="headerlink" title="2.2.4 运行时读取配置文件"></a>2.2.4 运行时读取配置文件</h3><p>Viper支持让应用程序<strong>在运行时实时读取配置文件的功能</strong>。  需要重新启动服务器以使配置生效的日子已经一去不复返了，使用viper的应用程序可以在运行时读取配置文件的更新，不会错过任何信息。  </p><p>只需告诉viper实例watchConfig。也可以在<strong>每次发生更改</strong>时提供一个函数让Viper运行。</p><p>确保在调用WatchConfig()之前添加了所有的configPaths</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Config file changed:"</span>, e.Name)</span><br><span class="line">&#125;)</span><br><span class="line">viper.WatchConfig()</span><br></pre></td></tr></table></figure><h3 id="2-2-5-从IO流中读取配置文件"><a href="#2-2-5-从IO流中读取配置文件" class="headerlink" title="2.2.5 从IO流中读取配置文件"></a>2.2.5 从IO流中读取配置文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">viper.SetConfigType(<span class="string">"yaml"</span>) <span class="comment">// or viper.SetConfigType("YAML")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// any approach to require this configuration into your program.</span></span><br><span class="line"><span class="keyword">var</span> yamlExample = []<span class="keyword">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">Hacker: true</span></span><br><span class="line"><span class="string">name: steve</span></span><br><span class="line"><span class="string">hobbies:</span></span><br><span class="line"><span class="string">- skateboarding</span></span><br><span class="line"><span class="string">- snowboarding</span></span><br><span class="line"><span class="string">- go</span></span><br><span class="line"><span class="string">clothing:</span></span><br><span class="line"><span class="string">  jacket: leather</span></span><br><span class="line"><span class="string">  trousers: denim</span></span><br><span class="line"><span class="string">age: 35</span></span><br><span class="line"><span class="string">eyes : brown</span></span><br><span class="line"><span class="string">beard: true</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"></span><br><span class="line">viper.ReadConfig(bytes.NewBuffer(yamlExample))</span><br><span class="line"></span><br><span class="line">viper.Get(<span class="string">"name"</span>) <span class="comment">// this would be "steve"</span></span><br></pre></td></tr></table></figure><h3 id="2-2-6-重设值与覆盖、键使用别名"><a href="#2-2-6-重设值与覆盖、键使用别名" class="headerlink" title="2.2.6 重设值与覆盖、键使用别名"></a>2.2.6 重设值与覆盖、键使用别名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">viper.Set(<span class="string">"Verbose"</span>, <span class="literal">true</span>)</span><br><span class="line">viper.Set(<span class="string">"LogFile"</span>, LogFile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">viper.RegisterAlias(<span class="string">"loud"</span>, <span class="string">"Verbose"</span>)</span><br><span class="line"></span><br><span class="line">viper.Set(<span class="string">"verbose"</span>, <span class="literal">true</span>) <span class="comment">// same result as next line</span></span><br><span class="line">viper.Set(<span class="string">"loud"</span>, <span class="literal">true</span>)   <span class="comment">// same result as prior line</span></span><br><span class="line"></span><br><span class="line">viper.GetBool(<span class="string">"loud"</span>) <span class="comment">// true</span></span><br><span class="line">viper.GetBool(<span class="string">"verbose"</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="2-2-7-Get值"><a href="#2-2-7-Get值" class="headerlink" title="2.2.7 Get值"></a>2.2.7 Get值</h3><p>Viper提供的所有Get值的方法：</p><ul><li><code>Get(key string) : interface{}</code></li><li><code>GetBool(key string) : bool</code></li><li><code>GetFloat64(key string) : float64</code></li><li><code>GetInt(key string) : int</code></li><li><code>GetIntSlice(key string) : []int</code></li><li><code>GetString(key string) : string</code></li><li><code>GetStringMap(key string) : map[string]interface{}</code></li><li><code>GetStringMapString(key string) : map[string]string</code></li><li><code>GetStringSlice(key string) : []string</code></li><li><code>GetTime(key string) : time.Time</code></li><li><code>GetDuration(key string) : time.Duration</code></li><li><code>IsSet(key string) : bool</code></li><li><code>AllSettings() : map[string]interface{}</code></li></ul><p>需要注意的一件重要的事情是，如果没有找到，每个Get函数将返回一个零值。为了检查给定的键是否存在，提供了IsSet()方法。</p><p>获取多重嵌套的Key、数组：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"host"</span>: &#123;</span><br><span class="line">        <span class="attr">"address"</span>: <span class="string">"localhost"</span>,</span><br><span class="line">        <span class="attr">"ports"</span>: [</span><br><span class="line">            <span class="number">5799</span>,</span><br><span class="line">            <span class="number">6029</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"datastore"</span>: &#123;</span><br><span class="line">        <span class="attr">"metric"</span>: &#123;</span><br><span class="line">            <span class="attr">"host"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">3099</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"warehouse"</span>: &#123;</span><br><span class="line">            <span class="attr">"host"</span>: <span class="string">"198.0.0.1"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">2112</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetInt("host.ports.1") // returns 6029</span><br></pre></td></tr></table></figure><blockquote><p><font color='#39b54a'>注意： 如果有与上述方法中<code>.</code>取健相同，那么就使用该健</font></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"datastore.metric.host"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="string">"host"</span>: &#123;</span><br><span class="line">        <span class="string">"address"</span>: <span class="string">"localhost"</span>,</span><br><span class="line">        <span class="string">"port"</span>: <span class="number">5799</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"datastore"</span>: &#123;</span><br><span class="line">        <span class="string">"metric"</span>: &#123;</span><br><span class="line">            <span class="string">"host"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="string">"port"</span>: <span class="number">3099</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"warehouse"</span>: &#123;</span><br><span class="line">            <span class="string">"host"</span>: <span class="string">"198.0.0.1"</span>,</span><br><span class="line">            <span class="string">"port"</span>: <span class="number">2112</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetString(<span class="string">"datastore.metric.host"</span>) <span class="comment">// returns "0.0.0.0"</span></span><br></pre></td></tr></table></figure></blockquote><p>viper还支持远程在key/value数据库中读取配置，还可以读取环境变量等等高级功能，如果有需求的话可以看官方文档。</p><h1 id="三、结合使用"><a href="#三、结合使用" class="headerlink" title="三、结合使用"></a>三、结合使用</h1><p>结合使用其实也就是通过viper读取配置文件，然后给cobra的flag使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverCmd.Flags().Int(<span class="string">"port"</span>, <span class="number">1138</span>, <span class="string">"Port to run Application server on"</span>)</span><br><span class="line">viper.BindPFlag(<span class="string">"port"</span>, serverCmd.Flags().Lookup(<span class="string">"port"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/spf13/cobra&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/spf13/cobra&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/spf13/viper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/spf13/viper&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/spf13/cobra/blob/master/user_guide.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/spf13/cobra/blob/master/user_guide.md&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者&lt;a href=&quot;https://github.com/spf13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spf13&lt;/a&gt;有两个明星项目—cobra &amp;amp; viper （眼睛蛇与蝮蛇）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xwjpics.gumptlu.work/qinniu_uPic/zTvvSe.png&quot; alt=&quot;cobra和viper的代表图案&quot;&gt;&lt;/p&gt;
&lt;p&gt;能够帮助我们的go项目添加cmd应用以及读取初始的配置文件，并且两者还可以高效配合使用。&lt;/p&gt;
&lt;p&gt;本文就记录了一下这两个项目的基本使用方式（也是个人使用的记录），方便快速上手，如果想更详细了解的话可以去官网查看详细的文档.&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go调用python3:go-python3包的使用</title>
    <link href="https://xwjahahahaha.github.io/2021/10/06/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E5%8C%85%E5%AD%A6%E4%B9%A0/go%E8%B0%83%E7%94%A8python3-go-python3%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://xwjahahahaha.github.io/2021/10/06/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E5%8C%85%E5%AD%A6%E4%B9%A0/go%E8%B0%83%E7%94%A8python3-go-python3%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-10-06T08:00:32.000Z</published>
    <updated>2021-10-11T07:22:42.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/150253406" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/150253406</a></p><p><a href="https://blog.csdn.net/skyztttt/article/details/8115086" target="_blank" rel="noopener">https://blog.csdn.net/skyztttt/article/details/8115086</a></p><p><a href="https://poweruser.blog/embedding-python-in-go-338c0399f3d5" target="_blank" rel="noopener">https://poweruser.blog/embedding-python-in-go-338c0399f3d5</a></p><p>包地址：</p><p>python2：<a href="https://github.com/sbinet/go-python" target="_blank" rel="noopener">https://github.com/sbinet/go-python</a></p><p>python3：<a href="https://github.com/DataDog/go-python3" target="_blank" rel="noopener">https://github.com/DataDog/go-python3</a></p></blockquote><a id="more"></a><p>Python是机器/深度学习御用开发语言，Golang是新时代后端开发语言。Python很适合算法写模型，而Golang很适合提供API服务，两位同志都红的发紫。</p><p>出于项目需求和兴趣，这里就介绍一下正确搅基的办法。</p><p>从网络中查询资料后，发现两个好用的包（见上方）</p><p><strong>因为python使用的是3.x，所以本文使用的是DataDog/go-python3版本， sbinet/go-python对应python2.x</strong></p><p>[TOC]</p><h1 id="一、安装go-python3包"><a href="#一、安装go-python3包" class="headerlink" title="一、安装go-python3包"></a>一、安装go-python3包</h1><p>安装就有点麻烦。。。</p><blockquote><p>我的环境</p><p>系统：MacOS Big Sur 11.6 M1芯片 arm64</p><p>go：go version go1.16.5 darwin/arm64</p><p>python：python3.9</p></blockquote><p>命令: <code>go get github.com/DataDog/go-python3</code></p><p>报错1:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> github.com/DataDog/go-python3</span></span><br><span class="line">../../../go_projects/pkg/mod/github.com/!data!dog/go-python3@v0.0.0-20210805105248-03d93fb21b67/dict.go:141:13: could not determine kind of name for C.PyDict_ClearFreeList</span><br></pre></td></tr></table></figure><p>原因：</p><p><strong><code>DataDog/go-python3</code>只适用于<code>python3.7</code>版本！</strong>，所以之前我的电脑安装的是3.9，3.9版本删除了<code>C.PyDict_ClearFreeList</code>函数，所以找不到。</p><p>（The C.PyDict_ClearFreeList function <a href="https://docs.python.domainunion.de/3/whatsnew/3.9.html#id3" target="_blank" rel="noopener">has been removed</a> from the Python C API with Python 3.9)</p><p><a href="https://github.com/DataDog/go-python3/issues/38" target="_blank" rel="noopener">https://github.com/DataDog/go-python3/issues/38</a></p><p>解决：</p><p>使用<code>anaconda</code>创建一个python3.7的环境：（如果不会使用<code>anaconda</code>可以自行百度，不难）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n fs_py37 python=3.7</span><br><span class="line">conda activate fs_py37</span><br></pre></td></tr></table></figure><p>找到环境下<code>lib/pkgconfig</code>目录, 我的是：(一般都在conda安装中的envs下)</p><p><code>/Users/xwj/opt/anaconda3/envs/fs_py37/lib/pkgconfig</code></p><p>然后重置环境, go get:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=/Users/xwj/opt/anaconda3/envs/fs_py37/lib/pkgconfig</span><br><span class="line">go get github.com/DataDog/go-python3</span><br></pre></td></tr></table></figure><p>报错2（不是m1 mac的可能没问题）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> github.com/DataDog/go-python3</span></span><br><span class="line">ld: warning: ignoring file /Users/xwj/opt/anaconda3/envs/fs_py37/lib/libpython3.7m.dylib, building for macOS-arm64 but attempting to link with file built for macOS-x86_64</span><br><span class="line">Undefined symbols for architecture arm64:</span><br><span class="line">  "_PyBool_FromLong", referenced from:</span><br><span class="line">      __cgo_a0c8609171f9_Cfunc_PyBool_FromLong in _x002.o</span><br><span class="line">     (maybe you meant: __cgo_a0c8609171f9_Cfunc_PyBool_FromLong)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>原因：</p><p>anaconda安装的python3.7版本（amd64）与go的arm64架构不匹配（垃圾M1）</p><p>解决：</p><p>要么换python架构，要么换go的架构，反正两者架构要一致才可以</p><p>尴尬的是，目前M1还是不支持<a href="mailto:python@3.7">python@3.7</a>: <a href="https://doesitarm.com/formula/python@3.7/" target="_blank" rel="noopener">https://doesitarm.com/formula/python@3.7/</a></p><p>所以只能安装一个go的amd64版本也就是intel的x86 (以后也可能用得到)：</p><ol><li><p>官网下载压缩包：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a></p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/QvtNdL.png" alt="QvtNdL" style="zoom:67%;" /><p>注意选x86架构而不是ARM64</p></li><li><p>将解压的文件夹放到一个你喜欢的地方，我是<code>/Users/xwj/sdk/go_x86_1.17.1</code></p></li><li><p>进入这个文件夹修改<code>go</code>执行文件名字，防止和本来的arm架构的<code>go</code>重名，并且提醒自己使用的go环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd go_x86_1.17.1/bin</span><br><span class="line">mv go gox86</span><br></pre></td></tr></table></figure></li><li><p>添加配置文件：</p><p><code>vim ~/.zshrc</code>，我的配置文件如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Go arm64</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> GOROOT=<span class="string">"/Users/xwj/sdk/go1.17.1"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Go x86-64</span></span><br><span class="line">export GOROOT="/Users/xwj/sdk/go_x86_1.17.1"</span><br><span class="line">export GOPROXY=https://goproxy.cn,direct</span><br><span class="line">export GOPATH="/Users/xwj/projects/go_projects"</span><br><span class="line">export GO111MODULE="auto"</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/src:$GOPATH/bin</span><br></pre></td></tr></table></figure><p><code>source ~/.zshrc</code>, 重新打开一个终端</p><p><strong>想使用哪个就将另一个注释掉再source一下即可（重开终端）</strong></p></li><li><p>测试：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211006170400449.png" alt="image-20211006170400449"></p><p>这样go环境就可以切换了，目前先使用amd64的尝试</p></li></ol><p>下面再重新get测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=/Users/xwj/opt/anaconda3/envs/fs_py37/lib/pkgconfig</span><br><span class="line">gox86 get github.com/datadog/go-python3</span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/6561pH.png" alt="6561pH"></p><p>大功告成！</p><h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><h2 id="2-1-调用自定义python"><a href="#2-1-调用自定义python" class="headerlink" title="2.1 调用自定义python"></a>2.1 调用自定义python</h2><p>目录总体结构：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211006213827430.png" alt="image-20211006213827430"></p><p>测试的python文件</p><p><code>hello.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SayHello</span><span class="params">(xixi)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> xixi + <span class="string">"haha"</span></span><br></pre></td></tr></table></figure><p>可以将go调用python的过程分为以下5步：</p><ol><li><p>初始化python环境</p></li><li><p>引入模块py对象</p></li><li><p>使用该模块的变量与函数</p></li><li><p>解析结果</p></li><li><p>销毁python3运行环境</p></li></ol><p>以下五步的所有程序都在<code>main.go</code>文件中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/datadog/go-python3"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 初始化python环境</span></span><br><span class="line">python3.Py_Initialize()</span><br><span class="line"><span class="keyword">if</span> !python3.Py_IsInitialized() &#123;</span><br><span class="line">fmt.Println(<span class="string">"Error initializing the python interpreter"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 2. 设置本地python import 的路径</span></span><br><span class="line">p := <span class="string">"/Users/xwj/opt/anaconda3/envs/fs_py37/lib/python3.7/site-packages"</span></span><br><span class="line">InsertBeforeSysPath(p)</span><br><span class="line"><span class="comment">// 3. 导入hello模块</span></span><br><span class="line">hello := ImportModule(<span class="string">"./hello"</span>, <span class="string">"hello"</span>)</span><br><span class="line"><span class="comment">// pyObject =&gt; string 解析结果</span></span><br><span class="line">helloRepr, err := pythonRepr(hello)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"[MODULE] repr(hello) = %s\n"</span>, helloRepr)</span><br><span class="line"><span class="comment">// 4. 获取变量</span></span><br><span class="line">a := hello.GetAttrString(<span class="string">"a"</span>)</span><br><span class="line">aString, err := pythonRepr(a)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"[VARS] a = %#v\n"</span>, aString)</span><br><span class="line"><span class="comment">// 5. 获取函数方法</span></span><br><span class="line">SayHello := hello.GetAttrString(<span class="string">"SayHello"</span>)</span><br><span class="line"><span class="comment">// 设置调用的参数（一个元组）</span></span><br><span class="line">args := python3.PyTuple_New(<span class="number">1</span>)<span class="comment">// 创建存储空间</span></span><br><span class="line">python3.PyTuple_SetItem(args, <span class="number">0</span>, python3.PyUnicode_FromString(<span class="string">"xwj"</span>))<span class="comment">// 设置值</span></span><br><span class="line">res := SayHello.Call(args, python3.Py_None)<span class="comment">// 调用</span></span><br><span class="line">fmt.Printf(<span class="string">"[FUNC] res = %s\n"</span>, python3.PyUnicode_AsUTF8(res))</span><br><span class="line"><span class="comment">// 6. 调用第三方库sklearn</span></span><br><span class="line">sklearn := hello.GetAttrString(<span class="string">"sklearn"</span>)</span><br><span class="line">skVersion := sklearn.GetAttrString(<span class="string">"__version__"</span>)</span><br><span class="line">sklearnRepr, err := pythonRepr(sklearn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">skVersionRepr, err := pythonRepr(skVersion)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"[IMPORT] sklearn = %s\n"</span>, sklearnRepr)</span><br><span class="line">fmt.Printf(<span class="string">"[IMPORT] sklearn version =  %s\n"</span>, skVersionRepr)</span><br><span class="line"><span class="comment">//// 7. 结束环境</span></span><br><span class="line">python3.Py_Finalize()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InsertBeforeSysPath</span></span><br><span class="line"><span class="comment">// @Description: 添加site-packages路径即包的查找路径</span></span><br><span class="line"><span class="comment">// @param p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertBeforeSysPath</span><span class="params">(p <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">sysModule := python3.PyImport_ImportModule(<span class="string">"sys"</span>)</span><br><span class="line">path := sysModule.GetAttrString(<span class="string">"path"</span>)</span><br><span class="line">python3.PyList_Append(path, python3.PyUnicode_FromString(p))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImportModule</span></span><br><span class="line"><span class="comment">// @Description: 倒入一个包</span></span><br><span class="line"><span class="comment">// @param dir</span></span><br><span class="line"><span class="comment">// @param name</span></span><br><span class="line"><span class="comment">// @return *python3.PyObject</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ImportModule</span><span class="params">(dir, name <span class="keyword">string</span>)</span> *<span class="title">python3</span>.<span class="title">PyObject</span></span> &#123;</span><br><span class="line">sysModule := python3.PyImport_ImportModule(<span class="string">"sys"</span>) <span class="comment">// import sys</span></span><br><span class="line">path := sysModule.GetAttrString(<span class="string">"path"</span>)            <span class="comment">// path = sys.path</span></span><br><span class="line">python3.PyList_Insert(path, <span class="number">0</span>, python3.PyUnicode_FromString(dir)) <span class="comment">// path.insert(0, dir)</span></span><br><span class="line"><span class="keyword">return</span> python3.PyImport_ImportModule(name)            <span class="comment">// return __import__(name)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pythonRepr</span></span><br><span class="line"><span class="comment">// @Description: PyObject转换为string</span></span><br><span class="line"><span class="comment">// @param o</span></span><br><span class="line"><span class="comment">// @return string</span></span><br><span class="line"><span class="comment">// @return error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pythonRepr</span><span class="params">(o *python3.PyObject)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> o == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"object is nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line">s := o.Repr()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">python3.PyErr_Clear()</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"failed to call Repr object method"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> s.DecRef()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> python3.PyUnicode_AsUTF8(s), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PrintList</span></span><br><span class="line"><span class="comment">// @Description: 输出一个List</span></span><br><span class="line"><span class="comment">// @param list</span></span><br><span class="line"><span class="comment">// @return error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintList</span><span class="params">(list *python3.PyObject)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> exc := python3.PyErr_Occurred(); list == <span class="literal">nil</span> &amp;&amp; exc != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"Fail to create python list object"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> list.DecRef()</span><br><span class="line">repr, err := pythonRepr(list)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"fail to get representation of object list"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"python list: %s\n"</span>, repr)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成可执行文件<code>test</code>并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gox86 build ./</span><br><span class="line">./test</span><br></pre></td></tr></table></figure><p>运行时报错：<code>dyld: Library not loaded: @rpath/libpython3.7m.dylib</code></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/UFgcZm.png" alt="UFgcZm"></p><p>原因：</p><p>该运行文件没有链接到需要匹配的python lib库</p><p>解决：</p><p>首先查看该文件的依赖文件：</p><p><code>otool -L /Users/xwj/projects/blockchain_projects/FedSharing/fed_sharing/mainchain/miner/test/./test</code></p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/mYYj86.png" alt="mYYj86"></p><p>可以看到有两个依赖，第一个无法加载，可能就是路径有问题</p><p>在此之前，我们可以简单了解一下<code>@executable_path、@loader_path、@rpath</code>三者都是什么意思：</p><ul><li>@executable_path：就是可执行程序的路径</li><li>@loader_path：可以通过这个path来设置动态库的install path name</li><li>@rpath：它是run path的缩写。本质上它不是一个明确的path，甚至可以说它不是一个path。它只是一个变量，或者叫<strong>占位符</strong>。这个变量通过XCode中的run path选项设置值，或者通过<code>install_name_tool</code>的<code>-add_rpath</code>设置值。设置好run path之后，所有的@rpath都会被替换掉</li></ul><p>我们并没有设置@rpath，所以导致失败。</p><p>所以在这里我们给其设置一个@rpath即之前本地conda创建的库，这样就可以链接上了。</p><p>找到库的路径，我的是<code>/Users/xwj/opt/anaconda3/envs/fs_py37/lib/libpython3.7m.dylib</code> (就是在你创建的环境名下的lib中)</p><p>然后对这个可执行文件<code>test</code>运行以下命令添加：</p><p><code>install_name_tool -add_rpath /Users/xwj/opt/anaconda3/envs/fs_py37/lib ./test</code></p><blockquote><p><font color='#39b54a'>如果你的可执行程序希望在多个机器上都适配，那么可以添加一个链接，把lib放到项目相对路径下，使用@executable_path指向这个相对路径</font></p></blockquote><p>再次运行即可</p><p>输出如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211006215622130.png" alt="image-20211006215622130"></p><h2 id="2-2-调用import的第三方库包"><a href="#2-2-调用import的第三方库包" class="headerlink" title="2.2 调用import的第三方库包"></a>2.2 调用import的第三方库包</h2><p>这里以<code>sklearn</code>为例</p><p>在hello.py中添加<code>import sklearn</code></p><p>在conda环境下下载：<code>conda install scikit-learn -y</code></p><p>如果使用IDE记得将IDE中python环境设置与conda activate的环境一致</p><p>在<code>main.go</code>中添加:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 6. 调用第三方库sklearn</span></span><br><span class="line">sklearn := hello.GetAttrString(<span class="string">"sklearn"</span>)</span><br><span class="line">skVersion := sklearn.GetAttrString(<span class="string">"__version__"</span>)</span><br><span class="line">sklearnRepr, err := pythonRepr(sklearn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">skVersionRepr, err := pythonRepr(skVersion)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"[IMPORT] sklearn = %s\n"</span>, sklearnRepr)</span><br><span class="line">fmt.Printf(<span class="string">"[IMPORT] sklearn version =  %s\n"</span>, skVersionRepr)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211006230529317.png" alt="image-20211006230529317"></p><p>基本的使用可以了之后就可以自由的使用go去调用python函数了，还有更多的功能（例如设置python变量的值等）都可以在<a href="https://docs.python.org/3.7/c-api/index.html查看！" target="_blank" rel="noopener">https://docs.python.org/3.7/c-api/index.html查看！</a></p><h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><p>虽然go和python都是自动管理内存的，但是当我们使用<code>PyObject</code>的时候我们需要手动提示Python runtime该<code>PyObject</code>是否还需要，否则就可能发生内存的泄漏。</p><p>每个<code>PyObject</code>都有一个引用计数，如果它降为0,Python的垃圾收集器知道它可以释放内存。</p><p>当我们不再需要一个对象时，有时我们需要减少<code>ref count</code>，有时我们需要增加它，以确保内存不会被过快释放。</p><p>每一个<code>PyObject</code>都有两个函数:</p><ul><li><code>.DecRef()</code>: 减少引用计数</li><li><code>.IncRef()</code>: 增加引用计数</li></ul><p>当我们调用Python C API函数时，输入和返回的<code>PyObjects</code>会发生以下三种已定义的情况:</p><ol><li><p>Return value: “New” reference</p><p>大多数在当我们创建一个新的Obecjt的时候(i.e. <code>PyList_new</code>)</p><p>一旦你不再需要<code>PyObject</code>，你可以<strong>减少</strong>引用计数<code>.DecRef()</code>，或者把它交给需要的人(例如，另一个使用它的函数，或者把它作为返回值传递给调用者，然后减值)。否则就会出现内存泄漏。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pObject := python3.PyUnicode_FromString(p)</span><br><span class="line"><span class="keyword">defer</span> pObject.DecRef()</span><br></pre></td></tr></table></figure></li><li><p>The function “steals” a reference to an item</p><p>大多数在函数设置set items的时候，例如<code>PyList_setItem</code>, 这时候我们不需要做任何事</p></li><li><p>Return value: “Borrowed” reference</p><p>两个指针指向同一个内存空间</p><p>大多数函数get items的时候，例如<code>PyList_GetItem</code></p><p>如果你想继续处理这个对象/指针，就<strong>增加</strong>引用计数(并注意以后它会以某种方式减少)。</p></li></ol><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pylist := python3.PyList_New(<span class="built_in">len</span>(data)) <span class="comment">//retval: New reference, gets stolen later</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">  item := python3.PyFloat_FromDouble(data[i]) <span class="comment">//ret val: New reference, gets stolen later</span></span><br><span class="line">  ret := python3.PyList_SetItem(pylist, i, item)</span><br><span class="line">  <span class="keyword">if</span> ret != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> python3.PyErr_Occurred() != <span class="literal">nil</span> &#123;</span><br><span class="line">      python3.PyErr_Print()</span><br><span class="line">    &#125;</span><br><span class="line">    item.DecRef()</span><br><span class="line">    pylist.DecRef()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"error setting list item"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们心创建一个<code>PyObject</code>时因为后续还要使用(<code>stolen</code>加入到List中)，所以我们先不<code>.DecRef()</code>，当<code>pylist.DecRef()</code>的时候会把其中所有的元素都一起<code>.DecRef()</code></p><p>现在我们需要修改之前的<code>main.go</code>代码，防止内存的泄漏：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/datadog/go-python3"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 初始化python环境</span></span><br><span class="line">python3.Py_Initialize()</span><br><span class="line"><span class="keyword">if</span> !python3.Py_IsInitialized() &#123;</span><br><span class="line">fmt.Println(<span class="string">"Error initializing the python interpreter"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 7. 结束环境(提前defer)</span></span><br><span class="line"><span class="keyword">defer</span> python3.Py_Finalize()</span><br><span class="line"><span class="comment">// 2. 设置python import 的路径</span></span><br><span class="line">p := <span class="string">"/Users/xwj/opt/anaconda3/envs/fs_py37/lib/python3.7/site-packages"</span></span><br><span class="line">InsertBeforeSysPath(p)</span><br><span class="line"><span class="comment">// 3. 导入hello模块</span></span><br><span class="line">hello := ImportModule(<span class="string">"./hello"</span>, <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">defer</span> hello.DecRef()</span><br><span class="line"><span class="comment">// pyObject =&gt; string 解析结果</span></span><br><span class="line">helloRepr, err := pythonRepr(hello)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"[MODULE] repr(hello) = %s\n"</span>, helloRepr)</span><br><span class="line"><span class="comment">// 4. 获取变量</span></span><br><span class="line">a := hello.GetAttrString(<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">defer</span> a.DecRef()</span><br><span class="line">aString, err := pythonRepr(a)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"[VARS] a = %#v\n"</span>, aString)</span><br><span class="line"><span class="comment">// 5. 获取函数方法</span></span><br><span class="line">SayHello := hello.GetAttrString(<span class="string">"SayHello"</span>)</span><br><span class="line"><span class="keyword">defer</span> SayHello.DecRef()</span><br><span class="line"><span class="comment">// 设置调用的参数（一个元组）</span></span><br><span class="line">args := python3.PyTuple_New(<span class="number">1</span>)<span class="comment">// 创建存储空间</span></span><br><span class="line"><span class="keyword">defer</span> args.DecRef()</span><br><span class="line">input := python3.PyUnicode_FromString(<span class="string">"xwj"</span>)<span class="comment">// input不需要DecRef，因为DecRef args的时候就一起DecRef了</span></span><br><span class="line">python3.PyTuple_SetItem(args, <span class="number">0</span>, input)<span class="comment">// 设置值</span></span><br><span class="line">res := SayHello.Call(args, python3.Py_None)<span class="comment">// 调用</span></span><br><span class="line">fmt.Printf(<span class="string">"[FUNC] res = %s\n"</span>, python3.PyUnicode_AsUTF8(res))</span><br><span class="line"><span class="comment">// 6. 调用第三方库sklearn</span></span><br><span class="line">sklearn := hello.GetAttrString(<span class="string">"sklearn"</span>)</span><br><span class="line"><span class="keyword">defer</span> sklearn.DecRef()</span><br><span class="line">skVersion := sklearn.GetAttrString(<span class="string">"__version__"</span>)</span><br><span class="line"><span class="keyword">defer</span> skVersion.DecRef()</span><br><span class="line">sklearnRepr, err := pythonRepr(sklearn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">skVersionRepr, err := pythonRepr(skVersion)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"[IMPORT] sklearn = %s\n"</span>, sklearnRepr)</span><br><span class="line">fmt.Printf(<span class="string">"[IMPORT] sklearn version =  %s\n"</span>, skVersionRepr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InsertBeforeSysPath</span></span><br><span class="line"><span class="comment">// @Description: 添加site-packages路径即包的查找路径</span></span><br><span class="line"><span class="comment">// @param p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertBeforeSysPath</span><span class="params">(p <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">sysModule := python3.PyImport_ImportModule(<span class="string">"sys"</span>)</span><br><span class="line">path := sysModule.GetAttrString(<span class="string">"path"</span>)</span><br><span class="line">pObject := python3.PyUnicode_FromString(p)</span><br><span class="line"><span class="keyword">defer</span> pObject.DecRef()</span><br><span class="line">python3.PyList_Append(path, pObject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImportModule</span></span><br><span class="line"><span class="comment">// @Description: 倒入一个包</span></span><br><span class="line"><span class="comment">// @param dir</span></span><br><span class="line"><span class="comment">// @param name</span></span><br><span class="line"><span class="comment">// @return *python3.PyObject</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ImportModule</span><span class="params">(dir, name <span class="keyword">string</span>)</span> *<span class="title">python3</span>.<span class="title">PyObject</span></span> &#123;</span><br><span class="line">sysModule := python3.PyImport_ImportModule(<span class="string">"sys"</span>) <span class="comment">// import sys</span></span><br><span class="line">path := sysModule.GetAttrString(<span class="string">"path"</span>)            <span class="comment">// path = sys.path</span></span><br><span class="line">dirObject := python3.PyUnicode_FromString(dir)</span><br><span class="line"><span class="keyword">defer</span> dirObject.DecRef()</span><br><span class="line">python3.PyList_Insert(path, <span class="number">0</span>, dirObject) <span class="comment">// path.insert(0, dir)</span></span><br><span class="line"><span class="keyword">return</span> python3.PyImport_ImportModule(name)            <span class="comment">// return __import__(name)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pythonRepr</span></span><br><span class="line"><span class="comment">// @Description: PyObject转换为string</span></span><br><span class="line"><span class="comment">// @param o</span></span><br><span class="line"><span class="comment">// @return string</span></span><br><span class="line"><span class="comment">// @return error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pythonRepr</span><span class="params">(o *python3.PyObject)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> o == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"object is nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line">s := o.Repr()<span class="comment">// 获取对象转换为可读</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">python3.PyErr_Clear()</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"failed to call Repr object method"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> s.DecRef()</span><br><span class="line"><span class="keyword">return</span> python3.PyUnicode_AsUTF8(s), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PrintList</span></span><br><span class="line"><span class="comment">// @Description: 输出一个List</span></span><br><span class="line"><span class="comment">// @param list</span></span><br><span class="line"><span class="comment">// @return error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintList</span><span class="params">(list *python3.PyObject)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> exc := python3.PyErr_Occurred(); list == <span class="literal">nil</span> &amp;&amp; exc != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"Fail to create python list object"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> list.DecRef()</span><br><span class="line">repr, err := pythonRepr(list)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"fail to get representation of object list"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"python list: %s\n"</span>, repr)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、Pylist迭代器"><a href="#四、Pylist迭代器" class="headerlink" title="四、Pylist迭代器"></a>四、Pylist迭代器</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pylist := python3.PyList_New(<span class="built_in">len</span>(data)) <span class="comment">//retval: New reference, gets stolen later</span></span><br><span class="line"><span class="keyword">defer</span> pylist.DecRef()</span><br><span class="line"><span class="comment">// 获取迭代器</span></span><br><span class="line">seq := pylist.GetIter() <span class="comment">//ret val: New reference</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">defer</span> seq.DecRef()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器有next函数，能够返回下一个item</span></span><br><span class="line">tNext := seq.GetAttrString(<span class="string">"__next__"</span>) <span class="comment">//ret val: new ref</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">defer</span> tNext.DecRef()</span><br><span class="line"></span><br><span class="line">pylistLen := pylist.Length()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= pylistLen; i++ &#123;</span><br><span class="line">  item := tNext.CallObject(<span class="literal">nil</span>) <span class="comment">//ret val: new ref</span></span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">if</span> item != <span class="literal">nil</span> &#123;</span><br><span class="line">    item.DecRef()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、多个goroutine调用python"><a href="#五、多个goroutine调用python" class="headerlink" title="五、多个goroutine调用python"></a>五、多个goroutine调用python</h1><p>要点： <strong>保证python在一段时间中只给一个线程调用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># foo.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_odds</span><span class="params">(limit=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Print odds numbers &lt; limit</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(limit):</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span>:</span><br><span class="line">            sys.stderr.write(<span class="string">"&#123;&#125;\n"</span>.format(i))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_even</span><span class="params">(limit=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Print even numbers &lt; limit</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(limit):</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            sys.stderr.write(<span class="string">"&#123;&#125;\n"</span>.format(i))</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We’ll try to print odd and even numbers concurrently from Go, using two different goroutines (thus involving threads):</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/sbinet/go-python"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// PyEval_InitThreads() 创建全局解释器GIL并且会锁定他</span></span><br><span class="line">    python.Initialize()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fooModule := python.PyImport_ImportModule(<span class="string">"foo"</span>)</span><br><span class="line">    odds := fooModule.GetAttrString(<span class="string">"print_odds"</span>)</span><br><span class="line">    even := fooModule.GetAttrString(<span class="string">"print_even"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前锁定的状态，然后释放GIL锁</span></span><br><span class="line">    state := python.PyEval_SaveThread()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 获取当前的GIL并锁定</span></span><br><span class="line">        _gstate := python.PyGILState_Ensure()</span><br><span class="line">        odds.Call(python.PyTuple_New(<span class="number">0</span>), python.PyDict_New())</span><br><span class="line">      <span class="comment">// 释放当前状态</span></span><br><span class="line">        python.PyGILState_Release(_gstate)</span><br><span class="line"></span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 获取当前的GIL并锁定</span></span><br><span class="line">        _gstate := python.PyGILState_Ensure()</span><br><span class="line">        even.Call(python.PyTuple_New(<span class="number">0</span>), python.PyDict_New())</span><br><span class="line">      <span class="comment">// 释放当前状态</span></span><br><span class="line">        python.PyGILState_Release(_gstate)</span><br><span class="line"></span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当我们不在需要GIL的时候，在关闭python环境之前将状态重新存储并锁定GIL，然后关闭</span></span><br><span class="line">    python.PyEval_RestoreThread(state)</span><br><span class="line">    python.Finalize()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总共就是三个步骤：</p><ol><li>Save the state and lock the GIL.</li><li>Do Python.</li><li>Restore the state and unlock the GIL.</li></ol><h1 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h1><h2 id="6-1-多次调用内存消耗"><a href="#6-1-多次调用内存消耗" class="headerlink" title="6.1 多次调用内存消耗"></a>6.1 多次调用内存消耗</h2><p>循环调用一个go-python函数(i.e.<code>demo</code>)内存会上升一段然后再保持平稳，理论上说没有内存泄露应该是一条直线</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  demo(oModule)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/rwZcyk.png" alt="rwZcyk"></p><p>出现这样的原因是go的自动内存回收机制而不是出现了内存泄漏</p><h2 id="6-2-重复导包"><a href="#6-2-重复导包" class="headerlink" title="6.2 重复导包"></a>6.2 重复导包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python3.Py_Initialize()</span><br><span class="line">python3.PyRun_SimpleString(<span class="string">"import numpy"</span>)</span><br><span class="line">python3.Py_Finalize()</span><br><span class="line">python3.Py_Initialize()</span><br><span class="line">python3.PyRun_SimpleString(<span class="string">"import numpy"</span>)</span><br><span class="line"><span class="comment">// segfault happening here</span></span><br></pre></td></tr></table></figure><p>有一些python拓展包（i.e. <code>numpy</code>）如果像上面这样重复导入会报错</p><h2 id="6-3-支持的Python"><a href="#6-3-支持的Python" class="headerlink" title="6.3 支持的Python"></a>6.3 支持的Python</h2><p>在删除了<code>PyEval_ReInitThreads</code>函数的绑定后，在Win、Mac、Linux上成功地在Python 3.8上运行了go-python3，该函数已从Python 3.8开始的Python C API中删除。我还没有用Python 3.9进行测试。</p><p>所以，结论是只当前支持python 3.7</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/150253406&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/150253406&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/skyztttt/article/details/8115086&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/skyztttt/article/details/8115086&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://poweruser.blog/embedding-python-in-go-338c0399f3d5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://poweruser.blog/embedding-python-in-go-338c0399f3d5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包地址：&lt;/p&gt;
&lt;p&gt;python2：&lt;a href=&quot;https://github.com/sbinet/go-python&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sbinet/go-python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;python3：&lt;a href=&quot;https://github.com/DataDog/go-python3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/DataDog/go-python3&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Ethermint-2-tharsis/ethermint</title>
    <link href="https://xwjahahahaha.github.io/2021/10/04/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Cosmos/Ethermint/Ethermint-2-tharsisethermint/"/>
    <id>https://xwjahahahaha.github.io/2021/10/04/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Cosmos/Ethermint/Ethermint-2-tharsisethermint/</id>
    <published>2021-10-04T07:51:02.000Z</published>
    <updated>2021-10-18T14:53:48.591Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>记录使用tharsis/ethermint的一些操作记录与错误总结</strong></p><p><strong>注意:</strong>目前ethermint转移到了新的项目地址：<a href="https://github.com/tharsis/ethermint.git" target="_blank" rel="noopener">https://github.com/tharsis/ethermint.git</a></p><p>老的项目地址是：<a href="https://github.com/cosmos/ethermint.git，官网文档地址：https://docs.ethermint.zone" target="_blank" rel="noopener">https://github.com/cosmos/ethermint.git，官网文档地址：https://docs.ethermint.zone</a></p><p>需要注意的是<strong>官网教程对应老版本（cosmos）的ethermint</strong>, 会有所冲突。</p><p><strong>本文使用的是新版本的ethermint，另一篇是老版本的ethermint</strong>，可以看这篇 <a href="https://blog.csdn.net/weixin_43988498/article/details/120613591" target="_blank" rel="noopener">Ethermint-1-cosmos/ethermint</a></p><p>建议先按官网教程熟悉老版本！</p></blockquote><a id="more"></a><h1 id="一、tharsis-ethermint的一些改动"><a href="#一、tharsis-ethermint的一些改动" class="headerlink" title="一、tharsis/ethermint的一些改动"></a>一、tharsis/ethermint的一些改动</h1><ol><li><code>ethermintcli</code>与<code>ethermintd</code>两个命令行程序在新版本合并为了一个命令行<code>ethermintd</code>,所以之前使用的命令都在其中使用。</li><li><code>init.sh</code>程序自动会启动rest-rpc服务，不要额外启动jrpc了，默认的jrpc端口是9000</li><li>新的节点连接时会快速同步区块高度</li><li>新的日志输出样式</li></ol><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/4z3vWU-20211005142705367.png" alt="4z3vWU"></p><h1 id="二、遇到的问题与Bug"><a href="#二、遇到的问题与Bug" class="headerlink" title="二、遇到的问题与Bug"></a>二、遇到的问题与Bug</h1><h2 id="2-1-Remix上无法部署合约"><a href="#2-1-Remix上无法部署合约" class="headerlink" title="2.1 Remix上无法部署合约"></a>2.1 Remix上无法部署合约</h2><p>问题描述：</p><p><a href="https://github.com/tharsis/ethermint/issues/79" target="_blank" rel="noopener">https://github.com/tharsis/ethermint/issues/79</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERR failed to broadcast tx error="couldn't retrieve sender address ('') from the ethereum transaction\n --- at github.com/tharsis/ethermint/app/ante/eth.go:82 (EthSigVerificationDecorator.AnteHandle) ---\nCaused by: invalid chain id for signer: tx intended signer does not match the given signer" client=json-rpc t=2021-10-05T13:17:16+0800 lvl=warn msg="Served eth_sendRawTransaction" conn=192.168.31.214:59126 reqid=9136769938060 t=3.430958ms err="couldn't retrieve sender address ('') from the ethereum transaction\n --- at github.com/tharsis/ethermint/app/ante/eth.go:82 (EthSigVerificationDecorator.AnteHandle) ---\nCaused by: invalid chain id for signer: tx intended signer does not match the given signer"</span><br></pre></td></tr></table></figure><p>原因：MetaMask上的设置chain ID与启动的rpc不匹配，导致签名失败。</p><p>解决：修改MetaMask上的设置与自己设置的chain ID匹配</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211005142923438.png" alt="image-20211005142923438" style="zoom:67%;" /><h2 id="2-2-mykey-info-key-not-found"><a href="#2-2-mykey-info-key-not-found" class="headerlink" title="2.2 mykey.info: key not found"></a>2.2 mykey.info: key not found</h2><p>问题描述：</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211005150526046.png" alt="image-20211005150526046"></p><p>原因与解决：</p><p>在使用<code>ethermintd keys</code>命令的时候如果添加账户使用的是<code>--keyring-backend=test</code>, 那么操作<code>unsafe-export-eth-key</code>也需要加上这个flag</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20211005150551486.png" alt="image-20211005150551486"></p><h2 id="2-3-生成交易时MetaMask报错invalid-nonce"><a href="#2-3-生成交易时MetaMask报错invalid-nonce" class="headerlink" title="2.3 生成交易时MetaMask报错invalid nonce"></a>2.3 生成交易时MetaMask报错invalid nonce</h2><p>问题描述：</p><p><a href="https://github.com/tharsis/ethermint/issues/317" target="_blank" rel="noopener">https://github.com/tharsis/ethermint/issues/317</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">creation of FSCoin errored: Error: [ethjs-query] while formatting outputs from RPC '&#123;"value":&#123;"code":-32603,"data":&#123;"code":-32000,"message":" --- at github.com/tharsis/ethermint/app/ante/eth.go:218 (EthNonceVerificationDecorator.AnteHandle) ---\nCaused by: invalid nonce; got 2, expected 1: invalid sequence"&#125;&#125;&#125;'</span><br></pre></td></tr></table></figure><h2 id="2-4-生成交易时MetaMask报错Key-not-found"><a href="#2-4-生成交易时MetaMask报错Key-not-found" class="headerlink" title="2.4 生成交易时MetaMask报错Key not found"></a>2.4 生成交易时MetaMask报错Key not found</h2><p>问题描述:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">creation of FSCoin errored: Error: [ethjs-query] while formatting outputs from RPC '&#123;"value":&#123;"code":-32603,"data":&#123;"code":-32000,"message":"rpc error: code = NotFound desc = rpc error: code = NotFound desc = account ethm10y032nunen0z6eu0msmleqk98ypjk5efdrxw9c not found: key not found"&#125;&#125;&#125;'</span><br></pre></td></tr></table></figure><p>当添加账户使用<code>--recover</code>时，在MetaMask上发起交易会找不到当前账户，但是如果是新倒入的账户（私钥）而不是<code>–recover</code>，则MetaMask可以正常使用</p><p>原因：未知，可能是MetaMask的问题</p><p>解决：不使用<code>–recover</code>，而是在第一次添加账户后，每次直接启动即可，不用<code>init.sh</code>：</p><p><code>ethermintd start --pruning=nothing —-trace --log_level info --minimum-gas-prices=0.0001aphoton --json-rpc.api eth,txpool,personal,net,debug,web3,miner</code></p><h1 id="三、自定义修改"><a href="#三、自定义修改" class="headerlink" title="三、自定义修改"></a>三、自定义修改</h1><h2 id="3-1-修改ethermint的代币aphoton为自定义代币"><a href="#3-1-修改ethermint的代币aphoton为自定义代币" class="headerlink" title="3.1 修改ethermint的代币aphoton为自定义代币"></a>3.1 修改ethermint的代币aphoton为自定义代币</h2><p>在<code>init.sh</code>中修改<code>aphoton</code>为自定义的名称</p><p>Vim: <code>%s/aphoton/[自定义名称]/g</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Change parameter token denominations to fscoin</span></span><br><span class="line">cat $HOME/.ethermintd/config/genesis.json | jq '.app_state["staking"]["params"]["bond_denom"]="aphoton"' &gt; $HOME/.ethermintd/config/tmp_genesis.json &amp;&amp; mv $HOME/.ethermintd/config/tmp_genesis.json $HOME/.ethermintd/config/genesis.json</span><br><span class="line">cat $HOME/.ethermintd/config/genesis.json | jq '.app_state["crisis"]["constant_fee"]["denom"]="aphoton"' &gt; $HOME/.ethermintd/config/tmp_genesis.json &amp;&amp; mv $HOME/.ethermintd/config/tmp_genesis.json $HOME/.ethermintd/config/genesis.json</span><br><span class="line">cat $HOME/.ethermintd/config/genesis.json | jq '.app_state["gov"]["deposit_params"]["min_deposit"][0]["denom"]="aphoton"' &gt; $HOME/.ethermintd/config/tmp_genesis.json &amp;&amp; mv $HOME/.ethermintd/config/tmp_genesis.json $HOME/.ethermintd/config/genesis.json</span><br><span class="line">cat $HOME/.ethermintd/config/genesis.json | jq '.app_state["mint"]["params"]["mint_denom"]="aphoton"' &gt; $HOME/.ethermintd/config/tmp_genesis.json &amp;&amp; mv $HOME/.ethermintd/config/tmp_genesis.json $HOME/.ethermintd/config/genesis.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加这一行</span></span><br><span class="line">cat $HOME/.ethermintd/config/genesis.json | jq '.app_state["evm"]["params"]["evm_denom"]="aphoton"' &gt; $HOME/.ethermintd/config/tmp_genesis.json &amp;&amp; mv $HOME/.ethermintd/config/tmp_genesis.json $HOME/.ethermintd/config/genesis.json</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;记录使用tharsis/ethermint的一些操作记录与错误总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;目前ethermint转移到了新的项目地址：&lt;a href=&quot;https://github.com/tharsis/ethermint.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/tharsis/ethermint.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;老的项目地址是：&lt;a href=&quot;https://github.com/cosmos/ethermint.git，官网文档地址：https://docs.ethermint.zone&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/cosmos/ethermint.git，官网文档地址：https://docs.ethermint.zone&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是&lt;strong&gt;官网教程对应老版本（cosmos）的ethermint&lt;/strong&gt;, 会有所冲突。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文使用的是新版本的ethermint，另一篇是老版本的ethermint&lt;/strong&gt;，可以看这篇 &lt;a href=&quot;https://blog.csdn.net/weixin_43988498/article/details/120613591&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ethermint-1-cosmos/ethermint&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;建议先按官网教程熟悉老版本！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0230</title>
    <link href="https://xwjahahahaha.github.io/2021/10/02/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0230/"/>
    <id>https://xwjahahahaha.github.io/2021/10/02/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-10/%E6%97%A5%E8%AE%B0-0230/</id>
    <published>2021-10-02T00:55:11.000Z</published>
    <updated>2021-10-02T03:53:26.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划:"></a>学习规划:</h2><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul><li><input checked="" disabled="" type="checkbox"> cosmos项目架构熟悉,<del>做</del></li><li><input checked="" disabled="" type="checkbox"> <del>完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 科技部编程比赛项目实现(使用cosmos)</li><li><input checked="" disabled="" type="checkbox"> Go公链实现项目(simple_bitcoin)</li><li><input checked="" disabled="" type="checkbox"> 专利一篇(金链积分)</li><li><input checked="" disabled="" type="checkbox"> 华为区块链比赛</li><li><input checked="" disabled="" type="checkbox"> 第一篇论文初稿(blockchain + FL)  </li></ul><a id="more"></a><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul><li><input disabled="" type="checkbox"> 论文实验(编码实现)</li><li><input disabled="" type="checkbox"> 第一篇投稿</li><li><input disabled="" type="checkbox"> 项目一：FedSharing（Cosmos、p2p）</li></ul><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul><li><input disabled="" type="checkbox"> go-vue-admin项目: Go网络编程(base、Echo、Gin) </li><li><input disabled="" type="checkbox"> ORM(Gorm)、数据库(mysql, PostgreSQL)、数据关系表设计</li><li><input disabled="" type="checkbox"> Go设计模式  </li><li><input disabled="" type="checkbox"> Docker </li><li><input disabled="" type="checkbox"> 容器编程k8s</li><li><input disabled="" type="checkbox"> 缓存、日志</li><li><input disabled="" type="checkbox"> 微服务(消息队列、任务调度、rpc)</li></ul><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul><li><input disabled="" type="checkbox"> 项目二：简易Baas平台（Fabric、k8s、go-vue-admin）</li><li><input disabled="" type="checkbox"> 面经</li><li><input disabled="" type="checkbox"> 大量刷题</li></ul><h3 id="算法刷题"><a href="#算法刷题" class="headerlink" title="算法刷题"></a>算法刷题</h3><p>剑指offer刷完（47）+ 代码随想录专题（180）+ 老题目（120）$\approx$ 350（230新题 + 120老题）</p><p>11月截止，工作日：60天  =&gt; 一天4道新题 + 2道老题</p><ul><li><input disabled="" type="checkbox"> 9月底： 剑指offer结束</li><li><input disabled="" type="checkbox"> 10月底：80道新题 + 50道老题</li><li><input disabled="" type="checkbox"> 11月底：100道新题 + 70道老题</li></ul><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 英语50词</li><li><input disabled="" type="checkbox"> Leetcode刷题：</li><li><input checked="" disabled="" type="checkbox"> FeSharing侧链80%完成</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;学习规划&quot;&gt;&lt;a href=&quot;#学习规划&quot; class=&quot;headerlink&quot; title=&quot;学习规划:&quot;&gt;&lt;/a&gt;学习规划:&lt;/h2&gt;&lt;h3 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; cosmos项目架构熟悉,&lt;del&gt;做&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;del&gt;完全部的案例&lt;/del&gt;,&lt;del&gt;并且熟悉SDK&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 科技部编程比赛项目实现(使用cosmos)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Go公链实现项目(simple_bitcoin)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 专利一篇(金链积分)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 华为区块链比赛&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 第一篇论文初稿(blockchain + FL)  &lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>P2P网络编程-3-案例实践：PubSub</title>
    <link href="https://xwjahahahaha.github.io/2021/09/26/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/P2P/P2P%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-3-%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5%EF%BC%9APubSub/"/>
    <id>https://xwjahahahaha.github.io/2021/09/26/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/P2P/P2P%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-3-%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5%EF%BC%9APubSub/</id>
    <published>2021-09-26T05:59:04.000Z</published>
    <updated>2021-09-26T06:51:47.629Z</updated>
    
    <content type="html"><![CDATA[<p>libp2p网络通信中还有一种方式就是PubSub模式，也称订阅发布的模式，官方给出了订阅发布模式的一个案例=&gt; 聊天室</p><p>在此学习记录一下</p><p>官方代码地址：<a href="https://github.com/libp2p/go-libp2p/tree/master/examples/pubsub" target="_blank" rel="noopener">https://github.com/libp2p/go-libp2p/tree/master/examples/pubsub</a></p><a id="more"></a><h1 id="一、效果演示"><a href="#一、效果演示" class="headerlink" title="一、效果演示"></a>一、效果演示</h1><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/chat-example.gif" alt="chat-example"></p><h1 id="二、代码理解"><a href="#二、代码理解" class="headerlink" title="二、代码理解"></a>二、代码理解</h1><h2 id="2-1-总体框架"><a href="#2-1-总体框架" class="headerlink" title="2.1 总体框架"></a>2.1 总体框架</h2><p>总的来说代码构成由这五个步骤：</p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20210926142032549.png" alt="image-20210926142032549" style="zoom:50%;" /><p>1~2两步较为简单不再赘述, 下面几点分点描述</p><h2 id="2-2-创建mDNS节点发现服务"><a href="#2-2-创建mDNS节点发现服务" class="headerlink" title="2.2 创建mDNS节点发现服务"></a>2.2 创建mDNS节点发现服务</h2><p>注意，使用mDNS作为节点发现需要保证所有的节点在同一个局域网即节点发现的范围在同一个局域网下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// discoveryNotifee gets notified when we find a new peer via mDNS discovery</span></span><br><span class="line"><span class="comment">// 节点发现的通告结构体，继承Notifee</span></span><br><span class="line"><span class="keyword">type</span> discoveryNotifee <span class="keyword">struct</span> &#123;</span><br><span class="line">h host.Host</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlePeerFound connects to peers discovered via mDNS. Once they're connected,</span></span><br><span class="line"><span class="comment">// the PubSub system will automatically start interacting with them if they also</span></span><br><span class="line"><span class="comment">// support PubSub.</span></span><br><span class="line"><span class="comment">// 继承函数，节点发现后的处理函数：自动链接节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *discoveryNotifee)</span> <span class="title">HandlePeerFound</span><span class="params">(pi peer.AddrInfo)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"discovered new peer %s\n"</span>, pi.ID.Pretty())</span><br><span class="line">err := n.h.Connect(context.Background(), pi)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"error connecting to peer %s: %s\n"</span>, pi.ID.Pretty(), err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setupDiscovery creates an mDNS discovery service and attaches it to the libp2p Host.</span></span><br><span class="line"><span class="comment">// This lets us automatically discover peers on the same LAN and connect to them.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupDiscovery</span><span class="params">(ctx context.Context, h host.Host)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// setup mDNS discovery to find local peers</span></span><br><span class="line">disc := mdns.NewMdnsService(h, DiscoveryServiceTag)</span><br><span class="line"></span><br><span class="line">n := discoveryNotifee&#123;h: h&#125;</span><br><span class="line">disc.RegisterNotifee(&amp;n)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-加入聊天房"><a href="#2-3-加入聊天房" class="headerlink" title="2.3 加入聊天房"></a>2.3 加入聊天房</h2><p>每个节点通过订阅房间的统一topic实现PubSub</p><h3 id="1-聊天房数据结构"><a href="#1-聊天房数据结构" class="headerlink" title="1.聊天房数据结构"></a>1.聊天房数据结构</h3><p>与一个topic一一对应，可以通过ChatRoom.Publish在topic中发布消息，并且接收所有的消息到Messages的channel中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChatRoom <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Messages is a channel of messages received from other peers in the chat room</span></span><br><span class="line">Messages <span class="keyword">chan</span> *ChatMessage</span><br><span class="line"></span><br><span class="line">ctx   context.Context</span><br><span class="line">ps    *pubsub.PubSub</span><br><span class="line">topic *pubsub.Topic</span><br><span class="line">sub   *pubsub.Subscription</span><br><span class="line"></span><br><span class="line">roomName <span class="keyword">string</span></span><br><span class="line">self     peer.ID</span><br><span class="line">nick     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChatMessage gets converted to/from JSON and sent in the body of pubsub messages.</span></span><br><span class="line"><span class="keyword">type</span> ChatMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">Message    <span class="keyword">string</span></span><br><span class="line">SenderID   <span class="keyword">string</span></span><br><span class="line">SenderNick <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cr *ChatRoom)</span> <span class="title">Publish</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">m := ChatMessage&#123;</span><br><span class="line">Message:    message,</span><br><span class="line">SenderID:   cr.self.Pretty(),</span><br><span class="line">SenderNick: cr.nick,</span><br><span class="line">&#125;</span><br><span class="line">msgBytes, err := json.Marshal(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cr.topic.Publish(cr.ctx, msgBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-加入聊天房逻辑"><a href="#2-加入聊天房逻辑" class="headerlink" title="2.加入聊天房逻辑"></a>2.加入聊天房逻辑</h3><img src="http://xwjpics.gumptlu.work/qinniu_uPic/image-20210926143906101.png" alt="image-20210926143906101" style="zoom:50%;" /><p>分为三步，成功后返回一个新的ChatRoom实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JoinChatRoom</span><span class="params">(ctx context.Context, ps *pubsub.PubSub, selfID peer.ID, nickname <span class="keyword">string</span>, roomName <span class="keyword">string</span>)</span> <span class="params">(*ChatRoom, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// join the pubsub topic</span></span><br><span class="line">topic, err := ps.Join(topicName(roomName))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and subscribe to it</span></span><br><span class="line">sub, err := topic.Subscribe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cr := &amp;ChatRoom&#123;</span><br><span class="line">ctx:      ctx,</span><br><span class="line">ps:       ps,</span><br><span class="line">topic:    topic,</span><br><span class="line">sub:      sub,</span><br><span class="line">self:     selfID,</span><br><span class="line">nick:     nickname,</span><br><span class="line">roomName: roomName,</span><br><span class="line">Messages: <span class="built_in">make</span>(<span class="keyword">chan</span> *ChatMessage, ChatRoomBufSize),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start reading messages from the subscription in a loop</span></span><br><span class="line"><span class="keyword">go</span> cr.readLoop()</span><br><span class="line"><span class="keyword">return</span> cr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布和订阅较为直观，下面是循环读取：</p><h3 id="3-循环读取消息内容"><a href="#3-循环读取消息内容" class="headerlink" title="3.循环读取消息内容"></a>3.循环读取消息内容</h3><p>循环读取内容，并将被容加入到消息channel中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readLoop pulls messages from the pubsub topic and pushes them onto the Messages channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cr *ChatRoom)</span> <span class="title">readLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// Next returns the next message in our subscription</span></span><br><span class="line"><span class="comment">// 找到下一个消息</span></span><br><span class="line">msg, err := cr.sub.Next(cr.ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(cr.Messages)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// only forward messages delivered by others</span></span><br><span class="line"><span class="comment">// 只接收别人的消息</span></span><br><span class="line"><span class="keyword">if</span> msg.ReceivedFrom == cr.self &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">cm := <span class="built_in">new</span>(ChatMessage)</span><br><span class="line">err = json.Unmarshal(msg.Data, cm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// send valid messages onto the Messages channel</span></span><br><span class="line"><span class="comment">// 把消息加入 Messages channel</span></span><br><span class="line">cr.Messages &lt;- cm</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-获取当前topic所有连接者"><a href="#4-获取当前topic所有连接者" class="headerlink" title="4.获取当前topic所有连接者"></a>4.获取当前topic所有连接者</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cr *ChatRoom)</span> <span class="title">ListPeers</span><span class="params">()</span> []<span class="title">peer</span>.<span class="title">ID</span></span> &#123;</span><br><span class="line">  <span class="comment">// ListPeers returns a list of peers we are connected to in the given topic.</span></span><br><span class="line"><span class="keyword">return</span> cr.ps.ListPeers(topicName(cr.roomName))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于UI部分不是重点，会使用即可</p><p>总体来说案例使用较为简单，可以快速上手！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;libp2p网络通信中还有一种方式就是PubSub模式，也称订阅发布的模式，官方给出了订阅发布模式的一个案例=&amp;gt; 聊天室&lt;/p&gt;
&lt;p&gt;在此学习记录一下&lt;/p&gt;
&lt;p&gt;官方代码地址：&lt;a href=&quot;https://github.com/libp2p/go-libp2p/tree/master/examples/pubsub&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/libp2p/go-libp2p/tree/master/examples/pubsub&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
