<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识与头发不可兼得</title>
  
  <subtitle>文杰的博客</subtitle>
  <link href="https://xwjahahahaha.github.io/atom.xml" rel="self"/>
  
  <link href="https://xwjahahahaha.github.io/"/>
  <updated>2021-04-09T01:44:15.358Z</updated>
  <id>https://xwjahahahaha.github.io/</id>
  
  <author>
    <name>DDDemons hide</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>200-岛屿数量</title>
    <link href="https://xwjahahahaha.github.io/2021/04/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%9B%BE/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>https://xwjahahahaha.github.io/2021/04/09/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E5%9B%BE/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</id>
    <published>2021-04-09T01:40:00.000Z</published>
    <updated>2021-04-09T01:44:15.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><p>难度中等</p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><a id="more"></a> <p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>深度优先、广度优先</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深度优先遍历</span></span><br><span class="line"><span class="comment">// 时间复杂度/空间复杂度(栈深度): O(M*N) 最坏全部为1 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="keyword">byte</span>)</span> <span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有节点,为1则开始Dfs</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span> &#123;</span><br><span class="line">                Dfs(grid, i, j)</span><br><span class="line">                count ++ </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用递归,隐性的维护一个栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dfs</span><span class="params">(grid [][]<span class="keyword">byte</span>, r, c <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取grid的大小,获取边界的大小</span></span><br><span class="line">    rowLength := <span class="built_in">len</span>(grid)</span><br><span class="line">    columLength := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 将当前位置节点置为0,代表已遍历</span></span><br><span class="line">    grid[r][c] = <span class="string">'0'</span></span><br><span class="line">    <span class="comment">// 递归深度遍历起点(dfs)</span></span><br><span class="line">    <span class="comment">// 上下左右递归</span></span><br><span class="line">    <span class="keyword">if</span> r<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">'1'</span> &#123;</span><br><span class="line">        Dfs(grid, r<span class="number">-1</span>, c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r+<span class="number">1</span>&lt;rowLength &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span> &#123;</span><br><span class="line">        Dfs(grid, r+<span class="number">1</span>, c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">'1'</span> &#123;</span><br><span class="line">        Dfs(grid, r, c<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c+<span class="number">1</span>&lt;columLength &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span> &#123;</span><br><span class="line">        Dfs(grid, r, c+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS广度优先遍历, 维护一个队列</span></span><br><span class="line"><span class="comment">// 时间复杂度O(MN), 空间复杂度O(min(M,N))</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="keyword">byte</span>)</span> <span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    queue := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    rowLength := <span class="built_in">len</span>(grid)</span><br><span class="line">    columLength := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;rowLength; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;columLength; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span> &#123;</span><br><span class="line">                count ++</span><br><span class="line">                <span class="comment">// 入队</span></span><br><span class="line">                loc := []<span class="keyword">int</span>&#123;i, j&#125;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, loc)</span><br><span class="line">                Bfs(grid, queue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bfs</span><span class="params">(grid [][]<span class="keyword">byte</span>, queue [][]<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    rowLength := <span class="built_in">len</span>(grid)</span><br><span class="line">    columLength := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         <span class="comment">// 出队</span></span><br><span class="line">        loc := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="comment">// 置为0</span></span><br><span class="line">        r, c := loc[<span class="number">0</span>], loc[<span class="number">1</span>]</span><br><span class="line">        grid[r][c] = <span class="string">'0'</span></span><br><span class="line">        <span class="comment">// 层次遍历, 上下左右</span></span><br><span class="line">        <span class="keyword">if</span> r<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">'1'</span> &#123;</span><br><span class="line">            <span class="comment">// 入队</span></span><br><span class="line">            queue = <span class="built_in">append</span>(queue, []<span class="keyword">int</span>&#123;r<span class="number">-1</span>, c&#125;)</span><br><span class="line">            grid[r<span class="number">-1</span>][c] = <span class="string">'0'</span>                  <span class="comment">// 确定此节点立即置为0, 不然外三层循环(主函数)又会重复</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r+<span class="number">1</span>&lt;rowLength &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span> &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, []<span class="keyword">int</span>&#123;r+<span class="number">1</span>, c&#125;)</span><br><span class="line">            grid[r+<span class="number">1</span>][c] = <span class="string">'0'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">'1'</span> &#123;</span><br><span class="line">           queue = <span class="built_in">append</span>(queue, []<span class="keyword">int</span>&#123;r, c<span class="number">-1</span>&#125;)</span><br><span class="line">           grid[r][c<span class="number">-1</span>] = <span class="string">'0'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c+<span class="number">1</span>&lt;columLength &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span> &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, []<span class="keyword">int</span>&#123;r, c+<span class="number">1</span>&#125;)</span><br><span class="line">            grid[r][c+<span class="number">1</span>] = <span class="string">'0'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;200-岛屿数量&quot;&gt;&lt;a href=&quot;#200-岛屿数量&quot; class=&quot;headerlink&quot; title=&quot;200. 岛屿数量&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;200. 岛屿数量&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给你一个由 &lt;code&gt;&amp;#39;1&amp;#39;&lt;/code&gt;（陆地）和 &lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt;（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;p&gt;岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。&lt;/p&gt;
&lt;p&gt;此外，你可以假设该网格的四条边均被水包围。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0155</title>
    <link href="https://xwjahahahaha.github.io/2021/04/09/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0155/"/>
    <id>https://xwjahahahaha.github.io/2021/04/09/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0155/</id>
    <published>2021-04-09T00:32:53.000Z</published>
    <updated>2021-04-09T01:46:48.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>每天</th><th>开发-云容器技术</th><th>项目与框架</th><th>科研-区块链(FL+BC)</th><th>预备事宜</th></tr></thead><tbody><tr><td>1.</td><td><strong>英语单词</strong></td><td>go基础</td><td>SimpleBitcoin</td><td>FL/分布式存储论文一周一篇细读</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>2.</td><td>语法课看完</td><td>go网络编程、Web框架</td><td>联邦学习框架</td><td>写专利</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>3.</td><td><font color='red'>六级</font></td><td>go数据库、ORM、go高级编程</td><td></td><td>机器学习课程</td><td>为<strong>7月/研二初暑期实习</strong>做准备</td></tr><tr><td>4.</td><td>Leetcode</td><td>go容器技术docker、k8s</td><td></td><td></td><td></td></tr><tr><td>5.</td><td></td><td>go微服务与任务调度</td><td></td><td></td><td></td></tr><tr><td>6.</td><td></td><td>看源码docker、k8s、Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr><tr><td>7.</td><td></td><td>Linux、C++</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文FL+BC</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、go设计模式、 确定研究主方向,第一篇论文初稿与老师讨论</li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm)</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 docker、k8s</li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 缓存、日志</li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-20 微服务(消息队列、任务调度、rpc)</li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 英语</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input disabled="" type="checkbox"> </li><li><input disabled="" type="checkbox"> </li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;每天&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;项目与框架&lt;/th&gt;
&lt;th&gt;科研-区块链(FL+BC)&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;go基础&lt;/td&gt;
&lt;td&gt;SimpleBitcoin&lt;/td&gt;
&lt;td&gt;FL/分布式存储论文一周一篇细读&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;go网络编程、Web框架&lt;/td&gt;
&lt;td&gt;联邦学习框架&lt;/td&gt;
&lt;td&gt;写专利&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;go数据库、ORM、go高级编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;机器学习课程&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月/研二初暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;Leetcode&lt;/td&gt;
&lt;td&gt;go容器技术docker、k8s&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;go微服务与任务调度&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;看源码docker、k8s、Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Linux、C++&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>智能合约开发-uniswap-1</title>
    <link href="https://xwjahahahaha.github.io/2021/04/08/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Ethereum/%E9%A1%B9%E7%9B%AE/uniswap/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91-uniswap-1/"/>
    <id>https://xwjahahahaha.github.io/2021/04/08/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E5%8C%BA%E5%9D%97%E9%93%BE/Ethereum/%E9%A1%B9%E7%9B%AE/uniswap/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91-uniswap-1/</id>
    <published>2021-04-08T12:11:51.000Z</published>
    <updated>2021-04-08T12:25:19.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基本知识"><a href="#一、基本知识" class="headerlink" title="一、基本知识"></a>一、基本知识</h1><h2 id="1-1-流动性挖矿"><a href="#1-1-流动性挖矿" class="headerlink" title="1.1 流动性挖矿"></a>1.1 流动性挖矿</h2><p>通过具有挖矿机制的 DeFi 产品，按要求存入或者借出指定的代币资产，为产品的资金池提供流动性而获取收益的过程。</p><p>将资产投资到该DeFI项目中,其还会根据你的贡献(金额大小、时间长短)返回给你其对应的token, 该项目也增强了流动性</p><p><font color='#39b54a'>(说白了,交易所看作银行,存钱给银行,银行还给你它的股份(token)而不是只有单纯的利息)</font></p><h2 id="1-2-去中心化交易所"><a href="#1-2-去中心化交易所" class="headerlink" title="1.2 去中心化交易所"></a>1.2 去中心化交易所</h2><h2 id="1-3-闪电贷"><a href="#1-3-闪电贷" class="headerlink" title="1.3 闪电贷"></a>1.3 闪电贷</h2><p>不需要抵押、不需要信用保证即可贷款</p><p>依靠区块链的出块间隔,在一个出块间隔内实现先使用金额,但是没有上链,在上链之前归还金额,否则交易就会回滚,这就是闪电贷的原理</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、基本知识&quot;&gt;&lt;a href=&quot;#一、基本知识&quot; class=&quot;headerlink&quot; title=&quot;一、基本知识&quot;&gt;&lt;/a&gt;一、基本知识&lt;/h1&gt;&lt;h2 id=&quot;1-1-流动性挖矿&quot;&gt;&lt;a href=&quot;#1-1-流动性挖矿&quot; class=&quot;headerlink&quot; title=&quot;1.1 流动性挖矿&quot;&gt;&lt;/a&gt;1.1 流动性挖矿&lt;/h2&gt;&lt;p&gt;通过具有挖矿机制的 DeFi 产品，按要求存入或者借出指定的代币资产，为产品的资金池提供流动性而获取收益的过程。&lt;/p&gt;
&lt;p&gt;将资产投资到该DeFI项目中,其还会根据你的贡献(金额大小、时间长短)返回给你其对应的token, 该项目也增强了流动性&lt;/p&gt;
&lt;p&gt;&lt;font color=&#39;#39b54a&#39;&gt;(说白了,交易所看作银行,存钱给银行,银行还给你它的股份(token)而不是只有单纯的利息)&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-2-去中心化交易所&quot;&gt;&lt;a href=&quot;#1-2-去中心化交易所&quot; class=&quot;headerlink&quot; title=&quot;1.2 去中心化交易所&quot;&gt;&lt;/a&gt;1.2 去中心化交易所&lt;/h2&gt;&lt;h2 id=&quot;1-3-闪电贷&quot;&gt;&lt;a href=&quot;#1-3-闪电贷&quot; class=&quot;headerlink&quot; title=&quot;1.3 闪电贷&quot;&gt;&lt;/a&gt;1.3 闪电贷&lt;/h2&gt;&lt;p&gt;不需要抵押、不需要信用保证即可贷款&lt;/p&gt;
&lt;p&gt;依靠区块链的出块间隔,在一个出块间隔内实现先使用金额,但是没有上链,在上链之前归还金额,否则交易就会回滚,这就是闪电贷的原理&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="solidaty" scheme="https://xwjahahahaha.github.io/categories/technical/solidaty/"/>
    
    
    <category term="solidaty" scheme="https://xwjahahahaha.github.io/tags/solidaty/"/>
    
  </entry>
  
  <entry>
    <title>日记_0154</title>
    <link href="https://xwjahahahaha.github.io/2021/04/08/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0154/"/>
    <id>https://xwjahahahaha.github.io/2021/04/08/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0154/</id>
    <published>2021-04-08T03:45:47.000Z</published>
    <updated>2021-04-08T15:14:11.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发-云容器技术</th><th>科研-区块链</th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>论文一周一篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> Advances_and_Open_Problems_in_Federated_Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文联邦学习</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、go设计模式、 确定研究主方向,第一篇论文初稿与老师讨论</li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm)</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 docker、k8s</li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 缓存、日志</li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-20 微服务(消息队列、任务调度、rpc)</li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 英语</li><li><input disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> go网络编程 =&gt; 表单(预防跨站输出)</li><li><input checked="" disabled="" type="checkbox"> 智能合约</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2><ul><li>认清想要什么,主次分明.</li><li>更加努力才,不用羡慕,你也可以</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;科研-区块链&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;论文一周一篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Advances_and_Open_Problems_in_Federated_Learning》</title>
    <link href="https://xwjahahahaha.github.io/2021/04/07/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E8%AE%BA%E6%96%87/%E3%80%8AAdvances-and-Open-Problems-in-Federated-Learning%E3%80%8B/"/>
    <id>https://xwjahahahaha.github.io/2021/04/07/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E8%AE%BA%E6%96%87/%E3%80%8AAdvances-and-Open-Problems-in-Federated-Learning%E3%80%8B/</id>
    <published>2021-04-07T09:14:30.000Z</published>
    <updated>2021-04-07T11:37:05.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基本信息"><a href="#一、基本信息" class="headerlink" title="一、基本信息"></a>一、基本信息</h1><p>该文章由来自麻省理工、斯坦福、加州大学、南洋理工、谷歌等25所国际知名高校(机构)的58位学者联合发表，文章源于2019年6月17日至18日在谷歌西雅图举办的联邦学习学习和分析研讨会，共105页，调研了438篇文献，介绍了最新的联邦学习进展，并提出大量开放型问题。</p><blockquote><p>中文翻译版本gitbook: <a href="https://xwzheng.gitbook.io/fl/" target="_blank" rel="noopener">https://xwzheng.gitbook.io/fl/</a></p><p>github地址: <a href="https://github.com/open-intelligence/federated-learning-chinese" target="_blank" rel="noopener">https://github.com/open-intelligence/federated-learning-chinese</a></p></blockquote><p><font color='#39b54a'>感谢翻译,阅读中文版本做了总体的思维导图,以及记录一下文中的细节</font></p><a id="more"></a><h1 id="二、总览"><a href="#二、总览" class="headerlink" title="二、总览"></a>二、总览</h1><h1 id="三、细节记录"><a href="#三、细节记录" class="headerlink" title="三、细节记录"></a>三、细节记录</h1><h2 id="3-1-基本概念-术语"><a href="#3-1-基本概念-术语" class="headerlink" title="3.1 基本概念/术语"></a>3.1 基本概念/术语</h2><h3 id="1-IID独立同分布"><a href="#1-IID独立同分布" class="headerlink" title="1.IID独立同分布"></a>1.IID独立同分布</h3><blockquote><p>来源:<a href="https://blog.csdn.net/weixin_41847115/article/details/82956256" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41847115/article/details/82956256</a></p></blockquote><ul><li><p>独立同分布independent and identically distributed (i.i.d.)</p><p>   在概率统计理论中，如果变量序列或者其他随机变量有相同的概率分布，并且互相独立，那么这些随机变量是独立同分布。</p><p>   在西瓜书中解释是：输入空间中的所有样本服从一个隐含未知的分布，训练数据所有样本都是独立地从这个分布上采样而得。</p></li><li><p>简单解释:独立、同分布、独立同分布</p><ul><li><p>独立：<strong>每次抽样之间没有关系，不会相互影响</strong></p><p>举例：给一个骰子，每次抛骰子抛到几就是几，这是独立；如果我要抛骰子两次之和大于8，那么第一次和第二次抛就不独立，因为第二次抛的结果和第一次相关。</p></li><li><p>同分布：<strong>每次抽样，样本服从同一个分布</strong></p><p>举例：给一个骰子，每次抛骰子得到任意点数的概率都是六分之一，这个就是同分布</p></li><li><p>独立同分布：<strong>i,i,d，每次抽样之间独立而且同分布</strong></p></li></ul></li><li><p>机器学习领域的重要假设</p><p>IID独立同分布。即假设训练数据和测试数据是满足相同分布的，它是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障(<strong>让机器学习满足概率论上的一些基础假设</strong>)。</p></li><li><p>目前</p><p>机器学习并不总要求独立同分布，在不少问题中要求样本数据采样自同一个分布是因为希望用训练数据集得到的模型可以合理的用于测试数据集，使用独立同分布假设能够解释得通。</p><p>目前一些机器学习内容已经不再囿于独立同分布假设下，一些问题会假设样本没有同分布。</p></li><li><p>Non-IID</p><p>不服从独立同分布,<strong>非独立</strong>或者<strong>非同步</strong>或者<strong>两者都不满足</strong></p></li></ul><h3 id="2-联邦平均"><a href="#2-联邦平均" class="headerlink" title="2.联邦平均"></a>2.联邦平均</h3><h3 id="3-超参数"><a href="#3-超参数" class="headerlink" title="3.超参数"></a>3.超参数</h3><h3 id="2-联邦学习概念"><a href="#2-联邦学习概念" class="headerlink" title="2.联邦学习概念"></a>2.联邦学习概念</h3><h4 id="1-广泛定义"><a href="#1-广泛定义" class="headerlink" title="1.广泛定义"></a>1.广泛定义</h4><blockquote><p>定义: 联合学习是一种机器学习设置，其中<strong>多个实体（客户端）</strong>在<strong>中央服务器或服务提供商</strong>的协调下协作解决机器学习问题。<strong>==每个客户的原始数据都存储在本地，并且不会交换或转移==</strong>；从而代替了用于立即聚合的有针对性的更新用于实现学习目标</p></blockquote><p>自从最初引入联邦学习一词以来，它就着重于移动和边缘设备应用程序[289、287]</p><h4 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2.生命周期"></a>2.生命周期</h4><p>图1 : 联邦学习系统中经过FL训练的模型和各种参与者的生命周期</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/mSJGY5.png" alt="mSJGY5"></p><p>典型的工作流程是：</p><ol><li><strong>问题识别：</strong> 模型工程师识别确立一个需要在FL中解决的问题。</li><li><strong>客户工具：</strong> 如果需要，可以对客户端（例如，在手机上运行的应用程序）进行工具化，以在本地（时间和数量上受限制）存储必要的训练数据。在许多情况下，该应用程序已经存储了这些数据（例如，短信应用程序必须存储文本消息，照片管理应用程序已经存储了照片）。但是，在某些情况下，可能需要维护其他数据或元数据，例如用户交互数据，为监督学习任务提供标签。</li><li><strong>仿真原型（可选）：</strong>模型工程师可以使用代理数据集在FL模拟中对模型体系结构进行原型设计并测试学习<strong>超参数。</strong></li><li><strong>联邦模型训练：</strong> 开始执行多个联邦训练任务以训练模型的不同变体，或使用不同的优化超参数。</li><li><strong>（联邦）模型评估：</strong> 在对任务进行了足够的训练之后（通常是几天，请参阅下文），将对模型进行分析并选择好的候选。分析可能包括在数据中心的标准数据集上计算的度量矩阵，或者是联邦评估，其中，将模型推送给受约束的客户，以评估本地客户数据。</li><li><strong>部署方式：</strong> 最后，一旦选择了一个好的模型，就会通过标准的模型启动过程，包括手动的质量审查，实时A / B测试（通常通过在某些设备上使用新模型以及在其他设备上使用上一代模型来比较其内在性能）以及在一个分阶段推出（以便在影响太多用户之前可以发现并回退不良行为）。模型的特定启动过程由应用程序的所有者设置，通常与模型的训练方式无关。换句话说，此步骤将同样适用于通过联邦学习或传统数据中心方法训练的模型。</li></ol><hr><p>服务器（服务提供商）通过重复以下步骤直到停止训练来<strong>协调训练过程</strong>（由监视培训过程的模型工程师自行决定）：</p><ol><li><strong>客户端选择：</strong>服务器从一组符合资格要求的客户端中采样。例如，为避免影响设备用户，移动电话可能仅在未计量的wi-fi连接上插入且处于空闲状态时才签入服务器。</li><li><strong>传播：</strong> 选定的客户端从服务器下载当前模型权重和训练程序（例如TensorFlow图[6]）。</li><li><strong>客户端计算：</strong> 每个选定的设备都通过执行训练程序在本地计算对模型的更新，例如，可以在本地数据上运行SGD（如联邦平均）。</li><li><strong>聚合：</strong> 服务器收集设备更新的汇总。为了提高效率，一旦有足够数量的设备报告了结果，用户就可以在此处放散手。此阶段也是许多其他技术的集成点，这些技术将在后面讨论，可能包括：用于增加隐私的安全聚合，为了通信效率而对聚合进行有损压缩，以及针对差分隐私的噪声添加和更新限幅。</li><li><strong>模型选择：</strong> 服务器根据从参与当前轮次的客户端计算出的聚合更新在本地更新共享模型。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、基本信息&quot;&gt;&lt;a href=&quot;#一、基本信息&quot; class=&quot;headerlink&quot; title=&quot;一、基本信息&quot;&gt;&lt;/a&gt;一、基本信息&lt;/h1&gt;&lt;p&gt;该文章由来自麻省理工、斯坦福、加州大学、南洋理工、谷歌等25所国际知名高校(机构)的58位学者联合发表，文章源于2019年6月17日至18日在谷歌西雅图举办的联邦学习学习和分析研讨会，共105页，调研了438篇文献，介绍了最新的联邦学习进展，并提出大量开放型问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中文翻译版本gitbook: &lt;a href=&quot;https://xwzheng.gitbook.io/fl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://xwzheng.gitbook.io/fl/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github地址: &lt;a href=&quot;https://github.com/open-intelligence/federated-learning-chinese&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/open-intelligence/federated-learning-chinese&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font color=&#39;#39b54a&#39;&gt;感谢翻译,阅读中文版本做了总体的思维导图,以及记录一下文中的细节&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="knowledge" scheme="https://xwjahahahaha.github.io/categories/knowledge/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式系统中的不可能理论</title>
    <link href="https://xwjahahahaha.github.io/2021/04/07/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%90%86%E8%AE%BA/"/>
    <id>https://xwjahahahaha.github.io/2021/04/07/%E7%9F%A5%E8%AF%86%E8%B4%B4/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%90%86%E8%AE%BA/</id>
    <published>2021-04-07T07:45:15.000Z</published>
    <updated>2021-04-07T11:44:04.682Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>内容转载于:<a href="https://developer.aliyun.com/article/702243" target="_blank" rel="noopener">https://developer.aliyun.com/article/702243</a></p></blockquote><a id="more"></a><h1 id="不可能三角"><a href="#不可能三角" class="headerlink" title="不可能三角"></a>不可能三角</h1><p>这些实践中遇到的问题，也引发了诸多计算科学家进行了非常多的理论研究。这些理论研究对于工程技术人员而言或许过于抽象繁琐，有些甚至是无趣的数学问题，但这些理论对于指导我们解决这些问题意义重大。<strong>这些理论相当于是告诉了我们这类问题解法的理论极限，以及哪些方向可以探索、哪些方向是死路一条。</strong> <strong>站在前人的肩膀上，才不至于花毕生精力去研制“永动机”。</strong>这些理论大家应该都有所了解，这里只简单回顾。</p><h2 id="FLP-impossibility"><a href="#FLP-impossibility" class="headerlink" title="FLP impossibility"></a>FLP impossibility</h2><p>早在1985年，Fisher、Lynch、Paterson三位科学家就发表了关于分布式一致性问题的不可能定理：在完全异步的分布式网络中，故障容错问题无法被解决。（ <em>We have shown that a natural and important problem of fault-tolerant cooperative computing cannot be solved in a totally asynchronous model of computation.</em> ）说得更直白点：==在<strong>异步网络</strong>中，不可能存在能够容忍节点故障的一致性算法，哪怕只有一个节点故障。并且这里并没有考虑拜占庭错误，而是假设网络非常稳定、所有的消息都能被正确传递、并且仅被传递一次，即便如此都不可能找到能容忍哪怕只有一个节点失效的一致性协议，可见该结论有多强。==（ <em>In this paper, we show the surprising result that no completely asynchronous consensus protocol can tolerate even a single unannounced process death. We do not consider Byzantine failures, and we assume that the message system is reliableit delivers all messages correctly and exactly once.</em> ）</p><p>当然了，这只是理论上的。它的意义在于告诉我们此类问题的理论极限，并不意味着此类问题在实践中也不可能被“解决”。如果我们愿意放宽限制、做出牺牲，在工程上是可以找到切实可行的解法的。</p><p>FLP不可能定理的最大适用前提是<strong>异步网络模型</strong>。何为同步、异步模型呢？</p><ul><li>所谓异步模型，是说从一个节点到另一个节点的<strong>消息延迟是有限的，但可能是无界的</strong>（finite but can be unbounded）。这就意味着如果一个节点没有收到消息，它无法判断消息到底是丢失了，还是只是延迟了。也就是说，我们无法通过超时时间来判断某个节点是否故障。</li><li>所谓同步模型，是说<strong>消息传递的延迟是有限的，且是有界的</strong>。这就意味着我们可以通过经验或采样精确估算消息的最大可能延迟，从而可以通过超时时间来确定消息是否丢失、节点是否故障。</li></ul><p>所幸的是，我们所处于的<strong>真实的网络世界更接近同步模型</strong>，在很多场景上，我们都可以通过经验或采样确定最大超时时间。举个通俗点的例子：你给朋友快递了一本书，朋友过了3天还没收到，此时朋友很难判断到底是快递延迟了，还是快递出问题送丢了。但是如果过了一个月，朋友仍没收到书，基本就可以断定快递送丢了。而背后的推论就是基于经验或统计：通常快递都能在1-2周内送达。显然，异步模型其实是反映了节点间通讯的最差情况、极端情况，异步模型包含了同步模型，即能在异步模型上有效的一致性协议，在同步模型上也同样有效。而同步模型是对异步模型做了修正和约束，从而使得更接近真实世界，也使得在实践中一致性问题有可能得到有效解。</p><p>另外，即便是在异步网络模型下，FLP也并不意味着一致性永远无法达成，只是说无法保证在有界的时间（in bounded time）内达成。在实践上，如果放宽对bounded time的限制，仍然是有可能找到实践中的解法的。</p><p>而根据DLS的研究（<a href="http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf" target="_blank" rel="noopener">http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf</a> ），一致性算法按照网络模型可以分为三大类：</p><ul><li>部分同步网络模型（partially synchronous model）中的一致性协议可以容忍最多1/3的任意错误。这里的部分同步模型是指<strong>网络延迟是有界的，<u>但是我们无法提前得知</u>。</strong>这里的容错也包含了拜占庭类错误。</li><li>异步网络模型（asynchronous model）中的确定性协议无法容忍错误。这里的异步模型即是前文所说的网络延迟是无界的。该结论其实就是FLP不可能定理的含义，在完全异步网络中的确定性协议不能容忍哪怕只有一个节点的错误。</li><li>同步网络模型（synchronous model）可以达到惊人的100%容错，虽然对错误节点超过1/2时的节点行为有限制。这里的同步模型是指<strong>网络延迟一定是有界的</strong>，即<strong>小于某个已知的常数</strong>。</li></ul><p>从另一个角度来理解，FLP实际上考虑了分布式系统的3个属性：<font color='#e54d42'>安全(safety)、活性（liveness)、容错：</font></p><ul><li>安全是说系统内各个节点达成的值是<strong>一致的、</strong> <strong>==有效的==</strong>。safety其实是保证系统一致性运行的最低要求，其核心是cannot do something bad，即不能干坏事、不能做错事。</li><li><strong>==活性是说系统内各个节点最终（在有限时间内）必须能够达成一致，即系统必须能够向前推进，不能永远处于达不成一致的状态。==</strong>liveness其实是更高要求，意味着不能只是不干坏事，也不能一直不干事，you must do something good，即必须使得整个系统能良好运转下去。</li><li>容错是说该协议在<strong>有节点故障</strong>的情况下也必须能有效。</li></ul><p>FLP不可能定理其实意味着在异步网络中，不可能存在同时满足这三者的分布式一致性协议。因为分布式环境中，节点故障几乎是必然的，因此容错是必须要考虑的因素，所以<strong>==FLP不可能定理就意味着一致性协议在能做到容错的情况下，没办法同时做到安全性与系统活性。==</strong>通常在实践中，我们可以做出部分牺牲，比如<u>牺牲一部分安全性，意味着系统总能很快达成结论，但结论的可靠性不足；或者牺牲一部分系统活性，意味着系统达成的结论非常可靠，但可能长时间、甚至永远都在争论中，无法达成结论。</u>所幸的是，很多时候现实世界的鲁棒性很强，使一致性协议失效的倒霉事件发生的概率也很可能极低<font color='#39b54a'>(概率上始终没有达成共识,虽然这样在概率上可能性非常低)</font>。</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/MfnzwJ.png" alt="MfnzwJ"></p><p>FLP不可能定理示意图（<a href="https://www.slideshare.net/oryband/the-stellar-blockchain-and-the-story-of-the-federated-consensusblockchain-academy?spm=a2c6h.12873639.0.0.7e2b7a59vrG4WV" target="_blank" rel="noopener">https://www.slideshare.net/oryband/the-stellar-blockchain-and-the-story-of-the-federated-consensusblockchain-academy</a>）</p><p>另外，FLP并未排除Las Vegas类随机算法，许多一致性算法采用了这种<strong><u>随机性</u>来规避FLP不可能定理对于确定性异步网络的限制</strong>。此类非确定性一致性算法涉及Las Vegas规则：<strong>==<font color='#e54d42'>网络最终一定能达成一致，但是达成一致所需要的时间可能是无界的。此类算法每轮共识决策都有一定的概率，并且系统在T秒内能够达成一致的概率P随着时间T的增加而指数增长并趋近于1(最终一致性)</font>==</strong>。事实上，该方法被许多成功的一致性算法所采用，是在FLP不可能定理笼罩下的安全地带（escape hatch），比特币的共识机制就是采用了这样的方法。</p><h2 id="CAP-theorem"><a href="#CAP-theorem" class="headerlink" title="CAP theorem"></a>CAP theorem</h2><p>众所周知、大名鼎鼎的CAP原理，从另一个维度，简单明了、直截了当地告诉我们：==<strong>可用性、一致性与网络分区容错性这三者不可能同时实现，而只能实现任意其中的两个</strong>==。( *”Of three properties of shared-data systems (data consistency, system availability and tolerance to network partitions) one can only achieve two at any given time”.*) CAP与FLP看起来有相似之处，其实二者并不尽相同，二者是从不同的维度思考问题，另外即使是很相似的概念，内涵也并不完全一样。比如：</p><ul><li>FLP面对的是<strong>分布式一致性问题</strong>，而CAP面对的是<strong>分布式网络中的数据同步与复制</strong>。</li><li><font color='#e54d42'><strong>FLP是说在异步网络模型中，三者不可能同时实现；而CAP是说在所有场景下，三者都不可能同时实现。</strong></font></li><li>FLP中的<strong>liveness强调的是一致性算法的内在属性<font color='#39b54a'>内部节点共识</font></strong>；而CAP中的<strong>availability强调的是一致性算法对外呈现的外在属性<font color='#39b54a'>外部访问可用</font></strong>。</li></ul><p>理论上，只能从CAP三者中选择两者，然而，这种选择的边界并非是非此即彼的（not binary），很多时候混合考虑不同程度的各个因素，结果可能是更好的。（ <em>The whole spectrum in between is useful; mixing different levels of Availability and Consistency usually yields a better result.</em>）</p><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/2eb2x4.png" alt="2eb2x4"></p><p>CAP理论示意图（<a href="https://www.researchgate.net/figure/Visualization-of-CAP-theorem_fig2_282679529）" target="_blank" rel="noopener">https://www.researchgate.net/figure/Visualization-of-CAP-theorem_fig2_282679529）</a></p><p>在实践中，我们通常需要根据实际业务场景做折中权衡。比如：</p><ul><li>传统的关系型数据库如mysql等多采用<strong>ACID</strong>（atomicity, consistency, isolation and durability）理论，通过<strong>同步事务操作保证了强一致性</strong>；因节点较少（一般只有主从），可用性也比较一般；网络拓扑较为简单，而弱化了分区容错性。</li><li>NoSQL存储系统如hbase等多采用<strong>BASE</strong>（Basically Available、Soft state、Eventually consistent）理论，通过<strong>多节点多副本</strong>保证了较高的可用性；另外因节点数增多、网络环境也更复杂，也考虑了网络分区容错性；但一致性较弱，只能保证最终一致性。</li></ul><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/3bbSTW.png" alt="3bbSTW"></p><p>ACID与BASE对比（<a href="https://people.eecs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf）" target="_blank" rel="noopener">https://people.eecs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf）</a></p><p>当然，这些并不是定论，各个系统都在各自不断的进化完善中，今天的结论明天可能就会被打破。更好的系统一定是不断探索适合自己的场景，找到更佳的平衡点。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;内容转载于:&lt;a href=&quot;https://developer.aliyun.com/article/702243&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.aliyun.com/article/702243&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="knowledge" scheme="https://xwjahahahaha.github.io/categories/knowledge/"/>
    
    
  </entry>
  
  <entry>
    <title>230-二叉搜索树中第K小的元素</title>
    <link href="https://xwjahahahaha.github.io/2021/04/07/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>https://xwjahahahaha.github.io/2021/04/07/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2021-04-07T02:38:26.000Z</published>
    <updated>2021-04-07T02:41:40.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. 二叉搜索树中第K小的元素</a></h4><p>难度中等374</p><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数为 <code>n</code> 。</li><li><code>1 &lt;= k &lt;= n &lt;= 104</code></li><li><code>0 &lt;= Node.val &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p><a id="more"></a><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对于搜索树,中序遍历的结果就是有序的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(root *TreeNode, k <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// order := []int&#123;&#125;</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> helper <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    helper = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            helper(node.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        <span class="comment">// order = append(order, node.Val)</span></span><br><span class="line">        count ++</span><br><span class="line">        <span class="comment">// 判断是否到达第k个</span></span><br><span class="line">        <span class="keyword">if</span> count == k &#123;</span><br><span class="line">            res = node.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            helper(node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代实现中序遍历, 迭代找到后能够提前结束,提高效率</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(root *TreeNode, k <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        count ++ </span><br><span class="line">        <span class="keyword">if</span> count == k &#123;</span><br><span class="line">            <span class="keyword">return</span> root.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        root = root.Right </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;230-二叉搜索树中第K小的元素&quot;&gt;&lt;a href=&quot;#230-二叉搜索树中第K小的元素&quot; class=&quot;headerlink&quot; title=&quot;230. 二叉搜索树中第K小的元素&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;230. 二叉搜索树中第K小的元素&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等374&lt;/p&gt;
&lt;p&gt;给定一个二叉搜索树的根节点 &lt;code&gt;root&lt;/code&gt; ，和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你设计一个算法查找其中第 &lt;code&gt;k&lt;/code&gt; 个最小元素（从 1 开始计数）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [3,1,4,null,2], k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：root &amp;#x3D; [5,3,6,2,4,null,null,1], k &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;





&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树中的节点数为 &lt;code&gt;n&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= k &amp;lt;= n &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= Node.val &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 &lt;code&gt;k&lt;/code&gt; 小的值，你将如何优化算法？&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0153</title>
    <link href="https://xwjahahahaha.github.io/2021/04/07/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0153/"/>
    <id>https://xwjahahahaha.github.io/2021/04/07/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0153/</id>
    <published>2021-04-07T00:37:51.000Z</published>
    <updated>2021-04-08T03:45:37.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发-云容器技术</th><th>科研-区块链</th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>论文一周一篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文联邦学习</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、go设计模式、 确定研究主方向,第一篇论文初稿与老师讨论</li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm)</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 docker、k8s</li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 缓存、日志</li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-20 微服务(消息队列、任务调度、rpc)</li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语100词</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> go网络编程Web基础部分 http包</li><li><input checked="" disabled="" type="checkbox"> 论文《Advances_and_Open_Problems_in_Federated_Learning》</li><li><input checked="" disabled="" type="checkbox"> 机器学习P36</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;科研-区块链&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;论文一周一篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0152</title>
    <link href="https://xwjahahahaha.github.io/2021/04/06/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0152/"/>
    <id>https://xwjahahahaha.github.io/2021/04/06/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0152/</id>
    <published>2021-04-06T12:36:12.000Z</published>
    <updated>2021-04-06T14:20:37.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发-云容器技术</th><th>科研-区块链</th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>论文一周一篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文联邦学习</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、go设计模式、 确定研究主方向,第一篇论文初稿与老师讨论</li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm)</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 docker、k8s</li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 缓存、日志</li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-20 微服务(消息队列、任务调度、rpc)</li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 英语</li><li><input disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> Simple-bitcoin 项目</li><li><input checked="" disabled="" type="checkbox"> 云计算 Dynamo结束</li><li><input checked="" disabled="" type="checkbox"> 网络编程初步</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;科研-区块链&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;论文一周一篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-4-项目库</title>
    <link href="https://xwjahahahaha.github.io/2021/04/05/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/Go%E8%AF%AD%E8%A8%80-4-%E9%A1%B9%E7%9B%AE%E5%BA%93/"/>
    <id>https://xwjahahahaha.github.io/2021/04/05/%E6%8A%80%E6%9C%AF%E8%B4%B4/GoLang/Go%E8%AF%AD%E8%A8%80-4-%E9%A1%B9%E7%9B%AE%E5%BA%93/</id>
    <published>2021-04-05T12:26:59.000Z</published>
    <updated>2021-04-07T07:43:50.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做项目,不可能从零开始,也是组件搭积木的过程,核心代码由自己完成,一些优秀的材料还是可以学习借鉴的.</p><p>golang的一些开源的好用的库的使用记录细节</p><a id="more"></a><blockquote><p>参考资料:</p><p>原文链接：<a href="https://blog.csdn.net/darjun/article/details/104032118" target="_blank" rel="noopener">https://blog.csdn.net/darjun/article/details/104032118</a></p></blockquote><h1 id="一、命令行cli工具Cobra"><a href="#一、命令行cli工具Cobra" class="headerlink" title="一、命令行cli工具Cobra"></a>一、命令行cli工具Cobra</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><blockquote><p>项目地址: <a href="https://pkg.go.dev/github.com/spf13/cobra" target="_blank" rel="noopener">https://pkg.go.dev/github.com/spf13/cobra</a></p></blockquote><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/0y9FQX.png" alt="0y9FQX"></p><p>cobra是一个命令行程序库，可以用来编写命令行程序。同时，它也提供了一个脚手架，用于生成基于 cobra 的应用程序框架。非常多知名的开源项目使用了 cobra 库构建命令行，如Kubernetes、Hugo、etcd、<a href="https://github.com/cli/cli" target="_blank" rel="noopener">Github CLI</a>、cosmos等等等等。本文介绍 cobra 库的基本使用和一些有趣的特性。</p><p>关于作者spf13，这里多说两句。spf13 开源不少项目，而且他的开源项目质量都比较高。相信使用过 vim 的都知道spf13-vim，号称 vim 终极配置。可以一键配置，对于我这样的懒人来说绝对是福音。他的viper是一个完整的配置解决方案。完美支持JSON/TOML/YAML/HCL/envfile/Java properties 配置文件等格式，还有一些比较实用的特性，如配置热更新、多查找目录、配置保存等。还有非常火的静态网站生成器hugo也是他的作品。</p><p>cobra 提供非常丰富的功能：</p><ul><li>轻松支持子命令，如<code>app server</code>，<code>app fetch</code>等； </li><li>完全兼容 POSIX 选项（包括短、长选项）； </li><li>嵌套子命令； </li><li>全局、本地层级选项。可以在多处设置选项，按照一定的顺序取用； </li><li>使用脚手架轻松生成程序框架和命令。</li></ul><p>一些概念:</p><p>例 : <code>hugo server --port=1313</code></p><ul><li><p>Commands: 命令    <code>Hugo</code> 是最高层command,<code>server</code>是一个子command</p><p>命令是应用程序的中心点。应用程序支持的每个交互都包含在一个命令中。一个命令可以有子命令，也可以有选择地运行一个操作。</p></li><li><p>Flags: a way to modify the behavior of a command    <code>port</code>是flags</p><p> Cobra完全支持posix兼容的标志以及Go标志包。Cobra命令可以定义持久化到子命令的标志，以及仅对该命令可用的标志。</p></li><li><p>参数（Arg）：命令的参数，即要操作的对象；<font color='#39b54a'>(传递要命令要执行的相关参数)</font></p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>go get -u github.com/spf13/cobra</code></p><h2 id="为自己的项目创建一个Cli"><a href="#为自己的项目创建一个Cli" class="headerlink" title="为自己的项目创建一个Cli"></a>为自己的项目创建一个Cli</h2><p>使用Cobra Library实现一个自己项目的Cli</p><h3 id="1-Create-rootCmd"><a href="#1-Create-rootCmd" class="headerlink" title="1. Create rootCmd"></a>1. Create rootCmd</h3><p><code>app/cmd/root.go:</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">  Use:   <span class="string">"hugo"</span>,</span><br><span class="line">  Short: <span class="string">"Hugo is a very fast static site generator"</span>,</span><br><span class="line">  Long: <span class="string">`A Fast and Flexible Static Site Generator built with</span></span><br><span class="line"><span class="string">                love by spf13 and friends in Go.</span></span><br><span class="line"><span class="string">                Complete documentation is available at http://hugo.spf13.com`</span>,</span><br><span class="line">  Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Do Stuff Here</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := rootCmd.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Create-your-main-go"><a href="#2-Create-your-main-go" class="headerlink" title="2. Create your main.go"></a>2. Create your main.go</h3><p>运行go编译后的二进制文件就会执行这个命令</p><p>一般将go编译与rootCmd Use一样的二进制文件名<code>go build -o 指定名字</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"&#123;pathToYourApp&#125;/cmd"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cmd.Execute()<span class="comment">// 运行go编译后的二进制文件就会执行这个命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Create-additional-commands"><a href="#3-Create-additional-commands" class="headerlink" title="3. Create additional commands"></a>3. Create additional commands</h3><p>可以定义额外的命令，通常在cmd/目录中给每个命令各自的文件。</p><p>这一步是在创建<strong>子command</strong></p><p>如果你想创建一个版本命令，你可以创建cmd/version。去填充它如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"github.com/spf13/cobra"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rootCmd.AddCommand(versionCmd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> versionCmd = &amp;cobra.Command&#123;</span><br><span class="line">  Use:   <span class="string">"version"</span>,</span><br><span class="line">  Short: <span class="string">"Print the version number of Hugo"</span>,</span><br><span class="line">  Long:  <span class="string">`All software has versions. This is Hugo's`</span>,</span><br><span class="line">  Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hugo Static Site Generator v0.9 -- HEAD"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;做项目,不可能从零开始,也是组件搭积木的过程,核心代码由自己完成,一些优秀的材料还是可以学习借鉴的.&lt;/p&gt;
&lt;p&gt;golang的一些开源的好用的库的使用记录细节&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/categories/technical/golang/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>116-填充每个节点的下一个右侧节点指针</title>
    <link href="https://xwjahahahaha.github.io/2021/04/05/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <id>https://xwjahahahaha.github.io/2021/04/05/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</id>
    <published>2021-04-05T03:07:06.000Z</published>
    <updated>2021-04-05T03:08:30.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></h4><p>难度中等</p><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p> <a id="more"></a><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p><strong>示例：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数量少于 <code>4096</code></li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p><strong>==借助上一步的成果完成下一步==</strong>,很重要的思想!</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * type Node struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *Node</span></span><br><span class="line"><span class="comment"> *     Right *Node</span></span><br><span class="line"><span class="comment"> *     Next *Node</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 层次遍历改进</span></span><br><span class="line"><span class="comment">// 时间复杂度O(N) 空间复杂度O(N) 不满足常量级</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> <span class="params">(head *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*Node&#123;&#125;</span><br><span class="line">    divisionNode := &amp;Node&#123;&#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root, divisionNode)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:<span class="built_in">len</span>(queue)]</span><br><span class="line">        <span class="keyword">if</span> node == divisionNode &#123;</span><br><span class="line">            <span class="comment">// 层结束</span></span><br><span class="line">            node.Next = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, divisionNode)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 层未结束</span></span><br><span class="line">            <span class="comment">// 队列下一个就是右侧节点</span></span><br><span class="line">            <span class="comment">// 队列下一个节点不能是分隔符节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; queue[<span class="number">0</span>] != divisionNode &#123;</span><br><span class="line">                node.Next = queue[<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左右孩子入队</span></span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助上层已建立的next指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> <span class="params">(head *Node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建最左指针</span></span><br><span class="line">    utmostLeft := root</span><br><span class="line">    <span class="comment">// 因为是完美二叉树,所以最左节点一定在最左边</span></span><br><span class="line">    <span class="comment">// 当最左指针的下一层为空时,代表层级遍历结束(不用再为下一层建立next指针)</span></span><br><span class="line">    <span class="keyword">for</span> utmostLeft.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 使用next指针遍历当前层</span></span><br><span class="line">        <span class="comment">// 注意,根节点的next本来就是为nil</span></span><br><span class="line">        <span class="keyword">for</span> node:=utmostLeft; node!=<span class="literal">nil</span>; node = node.Next &#123;</span><br><span class="line">            <span class="comment">// 为下层建立next有两种情况</span></span><br><span class="line">            <span class="comment">// 1. 同一个父节点: 直接相连</span></span><br><span class="line">            node.Left.Next = node.Right</span><br><span class="line">            <span class="comment">// 2. 不同父节点: 使用上层建立的next指针快速相连</span></span><br><span class="line">            <span class="keyword">if</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">                node.Right.Next = node.Next.Left    </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前节点没有next,则其右孩子也不需要next</span></span><br><span class="line">                <span class="comment">// 因为本身就是nil,所以这一步可以省略</span></span><br><span class="line">                node.Right.Next = <span class="literal">nil</span></span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;     </span><br><span class="line">        utmostLeft = utmostLeft.Left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;116-填充每个节点的下一个右侧节点指针&quot;&gt;&lt;a href=&quot;#116-填充每个节点的下一个右侧节点指针&quot; class=&quot;headerlink&quot; title=&quot;116. 填充每个节点的下一个右侧节点指针&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;116. 填充每个节点的下一个右侧节点指针&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给定一个 &lt;strong&gt;完美二叉树&lt;/strong&gt; ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct Node &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 &lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;初始状态下，所有 next 指针都被设置为 &lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0151</title>
    <link href="https://xwjahahahaha.github.io/2021/04/05/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0151/"/>
    <id>https://xwjahahahaha.github.io/2021/04/05/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0151/</id>
    <published>2021-04-05T00:52:53.000Z</published>
    <updated>2021-04-06T12:35:42.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发-云容器技术</th><th>科研-区块链</th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>论文一周一篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文联邦学习</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、go设计模式、 确定研究主方向,第一篇论文初稿与老师讨论</li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm)</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 docker、k8s容器云技术</li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 缓存、日志</li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-20 微服务(消息队列、任务调度、rpc)</li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语100词 + 语法课P9</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> 云计算ppt结束 =&gt; Dynamo数据库了解</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;科研-区块链&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;论文一周一篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>105-从前序与中序遍历序列构造二叉树</title>
    <link href="https://xwjahahahaha.github.io/2021/04/04/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://xwjahahahaha.github.io/2021/04/04/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-04-04T02:54:16.000Z</published>
    <updated>2021-04-04T03:01:21.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h4><p>难度中等</p><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><a id="more"></a><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>总体是递归的过程</p><ol><li>根据前序遍历的preLeft找到根节点</li><li>在中序遍历中找到根节点pIndex</li><li>计算左子树的长度, len = pIndex-1-inLeft+1 = pIndex-inLeft</li><li>推算前序遍历左子树范围(长度与中序相等) x - (preLeft+1) + 1 = len   =&gt; x = pIndex-inLeft+preLeft</li><li>这样右子树也可得出</li><li>递归左右子树</li><li>本次根节点链接左右子树的根节点</li></ol><p><img src="http://xwjpics.gumptlu.work/qinniu_uPic/zkfP9T.png" alt="zkfP9T"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> <span class="params">(head *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 遍历中序一次创建映射</span></span><br><span class="line">    where := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> inorder &#123;</span><br><span class="line">        where[v] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">var</span> helper <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span></span><br><span class="line">    helper = <span class="function"><span class="keyword">func</span> <span class="params">(preLeft, preRight, inLeft, inRight <span class="keyword">int</span>)</span> <span class="params">(childNode *TreeNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> preLeft &gt; preRight || inLeft &gt; inRight &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定根节点位置</span></span><br><span class="line">        pIndex := where[preorder[preLeft]]</span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        node := &amp;TreeNode&#123; Val : inorder[pIndex] &#125;</span><br><span class="line">        <span class="comment">// 递归左右子树</span></span><br><span class="line">        leftNode := helper(preLeft+<span class="number">1</span>, pIndex-inLeft+preLeft, inLeft, pIndex<span class="number">-1</span>)</span><br><span class="line">        rightNode := helper(pIndex-inLeft+preLeft+<span class="number">1</span>, preRight, pIndex+<span class="number">1</span>, inRight)</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        node.Left = leftNode</span><br><span class="line">        node.Right = rightNode </span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="built_in">len</span>(preorder)<span class="number">-1</span>, <span class="number">0</span>, <span class="built_in">len</span>(inorder)<span class="number">-1</span>)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;105-从前序与中序遍历序列构造二叉树&quot;&gt;&lt;a href=&quot;#105-从前序与中序遍历序列构造二叉树&quot; class=&quot;headerlink&quot; title=&quot;105. 从前序与中序遍历序列构造二叉树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;105. 从前序与中序遍历序列构造二叉树&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;根据一棵树的前序遍历与中序遍历构造二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br&gt;你可以假设树中没有重复的元素。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0150</title>
    <link href="https://xwjahahahaha.github.io/2021/04/04/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0150/"/>
    <id>https://xwjahahahaha.github.io/2021/04/04/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0150/</id>
    <published>2021-04-04T01:16:07.000Z</published>
    <updated>2021-04-05T00:43:57.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发-云容器技术</th><th>科研-区块链</th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>论文一周一篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li><del>学弟的cosmos隐私保护项目</del></li><li>第一篇论文联邦学习</li><li><del>科技部编程比赛</del></li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> 3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></li><li><input checked="" disabled="" type="checkbox"> 3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</li><li><input disabled="" type="checkbox"> 3-20 ~ 3-31 Go公链实现项目</li></ul><p>四月</p><ul><li><input disabled="" type="checkbox"> 4-1 ~ 4-20 Go网络编程(base、Echo、Gin)、go设计模式、 确定研究主方向,第一篇论文初稿与老师讨论</li><li><input disabled="" type="checkbox"> 4-21 ~ 4-30 论文实验(编码)、数据库(mysql, PostgreSQL), ORM(Gorm)</li></ul><p>五月</p><ul><li><input disabled="" type="checkbox"> 5-1 ~ 5-20 docker、k8s</li><li><input disabled="" type="checkbox"> 5-21 ~ 5-31 缓存、日志</li></ul><p>六月</p><ul><li><input disabled="" type="checkbox"> 6-1 ~ 6-20 微服务(消息队列、任务调度、rpc)</li></ul><p>四五月中要好好准备六级, 这次要过.</p><ul><li>go开发走云容器技术</li><li>区块链开发走科研论文、Etherem、Fabric、源码分析、Cosmos使用</li></ul><p><strong>有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语105单词</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> 机器学习 =&gt; p31</li><li><input checked="" disabled="" type="checkbox"> 云计算演讲准备  Amazon Dynamo</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发-云容器技术&lt;/th&gt;
&lt;th&gt;科研-区块链&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;论文一周一篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>日记_0149</title>
    <link href="https://xwjahahahaha.github.io/2021/04/03/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0149/"/>
    <id>https://xwjahahahaha.github.io/2021/04/03/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0149/</id>
    <published>2021-04-03T05:28:55.000Z</published>
    <updated>2021-04-03T14:34:12.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发</th><th>项目</th><th><font color='red'>科研</font></th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>区块链公链项目</td><td>论文一周两篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td></td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td></td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input checked="" disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li>学弟的cosmos隐私保护项目</li><li>第一篇论文</li><li>科技部编程比赛</li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> <p>3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></p></li><li><input checked="" disabled="" type="checkbox"> <p>3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</p></li><li><input disabled="" type="checkbox"> <p>3-20~3-31 Go公链实现项目</p></li><li><input disabled="" type="checkbox"> <p>确定研究主方向,第一篇论文初稿与老师讨论</p></li></ul><p>四月 主要准备算法与Go后端框架的学习</p><p>四五月中要好好准备六级, 这次要过.</p><p>五月~七月 算法、面试准备</p><p><strong>走go开发, 有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input disabled="" type="checkbox"> 英语</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> FL第二篇论文结束</li><li><input checked="" disabled="" type="checkbox"> Go Advance =&gt; p108</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2><ul><li>善于总结也要善于复习</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发&lt;/th&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;&lt;font color=&#39;red&#39;&gt;科研&lt;/font&gt;&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;区块链公链项目&lt;/td&gt;
&lt;td&gt;论文一周两篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>103-二叉树的锯齿形层次遍历</title>
    <link href="https://xwjahahahaha.github.io/2021/04/03/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>https://xwjahahahaha.github.io/2021/04/03/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</id>
    <published>2021-04-03T05:06:42.000Z</published>
    <updated>2021-04-03T05:10:06.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层序遍历</a></h4><p>难度中等</p><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><a id="more"></a><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回锯齿形层序遍历如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>两种方法: 递归(深度优先)、迭代(广度优先) 不翻转奇数层数组,而是在插入时判断层数奇数层倒叙插入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span> <span class="params">(res [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建递归函数</span></span><br><span class="line">    <span class="keyword">var</span> recursive <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode, <span class="keyword">int</span>)</span></span></span><br><span class="line">    recursive = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, level <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前层次与结果集大小相等,那么就为新的层创建空间</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) == level &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断层数奇偶,决定插入结果集顺序,奇数反序,偶数正序</span></span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">0</span> || level % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            res[level] = <span class="built_in">append</span>(res[level], node.Val)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 反序添加</span></span><br><span class="line">            res[level] = <span class="built_in">append</span>(res[level], <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> i:=<span class="built_in">len</span>(res[level])<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">                res[level][i] = res[level][i<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            res[level][<span class="number">0</span>] = node.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归子节点</span></span><br><span class="line">        <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            recursive(node.Left, level+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            recursive(node.Right, level+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    recursive(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span> <span class="params">(resList [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    res := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    division := &amp;TreeNode&#123;&#125;</span><br><span class="line">    <span class="comment">// 加入根节点与分隔符节点</span></span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root, division)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 弹出节点</span></span><br><span class="line">        node := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="comment">// 判断是否为分隔符节点</span></span><br><span class="line">        <span class="keyword">if</span> node == division &#123;</span><br><span class="line">            resList = <span class="built_in">append</span>(resList, res)</span><br><span class="line">            res = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, division)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 层还未结束,继续添加</span></span><br><span class="line">            <span class="comment">// 根据当前层数奇偶,判断添加到结果集的顺序.奇数为逆序,偶数为顺序</span></span><br><span class="line">            level := <span class="built_in">len</span>(resList)</span><br><span class="line">            <span class="keyword">if</span> level == <span class="number">0</span> || level % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反序添加</span></span><br><span class="line">                res = <span class="built_in">append</span>(res, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> i:=<span class="built_in">len</span>(res)<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">                    res[i] = res[i<span class="number">-1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                res[<span class="number">0</span>] = node.Val</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加子节点到队列</span></span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;103-二叉树的锯齿形层序遍历&quot;&gt;&lt;a href=&quot;#103-二叉树的锯齿形层序遍历&quot; class=&quot;headerlink&quot; title=&quot;103. 二叉树的锯齿形层序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;103. 二叉树的锯齿形层序遍历&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>145-二叉树的后序遍历</title>
    <link href="https://xwjahahahaha.github.io/2021/04/01/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://xwjahahahaha.github.io/2021/04/01/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-04-01T02:10:31.000Z</published>
    <updated>2021-04-01T02:11:18.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></h4><p>难度中等555</p><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> recursive <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">    recursive = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 边界情况</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        recursive(node.Left)</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        recursive(node.Right)</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    recursive(root)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    <span class="comment">// 已访问的右子节点需要标记,防止死循环</span></span><br><span class="line">    <span class="keyword">var</span> visited *TreeNode       <span class="comment">// 表示已访问</span></span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 左走,入栈</span></span><br><span class="line">        <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走完,出栈,到达中间根节点</span></span><br><span class="line">        root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">// 判断此根节点右子节点</span></span><br><span class="line">        <span class="comment">// 1. 为空或已访问则结束此根节点</span></span><br><span class="line">        <span class="keyword">if</span> root.Right == <span class="literal">nil</span> || root.Right == visited &#123;</span><br><span class="line">            <span class="comment">// 加入结果集</span></span><br><span class="line">            res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">            visited = root</span><br><span class="line">            root = <span class="literal">nil</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 2. 不为空或者未访问责重新入栈访问右节点</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, root)     <span class="comment">// root重新入栈</span></span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;145-二叉树的后序遍历&quot;&gt;&lt;a href=&quot;#145-二叉树的后序遍历&quot; class=&quot;headerlink&quot; title=&quot;145. 二叉树的后序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-postorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;145. 二叉树的后序遍历&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等555&lt;/p&gt;
&lt;p&gt;给定一个二叉树，返回它的 &lt;em&gt;后序&lt;/em&gt; 遍历。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>日记_0148</title>
    <link href="https://xwjahahahaha.github.io/2021/04/01/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0148/"/>
    <id>https://xwjahahahaha.github.io/2021/04/01/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/%E6%97%A5%E8%AE%B0/2021-04/%E6%97%A5%E8%AE%B0-0148/</id>
    <published>2021-04-01T00:42:50.000Z</published>
    <updated>2021-04-02T05:29:01.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><table><thead><tr><th>任务</th><th>英语</th><th>开发</th><th>项目</th><th><font color='red'>科研</font></th><th>预备事宜</th></tr></thead><tbody><tr><td>①</td><td><strong>英语单词</strong></td><td><strong>go学习体系 go书看完</strong></td><td>区块链公链项目</td><td>论文一周两篇细读,每个月尝试写一篇</td><td>准备参加<strong>编程类的比赛或者拿编程证书</strong></td></tr><tr><td>②</td><td>语法课看完</td><td>区块链框架Cosmos</td><td>金窝窝项目需求准备cosmos</td><td>分布式课程论文</td><td>看比赛资讯，准备<strong>区块链比赛</strong></td></tr><tr><td>③</td><td>英文视频学习</td><td>Linux学完</td><td>本科毕业设计</td><td></td><td>为<strong>7月暑期实习</strong>做准备</td></tr><tr><td>④</td><td><font color='red'>六级</font></td><td>看源码Fabric、以太坊、比特币等</td><td>科技部编程比赛</td><td></td><td></td></tr><tr><td>⑤</td><td></td><td></td><td>微信小程序前端uni-app</td><td></td><td></td></tr><tr><td>⑥</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="论文阅读梳理："><a href="#论文阅读梳理：" class="headerlink" title="论文阅读梳理："></a>论文阅读梳理：</h2><h3 id="粗读："><a href="#粗读：" class="headerlink" title="粗读："></a>粗读：</h3><ul><li><input checked="" disabled="" type="checkbox"> 网上资料学习:闪电网络</li></ul><h3 id="细读："><a href="#细读：" class="headerlink" title="细读："></a>细读：</h3><ul><li><input checked="" disabled="" type="checkbox"> Cosmos whitepaper</li><li><input checked="" disabled="" type="checkbox"> 《区块链共识协议综述》</li><li><input checked="" disabled="" type="checkbox"> 《基于区块链技术的车联网高效匿名认证方案_陈葳葳》</li><li><input checked="" disabled="" type="checkbox"> Federated Machine Learning: Concept and Applications</li><li><input disabled="" type="checkbox"> Blockchained On-Device Federated Learning</li><li><input disabled="" type="checkbox"> DeepChain: Auditable and Privacy-Preserving Deep Learning with Blockchain-based Incentive</li></ul><h2 id="学期规划"><a href="#学期规划" class="headerlink" title="学期规划:"></a>学期规划:</h2><ul><li>学弟的cosmos隐私保护项目</li><li>第一篇论文</li><li>科技部编程比赛</li><li>暑期实习准备(Go, 算法等)</li></ul><p>三月 </p><ul><li><input checked="" disabled="" type="checkbox"> <p>3-3 ~ 3-7 cosmos项目架构熟悉,<del>做完全部的案例</del>,<del>并且熟悉SDK</del></p></li><li><input checked="" disabled="" type="checkbox"> <p>3-8 ~ 3-20 科技部编程比赛项目实现(使用cosmos)</p></li><li><input disabled="" type="checkbox"> <p>3-20~3-31 Go公链实现项目</p></li><li><input disabled="" type="checkbox"> <p>确定研究主方向,第一篇论文初稿与老师讨论</p></li></ul><p>四月 主要准备算法与Go后端框架的学习</p><p>四五月中要好好准备六级, 这次要过.</p><p>五月~七月 算法、面试准备</p><p><strong>走go开发, 有底层技术才有实现想法的权利</strong></p><h2 id="今日完成的任务："><a href="#今日完成的任务：" class="headerlink" title="今日完成的任务："></a>今日完成的任务：</h2><ul><li><input checked="" disabled="" type="checkbox"> 英语70词</li><li><input checked="" disabled="" type="checkbox"> leetcode一题</li><li><input checked="" disabled="" type="checkbox"> 机器学习 =&gt; p24</li><li><input checked="" disabled="" type="checkbox"> 论文 </li><li><input checked="" disabled="" type="checkbox"> go advance =&gt; p89</li></ul><h2 id="今日自省"><a href="#今日自省" class="headerlink" title="今日自省"></a>今日自省</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;英语&lt;/th&gt;
&lt;th&gt;开发&lt;/th&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;&lt;font color=&#39;red&#39;&gt;科研&lt;/font&gt;&lt;/th&gt;
&lt;th&gt;预备事宜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;①&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;英语单词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;go学习体系 go书看完&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;区块链公链项目&lt;/td&gt;
&lt;td&gt;论文一周两篇细读,每个月尝试写一篇&lt;/td&gt;
&lt;td&gt;准备参加&lt;strong&gt;编程类的比赛或者拿编程证书&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;②&lt;/td&gt;
&lt;td&gt;语法课看完&lt;/td&gt;
&lt;td&gt;区块链框架Cosmos&lt;/td&gt;
&lt;td&gt;金窝窝项目需求准备cosmos&lt;/td&gt;
&lt;td&gt;分布式课程论文&lt;/td&gt;
&lt;td&gt;看比赛资讯，准备&lt;strong&gt;区块链比赛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;③&lt;/td&gt;
&lt;td&gt;英文视频学习&lt;/td&gt;
&lt;td&gt;Linux学完&lt;/td&gt;
&lt;td&gt;本科毕业设计&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为&lt;strong&gt;7月暑期实习&lt;/strong&gt;做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;④&lt;/td&gt;
&lt;td&gt;&lt;font color=&#39;red&#39;&gt;六级&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;看源码Fabric、以太坊、比特币等&lt;/td&gt;
&lt;td&gt;科技部编程比赛&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑤&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;微信小程序前端uni-app&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;⑥&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
    
    <category term="每日一记" scheme="https://xwjahahahaha.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>144-二叉树的前序遍历</title>
    <link href="https://xwjahahahaha.github.io/2021/03/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://xwjahahahaha.github.io/2021/03/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-03-31T03:02:25.000Z</published>
    <updated>2021-03-31T03:03:40.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></h4><p>难度中等</p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p> <a id="more"></a><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> recursive <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    <span class="comment">// 函数定义</span></span><br><span class="line">    recursive = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        recursive(root.Left)</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        recursive(root.Right)  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    recursive(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="comment">// 中</span></span><br><span class="line">           stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">           res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">           <span class="comment">// 左</span></span><br><span class="line">           root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 弹出</span></span><br><span class="line">        root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        root = root.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;144-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#144-二叉树的前序遍历&quot; class=&quot;headerlink&quot; title=&quot;144. 二叉树的前序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-preorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;144. 二叉树的前序遍历&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;
&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回它节点值的 &lt;strong&gt;前序&lt;/strong&gt; 遍历。&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>94-二叉树的中序遍历</title>
    <link href="https://xwjahahahaha.github.io/2021/03/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://xwjahahahaha.github.io/2021/03/31/%E6%8A%80%E6%9C%AF%E8%B4%B4/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%81%8D%E5%8E%86/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-03-31T02:31:39.000Z</published>
    <updated>2021-03-31T03:03:47.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h4><p>难度中等</p><a id="more"></a><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p>递归与迭代</p><p>时间复杂度O(N)</p><p>空间复杂度O(N) (最坏当链表为一条直线时,栈的深度就是N)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    GetPath(&amp;path, root)</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPath</span><span class="params">(path *[]<span class="keyword">int</span>, root *TreeNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    GetPath(path, root.Left)</span><br><span class="line">    *path = <span class="built_in">append</span>(*path, root.Val)</span><br><span class="line">    GetPath(path, root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="comment">// 维护一个栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> <span class="params">(res []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   stack := []*TreeNode&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="comment">// 一直遍历左边</span></span><br><span class="line">       <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="comment">// 入栈</span></span><br><span class="line">           stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">           root = root.Left</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 处理中间</span></span><br><span class="line">       root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">       stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">       res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">       <span class="comment">// 右边</span></span><br><span class="line">       root = root.Right</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;h4 id=&quot;94-二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#94-二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;94. 二叉树的中序遍历&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-inorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;94. 二叉树的中序遍历&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度中等&lt;/p&gt;</summary>
    
    
    
    <category term="technical" scheme="https://xwjahahahaha.github.io/categories/technical/"/>
    
    <category term="leetcode" scheme="https://xwjahahahaha.github.io/categories/technical/leetcode/"/>
    
    
    <category term="golang" scheme="https://xwjahahahaha.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
